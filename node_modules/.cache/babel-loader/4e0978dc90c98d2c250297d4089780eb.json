{"ast":null,"code":"/*\r\n * wysiwyg web editor\r\n *\r\n * suneditor.js\r\n * Copyright 2017 JiHong Lee.\r\n * MIT license.\r\n */\n'use strict';\n\nimport _Constructor from './constructor';\nimport _Context from './context';\nimport _history from './history';\nimport _util from './util';\nimport _notice from '../plugins/modules/_notice';\n/**\r\n * @description SunEditor constuctor function.\r\n * create core object and event registration.\r\n * core, event, functions\r\n * @param {Object} context\r\n * @param {Object} pluginCallButtons\r\n * @param {Object} plugins \r\n * @param {Object} lang\r\n * @param {Object} options\r\n * @param {Object} _responsiveButtons\r\n * @returns {Object} functions Object\r\n */\n\nexport default function (context, pluginCallButtons, plugins, lang, options, _responsiveButtons) {\n  var _d = context.element.originElement.ownerDocument || document;\n\n  var _w = _d.defaultView || window;\n\n  var util = _util;\n  var icons = options.icons;\n  /**\r\n   * @description editor core object\r\n   * should always bind this object when registering an event in the plug-in.\r\n   */\n\n  var core = {\n    _d: _d,\n    _w: _w,\n    _parser: new _w.DOMParser(),\n    _prevRtl: options.rtl,\n    _editorHeight: 0,\n    _listCamel: options.__listCommonStyle,\n    _listKebab: util.camelToKebabCase(options.__listCommonStyle),\n\n    /**\r\n     * @description Document object of the iframe if created as an iframe || _d\r\n     * @private\r\n     */\n    _wd: null,\n\n    /**\r\n     * @description Window object of the iframe if created as an iframe || _w\r\n     * @private\r\n     */\n    _ww: null,\n\n    /**\r\n     * @description Closest ShadowRoot to editor if found\r\n     * @private\r\n     */\n    _shadowRoot: null,\n\n    /**\r\n     * @description Block controller mousedown events in \"shadowRoot\" environment\r\n     * @private\r\n     */\n    _shadowRootControllerEventTarget: null,\n\n    /**\r\n     * @description Util object\r\n     */\n    util: util,\n\n    /**\r\n     * @description Functions object\r\n     */\n    functions: null,\n\n    /**\r\n     * @description Editor options\r\n     */\n    options: null,\n\n    /**\r\n     * @description Computed style of the wysiwyg area (window.getComputedStyle(context.element.wysiwyg))\r\n     */\n    wwComputedStyle: null,\n\n    /**\r\n     * @description Notice object\r\n     */\n    notice: _notice,\n\n    /**\r\n     * @description Default icons object\r\n     */\n    icons: icons,\n\n    /**\r\n     * @description History object for undo, redo\r\n     */\n    history: null,\n\n    /**\r\n     * @description Elements and user options parameters of the suneditor\r\n     */\n    context: context,\n\n    /**\r\n     * @description Plugin buttons\r\n     */\n    pluginCallButtons: pluginCallButtons,\n\n    /**\r\n     * @description Loaded plugins\r\n     */\n    plugins: plugins || {},\n\n    /**\r\n     * @description Whether the plugin is initialized\r\n     */\n    initPlugins: {},\n\n    /**\r\n     * @description Object for managing submenu elements\r\n     * @private\r\n     */\n    _targetPlugins: {},\n\n    /**\r\n     * @description Save rendered submenus and containers\r\n     * @private\r\n     */\n    _menuTray: {},\n\n    /**\r\n     * @description loaded language\r\n     */\n    lang: lang,\n\n    /**\r\n     * @description The selection node (core.getSelectionNode()) to which the effect was last applied\r\n     */\n    effectNode: null,\n\n    /**\r\n     * @description submenu element\r\n     */\n    submenu: null,\n\n    /**\r\n     * @description container element\r\n     */\n    container: null,\n\n    /**\r\n     * @description current subment name\r\n     * @private\r\n     */\n    _submenuName: '',\n\n    /**\r\n     * @description binded submenuOff method\r\n     * @private\r\n     */\n    _bindedSubmenuOff: null,\n\n    /**\r\n     * @description binded containerOff method\r\n     * @private\r\n     */\n    _bindedContainerOff: null,\n\n    /**\r\n     * @description active button element in submenu\r\n     */\n    submenuActiveButton: null,\n\n    /**\r\n     * @description active button element in container\r\n     */\n    containerActiveButton: null,\n\n    /**\r\n     * @description The elements array to be processed unvisible when the controllersOff function is executed (resizing, link modified button, table controller)\r\n     */\n    controllerArray: [],\n\n    /**\r\n     * @description The name of the plugin that called the currently active controller\r\n     */\n    currentControllerName: '',\n\n    /**\r\n     * @description The target element of current controller\r\n     */\n    currentControllerTarget: null,\n\n    /**\r\n     * @description The file component object of current selected file tag (getFileComponent)\r\n     */\n    currentFileComponentInfo: null,\n\n    /**\r\n     * @description An array of buttons whose class name is not \"se-code-view-enabled\"\r\n     */\n    codeViewDisabledButtons: [],\n\n    /**\r\n     * @description An array of buttons whose class name is not \"se-resizing-enabled\"\r\n     */\n    resizingDisabledButtons: [],\n\n    /**\r\n     * @description active more layer element in submenu\r\n     * @private\r\n     */\n    _moreLayerActiveButton: null,\n\n    /**\r\n     * @description Tag whitelist RegExp object used in \"_consistencyCheckOfHTML\" method\r\n     * ^(options._editorTagsWhitelist)$\r\n     * @private\r\n     */\n    _htmlCheckWhitelistRegExp: null,\n\n    /**\r\n     * @description Tag blacklist RegExp object used in \"_consistencyCheckOfHTML\" method\r\n     * @private\r\n     */\n    _htmlCheckBlacklistRegExp: null,\n\n    /**\r\n     * @description RegExp when using check disallowd tags. (b, i, ins, strike, s)\r\n     * @private\r\n     */\n    _disallowedTextTagsRegExp: null,\n\n    /**\r\n     * @description Editor tags whitelist (RegExp object)\r\n     * util.createTagsWhitelist(options._editorTagsWhitelist)\r\n     */\n    editorTagsWhitelistRegExp: null,\n\n    /**\r\n     * @description Editor tags blacklist (RegExp object)\r\n     * util.createTagsBlacklist(options.tagsBlacklist)\r\n     */\n    editorTagsBlacklistRegExp: null,\n\n    /**\r\n     * @description Tag whitelist when pasting (RegExp object)\r\n     * util.createTagsWhitelist(options.pasteTagsWhitelist)\r\n     */\n    pasteTagsWhitelistRegExp: null,\n\n    /**\r\n     * @description Tag blacklist when pasting (RegExp object)\r\n     * util.createTagsBlacklist(options.pasteTagsBlacklist)\r\n     */\n    pasteTagsBlacklistRegExp: null,\n\n    /**\r\n     * @description Boolean value of whether the editor has focus\r\n     */\n    hasFocus: false,\n\n    /**\r\n     * @description Boolean value of whether the editor is disabled\r\n     */\n    isDisabled: false,\n\n    /**\r\n     * @description Boolean value of whether the editor is readOnly\r\n     */\n    isReadOnly: false,\n\n    /**\r\n     * @description Attributes whitelist used by the cleanHTML method\r\n     * @private\r\n     */\n    _attributesWhitelistRegExp: null,\n\n    /**\r\n     * @description Attributes blacklist used by the cleanHTML method\r\n     * @private\r\n     */\n    _attributesBlacklistRegExp: null,\n\n    /**\r\n     * @description Attributes of tags whitelist used by the cleanHTML method\r\n     * @private\r\n     */\n    _attributesTagsWhitelist: null,\n\n    /**\r\n     * @description Attributes of tags blacklist used by the cleanHTML method\r\n     * @private\r\n     */\n    _attributesTagsBlacklist: null,\n\n    /**\r\n     * @description binded controllersOff method\r\n     * @private\r\n     */\n    _bindControllersOff: null,\n\n    /**\r\n     * @description Is inline mode?\r\n     * @private\r\n     */\n    _isInline: null,\n\n    /**\r\n     * @description Is balloon|balloon-always mode?\r\n     * @private\r\n     */\n    _isBalloon: null,\n\n    /**\r\n     * @description Is balloon-always mode?\r\n     * @private\r\n     */\n    _isBalloonAlways: null,\n\n    /**\r\n     * @description Required value when using inline mode to sticky toolbar\r\n     * @private\r\n     */\n    _inlineToolbarAttr: {\n      top: '',\n      width: '',\n      isShow: false\n    },\n\n    /**\r\n     * @description Variable that controls the \"blur\" event in the editor of inline or balloon mode when the focus is moved to submenu\r\n     * @private\r\n     */\n    _notHideToolbar: false,\n\n    /**\r\n     * @description Variable value that sticky toolbar mode\r\n     * @private\r\n     */\n    _sticky: false,\n\n    /**\r\n     * @description Variables for controlling focus and blur events\r\n     * @private\r\n     */\n    _antiBlur: false,\n\n    /**\r\n     * @description Component line breaker element\r\n     * @private\r\n     */\n    _lineBreaker: null,\n    _lineBreakerButton: null,\n\n    /**\r\n     * @description If true, (initialize, reset) all indexes of image, video information\r\n     * @private\r\n     */\n    _componentsInfoInit: true,\n    _componentsInfoReset: false,\n\n    /**\r\n     * @description Plugins array with \"active\" method.\r\n     * \"activePlugins\" runs the \"add\" method when creating the editor.\r\n     */\n    activePlugins: null,\n\n    /**\r\n     * @description Information of tags that should maintain HTML structure, style, class name, etc. (In use by \"math\" plugin)\r\n     * When inserting \"html\" such as paste, it is executed on the \"html\" to be inserted. (core.cleanHTML)\r\n     * Basic Editor Actions:\r\n     * 1. All classes not starting with \"__se__\" or \"se-\" in the editor are removed.\r\n     * 2. The style of all tags except the \"span\" tag is removed from the editor.\r\n     * \"managedTagsInfo\" structure ex:\r\n     * managedTagsInfo: {\r\n     *   query: '.__se__xxx, se-xxx'\r\n     *   map: {\r\n     *     '__se__xxx': method.bind(core),\r\n     *     'se-xxx': method.bind(core),\r\n     *   }\r\n     * }\r\n     * @example\r\n     * Define in the following return format in the \"managedTagInfo\" function of the plugin.\r\n     * managedTagInfo() => {\r\n     *  return {\r\n     *    className: 'string', // Class name to identify the tag. (\"__se__xxx\", \"se-xxx\")\r\n     *    // Change the html of the \"element\". (\"element\" is the element found with \"className\".)\r\n     *    // \"method\" is executed by binding \"core\".\r\n     *    method: function (element) {\r\n     *      // this === core\r\n     *      element.innerHTML = // (rendered html);\r\n     *    }\r\n     *  }\r\n     * }\r\n     */\n    managedTagsInfo: null,\n\n    /**\r\n     * @description cashing: options.charCounterType === 'byte-html'\r\n     * @private\r\n     */\n    _charTypeHTML: false,\n\n    /**\r\n     * @description Array of \"checkFileInfo\" functions with the core bound\r\n     * (Plugins with \"checkFileInfo\" and \"resetFileInfo\" methods)\r\n     * \"fileInfoPlugins\" runs the \"add\" method when creating the editor.\r\n     * \"checkFileInfo\" method is always call just before the \"change\" event.\r\n     * @private\r\n     */\n    _fileInfoPluginsCheck: null,\n\n    /**\r\n     * @description Array of \"resetFileInfo\" functions with the core bound\r\n     * (Plugins with \"checkFileInfo\" and \"resetFileInfo\" methods)\r\n     * \"checkFileInfo\" method is always call just before the \"functions.setOptions\" method.\r\n     * @private\r\n     */\n    _fileInfoPluginsReset: null,\n\n    /**\r\n     * @description Variables for file component management\r\n     * @private\r\n     */\n    _fileManager: {\n      tags: null,\n      regExp: null,\n      queryString: null,\n      pluginRegExp: null,\n      pluginMap: null\n    },\n\n    /**\r\n     * @description Elements that need to change text or className for each selection change\r\n     * After creating the editor, \"activePlugins\" are added.\r\n     * @property {Element} STRONG bold button\r\n     * @property {Element} U underline button\r\n     * @property {Element} EM italic button\r\n     * @property {Element} DEL strike button\r\n     * @property {Element} SUB subscript button\r\n     * @property {Element} SUP superscript button\r\n     * @property {Element} OUTDENT outdent button\r\n     * @property {Element} INDENT indent button\r\n     */\n    commandMap: null,\n\n    /**\r\n     * @description CSS properties related to style tags \r\n     * @private\r\n     */\n    _commandMapStyles: {\n      STRONG: ['font-weight'],\n      U: ['text-decoration'],\n      EM: ['font-style'],\n      DEL: ['text-decoration']\n    },\n\n    /**\r\n     * @description Style button related to edit area\r\n     * @property {Element} fullScreen fullScreen button element\r\n     * @property {Element} showBlocks showBlocks button element\r\n     * @property {Element} codeView codeView button element\r\n     * @private\r\n     */\n    _styleCommandMap: null,\n\n    /**\r\n     * @description Variables used internally in editor operation\r\n     * @property {Boolean} isCodeView State of code view\r\n     * @property {Boolean} isFullScreen State of full screen\r\n     * @property {Number} innerHeight_fullScreen InnerHeight in editor when in full screen\r\n     * @property {Number} resizeClientY Remember the vertical size of the editor before resizing the editor (Used when calculating during resize operation)\r\n     * @property {Number} tabSize Indent size of tab (4)\r\n     * @property {Number} codeIndent Indent size of Code view mode (2)\r\n     * @property {Number} minResizingSize Minimum size of editing area when resized {Number} (.se-wrapper-inner {min-height: 65px;} || 65)\r\n     * @property {Array} currentNodes  An array of the current cursor's node structure\r\n     * @private\r\n     */\n    _variable: {\n      isChanged: false,\n      isCodeView: false,\n      isFullScreen: false,\n      innerHeight_fullScreen: 0,\n      resizeClientY: 0,\n      tabSize: 4,\n      codeIndent: 2,\n      minResizingSize: util.getNumber(context.element.wysiwygFrame.style.minHeight || '65', 0),\n      currentNodes: [],\n      currentNodesMap: [],\n      _range: null,\n      _selectionNode: null,\n      _originCssText: context.element.topArea.style.cssText,\n      _bodyOverflow: '',\n      _editorAreaOriginCssText: '',\n      _wysiwygOriginCssText: '',\n      _codeOriginCssText: '',\n      _fullScreenAttrs: {\n        sticky: false,\n        balloon: false,\n        inline: false\n      },\n      _lineBreakComp: null,\n      _lineBreakDir: ''\n    },\n\n    /**\r\n     * @description Save the current buttons states to \"allCommandButtons\" object\r\n     * @private\r\n     */\n    _saveButtonStates: function _saveButtonStates() {\n      if (!this.allCommandButtons) this.allCommandButtons = {};\n\n      var currentButtons = this.context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]');\n\n      for (var i = 0, element, command; i < currentButtons.length; i++) {\n        element = currentButtons[i];\n        command = element.getAttribute('data-command');\n        this.allCommandButtons[command] = element;\n      }\n    },\n\n    /**\r\n     * @description Recover the current buttons states from \"allCommandButtons\" object\r\n     * @private\r\n     */\n    _recoverButtonStates: function _recoverButtonStates() {\n      if (this.allCommandButtons) {\n        var currentButtons = this.context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]');\n\n        for (var i = 0, button, command, oldButton; i < currentButtons.length; i++) {\n          button = currentButtons[i];\n          command = button.getAttribute('data-command');\n          oldButton = this.allCommandButtons[command];\n\n          if (oldButton) {\n            button.parentElement.replaceChild(oldButton, button);\n            if (this.context.tool[command]) this.context.tool[command] = oldButton;\n          }\n        }\n      }\n    },\n\n    /**\r\n     * @description If the plugin is not added, add the plugin and call the 'add' function.\r\n     * If the plugin is added call callBack function.\r\n     * @param {String} pluginName The name of the plugin to call\r\n     * @param {function} callBackFunction Function to be executed immediately after module call\r\n     * @param {Element|null} _target Plugin target button (This is not necessary if you have a button list when creating the editor)\r\n     */\n    callPlugin: function callPlugin(pluginName, callBackFunction, _target) {\n      _target = _target || pluginCallButtons[pluginName];\n\n      if (!this.plugins[pluginName]) {\n        throw Error('[SUNEDITOR.core.callPlugin.fail] The called plugin does not exist or is in an invalid format. (pluginName:\"' + pluginName + '\")');\n      } else if (!this.initPlugins[pluginName]) {\n        this.plugins[pluginName].add(this, _target);\n        this.initPlugins[pluginName] = true;\n      } else if (typeof this._targetPlugins[pluginName] === 'object' && !!_target) {\n        this.initMenuTarget(pluginName, _target, this._targetPlugins[pluginName]);\n      }\n\n      if (this.plugins[pluginName].active && !this.commandMap[pluginName] && !!_target) {\n        this.commandMap[pluginName] = _target;\n        this.activePlugins.push(pluginName);\n      }\n\n      if (typeof callBackFunction === 'function') callBackFunction();\n    },\n\n    /**\r\n     * @description If the module is not added, add the module and call the 'add' function\r\n     * @param {Array} moduleArray module object's Array [dialog, resizing]\r\n     */\n    addModule: function addModule(moduleArray) {\n      for (var i = 0, len = moduleArray.length, moduleName; i < len; i++) {\n        moduleName = moduleArray[i].name;\n\n        if (!this.plugins[moduleName]) {\n          this.plugins[moduleName] = moduleArray[i];\n        }\n\n        if (!this.initPlugins[moduleName]) {\n          this.initPlugins[moduleName] = true;\n          if (typeof this.plugins[moduleName].add === 'function') this.plugins[moduleName].add(this);\n        }\n      }\n    },\n\n    /**\r\n     * @description Gets the current editor-relative scroll offset.\r\n     * @returns {Object} {top, left}\r\n     */\n    getGlobalScrollOffset: function getGlobalScrollOffset() {\n      var t = 0,\n          l = 0;\n      var el = context.element.topArea;\n\n      while (el) {\n        t += el.scrollTop;\n        l += el.scrollLeft;\n        el = el.parentElement;\n      }\n\n      el = this._shadowRoot ? this._shadowRoot.host : null;\n\n      while (el) {\n        t += el.scrollTop;\n        l += el.scrollLeft;\n        el = el.parentElement;\n      }\n\n      return {\n        top: t,\n        left: l\n      };\n    },\n\n    /**\r\n     * @description Method for managing submenu element.\r\n     * You must add the \"submenu\" element using the this method at custom plugin.\r\n     * @param {String} pluginName Plugin name\r\n     * @param {Element|null} target Target button\r\n     * @param {Element} menu Submenu element\r\n     */\n    initMenuTarget: function initMenuTarget(pluginName, target, menu) {\n      if (!target) {\n        this._targetPlugins[pluginName] = menu;\n      } else {\n        context.element._menuTray.appendChild(menu);\n\n        this._targetPlugins[pluginName] = true;\n        this._menuTray[target.getAttribute('data-command')] = menu;\n      }\n    },\n\n    /**\r\n     * @description Enable submenu\r\n     * @param {Element} element Submenu's button element to call\r\n     */\n    submenuOn: function submenuOn(element) {\n      if (this._bindedSubmenuOff) this._bindedSubmenuOff();\n      if (this._bindControllersOff) this.controllersOff();\n      var submenuName = this._submenuName = element.getAttribute('data-command');\n      var menu = this.submenu = this._menuTray[submenuName];\n      this.submenuActiveButton = element;\n\n      this._setMenuPosition(element, menu);\n\n      this._bindedSubmenuOff = this.submenuOff.bind(this);\n      this.addDocEvent('mousedown', this._bindedSubmenuOff, false);\n      if (this.plugins[submenuName].on) this.plugins[submenuName].on.call(this);\n      this._antiBlur = true;\n    },\n\n    /**\r\n     * @description Disable submenu\r\n     */\n    submenuOff: function submenuOff() {\n      this.removeDocEvent('mousedown', this._bindedSubmenuOff);\n      this._bindedSubmenuOff = null;\n\n      if (this.submenu) {\n        this._submenuName = '';\n        this.submenu.style.display = 'none';\n        this.submenu = null;\n        util.removeClass(this.submenuActiveButton, 'on');\n        this.submenuActiveButton = null;\n        this._notHideToolbar = false;\n      }\n\n      this._antiBlur = false;\n    },\n\n    /**\r\n     * @description Disable more layer\r\n     */\n    moreLayerOff: function moreLayerOff() {\n      if (this._moreLayerActiveButton) {\n        var layer = context.element.toolbar.querySelector('.' + this._moreLayerActiveButton.getAttribute('data-command'));\n        layer.style.display = 'none';\n        util.removeClass(this._moreLayerActiveButton, 'on');\n        this._moreLayerActiveButton = null;\n      }\n    },\n\n    /**\r\n     * @description Enable container\r\n     * @param {Element} element Container's button element to call\r\n     */\n    containerOn: function containerOn(element) {\n      if (this._bindedContainerOff) this._bindedContainerOff();\n      var containerName = this._containerName = element.getAttribute('data-command');\n      var menu = this.container = this._menuTray[containerName];\n      this.containerActiveButton = element;\n\n      this._setMenuPosition(element, menu);\n\n      this._bindedContainerOff = this.containerOff.bind(this);\n      this.addDocEvent('mousedown', this._bindedContainerOff, false);\n      if (this.plugins[containerName].on) this.plugins[containerName].on.call(this);\n      this._antiBlur = true;\n    },\n\n    /**\r\n     * @description Disable container\r\n     */\n    containerOff: function containerOff() {\n      this.removeDocEvent('mousedown', this._bindedContainerOff);\n      this._bindedContainerOff = null;\n\n      if (this.container) {\n        this._containerName = '';\n        this.container.style.display = 'none';\n        this.container = null;\n        util.removeClass(this.containerActiveButton, 'on');\n        this.containerActiveButton = null;\n        this._notHideToolbar = false;\n      }\n\n      this._antiBlur = false;\n    },\n\n    /**\r\n     * @description Set the menu position. (submenu, container)\r\n     * @param {*} element Button element\r\n     * @param {*} menu Menu element\r\n     * @private\r\n     */\n    _setMenuPosition: function _setMenuPosition(element, menu) {\n      menu.style.visibility = 'hidden';\n      menu.style.display = 'block';\n      menu.style.height = '';\n      util.addClass(element, 'on');\n      var toolbar = this.context.element.toolbar;\n      var toolbarW = toolbar.offsetWidth;\n\n      var toolbarOffset = event._getEditorOffsets(context.element.toolbar);\n\n      var menuW = menu.offsetWidth;\n      var l = element.parentElement.offsetLeft + 3; // rtl\n\n      if (options.rtl) {\n        var elementW = element.offsetWidth;\n        var rtlW = menuW > elementW ? menuW - elementW : 0;\n        var rtlL = rtlW > 0 ? 0 : elementW - menuW;\n        menu.style.left = l - rtlW + rtlL + 'px';\n\n        if (toolbarOffset.left > event._getEditorOffsets(menu).left) {\n          menu.style.left = '0px';\n        }\n      } else {\n        var overLeft = toolbarW <= menuW ? 0 : toolbarW - (l + menuW);\n        if (overLeft < 0) menu.style.left = l + overLeft + 'px';else menu.style.left = l + 'px';\n      } // get element top\n\n\n      var t = 0;\n      var offsetEl = element;\n\n      while (offsetEl && offsetEl !== toolbar) {\n        t += offsetEl.offsetTop;\n        offsetEl = offsetEl.offsetParent;\n      }\n\n      var bt = t;\n\n      if (this._isBalloon) {\n        t += toolbar.offsetTop + element.offsetHeight;\n      } else {\n        t -= element.offsetHeight;\n      } // set menu position\n\n\n      var toolbarTop = toolbarOffset.top;\n      var menuHeight = menu.offsetHeight;\n      var scrollTop = this.getGlobalScrollOffset().top;\n      var menuHeight_bottom = _w.innerHeight - (toolbarTop - scrollTop + bt + element.parentElement.offsetHeight);\n\n      if (menuHeight_bottom < menuHeight) {\n        var menuTop = -1 * (menuHeight - bt + 3);\n        var insTop = toolbarTop - scrollTop + menuTop;\n        var menuHeight_top = menuHeight + (insTop < 0 ? insTop : 0);\n\n        if (menuHeight_top > menuHeight_bottom) {\n          menu.style.height = menuHeight_top + 'px';\n          menuTop = -1 * (menuHeight_top - bt + 3);\n        } else {\n          menu.style.height = menuHeight_bottom + 'px';\n          menuTop = bt + element.parentElement.offsetHeight;\n        }\n\n        menu.style.top = menuTop + 'px';\n      } else {\n        menu.style.top = bt + element.parentElement.offsetHeight + 'px';\n      }\n\n      menu.style.visibility = '';\n    },\n\n    /**\r\n     * @description Show controller at editor area (controller elements, function, \"controller target element(@Required)\", \"controller name(@Required)\", etc..)\r\n     * @param {*} arguments controller elements, functions..\r\n     */\n    controllersOn: function controllersOn() {\n      if (this._bindControllersOff) this._bindControllersOff();\n      this.controllerArray = [];\n\n      for (var i = 0, arg; i < arguments.length; i++) {\n        arg = arguments[i];\n        if (!arg) continue;\n\n        if (typeof arg === 'string') {\n          this.currentControllerName = arg;\n          continue;\n        }\n\n        if (typeof arg === 'function') {\n          this.controllerArray.push(arg);\n          continue;\n        }\n\n        if (!util.hasClass(arg, 'se-controller')) {\n          this.currentControllerTarget = arg;\n          this.currentFileComponentInfo = this.getFileComponent(arg);\n          continue;\n        }\n\n        if (arg.style) {\n          arg.style.display = 'block';\n\n          if (this._shadowRoot && this._shadowRootControllerEventTarget.indexOf(arg) === -1) {\n            arg.addEventListener('mousedown', function (e) {\n              e.preventDefault();\n              e.stopPropagation();\n            });\n\n            this._shadowRootControllerEventTarget.push(arg);\n          }\n        }\n\n        this.controllerArray.push(arg);\n      }\n\n      this._bindControllersOff = this.controllersOff.bind(this);\n      this.addDocEvent('mousedown', this._bindControllersOff, false);\n      this.addDocEvent('keydown', this._bindControllersOff, false);\n      this._antiBlur = true;\n      if (typeof functions.showController === 'function') functions.showController(this.currentControllerName, this.controllerArray, this);\n    },\n\n    /**\r\n     * @description Hide controller at editor area (link button, image resize button..)\r\n     * @param {KeyboardEvent|MouseEvent|null} e Event object when called from mousedown and keydown events registered in \"core.controllersOn\"\r\n     */\n    controllersOff: function controllersOff(e) {\n      this._lineBreaker.style.display = 'none';\n      var len = this.controllerArray.length;\n\n      if (e && e.target && len > 0) {\n        for (var i = 0; i < len; i++) {\n          if (typeof this.controllerArray[i].contains === 'function' && this.controllerArray[i].contains(e.target)) return;\n        }\n      }\n\n      if (this._fileManager.pluginRegExp.test(this.currentControllerName) && e && e.type === 'keydown' && e.keyCode !== 27) return;\n      context.element.lineBreaker_t.style.display = context.element.lineBreaker_b.style.display = 'none';\n      this._variable._lineBreakComp = null;\n      this.currentControllerName = '';\n      this.currentControllerTarget = null;\n      this.currentFileComponentInfo = null;\n      this.effectNode = null;\n      if (!this._bindControllersOff) return;\n      this.removeDocEvent('mousedown', this._bindControllersOff);\n      this.removeDocEvent('keydown', this._bindControllersOff);\n      this._bindControllersOff = null;\n\n      if (len > 0) {\n        for (var _i = 0; _i < len; _i++) {\n          if (typeof this.controllerArray[_i] === 'function') this.controllerArray[_i]();else this.controllerArray[_i].style.display = 'none';\n        }\n\n        this.controllerArray = [];\n      }\n\n      this._antiBlur = false;\n    },\n\n    /**\r\n     * @description Specify the position of the controller.\r\n     * @param {Element} controller Controller element.\r\n     * @param {Element} referEl Element that is the basis of the controller's position.\r\n     * @param {String} position Type of position (\"top\" | \"bottom\")\r\n     * When using the \"top\" position, there should not be an arrow on the controller.\r\n     * When using the \"bottom\" position there should be an arrow on the controller.\r\n     * @param {Object} addOffset These are the left and top values that need to be added specially. \r\n     * This argument is required. - {left: 0, top: 0}\r\n     * Please enter the value based on ltr mode.\r\n     * Calculated automatically in rtl mode.\r\n     */\n    setControllerPosition: function setControllerPosition(controller, referEl, position, addOffset) {\n      if (options.rtl) addOffset.left *= -1;\n      var offset = util.getOffset(referEl, context.element.wysiwygFrame);\n      controller.style.visibility = 'hidden';\n      controller.style.display = 'block'; // Height value of the arrow element is 11px\n\n      var topMargin = position === 'top' ? -(controller.offsetHeight + 2) : referEl.offsetHeight + 12;\n      controller.style.top = offset.top + topMargin + addOffset.top + 'px';\n      var l = offset.left - context.element.wysiwygFrame.scrollLeft + addOffset.left;\n      var controllerW = controller.offsetWidth;\n      var referElW = referEl.offsetWidth;\n      var allow = util.hasClass(controller.firstElementChild, 'se-arrow') ? controller.firstElementChild : null; // rtl (Width value of the arrow element is 22px)\n\n      if (options.rtl) {\n        var rtlW = controllerW > referElW ? controllerW - referElW : 0;\n        var rtlL = rtlW > 0 ? 0 : referElW - controllerW;\n        controller.style.left = l - rtlW + rtlL + 'px';\n\n        if (rtlW > 0) {\n          if (allow) allow.style.left = (controllerW - 14 < 10 + rtlW ? controllerW - 14 : 10 + rtlW) + 'px';\n        }\n\n        var overSize = context.element.wysiwygFrame.offsetLeft - controller.offsetLeft;\n\n        if (overSize > 0) {\n          controller.style.left = '0px';\n          if (allow) allow.style.left = overSize + 'px';\n        }\n      } else {\n        controller.style.left = l + 'px';\n\n        var _overSize = context.element.wysiwygFrame.offsetWidth - (controller.offsetLeft + controllerW);\n\n        if (_overSize < 0) {\n          controller.style.left = controller.offsetLeft + _overSize + 'px';\n          if (allow) allow.style.left = 20 - _overSize + 'px';\n        } else {\n          if (allow) allow.style.left = '20px';\n        }\n      }\n\n      controller.style.visibility = '';\n    },\n\n    /**\r\n     * @description javascript execCommand\r\n     * @param {String} command javascript execCommand function property\r\n     * @param {Boolean|undefined} showDefaultUI javascript execCommand function property\r\n     * @param {String|undefined} value javascript execCommand function property\r\n     */\n    execCommand: function execCommand(command, showDefaultUI, value) {\n      this._wd.execCommand(command, showDefaultUI, command === 'formatBlock' ? '<' + value + '>' : value); // history stack\n\n\n      this.history.push(true);\n    },\n\n    /**\r\n     * @description Focus to wysiwyg area using \"native focus function\"\r\n     */\n    nativeFocus: function nativeFocus() {\n      this.__focus();\n\n      this._editorRange();\n    },\n\n    /**\r\n     * @description Focus method\r\n     * @private\r\n     */\n    __focus: function __focus() {\n      var caption = util.getParentElement(this.getSelectionNode(), 'figcaption');\n\n      if (caption) {\n        caption.focus();\n      } else {\n        context.element.wysiwyg.focus();\n      }\n    },\n\n    /**\r\n     * @description Focus to wysiwyg area\r\n     */\n    focus: function focus() {\n      if (context.element.wysiwygFrame.style.display === 'none') return;\n\n      if (options.iframe) {\n        this.nativeFocus();\n      } else {\n        try {\n          var range = this.getRange();\n\n          if (range.startContainer === range.endContainer && util.isWysiwygDiv(range.startContainer)) {\n            var currentNode = range.commonAncestorContainer.children[range.startOffset];\n\n            if (!util.isFormatElement(currentNode) && !util.isComponent(currentNode)) {\n              var format = util.createElement(options.defaultTag);\n              var br = util.createElement('BR');\n              format.appendChild(br);\n              context.element.wysiwyg.insertBefore(format, currentNode);\n              this.setRange(br, 0, br, 0);\n              return;\n            }\n          }\n\n          this.setRange(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n        } catch (e) {\n          this.nativeFocus();\n        }\n      }\n\n      event._applyTagEffects();\n\n      if (this._isBalloon) event._toggleToolbarBalloon();\n    },\n\n    /**\r\n     * @description If \"focusEl\" is a component, then that component is selected; if it is a format element, the last text is selected\r\n     * If \"focusEdge\" is null, then selected last element\r\n     * @param {Element|null} focusEl Focus element\r\n     */\n    focusEdge: function focusEdge(focusEl) {\n      if (!focusEl) focusEl = context.element.wysiwyg.lastElementChild;\n      var fileComponentInfo = this.getFileComponent(focusEl);\n\n      if (fileComponentInfo) {\n        this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);\n      } else if (focusEl) {\n        focusEl = util.getChildElement(focusEl, function (current) {\n          return current.childNodes.length === 0 || current.nodeType === 3;\n        }, true);\n        if (!focusEl) this.nativeFocus();else this.setRange(focusEl, focusEl.textContent.length, focusEl, focusEl.textContent.length);\n      } else {\n        this.focus();\n      }\n    },\n\n    /**\r\n     * @description Focusout to wysiwyg area (.blur())\r\n     */\n    blur: function blur() {\n      if (options.iframe) {\n        context.element.wysiwygFrame.blur();\n      } else {\n        context.element.wysiwyg.blur();\n      }\n    },\n\n    /**\r\n     * @description Set current editor's range object and return.\r\n     * @param {Node} startCon The startContainer property of the selection object.\r\n     * @param {Number} startOff The startOffset property of the selection object.\r\n     * @param {Node} endCon The endContainer property of the selection object.\r\n     * @param {Number} endOff The endOffset property of the selection object.\r\n     * @returns {Object} Range object.\r\n     */\n    setRange: function setRange(startCon, startOff, endCon, endOff) {\n      if (!startCon || !endCon) return;\n      if (startOff > startCon.textContent.length) startOff = startCon.textContent.length;\n      if (endOff > endCon.textContent.length) endOff = endCon.textContent.length;\n\n      if (util.isFormatElement(startCon)) {\n        startCon = startCon.childNodes[startOff] || startCon.childNodes[startOff - 1] || startCon;\n        startOff = startOff > 0 ? startCon.nodeType === 1 ? 1 : startCon.textContent ? startCon.textContent.length : 0 : 0;\n      }\n\n      if (util.isFormatElement(endCon)) {\n        endCon = endCon.childNodes[endOff] || endCon.childNodes[endOff - 1] || endCon;\n        endOff = endOff > 0 ? endCon.nodeType === 1 ? 1 : endCon.textContent ? endCon.textContent.length : 0 : 0;\n      }\n\n      var range = this._wd.createRange();\n\n      try {\n        range.setStart(startCon, startOff);\n        range.setEnd(endCon, endOff);\n      } catch (error) {\n        console.warn('[SUNEDITOR.core.focus.error] ' + error);\n        this.nativeFocus();\n        return;\n      }\n\n      var selection = this.getSelection();\n\n      if (selection.removeAllRanges) {\n        selection.removeAllRanges();\n      }\n\n      selection.addRange(range);\n\n      this._rangeInfo(range, this.getSelection());\n\n      if (options.iframe) this.__focus();\n      return range;\n    },\n\n    /**\r\n     * @description Remove range object and button effect\r\n     */\n    removeRange: function removeRange() {\n      this._variable._range = null;\n      this._variable._selectionNode = null;\n      if (this.hasFocus) this.getSelection().removeAllRanges();\n\n      this._setKeyEffect([]);\n    },\n\n    /**\r\n     * @description Get current editor's range object\r\n     * @returns {Object}\r\n     */\n    getRange: function getRange() {\n      var range = this._variable._range || this._createDefaultRange();\n\n      var selection = this.getSelection();\n      if (range.collapsed === selection.isCollapsed || !context.element.wysiwyg.contains(selection.focusNode)) return range;\n\n      if (selection.rangeCount > 0) {\n        this._variable._range = selection.getRangeAt(0);\n        return this._variable._range;\n      } else {\n        var sc = selection.anchorNode,\n            ec = selection.focusNode,\n            so = selection.anchorOffset,\n            eo = selection.focusOffset;\n        var compareValue = util.compareElements(sc, ec);\n        var rightDir = compareValue.ancestor && (compareValue.result === 0 ? so <= eo : compareValue.result > 1 ? true : false);\n        return this.setRange(rightDir ? sc : ec, rightDir ? so : eo, rightDir ? ec : sc, rightDir ? eo : so);\n      }\n    },\n\n    /**\r\n     * @description If the \"range\" object is a non-editable area, add a line at the top of the editor and update the \"range\" object.\r\n     * Returns a new \"range\" or argument \"range\".\r\n     * @param {Object} range core.getRange()\r\n     * @param {Element|null} container If there is \"container\" argument, it creates a line in front of the container.\r\n     * @returns {Object} range\r\n     */\n    getRange_addLine: function getRange_addLine(range, container) {\n      if (this._selectionVoid(range)) {\n        var wysiwyg = context.element.wysiwyg;\n        var op = util.createElement(options.defaultTag);\n        op.innerHTML = '<br>';\n        wysiwyg.insertBefore(op, container && container !== wysiwyg ? container.nextElementSibling : wysiwyg.firstElementChild);\n        this.setRange(op.firstElementChild, 0, op.firstElementChild, 1);\n        range = this._variable._range;\n      }\n\n      return range;\n    },\n\n    /**\r\n     * @description Get window selection obejct\r\n     * @returns {Object}\r\n     */\n    getSelection: function getSelection() {\n      return this._shadowRoot && this._shadowRoot.getSelection ? this._shadowRoot.getSelection() : this._ww.getSelection();\n    },\n\n    /**\r\n     * @description Get current select node\r\n     * @returns {Node}\r\n     */\n    getSelectionNode: function getSelectionNode() {\n      if (!context.element.wysiwyg.contains(this._variable._selectionNode)) this._editorRange();\n\n      if (!this._variable._selectionNode) {\n        var selectionNode = util.getChildElement(context.element.wysiwyg.firstChild, function (current) {\n          return current.childNodes.length === 0 || current.nodeType === 3;\n        }, false);\n\n        if (!selectionNode) {\n          this._editorRange();\n        } else {\n          this._variable._selectionNode = selectionNode;\n          return selectionNode;\n        }\n      }\n\n      return this._variable._selectionNode;\n    },\n\n    /**\r\n     * @description Saving the range object and the currently selected node of editor\r\n     * @private\r\n     */\n    _editorRange: function _editorRange() {\n      var selection = this.getSelection();\n      if (!selection) return null;\n      var range = null;\n\n      if (selection.rangeCount > 0) {\n        range = selection.getRangeAt(0);\n      } else {\n        range = this._createDefaultRange();\n      }\n\n      if (util.isFormatElement(range.endContainer) && range.endOffset === 0) {\n        range = this.setRange(range.startContainer, range.startOffset, range.startContainer, range.startContainer.length);\n      }\n\n      this._rangeInfo(range, selection);\n    },\n\n    /**\r\n     * @description Set \"range\" and \"selection\" info.\r\n     * @param {Object} range range object.\r\n     * @param {Object} selection selection object.\r\n     */\n    _rangeInfo: function _rangeInfo(range, selection) {\n      var selectionNode = null;\n      this._variable._range = range;\n\n      if (range.collapsed) {\n        if (util.isWysiwygDiv(range.commonAncestorContainer)) selectionNode = range.commonAncestorContainer.children[range.startOffset] || range.commonAncestorContainer;else selectionNode = range.commonAncestorContainer;\n      } else {\n        selectionNode = selection.extentNode || selection.anchorNode;\n      }\n\n      this._variable._selectionNode = selectionNode;\n    },\n\n    /**\r\n     * @description Return the range object of editor's first child node\r\n     * @returns {Object}\r\n     * @private\r\n     */\n    _createDefaultRange: function _createDefaultRange() {\n      var wysiwyg = context.element.wysiwyg;\n      wysiwyg.focus();\n\n      var range = this._wd.createRange();\n\n      var focusEl = wysiwyg.firstElementChild;\n\n      if (!focusEl) {\n        focusEl = util.createElement(options.defaultTag);\n        focusEl.innerHTML = '<br>';\n        wysiwyg.appendChild(focusEl);\n      }\n\n      range.setStart(focusEl, 0);\n      range.setEnd(focusEl, 0);\n      return range;\n    },\n\n    /**\r\n     * @description Returns true if there is no valid \"selection\".\r\n     * @param {Object} range core.getRange()\r\n     * @returns {Object} range\r\n     * @private\r\n     */\n    _selectionVoid: function _selectionVoid(range) {\n      var comm = range.commonAncestorContainer;\n      return util.isWysiwygDiv(range.startContainer) && util.isWysiwygDiv(range.endContainer) || /FIGURE/i.test(comm.nodeName) || this._fileManager.regExp.test(comm.nodeName) || util.isMediaComponent(comm);\n    },\n\n    /**\r\n     * @description Reset range object to text node selected status.\r\n     * @returns {Boolean} Returns false if there is no valid selection.\r\n     * @private\r\n     */\n    _resetRangeToTextNode: function _resetRangeToTextNode() {\n      var range = this.getRange();\n      if (this._selectionVoid(range)) return false;\n      var startCon = range.startContainer;\n      var startOff = range.startOffset;\n      var endCon = range.endContainer;\n      var endOff = range.endOffset;\n      var tempCon, tempOffset, tempChild;\n\n      if (util.isFormatElement(startCon)) {\n        if (!startCon.childNodes[startOff]) {\n          startCon = startCon.lastChild || startCon;\n          startOff = startCon.textContent.length;\n        } else {\n          startCon = startCon.childNodes[startOff] || startCon;\n          startOff = 0;\n        }\n\n        while (startCon && startCon.nodeType === 1 && startCon.firstChild) {\n          startCon = startCon.firstChild || startCon;\n          startOff = 0;\n        }\n      }\n\n      if (util.isFormatElement(endCon)) {\n        endCon = endCon.childNodes[endOff] || endCon.lastChild || endCon;\n\n        while (endCon && endCon.nodeType === 1 && endCon.lastChild) {\n          endCon = endCon.lastChild;\n        }\n\n        endOff = endCon.textContent.length;\n      } // startContainer\n\n\n      tempCon = util.isWysiwygDiv(startCon) ? context.element.wysiwyg.firstChild : startCon;\n      tempOffset = startOff;\n\n      if (util.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {\n        var onlyBreak = util.isBreak(tempCon);\n\n        if (!onlyBreak) {\n          while (tempCon && !util.isBreak(tempCon) && tempCon.nodeType === 1) {\n            tempCon = tempCon.childNodes[tempOffset] || tempCon.nextElementSibling || tempCon.nextSibling;\n            tempOffset = 0;\n          }\n\n          var format = util.getFormatElement(tempCon, null);\n\n          if (format === util.getRangeFormatElement(format, null)) {\n            format = util.createElement(util.getParentElement(tempCon, util.isCell) ? 'DIV' : options.defaultTag);\n            tempCon.parentNode.insertBefore(format, tempCon);\n            format.appendChild(tempCon);\n          }\n        }\n\n        if (util.isBreak(tempCon)) {\n          var emptyText = util.createTextNode(util.zeroWidthSpace);\n          tempCon.parentNode.insertBefore(emptyText, tempCon);\n          tempCon = emptyText;\n\n          if (onlyBreak) {\n            if (startCon === endCon) {\n              endCon = tempCon;\n              endOff = 1;\n            }\n          }\n        }\n      } // set startContainer\n\n\n      startCon = tempCon;\n      startOff = tempOffset; // endContainer\n\n      tempCon = util.isWysiwygDiv(endCon) ? context.element.wysiwyg.lastChild : endCon;\n      tempOffset = endOff;\n\n      if (util.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {\n        var _onlyBreak = util.isBreak(tempCon);\n\n        if (!_onlyBreak) {\n          while (tempCon && !util.isBreak(tempCon) && tempCon.nodeType === 1) {\n            tempChild = tempCon.childNodes;\n            if (tempChild.length === 0) break;\n            tempCon = tempChild[tempOffset > 0 ? tempOffset - 1 : tempOffset] || !/FIGURE/i.test(tempChild[0].nodeName) ? tempChild[0] : tempCon.previousElementSibling || tempCon.previousSibling || startCon;\n            tempOffset = tempOffset > 0 ? tempCon.textContent.length : tempOffset;\n          }\n\n          var _format = util.getFormatElement(tempCon, null);\n\n          if (_format === util.getRangeFormatElement(_format, null)) {\n            _format = util.createElement(util.isCell(_format) ? 'DIV' : options.defaultTag);\n            tempCon.parentNode.insertBefore(_format, tempCon);\n\n            _format.appendChild(tempCon);\n          }\n        }\n\n        if (util.isBreak(tempCon)) {\n          var _emptyText = util.createTextNode(util.zeroWidthSpace);\n\n          tempCon.parentNode.insertBefore(_emptyText, tempCon);\n          tempCon = _emptyText;\n          tempOffset = 1;\n\n          if (_onlyBreak && !tempCon.previousSibling) {\n            util.removeItem(endCon);\n          }\n        }\n      } // set endContainer\n\n\n      endCon = tempCon;\n      endOff = tempOffset; // set Range\n\n      this.setRange(startCon, startOff, endCon, endOff);\n      return true;\n    },\n\n    /**\r\n     * @description Returns a \"formatElement\"(util.isFormatElement) array from the currently selected range.\r\n     * @param {Function|null} validation The validation function. (Replaces the default validation function-util.isFormatElement(current))\r\n     * @returns {Array}\r\n     */\n    getSelectedElements: function getSelectedElements(validation) {\n      if (!this._resetRangeToTextNode()) return [];\n      var range = this.getRange();\n\n      if (util.isWysiwygDiv(range.startContainer)) {\n        var children = context.element.wysiwyg.children;\n        if (children.length === 0) return [];\n        this.setRange(children[0], 0, children[children.length - 1], children[children.length - 1].textContent.trim().length);\n        range = this.getRange();\n      }\n\n      var startCon = range.startContainer;\n      var endCon = range.endContainer;\n      var commonCon = range.commonAncestorContainer; // get line nodes\n\n      var lineNodes = util.getListChildren(commonCon, function (current) {\n        return validation ? validation(current) : util.isFormatElement(current);\n      });\n      if (!util.isWysiwygDiv(commonCon) && !util.isRangeFormatElement(commonCon)) lineNodes.unshift(util.getFormatElement(commonCon, null));\n      if (startCon === endCon || lineNodes.length === 1) return lineNodes;\n      var startLine = util.getFormatElement(startCon, null);\n      var endLine = util.getFormatElement(endCon, null);\n      var startIdx = null;\n      var endIdx = null;\n\n      var onlyTable = function onlyTable(current) {\n        return util.isTable(current) ? /^TABLE$/i.test(current.nodeName) : true;\n      };\n\n      var startRangeEl = util.getRangeFormatElement(startLine, onlyTable);\n      var endRangeEl = util.getRangeFormatElement(endLine, onlyTable);\n      if (util.isTable(startRangeEl) && util.isListCell(startRangeEl.parentNode)) startRangeEl = startRangeEl.parentNode;\n      if (util.isTable(endRangeEl) && util.isListCell(endRangeEl.parentNode)) endRangeEl = endRangeEl.parentNode;\n      var sameRange = startRangeEl === endRangeEl;\n\n      for (var i = 0, len = lineNodes.length, line; i < len; i++) {\n        line = lineNodes[i];\n\n        if (startLine === line || !sameRange && line === startRangeEl) {\n          startIdx = i;\n          continue;\n        }\n\n        if (endLine === line || !sameRange && line === endRangeEl) {\n          endIdx = i;\n          break;\n        }\n      }\n\n      if (startIdx === null) startIdx = 0;\n      if (endIdx === null) endIdx = lineNodes.length - 1;\n      return lineNodes.slice(startIdx, endIdx + 1);\n    },\n\n    /**\r\n     * @description Get format elements and components from the selected area. (P, DIV, H[1-6], OL, UL, TABLE..)\r\n     * If some of the component are included in the selection, get the entire that component.\r\n     * @param {Boolean} removeDuplicate If true, if there is a parent and child tag among the selected elements, the child tag is excluded.\r\n     * @returns {Array}\r\n     */\n    getSelectedElementsAndComponents: function getSelectedElementsAndComponents(removeDuplicate) {\n      var commonCon = this.getRange().commonAncestorContainer;\n      var myComponent = util.getParentElement(commonCon, util.isComponent);\n      var selectedLines = util.isTable(commonCon) ? this.getSelectedElements(null) : this.getSelectedElements(function (current) {\n        var component = this.getParentElement(current, this.isComponent);\n        return this.isFormatElement(current) && (!component || component === myComponent) || this.isComponent(current) && !this.getFormatElement(current);\n      }.bind(util));\n\n      if (removeDuplicate) {\n        for (var i = 0, len = selectedLines.length; i < len; i++) {\n          for (var j = i - 1; j >= 0; j--) {\n            if (selectedLines[j].contains(selectedLines[i])) {\n              selectedLines.splice(i, 1);\n              i--;\n              len--;\n              break;\n            }\n          }\n        }\n      }\n\n      return selectedLines;\n    },\n\n    /**\r\n     * @description Determine if this offset is the edge offset of container\r\n     * @param {Node} container The node of the selection object. (range.startContainer..)\r\n     * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)\r\n     * @param {String|undefined} dir Select check point - Both edge, Front edge or End edge. (\"front\": Front edge, \"end\": End edge, undefined: Both edge)\r\n     * @returns {Boolean}\r\n     */\n    isEdgePoint: function isEdgePoint(container, offset, dir) {\n      return dir !== 'end' && offset === 0 || (!dir || dir !== 'front') && !container.nodeValue && offset === 1 || (!dir || dir === 'end') && !!container.nodeValue && offset === container.nodeValue.length;\n    },\n\n    /**\r\n     * @description Check if the container and offset values are the edges of the format tag\r\n     * @param {Node} container The node of the selection object. (range.startContainer..)\r\n     * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)\r\n     * @param {String} dir Select check point - \"front\": Front edge, \"end\": End edge, undefined: Both edge.\r\n     * @returns {Array|null}\r\n     * @private\r\n     */\n    _isEdgeFormat: function _isEdgeFormat(node, offset, dir) {\n      if (!this.isEdgePoint(node, offset, dir)) return false;\n      var result = [];\n      dir = dir === 'front' ? 'previousSibling' : 'nextSibling';\n\n      while (node && !util.isFormatElement(node) && !util.isWysiwygDiv(node)) {\n        if (!node[dir] || util.isBreak(node[dir]) && !node[dir][dir]) {\n          if (node.nodeType === 1) result.push(node.cloneNode(false));\n          node = node.parentNode;\n        } else {\n          return null;\n        }\n      }\n\n      return result;\n    },\n\n    /**\r\n     * @description Show loading box\r\n     */\n    showLoading: function showLoading() {\n      context.element.loading.style.display = 'block';\n    },\n\n    /**\r\n     * @description Close loading box\r\n     */\n    closeLoading: function closeLoading() {\n      context.element.loading.style.display = 'none';\n    },\n\n    /**\r\n     * @description Append format element to sibling node of argument element.\r\n     * If the \"formatNodeName\" argument value is present, the tag of that argument value is inserted,\r\n     * If not, the currently selected format tag is inserted.\r\n     * @param {Element} element Insert as siblings of that element\r\n     * @param {String|Element|null} formatNode Node name or node obejct to be inserted\r\n     * @returns {Element}\r\n     */\n    appendFormatTag: function appendFormatTag(element, formatNode) {\n      if (!element || !element.parentNode) return null;\n      var currentFormatEl = util.getFormatElement(this.getSelectionNode(), null);\n      var oFormat = null;\n\n      if (util.isFreeFormatElement(currentFormatEl || element.parentNode)) {\n        oFormat = util.createElement('BR');\n      } else {\n        var oFormatName = formatNode ? typeof formatNode === 'string' ? formatNode : formatNode.nodeName : util.isFormatElement(currentFormatEl) && !util.isRangeFormatElement(currentFormatEl) && !util.isFreeFormatElement(currentFormatEl) ? currentFormatEl.nodeName : options.defaultTag;\n        oFormat = util.createElement(oFormatName);\n        oFormat.innerHTML = '<br>';\n\n        if (formatNode && typeof formatNode !== 'string' || !formatNode && util.isFormatElement(currentFormatEl)) {\n          util.copyTagAttributes(oFormat, formatNode || currentFormatEl);\n        }\n      }\n\n      if (util.isCell(element)) element.insertBefore(oFormat, element.nextElementSibling);else element.parentNode.insertBefore(oFormat, element.nextElementSibling);\n      return oFormat;\n    },\n\n    /**\r\n     * @description The method to insert a element and return. (used elements : table, hr, image, video)\r\n     * If \"element\" is \"HR\", insert and return the new line.\r\n     * @param {Element} element Element to be inserted\r\n     * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)\r\n     * @param {Boolean} checkCharCount If true, if \"options.maxCharCount\" is exceeded when \"element\" is added, null is returned without addition.\r\n     * @param {Boolean} notSelect If true, Do not automatically select the inserted component.\r\n     * @returns {Element}\r\n     */\n    insertComponent: function insertComponent(element, notHistoryPush, checkCharCount, notSelect) {\n      if (this.isReadOnly || checkCharCount && !this.checkCharCount(element, null)) {\n        return null;\n      }\n\n      var r = this.removeNode();\n      this.getRange_addLine(this.getRange(), r.container);\n      var oNode = null;\n      var selectionNode = this.getSelectionNode();\n      var formatEl = util.getFormatElement(selectionNode, null);\n\n      if (util.isListCell(formatEl)) {\n        this.insertNode(element, selectionNode === formatEl ? null : r.container.nextSibling, false);\n        if (!element.nextSibling) element.parentNode.appendChild(util.createElement('BR'));\n      } else {\n        if (this.getRange().collapsed && (r.container.nodeType === 3 || util.isBreak(r.container))) {\n          var depthFormat = util.getParentElement(r.container, function (current) {\n            return this.isRangeFormatElement(current);\n          }.bind(util));\n          oNode = util.splitElement(r.container, r.offset, !depthFormat ? 0 : util.getElementDepth(depthFormat) + 1);\n          if (oNode) formatEl = oNode.previousSibling;\n        }\n\n        this.insertNode(element, util.isRangeFormatElement(formatEl) ? null : formatEl, false);\n        if (formatEl && util.onlyZeroWidthSpace(formatEl)) util.removeItem(formatEl);\n      }\n\n      if (!notSelect) {\n        this.setRange(element, 0, element, 0);\n        var fileComponentInfo = this.getFileComponent(element);\n\n        if (fileComponentInfo) {\n          this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);\n        } else if (oNode) {\n          oNode = util.getEdgeChildNodes(oNode, null).sc || oNode;\n          this.setRange(oNode, 0, oNode, 0);\n        }\n      } // history stack\n\n\n      if (!notHistoryPush) this.history.push(1);\n      return oNode || element;\n    },\n\n    /**\r\n     * @description Gets the file component and that plugin name\r\n     * return: {target, component, pluginName} | null\r\n     * @param {Element} element Target element (figure tag, component div, file tag)\r\n     * @returns {Object|null}\r\n     */\n    getFileComponent: function getFileComponent(element) {\n      if (!this._fileManager.queryString || !element) return null;\n      var target, pluginName;\n\n      if (/^FIGURE$/i.test(element.nodeName) || /se-component/.test(element.className)) {\n        target = element.querySelector(this._fileManager.queryString);\n      }\n\n      if (!target && element.nodeName && this._fileManager.regExp.test(element.nodeName)) {\n        target = element;\n      }\n\n      if (target) {\n        pluginName = this._fileManager.pluginMap[target.nodeName.toLowerCase()];\n\n        if (pluginName) {\n          return {\n            target: target,\n            component: util.getParentElement(target, util.isComponent),\n            pluginName: pluginName\n          };\n        }\n      }\n\n      return null;\n    },\n\n    /**\r\n     * @description The component(image, video) is selected and the resizing module is called.\r\n     * @param {Element} element Element tag (img, iframe, video)\r\n     * @param {String} pluginName Plugin name (image, video)\r\n     */\n    selectComponent: function selectComponent(element, pluginName) {\n      if (util.isUneditableComponent(util.getParentElement(element, util.isComponent)) || util.isUneditableComponent(element)) return false;\n      if (!this.hasFocus) this.focus();\n      var plugin = this.plugins[pluginName];\n      if (!plugin) return;\n\n      _w.setTimeout(function () {\n        if (typeof plugin.select === 'function') this.callPlugin(pluginName, plugin.select.bind(this, element), null);\n\n        this._setComponentLineBreaker(element);\n      }.bind(this));\n    },\n\n    /**\r\n     * @description Set line breaker of component\r\n     * @param {Element} element Element tag (img, iframe, video)\r\n     * @private\r\n     */\n    _setComponentLineBreaker: function _setComponentLineBreaker(element) {\n      // line breaker\n      this._lineBreaker.style.display = 'none';\n      var container = util.getParentElement(element, util.isComponent);\n      var t_style = context.element.lineBreaker_t.style;\n      var b_style = context.element.lineBreaker_b.style;\n      var target = this.context.resizing.resizeContainer.style.display === 'block' ? this.context.resizing.resizeContainer : element;\n      var isList = util.isListCell(container.parentNode);\n      var componentTop, wScroll, w; // top\n\n      if (isList ? !container.previousSibling : !util.isFormatElement(container.previousElementSibling)) {\n        this._variable._lineBreakComp = container;\n        wScroll = context.element.wysiwyg.scrollTop;\n        componentTop = util.getOffset(element, context.element.wysiwygFrame).top + wScroll;\n        w = target.offsetWidth / 2 / 2;\n        t_style.top = componentTop - wScroll - 12 + 'px';\n        t_style.left = util.getOffset(target).left + w + 'px';\n        t_style.display = 'block';\n      } else {\n        t_style.display = 'none';\n      } // bottom\n\n\n      if (isList ? !container.nextSibling : !util.isFormatElement(container.nextElementSibling)) {\n        if (!componentTop) {\n          this._variable._lineBreakComp = container;\n          wScroll = context.element.wysiwyg.scrollTop;\n          componentTop = util.getOffset(element, context.element.wysiwygFrame).top + wScroll;\n          w = target.offsetWidth / 2 / 2;\n        }\n\n        b_style.top = componentTop + target.offsetHeight - wScroll - 12 + 'px';\n        b_style.left = util.getOffset(target).left + target.offsetWidth - w - 24 + 'px';\n        b_style.display = 'block';\n      } else {\n        b_style.display = 'none';\n      }\n    },\n\n    /**\r\n     * @description Delete selected node and insert argument value node and return.\r\n     * If the \"afterNode\" exists, it is inserted after the \"afterNode\"\r\n     * Inserting a text node merges with both text nodes on both sides and returns a new \"{ container, startOffset, endOffset }\".\r\n     * @param {Node} oNode Element to be inserted\r\n     * @param {Node|null} afterNode If the node exists, it is inserted after the node\r\n     * @param {Boolean} checkCharCount If true, if \"options.maxCharCount\" is exceeded when \"element\" is added, null is returned without addition.\r\n     * @returns {Object|Node|null}\r\n     */\n    insertNode: function insertNode(oNode, afterNode, checkCharCount) {\n      if (this.isReadOnly || checkCharCount && !this.checkCharCount(oNode, null)) {\n        return null;\n      }\n\n      var range = this.getRange();\n      var line = util.isListCell(range.commonAncestorContainer) ? range.commonAncestorContainer : util.getFormatElement(this.getSelectionNode(), null);\n      var insertListCell = util.isListCell(line) && (util.isListCell(oNode) || util.isList(oNode));\n      var parentNode,\n          originAfter,\n          tempAfterNode,\n          tempParentNode = null;\n      var freeFormat = util.isFreeFormatElement(line);\n      var isFormats = !freeFormat && (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode)) || util.isComponent(oNode);\n\n      if (insertListCell) {\n        tempAfterNode = afterNode || util.isList(oNode) ? line.lastChild : line.nextElementSibling;\n        tempParentNode = util.isList(oNode) ? line : (tempAfterNode || line).parentNode;\n      }\n\n      if (!afterNode && (isFormats || util.isComponent(oNode) || util.isMedia(oNode))) {\n        var isEdge = this.isEdgePoint(range.endContainer, range.endOffset, 'end');\n        var r = this.removeNode();\n        var container = r.container;\n        var prevContainer = r.prevContainer;\n\n        if (insertListCell && prevContainer) {\n          tempParentNode = prevContainer.nodeType === 3 ? prevContainer.parentNode : prevContainer;\n\n          if (tempParentNode.contains(container)) {\n            var sameParent = true;\n            tempAfterNode = container;\n\n            while (tempAfterNode.parentNode && tempAfterNode.parentNode !== tempParentNode) {\n              tempAfterNode = tempAfterNode.parentNode;\n              sameParent = false;\n            }\n\n            if (sameParent && container === prevContainer) tempAfterNode = tempAfterNode.nextSibling;\n          } else {\n            tempAfterNode = null;\n          }\n        } else if (insertListCell && util.isListCell(container) && !line.parentElement) {\n          line = util.createElement('LI');\n          tempParentNode.appendChild(line);\n          container.appendChild(tempParentNode);\n          tempAfterNode = null;\n        } else if (container.nodeType === 3 || util.isBreak(container) || insertListCell) {\n          var depthFormat = util.getParentElement(container, function (current) {\n            return this.isRangeFormatElement(current) || this.isListCell(current);\n          }.bind(util));\n          afterNode = util.splitElement(container, r.offset, !depthFormat ? 0 : util.getElementDepth(depthFormat) + 1);\n\n          if (afterNode) {\n            if (insertListCell) {\n              if (line.contains(container)) {\n                var subList = util.isList(line.lastElementChild);\n                var newCell = null;\n\n                if (!isEdge) {\n                  newCell = line.cloneNode(false);\n                  newCell.appendChild(afterNode.textContent.trim() ? afterNode : util.createTextNode(util.zeroWidthSpace));\n                }\n\n                if (subList) {\n                  if (!newCell) {\n                    newCell = line.cloneNode(false);\n                    newCell.appendChild(util.createTextNode(util.zeroWidthSpace));\n                  }\n\n                  newCell.appendChild(line.lastElementChild);\n                }\n\n                if (newCell) {\n                  tempParentNode.insertBefore(newCell, line.nextElementSibling);\n                  tempAfterNode = afterNode = newCell;\n                }\n              }\n            } else {\n              afterNode = afterNode.previousSibling;\n            }\n          }\n        }\n      }\n\n      range = !afterNode && !isFormats ? this.getRange_addLine(this.getRange(), null) : this.getRange();\n      var commonCon = range.commonAncestorContainer;\n      var startOff = range.startOffset;\n      var endOff = range.endOffset;\n      var formatRange = range.startContainer === commonCon && util.isFormatElement(commonCon);\n      var startCon = formatRange ? commonCon.childNodes[startOff] || commonCon.childNodes[0] || range.startContainer : range.startContainer;\n      var endCon = formatRange ? commonCon.childNodes[endOff] || commonCon.childNodes[commonCon.childNodes.length - 1] || range.endContainer : range.endContainer;\n\n      if (!insertListCell) {\n        if (!afterNode) {\n          parentNode = startCon;\n\n          if (startCon.nodeType === 3) {\n            parentNode = startCon.parentNode;\n          }\n          /** No Select range node */\n\n\n          if (range.collapsed) {\n            if (commonCon.nodeType === 3) {\n              if (commonCon.textContent.length > endOff) afterNode = commonCon.splitText(endOff);else afterNode = commonCon.nextSibling;\n            } else {\n              if (!util.isBreak(parentNode)) {\n                var c = parentNode.childNodes[startOff];\n                var focusNode = c && c.nodeType === 3 && util.onlyZeroWidthSpace(c) && util.isBreak(c.nextSibling) ? c.nextSibling : c;\n\n                if (focusNode) {\n                  if (!focusNode.nextSibling) {\n                    parentNode.removeChild(focusNode);\n                    afterNode = null;\n                  } else {\n                    afterNode = util.isBreak(focusNode) && !util.isBreak(oNode) ? focusNode : focusNode.nextSibling;\n                  }\n                } else {\n                  afterNode = null;\n                }\n              } else {\n                afterNode = parentNode;\n                parentNode = parentNode.parentNode;\n              }\n            }\n          } else {\n            /** Select range nodes */\n            var isSameContainer = startCon === endCon;\n\n            if (isSameContainer) {\n              if (this.isEdgePoint(endCon, endOff)) afterNode = endCon.nextSibling;else afterNode = endCon.splitText(endOff);\n              var removeNode = startCon;\n              if (!this.isEdgePoint(startCon, startOff)) removeNode = startCon.splitText(startOff);\n              parentNode.removeChild(removeNode);\n\n              if (parentNode.childNodes.length === 0 && isFormats) {\n                parentNode.innerHTML = '<br>';\n              }\n            } else {\n              var removedTag = this.removeNode();\n              var _container = removedTag.container;\n              var _prevContainer = removedTag.prevContainer;\n\n              if (_container && _container.childNodes.length === 0 && isFormats) {\n                if (util.isFormatElement(_container)) {\n                  _container.innerHTML = '<br>';\n                } else if (util.isRangeFormatElement(_container)) {\n                  _container.innerHTML = '<' + options.defaultTag + '><br></' + options.defaultTag + '>';\n                }\n              }\n\n              if (util.isListCell(_container) && oNode.nodeType === 3) {\n                parentNode = _container;\n                afterNode = null;\n              } else if (!isFormats && _prevContainer) {\n                parentNode = _prevContainer.nodeType === 3 ? _prevContainer.parentNode : _prevContainer;\n\n                if (parentNode.contains(_container)) {\n                  var _sameParent = true;\n                  afterNode = _container;\n\n                  while (afterNode.parentNode && afterNode.parentNode !== parentNode) {\n                    afterNode = afterNode.parentNode;\n                    _sameParent = false;\n                  }\n\n                  if (_sameParent && _container === _prevContainer) afterNode = afterNode.nextSibling;\n                } else {\n                  afterNode = null;\n                }\n              } else {\n                afterNode = isFormats ? endCon : _container === _prevContainer ? _container.nextSibling : _container;\n                parentNode = !afterNode || !afterNode.parentNode ? commonCon : afterNode.parentNode;\n              }\n\n              while (afterNode && !util.isFormatElement(afterNode) && afterNode.parentNode !== commonCon) {\n                afterNode = afterNode.parentNode;\n              }\n            }\n          }\n        } else {\n          // has afterNode\n          parentNode = afterNode.parentNode;\n          afterNode = afterNode.nextSibling;\n          originAfter = true;\n        }\n      }\n\n      try {\n        // set node\n        if (!insertListCell) {\n          if (util.isWysiwygDiv(afterNode) || parentNode === context.element.wysiwyg.parentNode) {\n            parentNode = context.element.wysiwyg;\n            afterNode = null;\n          }\n\n          if (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode) || !util.isListCell(parentNode) && util.isComponent(oNode)) {\n            var oldParent = parentNode;\n\n            if (util.isList(afterNode)) {\n              parentNode = afterNode;\n              afterNode = null;\n            } else if (util.isListCell(afterNode)) {\n              parentNode = afterNode.previousElementSibling || afterNode;\n            } else if (!originAfter && !afterNode) {\n              var _r = this.removeNode();\n\n              var _container2 = _r.container.nodeType === 3 ? util.isListCell(util.getFormatElement(_r.container, null)) ? _r.container : util.getFormatElement(_r.container, null) || _r.container.parentNode : _r.container;\n\n              var rangeCon = util.isWysiwygDiv(_container2) || util.isRangeFormatElement(_container2);\n              parentNode = rangeCon ? _container2 : _container2.parentNode;\n              afterNode = rangeCon ? null : _container2.nextSibling;\n            }\n\n            if (oldParent.childNodes.length === 0 && parentNode !== oldParent) util.removeItem(oldParent);\n          }\n\n          if (isFormats && !freeFormat && !util.isRangeFormatElement(parentNode) && !util.isListCell(parentNode) && !util.isWysiwygDiv(parentNode)) {\n            afterNode = parentNode.nextElementSibling;\n            parentNode = parentNode.parentNode;\n          }\n\n          if (util.isWysiwygDiv(parentNode) && (oNode.nodeType === 3 || util.isBreak(oNode))) {\n            var fNode = util.createElement(options.defaultTag);\n            fNode.appendChild(oNode);\n            oNode = fNode;\n          }\n        } // insert--\n\n\n        if (insertListCell) {\n          if (!tempParentNode.parentNode) {\n            parentNode = context.element.wysiwyg;\n            afterNode = null;\n          } else {\n            parentNode = tempParentNode;\n            afterNode = tempAfterNode;\n          }\n        } else {\n          afterNode = parentNode === afterNode ? parentNode.lastChild : afterNode;\n        }\n\n        if (util.isListCell(oNode) && !util.isList(parentNode)) {\n          if (util.isListCell(parentNode)) {\n            afterNode = parentNode.nextElementSibling;\n            parentNode = parentNode.parentNode;\n          } else {\n            var ul = util.createElement('ol');\n            parentNode.insertBefore(ul, afterNode);\n            parentNode = ul;\n            afterNode = null;\n          }\n\n          insertListCell = true;\n        }\n\n        parentNode.insertBefore(oNode, afterNode);\n\n        if (insertListCell) {\n          if (util.onlyZeroWidthSpace(line.textContent.trim())) {\n            util.removeItem(line);\n            oNode = oNode.lastChild;\n          } else {\n            var chList = util.getArrayItem(line.children, util.isList);\n\n            if (chList) {\n              if (oNode !== chList) {\n                oNode.appendChild(chList);\n                oNode = chList.previousSibling;\n              } else {\n                parentNode.appendChild(oNode);\n                oNode = parentNode;\n              }\n\n              if (util.onlyZeroWidthSpace(line.textContent.trim())) {\n                util.removeItem(line);\n              }\n            }\n          }\n        }\n      } catch (e) {\n        parentNode.appendChild(oNode);\n      } finally {\n        if ((util.isFormatElement(oNode) || util.isComponent(oNode)) && startCon === endCon) {\n          var cItem = util.getFormatElement(commonCon, null);\n\n          if (cItem && cItem.nodeType === 1 && util.isEmptyLine(cItem)) {\n            util.removeItem(cItem);\n          }\n        }\n\n        if (freeFormat && (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode))) {\n          oNode = this._setIntoFreeFormat(oNode);\n        }\n\n        if (!util.isComponent(oNode)) {\n          var offset = 1;\n\n          if (oNode.nodeType === 3) {\n            var previous = oNode.previousSibling;\n            var next = oNode.nextSibling;\n            var previousText = !previous || previous.nodeType === 1 || util.onlyZeroWidthSpace(previous) ? '' : previous.textContent;\n            var nextText = !next || next.nodeType === 1 || util.onlyZeroWidthSpace(next) ? '' : next.textContent;\n\n            if (previous && previousText.length > 0) {\n              oNode.textContent = previousText + oNode.textContent;\n              util.removeItem(previous);\n            }\n\n            if (next && next.length > 0) {\n              oNode.textContent += nextText;\n              util.removeItem(next);\n            }\n\n            var newRange = {\n              container: oNode,\n              startOffset: previousText.length,\n              endOffset: oNode.textContent.length - nextText.length\n            };\n            this.setRange(oNode, newRange.startOffset, oNode, newRange.endOffset);\n            return newRange;\n          } else if (!util.isBreak(oNode) && !util.isListCell(oNode) && util.isFormatElement(parentNode)) {\n            var zeroWidth = null;\n\n            if (!oNode.previousSibling || util.isBreak(oNode.previousSibling)) {\n              zeroWidth = util.createTextNode(util.zeroWidthSpace);\n              oNode.parentNode.insertBefore(zeroWidth, oNode);\n            }\n\n            if (!oNode.nextSibling || util.isBreak(oNode.nextSibling)) {\n              zeroWidth = util.createTextNode(util.zeroWidthSpace);\n              oNode.parentNode.insertBefore(zeroWidth, oNode.nextSibling);\n            }\n\n            if (util._isIgnoreNodeChange(oNode)) {\n              oNode = oNode.nextSibling;\n              offset = 0;\n            }\n          }\n\n          this.setRange(oNode, offset, oNode, offset);\n        } // history stack\n\n\n        this.history.push(true);\n        return oNode;\n      }\n    },\n    _setIntoFreeFormat: function _setIntoFreeFormat(oNode) {\n      var parentNode = oNode.parentNode;\n      var oNodeChildren, lastONode;\n\n      while (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode)) {\n        oNodeChildren = oNode.childNodes;\n        lastONode = null;\n\n        while (oNodeChildren[0]) {\n          lastONode = oNodeChildren[0];\n\n          if (util.isFormatElement(lastONode) || util.isRangeFormatElement(lastONode)) {\n            this._setIntoFreeFormat(lastONode);\n\n            if (!oNode.parentNode) break;\n            oNodeChildren = oNode.childNodes;\n            continue;\n          }\n\n          parentNode.insertBefore(lastONode, oNode);\n        }\n\n        if (oNode.childNodes.length === 0) util.removeItem(oNode);\n        oNode = util.createElement('BR');\n        parentNode.insertBefore(oNode, lastONode.nextSibling);\n      }\n\n      return oNode;\n    },\n\n    /**\r\n     * @description Delete the currently selected nodes and reset selection range\r\n     * Returns {container: \"the last element after deletion\", offset: \"offset\", prevContainer: \"previousElementSibling Of the deleted area\"}\r\n     * @returns {Object}\r\n     */\n    removeNode: function removeNode() {\n      this._resetRangeToTextNode();\n\n      var range = this.getRange();\n      var container,\n          offset = 0;\n      var startCon = range.startContainer;\n      var endCon = range.endContainer;\n      var startOff = range.startOffset;\n      var endOff = range.endOffset;\n      var commonCon = range.commonAncestorContainer.nodeType === 3 && range.commonAncestorContainer.parentNode === startCon.parentNode ? startCon.parentNode : range.commonAncestorContainer;\n\n      if (commonCon === startCon && commonCon === endCon) {\n        startCon = commonCon.children[startOff];\n        endCon = commonCon.children[endOff];\n        startOff = endOff = 0;\n      }\n\n      var beforeNode = null;\n      var afterNode = null;\n      var childNodes = util.getListChildNodes(commonCon, null);\n      var startIndex = util.getArrayIndex(childNodes, startCon);\n      var endIndex = util.getArrayIndex(childNodes, endCon);\n\n      if (childNodes.length > 0 && startIndex > -1 && endIndex > -1) {\n        for (var i = startIndex + 1, startNode = startCon; i >= 0; i--) {\n          if (childNodes[i] === startNode.parentNode && childNodes[i].firstChild === startNode && startOff === 0) {\n            startIndex = i;\n            startNode = startNode.parentNode;\n          }\n        }\n\n        for (var _i2 = endIndex - 1, endNode = endCon; _i2 > startIndex; _i2--) {\n          if (childNodes[_i2] === endNode.parentNode && childNodes[_i2].nodeType === 1) {\n            childNodes.splice(_i2, 1);\n            endNode = endNode.parentNode;\n            --endIndex;\n          }\n        }\n      } else {\n        if (childNodes.length === 0) {\n          if (util.isFormatElement(commonCon) || util.isRangeFormatElement(commonCon) || util.isWysiwygDiv(commonCon) || util.isBreak(commonCon) || util.isMedia(commonCon)) {\n            return {\n              container: commonCon,\n              offset: 0\n            };\n          } else if (commonCon.nodeType === 3) {\n            return {\n              container: commonCon,\n              offset: endOff\n            };\n          }\n\n          childNodes.push(commonCon);\n          startCon = endCon = commonCon;\n        } else {\n          startCon = endCon = childNodes[0];\n\n          if (util.isBreak(startCon) || util.onlyZeroWidthSpace(startCon)) {\n            return {\n              container: util.isMedia(commonCon) ? commonCon : startCon,\n              offset: 0\n            };\n          }\n        }\n\n        startIndex = endIndex = 0;\n      }\n\n      for (var _i3 = startIndex; _i3 <= endIndex; _i3++) {\n        var item = childNodes[_i3];\n\n        if (item.length === 0 || item.nodeType === 3 && item.data === undefined) {\n          this._nodeRemoveListItem(item);\n\n          continue;\n        }\n\n        if (item === startCon) {\n          if (startCon.nodeType === 1) {\n            if (util.isComponent(startCon)) continue;else beforeNode = util.createTextNode(startCon.textContent);\n          } else {\n            if (item === endCon) {\n              beforeNode = util.createTextNode(startCon.substringData(0, startOff) + endCon.substringData(endOff, endCon.length - endOff));\n              offset = startOff;\n            } else {\n              beforeNode = util.createTextNode(startCon.substringData(0, startOff));\n            }\n          }\n\n          if (beforeNode.length > 0) {\n            startCon.data = beforeNode.data;\n          } else {\n            this._nodeRemoveListItem(startCon);\n          }\n\n          if (item === endCon) break;\n          continue;\n        }\n\n        if (item === endCon) {\n          if (endCon.nodeType === 1) {\n            if (util.isComponent(endCon)) continue;else afterNode = util.createTextNode(endCon.textContent);\n          } else {\n            afterNode = util.createTextNode(endCon.substringData(endOff, endCon.length - endOff));\n          }\n\n          if (afterNode.length > 0) {\n            endCon.data = afterNode.data;\n          } else {\n            this._nodeRemoveListItem(endCon);\n          }\n\n          continue;\n        }\n\n        this._nodeRemoveListItem(item);\n      }\n\n      var endUl = util.getParentElement(endCon, 'ul');\n      var startLi = util.getParentElement(startCon, 'li');\n\n      if (endUl && startLi && startLi.contains(endUl)) {\n        container = endUl.previousSibling;\n        offset = container.textContent.length;\n      } else {\n        container = endCon && endCon.parentNode ? endCon : startCon && startCon.parentNode ? startCon : range.endContainer || range.startContainer;\n      }\n\n      if (!util.isWysiwygDiv(container) && container.childNodes.length === 0) {\n        var rc = util.removeItemAllParents(container, null, null);\n        if (rc) container = rc.sc || rc.ec || context.element.wysiwyg;\n      } // set range\n\n\n      this.setRange(container, offset, container, offset); // history stack\n\n      this.history.push(true);\n      return {\n        container: container,\n        offset: offset,\n        prevContainer: startCon && startCon.parentNode ? startCon : null\n      };\n    },\n    _nodeRemoveListItem: function _nodeRemoveListItem(item) {\n      var format = util.getFormatElement(item, null);\n      util.removeItem(item);\n      if (!util.isListCell(format)) return;\n      util.removeItemAllParents(format, null, null);\n\n      if (format && util.isList(format.firstChild)) {\n        format.insertBefore(util.createTextNode(util.zeroWidthSpace), format.firstChild);\n      }\n    },\n\n    /**\r\n     * @description Appended all selected format Element to the argument element and insert\r\n     * @param {Element} rangeElement Element of wrap the arguments (BLOCKQUOTE...)\r\n     */\n    applyRangeFormatElement: function applyRangeFormatElement(rangeElement) {\n      this.getRange_addLine(this.getRange(), null);\n      var rangeLines = this.getSelectedElementsAndComponents(false);\n      if (!rangeLines || rangeLines.length === 0) return;\n\n      linesLoop: for (var i = 0, len = rangeLines.length, line, nested, fEl, lEl, f, l; i < len; i++) {\n        line = rangeLines[i];\n        if (!util.isListCell(line)) continue;\n        nested = line.lastElementChild;\n\n        if (nested && util.isListCell(line.nextElementSibling) && rangeLines.indexOf(line.nextElementSibling) > -1) {\n          lEl = nested.lastElementChild;\n\n          if (rangeLines.indexOf(lEl) > -1) {\n            var list = null;\n\n            while (list = lEl.lastElementChild) {\n              if (util.isList(list)) {\n                if (rangeLines.indexOf(list.lastElementChild) > -1) {\n                  lEl = list.lastElementChild;\n                } else {\n                  continue linesLoop;\n                }\n              }\n            }\n\n            fEl = nested.firstElementChild;\n            f = rangeLines.indexOf(fEl);\n            l = rangeLines.indexOf(lEl);\n            rangeLines.splice(f, l - f + 1);\n            len = rangeLines.length;\n            continue;\n          }\n        }\n      }\n\n      var last = rangeLines[rangeLines.length - 1];\n      var standTag, beforeTag, pElement;\n\n      if (util.isRangeFormatElement(last) || util.isFormatElement(last)) {\n        standTag = last;\n      } else {\n        standTag = util.getRangeFormatElement(last, null) || util.getFormatElement(last, null);\n      }\n\n      if (util.isCell(standTag)) {\n        beforeTag = null;\n        pElement = standTag;\n      } else {\n        beforeTag = standTag.nextSibling;\n        pElement = standTag.parentNode;\n      }\n\n      var parentDepth = util.getElementDepth(standTag);\n      var listParent = null;\n      var lineArr = [];\n\n      var removeItems = function removeItems(parent, origin, before) {\n        var cc = null;\n\n        if (parent !== origin && !util.isTable(origin)) {\n          if (origin && util.getElementDepth(parent) === util.getElementDepth(origin)) return before;\n          cc = util.removeItemAllParents(origin, null, parent);\n        }\n\n        return cc ? cc.ec : before;\n      };\n\n      for (var _i4 = 0, _len = rangeLines.length, _line, originParent, depth, before, nextLine, nextList, _nested; _i4 < _len; _i4++) {\n        _line = rangeLines[_i4];\n        originParent = _line.parentNode;\n        if (!originParent || rangeElement.contains(originParent)) continue;\n        depth = util.getElementDepth(_line);\n\n        if (util.isList(originParent)) {\n          if (listParent === null) {\n            if (nextList) {\n              listParent = nextList;\n              _nested = true;\n              nextList = null;\n            } else {\n              listParent = originParent.cloneNode(false);\n            }\n          }\n\n          lineArr.push(_line);\n          nextLine = rangeLines[_i4 + 1];\n\n          if (_i4 === _len - 1 || nextLine && nextLine.parentNode !== originParent) {\n            // nested list\n            if (nextLine && _line.contains(nextLine.parentNode)) {\n              nextList = nextLine.parentNode.cloneNode(false);\n            }\n\n            var _list = originParent.parentNode,\n                p = void 0;\n\n            while (util.isList(_list)) {\n              p = util.createElement(_list.nodeName);\n              p.appendChild(listParent);\n              listParent = p;\n              _list = _list.parentNode;\n            }\n\n            var _edge = this.detachRangeFormatElement(originParent, lineArr, null, true, true);\n\n            if (parentDepth >= depth) {\n              parentDepth = depth;\n              pElement = _edge.cc;\n              beforeTag = removeItems(pElement, originParent, _edge.ec);\n              if (beforeTag) pElement = beforeTag.parentNode;\n            } else if (pElement === _edge.cc) {\n              beforeTag = _edge.ec;\n            }\n\n            if (pElement !== _edge.cc) {\n              before = removeItems(pElement, _edge.cc, before);\n              if (before !== undefined) beforeTag = before;else beforeTag = _edge.cc;\n            }\n\n            for (var c = 0, cLen = _edge.removeArray.length; c < cLen; c++) {\n              listParent.appendChild(_edge.removeArray[c]);\n            }\n\n            if (!_nested) rangeElement.appendChild(listParent);\n            if (nextList) _edge.removeArray[_edge.removeArray.length - 1].appendChild(nextList);\n            listParent = null;\n            _nested = false;\n          }\n        } else {\n          if (parentDepth >= depth) {\n            parentDepth = depth;\n            pElement = originParent;\n            beforeTag = _line.nextSibling;\n          }\n\n          rangeElement.appendChild(_line);\n\n          if (pElement !== originParent) {\n            before = removeItems(pElement, originParent);\n            if (before !== undefined) beforeTag = before;\n          }\n        }\n      }\n\n      this.effectNode = null;\n      util.mergeSameTags(rangeElement, null, false);\n      util.mergeNestedTags(rangeElement, function (current) {\n        return this.isList(current);\n      }.bind(util)); // Nested list\n\n      if (beforeTag && util.getElementDepth(beforeTag) > 0 && (util.isList(beforeTag.parentNode) || util.isList(beforeTag.parentNode.parentNode))) {\n        var depthFormat = util.getParentElement(beforeTag, function (current) {\n          return this.isRangeFormatElement(current) && !this.isList(current);\n        }.bind(util));\n        var splitRange = util.splitElement(beforeTag, null, !depthFormat ? 0 : util.getElementDepth(depthFormat) + 1);\n        splitRange.parentNode.insertBefore(rangeElement, splitRange);\n      } else {\n        // basic\n        pElement.insertBefore(rangeElement, beforeTag);\n        removeItems(rangeElement, beforeTag);\n      }\n\n      var edge = util.getEdgeChildNodes(rangeElement.firstElementChild, rangeElement.lastElementChild);\n\n      if (rangeLines.length > 1) {\n        this.setRange(edge.sc, 0, edge.ec, edge.ec.textContent.length);\n      } else {\n        this.setRange(edge.ec, edge.ec.textContent.length, edge.ec, edge.ec.textContent.length);\n      } // history stack\n\n\n      this.history.push(false);\n    },\n\n    /**\r\n     * @description The elements of the \"selectedFormats\" array are detached from the \"rangeElement\" element. (\"LI\" tags are converted to \"P\" tags)\r\n     * When \"selectedFormats\" is null, all elements are detached and return {cc: parentNode, sc: nextSibling, ec: previousSibling, removeArray: [Array of removed elements]}.\r\n     * @param {Element} rangeElement Range format element (PRE, BLOCKQUOTE, OL, UL...)\r\n     * @param {Array|null} selectedFormats Array of format elements (P, DIV, LI...) to remove.\r\n     * If null, Applies to all elements and return {cc: parentNode, sc: nextSibling, ec: previousSibling}\r\n     * @param {Element|null} newRangeElement The node(rangeElement) to replace the currently wrapped node.\r\n     * @param {Boolean} remove If true, deleted without detached.\r\n     * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)\r\n     * @returns {Object}\r\n     */\n    detachRangeFormatElement: function detachRangeFormatElement(rangeElement, selectedFormats, newRangeElement, remove, notHistoryPush) {\n      var range = this.getRange();\n      var so = range.startOffset;\n      var eo = range.endOffset;\n      var children = util.getListChildNodes(rangeElement, function (current) {\n        return current.parentNode === rangeElement;\n      });\n      var parent = rangeElement.parentNode;\n      var firstNode = null;\n      var lastNode = null;\n      var rangeEl = rangeElement.cloneNode(false);\n      var removeArray = [];\n      var newList = util.isList(newRangeElement);\n      var insertedNew = false;\n      var reset = false;\n      var moveComplete = false;\n\n      function appendNode(parent, insNode, sibling, originNode) {\n        if (util.onlyZeroWidthSpace(insNode)) insNode.innerHTML = util.zeroWidthSpace;\n\n        if (insNode.nodeType === 3) {\n          parent.insertBefore(insNode, sibling);\n          return insNode;\n        }\n\n        var insChildren = (moveComplete ? insNode : originNode).childNodes;\n        var format = insNode.cloneNode(false);\n        var first = null;\n        var c = null;\n\n        while (insChildren[0]) {\n          c = insChildren[0];\n\n          if (util._notTextNode(c) && !util.isBreak(c) && !util.isListCell(format)) {\n            if (format.childNodes.length > 0) {\n              if (!first) first = format;\n              parent.insertBefore(format, sibling);\n              format = insNode.cloneNode(false);\n            }\n\n            parent.insertBefore(c, sibling);\n            if (!first) first = c;\n          } else {\n            format.appendChild(c);\n          }\n        }\n\n        if (format.childNodes.length > 0) {\n          if (util.isListCell(parent) && util.isListCell(format) && util.isList(sibling)) {\n            if (newList) {\n              first = sibling;\n\n              while (sibling) {\n                format.appendChild(sibling);\n                sibling = sibling.nextSibling;\n              }\n\n              parent.parentNode.insertBefore(format, parent.nextElementSibling);\n            } else {\n              var originNext = originNode.nextElementSibling;\n              var detachRange = util.detachNestedList(originNode, false);\n\n              if (rangeElement !== detachRange || originNext !== originNode.nextElementSibling) {\n                var fChildren = format.childNodes;\n\n                while (fChildren[0]) {\n                  originNode.appendChild(fChildren[0]);\n                }\n\n                rangeElement = detachRange;\n                reset = true;\n              }\n            }\n          } else {\n            parent.insertBefore(format, sibling);\n          }\n\n          if (!first) first = format;\n        }\n\n        return first;\n      } // detach loop\n\n\n      for (var i = 0, len = children.length, insNode, lineIndex, next; i < len; i++) {\n        insNode = children[i];\n        if (insNode.nodeType === 3 && util.isList(rangeEl)) continue;\n        moveComplete = false;\n\n        if (remove && i === 0) {\n          if (!selectedFormats || selectedFormats.length === len || selectedFormats[0] === insNode) {\n            firstNode = rangeElement.previousSibling;\n          } else {\n            firstNode = rangeEl;\n          }\n        }\n\n        if (selectedFormats) lineIndex = selectedFormats.indexOf(insNode);\n\n        if (selectedFormats && lineIndex === -1) {\n          if (!rangeEl) rangeEl = rangeElement.cloneNode(false);\n          rangeEl.appendChild(insNode);\n        } else {\n          if (selectedFormats) next = selectedFormats[lineIndex + 1];\n\n          if (rangeEl && rangeEl.children.length > 0) {\n            parent.insertBefore(rangeEl, rangeElement);\n            rangeEl = null;\n          }\n\n          if (!newList && util.isListCell(insNode)) {\n            if (next && util.getElementDepth(insNode) !== util.getElementDepth(next) && (util.isListCell(parent) || util.getArrayItem(insNode.children, util.isList, false))) {\n              var insNext = insNode.nextElementSibling;\n              var detachRange = util.detachNestedList(insNode, false);\n\n              if (rangeElement !== detachRange || insNext !== insNode.nextElementSibling) {\n                rangeElement = detachRange;\n                reset = true;\n              }\n            } else {\n              var inner = insNode;\n              insNode = util.createElement(remove ? inner.nodeName : util.isList(rangeElement.parentNode) || util.isListCell(rangeElement.parentNode) ? 'LI' : util.isCell(rangeElement.parentNode) ? 'DIV' : options.defaultTag);\n              var isCell = util.isListCell(insNode);\n              var innerChildren = inner.childNodes;\n\n              while (innerChildren[0]) {\n                if (util.isList(innerChildren[0]) && !isCell) break;\n                insNode.appendChild(innerChildren[0]);\n              }\n\n              util.copyFormatAttributes(insNode, inner);\n              moveComplete = true;\n            }\n          } else {\n            insNode = insNode.cloneNode(false);\n          }\n\n          if (!reset) {\n            if (!remove) {\n              if (newRangeElement) {\n                if (!insertedNew) {\n                  parent.insertBefore(newRangeElement, rangeElement);\n                  insertedNew = true;\n                }\n\n                insNode = appendNode(newRangeElement, insNode, null, children[i]);\n              } else {\n                insNode = appendNode(parent, insNode, rangeElement, children[i]);\n              }\n\n              if (!reset) {\n                if (selectedFormats) {\n                  lastNode = insNode;\n\n                  if (!firstNode) {\n                    firstNode = insNode;\n                  }\n                } else if (!firstNode) {\n                  firstNode = lastNode = insNode;\n                }\n              }\n            } else {\n              removeArray.push(insNode);\n              util.removeItem(children[i]);\n            }\n\n            if (reset) {\n              reset = moveComplete = false;\n              children = util.getListChildNodes(rangeElement, function (current) {\n                return current.parentNode === rangeElement;\n              });\n              rangeEl = rangeElement.cloneNode(false);\n              parent = rangeElement.parentNode;\n              i = -1;\n              len = children.length;\n              continue;\n            }\n          }\n        }\n      }\n\n      var rangeParent = rangeElement.parentNode;\n      var rangeRight = rangeElement.nextSibling;\n\n      if (rangeEl && rangeEl.children.length > 0) {\n        rangeParent.insertBefore(rangeEl, rangeRight);\n      }\n\n      if (newRangeElement) firstNode = newRangeElement.previousSibling;else if (!firstNode) firstNode = rangeElement.previousSibling;\n      rangeRight = rangeElement.nextSibling !== rangeEl ? rangeElement.nextSibling : rangeEl ? rangeEl.nextSibling : null;\n\n      if (rangeElement.children.length === 0 || rangeElement.textContent.length === 0) {\n        util.removeItem(rangeElement);\n      } else {\n        util.removeEmptyNode(rangeElement, null);\n      }\n\n      var edge = null;\n\n      if (remove) {\n        edge = {\n          cc: rangeParent,\n          sc: firstNode,\n          ec: rangeRight,\n          removeArray: removeArray\n        };\n      } else {\n        if (!firstNode) firstNode = lastNode;\n        if (!lastNode) lastNode = firstNode;\n        var childEdge = util.getEdgeChildNodes(firstNode, lastNode.parentNode ? firstNode : lastNode);\n        edge = {\n          cc: (childEdge.sc || childEdge.ec).parentNode,\n          sc: childEdge.sc,\n          ec: childEdge.ec\n        };\n      }\n\n      this.effectNode = null;\n      if (notHistoryPush) return edge;\n\n      if (!remove && edge) {\n        if (!selectedFormats) {\n          this.setRange(edge.sc, 0, edge.sc, 0);\n        } else {\n          this.setRange(edge.sc, so, edge.ec, eo);\n        }\n      } // history stack\n\n\n      this.history.push(false);\n    },\n\n    /**\r\n     * @description \"selectedFormats\" array are detached from the list element.\r\n     * The return value is applied when the first and last lines of \"selectedFormats\" are \"LI\" respectively.\r\n     * @param {Array} selectedFormats Array of format elements (LI, P...) to remove.\r\n     * @param {Boolean} remove If true, deleted without detached.\r\n     * @returns {Object} {sc: <LI>, ec: <LI>}.\r\n     */\n    detachList: function detachList(selectedFormats, remove) {\n      var rangeArr = {};\n      var listFirst = false;\n      var listLast = false;\n      var first = null;\n      var last = null;\n\n      var passComponent = function (current) {\n        return !this.isComponent(current);\n      }.bind(util);\n\n      for (var i = 0, len = selectedFormats.length, r, o, lastIndex, isList; i < len; i++) {\n        lastIndex = i === len - 1;\n        o = util.getRangeFormatElement(selectedFormats[i], passComponent);\n        isList = util.isList(o);\n\n        if (!r && isList) {\n          r = o;\n          rangeArr = {\n            r: r,\n            f: [util.getParentElement(selectedFormats[i], 'LI')]\n          };\n          if (i === 0) listFirst = true;\n        } else if (r && isList) {\n          if (r !== o) {\n            var edge = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);\n            o = selectedFormats[i].parentNode;\n\n            if (listFirst) {\n              first = edge.sc;\n              listFirst = false;\n            }\n\n            if (lastIndex) last = edge.ec;\n\n            if (isList) {\n              r = o;\n              rangeArr = {\n                r: r,\n                f: [util.getParentElement(selectedFormats[i], 'LI')]\n              };\n              if (lastIndex) listLast = true;\n            } else {\n              r = null;\n            }\n          } else {\n            rangeArr.f.push(util.getParentElement(selectedFormats[i], 'LI'));\n            if (lastIndex) listLast = true;\n          }\n        }\n\n        if (lastIndex && util.isList(r)) {\n          var _edge2 = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);\n\n          if (listLast || len === 1) last = _edge2.ec;\n          if (listFirst) first = _edge2.sc || last;\n        }\n      }\n\n      return {\n        sc: first,\n        ec: last\n      };\n    },\n\n    /**\r\n     * @description Add, update, and delete nodes from selected text.\r\n     * 1. If there is a node in the \"appendNode\" argument, a node with the same tags and attributes as \"appendNode\" is added to the selection text.\r\n     * 2. If it is in the same tag, only the tag's attributes are changed without adding a tag.\r\n     * 3. If the \"appendNode\" argument is null, the node of the selection is update or remove without adding a new node.\r\n     * 4. The same style as the style attribute of the \"styleArray\" argument is deleted.\r\n     *    (Styles should be put with attribute names from css. [\"background-color\"])\r\n     * 5. The same class name as the class attribute of the \"styleArray\" argument is deleted.\r\n     *    (The class name is preceded by \".\" [\".className\"])\r\n     * 6. Use a list of styles and classes of \"appendNode\" in \"styleArray\" to avoid duplicate property values.\r\n     * 7. If a node with all styles and classes removed has the same tag name as \"appendNode\" or \"removeNodeArray\", or \"appendNode\" is null, that node is deleted.\r\n     * 8. Regardless of the style and class of the node, the tag with the same name as the \"removeNodeArray\" argument value is deleted.\r\n     * 9. If the \"strictRemove\" argument is true, only nodes with all styles and classes removed from the nodes of \"removeNodeArray\" are removed.\r\n     *10. It won't work if the parent node has the same class and same value style.\r\n     *    However, if there is a value in \"removeNodeArray\", it works and the text node is separated even if there is no node to replace.\r\n     * @param {Element|null} appendNode The element to be added to the selection. If it is null, only delete the node.\r\n     * @param {Array|null} styleArray The style or className attribute name Array to check (['font-size'], ['.className'], ['font-family', 'color', '.className']...])\r\n     * @param {Array|null} removeNodeArray An array of node names to remove types from, remove all formats when \"appendNode\" is null and there is an empty array or null value. (['span'], ['strong', 'em'] ...])\r\n     * @param {Boolean|null} strictRemove If true, only nodes with all styles and classes removed from the nodes of \"removeNodeArray\" are removed.\r\n     */\n    nodeChange: function nodeChange(appendNode, styleArray, removeNodeArray, strictRemove) {\n      this._resetRangeToTextNode();\n\n      var range = this.getRange_addLine(this.getRange(), null);\n      styleArray = styleArray && styleArray.length > 0 ? styleArray : false;\n      removeNodeArray = removeNodeArray && removeNodeArray.length > 0 ? removeNodeArray : false;\n      var isRemoveNode = !appendNode;\n      var isRemoveFormat = isRemoveNode && !removeNodeArray && !styleArray;\n      var startCon = range.startContainer;\n      var startOff = range.startOffset;\n      var endCon = range.endContainer;\n      var endOff = range.endOffset;\n\n      if (isRemoveFormat && range.collapsed && util.isFormatElement(startCon.parentNode) || startCon === endCon && startCon.nodeType === 1 && util.isNonEditable(startCon)) {\n        var format = startCon.parentNode;\n        if (!util.isListCell(format) || !util.getValues(format.style).some(function (k) {\n          return this._listKebab.indexOf(k) > -1;\n        }.bind(this))) return;\n      }\n\n      if (range.collapsed && !isRemoveFormat) {\n        if (startCon.nodeType === 1 && !util.isBreak(startCon) && !util.isComponent(startCon)) {\n          var afterNode = null;\n          var focusNode = startCon.childNodes[startOff];\n\n          if (focusNode) {\n            if (!focusNode.nextSibling) {\n              afterNode = null;\n            } else {\n              afterNode = util.isBreak(focusNode) ? focusNode : focusNode.nextSibling;\n            }\n          }\n\n          var zeroWidth = util.createTextNode(util.zeroWidthSpace);\n          startCon.insertBefore(zeroWidth, afterNode);\n          this.setRange(zeroWidth, 1, zeroWidth, 1);\n          range = this.getRange();\n          startCon = range.startContainer;\n          startOff = range.startOffset;\n          endCon = range.endContainer;\n          endOff = range.endOffset;\n        }\n      }\n\n      if (util.isFormatElement(startCon)) {\n        startCon = startCon.childNodes[startOff] || startCon.firstChild;\n        startOff = 0;\n      }\n\n      if (util.isFormatElement(endCon)) {\n        endCon = endCon.childNodes[endOff] || endCon.lastChild;\n        endOff = endCon.textContent.length;\n      }\n\n      if (isRemoveNode) {\n        appendNode = util.createElement('DIV');\n      }\n\n      var wRegExp = _w.RegExp;\n      var newNodeName = appendNode.nodeName;\n      /* checked same style property */\n\n      if (!isRemoveFormat && startCon === endCon && !removeNodeArray && appendNode) {\n        var sNode = startCon;\n        var checkCnt = 0;\n        var checkAttrs = [];\n        var checkStyles = appendNode.style;\n\n        for (var i = 0, len = checkStyles.length; i < len; i++) {\n          checkAttrs.push(checkStyles[i]);\n        }\n\n        var ckeckClasses = appendNode.classList;\n\n        for (var _i5 = 0, _len2 = ckeckClasses.length; _i5 < _len2; _i5++) {\n          checkAttrs.push('.' + ckeckClasses[_i5]);\n        }\n\n        if (checkAttrs.length > 0) {\n          while (!util.isFormatElement(sNode) && !util.isWysiwygDiv(sNode)) {\n            for (var _i6 = 0; _i6 < checkAttrs.length; _i6++) {\n              if (sNode.nodeType === 1) {\n                var s = checkAttrs[_i6];\n                var classReg = /^\\./.test(s) ? new wRegExp('\\\\s*' + s.replace(/^\\./, '') + '(\\\\s+|$)', 'ig') : false;\n                var styleCheck = isRemoveNode ? !!sNode.style[s] : !!sNode.style[s] && !!appendNode.style[s] && sNode.style[s] === appendNode.style[s];\n                var classCheck = classReg === false ? false : isRemoveNode ? !!sNode.className.match(classReg) : !!sNode.className.match(classReg) && !!appendNode.className.match(classReg);\n\n                if (styleCheck || classCheck) {\n                  checkCnt++;\n                }\n              }\n            }\n\n            sNode = sNode.parentNode;\n          }\n\n          if (checkCnt >= checkAttrs.length) return;\n        }\n      }\n\n      var start = {},\n          end = {};\n      var newNode,\n          styleRegExp = '',\n          classRegExp = '',\n          removeNodeRegExp = '';\n\n      if (styleArray) {\n        for (var _i7 = 0, _len3 = styleArray.length, _s; _i7 < _len3; _i7++) {\n          _s = styleArray[_i7];\n\n          if (/^\\./.test(_s)) {\n            classRegExp += (classRegExp ? '|' : '\\\\s*(?:') + _s.replace(/^\\./, '');\n          } else {\n            styleRegExp += (styleRegExp ? '|' : '(?:;|^|\\\\s)(?:') + _s;\n          }\n        }\n\n        if (styleRegExp) {\n          styleRegExp += ')\\\\s*:[^;]*\\\\s*(?:;|$)';\n          styleRegExp = new wRegExp(styleRegExp, 'ig');\n        }\n\n        if (classRegExp) {\n          classRegExp += ')(?=\\\\s+|$)';\n          classRegExp = new wRegExp(classRegExp, 'ig');\n        }\n      }\n\n      if (removeNodeArray) {\n        removeNodeRegExp = '^(?:' + removeNodeArray[0];\n\n        for (var _i8 = 1; _i8 < removeNodeArray.length; _i8++) {\n          removeNodeRegExp += '|' + removeNodeArray[_i8];\n        }\n\n        removeNodeRegExp += ')$';\n        removeNodeRegExp = new wRegExp(removeNodeRegExp, 'i');\n      }\n      /** validation check function*/\n\n\n      var wBoolean = _w.Boolean;\n      var _removeCheck = {\n        v: false\n      };\n\n      var validation = function validation(checkNode) {\n        var vNode = checkNode.cloneNode(false); // all path\n\n        if (vNode.nodeType === 3 || util.isBreak(vNode)) return vNode; // all remove\n\n        if (isRemoveFormat) return null; // remove node check\n\n        var tagRemove = !removeNodeRegExp && isRemoveNode || removeNodeRegExp && removeNodeRegExp.test(vNode.nodeName); // tag remove\n\n        if (tagRemove && !strictRemove) {\n          _removeCheck.v = true;\n          return null;\n        } // style regexp\n\n\n        var originStyle = vNode.style.cssText;\n        var style = '';\n\n        if (styleRegExp && originStyle.length > 0) {\n          style = originStyle.replace(styleRegExp, '').trim();\n          if (style !== originStyle) _removeCheck.v = true;\n        } // class check\n\n\n        var originClasses = vNode.className;\n        var classes = '';\n\n        if (classRegExp && originClasses.length > 0) {\n          classes = originClasses.replace(classRegExp, '').trim();\n          if (classes !== originClasses) _removeCheck.v = true;\n        } // remove only\n\n\n        if (isRemoveNode) {\n          if ((classRegExp || !originClasses) && (styleRegExp || !originStyle) && !style && !classes && tagRemove) {\n            _removeCheck.v = true;\n            return null;\n          }\n        } // change\n\n\n        if (style || classes || vNode.nodeName !== newNodeName || wBoolean(styleRegExp) !== wBoolean(originStyle) || wBoolean(classRegExp) !== wBoolean(originClasses)) {\n          if (styleRegExp && originStyle.length > 0) vNode.style.cssText = style;\n\n          if (!vNode.style.cssText) {\n            vNode.removeAttribute('style');\n          }\n\n          if (classRegExp && originClasses.length > 0) vNode.className = classes.trim();\n\n          if (!vNode.className.trim()) {\n            vNode.removeAttribute('class');\n          }\n\n          if (!vNode.style.cssText && !vNode.className && (vNode.nodeName === newNodeName || tagRemove)) {\n            _removeCheck.v = true;\n            return null;\n          }\n\n          return vNode;\n        }\n\n        _removeCheck.v = true;\n        return null;\n      }; // get line nodes\n\n\n      var lineNodes = this.getSelectedElements(null);\n      range = this.getRange();\n      startCon = range.startContainer;\n      startOff = range.startOffset;\n      endCon = range.endContainer;\n      endOff = range.endOffset;\n\n      if (!util.getFormatElement(startCon, null)) {\n        startCon = util.getChildElement(lineNodes[0], function (current) {\n          return current.nodeType === 3;\n        }, false);\n        startOff = 0;\n      }\n\n      if (!util.getFormatElement(endCon, null)) {\n        endCon = util.getChildElement(lineNodes[lineNodes.length - 1], function (current) {\n          return current.nodeType === 3;\n        }, false);\n        endOff = endCon.textContent.length;\n      }\n\n      var oneLine = util.getFormatElement(startCon, null) === util.getFormatElement(endCon, null);\n      var endLength = lineNodes.length - (oneLine ? 0 : 1); // node Changes\n\n      newNode = appendNode.cloneNode(false);\n\n      var isRemoveAnchor = isRemoveFormat || isRemoveNode && function (arr) {\n        for (var n = 0, _len4 = arr.length; n < _len4; n++) {\n          if (util._isMaintainedNode(arr[n]) || util._isSizeNode(arr[n])) return true;\n        }\n\n        return false;\n      }(removeNodeArray);\n\n      var isSizeNode = isRemoveNode || util._isSizeNode(newNode);\n\n      var _getMaintainedNode = this._util_getMaintainedNode.bind(util, isRemoveAnchor, isSizeNode);\n\n      var _isMaintainedNode = this._util_isMaintainedNode.bind(util, isRemoveAnchor, isSizeNode); // one line\n\n\n      if (oneLine) {\n        if (this._resetCommonListCell(lineNodes[0], styleArray)) range = this.setRange(startCon, startOff, endCon, endOff);\n\n        var newRange = this._nodeChange_oneLine(lineNodes[0], newNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, range.collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode);\n\n        start.container = newRange.startContainer;\n        start.offset = newRange.startOffset;\n        end.container = newRange.endContainer;\n        end.offset = newRange.endOffset;\n\n        if (start.container === end.container && util.onlyZeroWidthSpace(start.container)) {\n          start.offset = end.offset = 1;\n        }\n\n        this._setCommonListStyle(newRange.ancestor, null);\n      } else {\n        // multi line \n        var appliedCommonList = false;\n        if (endLength > 0 && this._resetCommonListCell(lineNodes[endLength], styleArray)) appliedCommonList = true;\n        if (this._resetCommonListCell(lineNodes[0], styleArray)) appliedCommonList = true;\n        if (appliedCommonList) this.setRange(startCon, startOff, endCon, endOff); // end\n\n        if (endLength > 0) {\n          newNode = appendNode.cloneNode(false);\n          end = this._nodeChange_endLine(lineNodes[endLength], newNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode);\n        } // mid\n\n\n        for (var _i9 = endLength - 1, _newRange; _i9 > 0; _i9--) {\n          this._resetCommonListCell(lineNodes[_i9], styleArray);\n\n          newNode = appendNode.cloneNode(false);\n          _newRange = this._nodeChange_middleLine(lineNodes[_i9], newNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, end.container);\n\n          if (_newRange.endContainer && _newRange.ancestor.contains(_newRange.endContainer)) {\n            end.ancestor = null;\n            end.container = _newRange.endContainer;\n          }\n\n          this._setCommonListStyle(_newRange.ancestor, null);\n        } // start\n\n\n        newNode = appendNode.cloneNode(false);\n        start = this._nodeChange_startLine(lineNodes[0], newNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, end.container);\n\n        if (start.endContainer) {\n          end.ancestor = null;\n          end.container = start.endContainer;\n        }\n\n        if (endLength <= 0) {\n          end = start;\n        } else if (!end.container) {\n          end.ancestor = null;\n          end.container = start.container;\n          end.offset = start.container.textContent.length;\n        }\n\n        this._setCommonListStyle(start.ancestor, null);\n\n        this._setCommonListStyle(end.ancestor || util.getFormatElement(end.container), null);\n      } // set range\n\n\n      this.controllersOff();\n      this.setRange(start.container, start.offset, end.container, end.offset); // history stack\n\n      this.history.push(false);\n    },\n\n    /**\r\n     * @description Reset common style of list cell\r\n     * @param {Element} el List cell element. <li>\r\n     * @param {Array|null} styleArray Style array\r\n     * @private\r\n     */\n    _resetCommonListCell: function _resetCommonListCell(el, styleArray) {\n      if (!util.isListCell(el)) return;\n      if (!styleArray) styleArray = this._listKebab;\n      var children = util.getArrayItem(el.childNodes, function (current) {\n        return !util.isBreak(current);\n      }, true);\n      var elStyles = el.style;\n      var ec = [],\n          ek = [],\n          elKeys = util.getValues(elStyles);\n\n      for (var i = 0, len = this._listKebab.length; i < len; i++) {\n        if (elKeys.indexOf(this._listKebab[i]) > -1 && styleArray.indexOf(this._listKebab[i]) > -1) {\n          ec.push(this._listCamel[i]);\n          ek.push(this._listKebab[i]);\n        }\n      }\n\n      if (!ec.length) return; // reset cell style---\n\n      var refer = util.createElement('SPAN');\n\n      for (var _i10 = 0, _len5 = ec.length; _i10 < _len5; _i10++) {\n        refer.style[ec[_i10]] = elStyles[ek[_i10]];\n        elStyles.removeProperty(ek[_i10]);\n      }\n\n      var sel = refer.cloneNode(false);\n      var r = null,\n          appliedEl = false;\n\n      var _loop = function _loop(_c, _s2, _i11, _len6) {\n        _c = children[_i11];\n\n        if (options._textTagsMap[_c.nodeName.toLowerCase()]) {\n          s = _s2;\n          {\n            c = _c;\n            return \"continue\";\n          }\n        }\n\n        _s2 = util.getValues(_c.style);\n\n        if (_s2.length === 0 || ec.some(function (k) {\n          c = _c;\n          s = _s2;\n          return _s2.indexOf(k) === -1;\n        }) && _s2.some(function (k) {\n          ec.indexOf(k) > -1;\n        })) {\n          r = _c.nextSibling;\n          sel.appendChild(_c);\n        } else if (sel.childNodes.length > 0) {\n          el.insertBefore(sel, r);\n          sel = refer.cloneNode(false);\n          r = null;\n          appliedEl = true;\n        }\n\n        c = _c;\n        s = _s2;\n      };\n\n      for (var _i11 = 0, _len6 = children.length, c, s; _i11 < _len6; _i11++) {\n        var _ret = _loop(c, s, _i11, _len6);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      if (sel.childNodes.length > 0) {\n        el.insertBefore(sel, r);\n        appliedEl = true;\n      }\n\n      if (!elStyles.length) {\n        el.removeAttribute('style');\n      }\n\n      return appliedEl;\n    },\n\n    /**\r\n     * @description If certain styles are applied to all child nodes of the list cell, the style of the list cell is also changed. (bold, color, size)\r\n     * @param {Element} el List cell element. <li>\r\n     * @param {Element|null} child Variable for recursive call. (\"null\" on the first call)\r\n     * @private\r\n     */\n    _setCommonListStyle: function _setCommonListStyle(el, child) {\n      if (!util.isListCell(el)) return;\n      var children = util.getArrayItem((child || el).childNodes, function (current) {\n        return !util.isBreak(current);\n      }, true);\n      child = children[0];\n      if (!child || children.length > 1 || child.nodeType !== 1) return; // set cell style---\n\n      var childStyle = child.style;\n      var elStyle = el.style;\n      var nodeName = child.nodeName.toLowerCase();\n      var appliedEl = false; // bold, italic\n\n      if (options._textTagsMap[nodeName] === options._defaultCommand.bold.toLowerCase()) elStyle.fontWeight = 'bold';\n      if (options._textTagsMap[nodeName] === options._defaultCommand.italic.toLowerCase()) elStyle.fontStyle = 'italic'; // styles\n\n      var cKeys = util.getValues(childStyle);\n\n      if (cKeys.length > 0) {\n        for (var i = 0, len = this._listCamel.length; i < len; i++) {\n          if (cKeys.indexOf(this._listKebab[i]) > -1) {\n            elStyle[this._listCamel[i]] = childStyle[this._listCamel[i]];\n            childStyle.removeProperty(this._listKebab[i]);\n            appliedEl = true;\n          }\n        }\n      }\n\n      this._setCommonListStyle(el, child);\n\n      if (!appliedEl) return; // common style\n\n      if (!childStyle.length) {\n        var ch = child.childNodes;\n        var p = child.parentNode;\n        var n = child.nextSibling;\n\n        while (ch.length > 0) {\n          p.insertBefore(ch[0], n);\n        }\n\n        util.removeItem(child);\n      }\n    },\n\n    /**\r\n     * @description Strip remove node\r\n     * @param {Node} removeNode The remove node\r\n     * @private\r\n     */\n    _stripRemoveNode: function _stripRemoveNode(removeNode) {\n      var element = removeNode.parentNode;\n      if (!removeNode || removeNode.nodeType === 3 || !element) return;\n      var children = removeNode.childNodes;\n\n      while (children[0]) {\n        element.insertBefore(children[0], removeNode);\n      }\n\n      element.removeChild(removeNode);\n    },\n\n    /**\r\n     * @description Return the parent maintained tag. (bind and use a util object)\r\n     * @param {Element} element Element\r\n     * @returns {Element}\r\n     * @private\r\n     */\n    _util_getMaintainedNode: function _util_getMaintainedNode(_isRemove, _isSizeNode, element) {\n      if (!element || _isRemove) return null;\n      return this.getParentElement(element, this._isMaintainedNode.bind(this)) || (!_isSizeNode ? this.getParentElement(element, this._isSizeNode.bind(this)) : null);\n    },\n\n    /**\r\n     * @description Check if element is a tag that should be persisted. (bind and use a util object)\r\n     * @param {Element} element Element\r\n     * @returns {Element}\r\n     * @private\r\n     */\n    _util_isMaintainedNode: function _util_isMaintainedNode(_isRemove, _isSizeNode, element) {\n      if (!element || _isRemove || element.nodeType !== 1) return false;\n\n      var anchor = this._isMaintainedNode(element);\n\n      return this.getParentElement(element, this._isMaintainedNode.bind(this)) ? anchor : anchor || (!_isSizeNode ? this._isSizeNode(element) : false);\n    },\n\n    /**\r\n     * @description wraps text nodes of line selected text.\r\n     * @param {Element} element The node of the line that contains the selected text node.\r\n     * @param {Element} newInnerNode The dom that will wrap the selected text area\r\n     * @param {Function} validation Check if the node should be stripped.\r\n     * @param {Node} startCon The startContainer property of the selection object.\r\n     * @param {Number} startOff The startOffset property of the selection object.\r\n     * @param {Node} endCon The endContainer property of the selection object.\r\n     * @param {Number} endOff The endOffset property of the selection object.\r\n     * @param {Boolean} isRemoveFormat Is the remove all formats command?\r\n     * @param {Boolean} isRemoveNode \"newInnerNode\" is remove node?\r\n     * @param {Boolean} collapsed range.collapsed\r\n     * @returns {{ancestor: *, startContainer: *, startOffset: *, endContainer: *, endOffset: *}}\r\n     * @private\r\n     */\n    _nodeChange_oneLine: function _nodeChange_oneLine(element, newInnerNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode) {\n      // not add tag\n      var parentCon = startCon.parentNode;\n\n      while (!parentCon.nextSibling && !parentCon.previousSibling && !util.isFormatElement(parentCon.parentNode) && !util.isWysiwygDiv(parentCon.parentNode)) {\n        if (parentCon.nodeName === newInnerNode.nodeName) break;\n        parentCon = parentCon.parentNode;\n      }\n\n      if (!isRemoveNode && parentCon === endCon.parentNode && parentCon.nodeName === newInnerNode.nodeName) {\n        if (util.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff)) && util.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {\n          var children = parentCon.childNodes;\n          var sameTag = true;\n\n          for (var i = 0, len = children.length, _c2, _s3, e, z; i < len; i++) {\n            _c2 = children[i];\n            z = !util.onlyZeroWidthSpace(_c2);\n\n            if (_c2 === startCon) {\n              _s3 = true;\n              continue;\n            }\n\n            if (_c2 === endCon) {\n              e = true;\n              continue;\n            }\n\n            if (!_s3 && z || _s3 && e && z) {\n              sameTag = false;\n              break;\n            }\n          }\n\n          if (sameTag) {\n            util.copyTagAttributes(parentCon, newInnerNode);\n            return {\n              ancestor: element,\n              startContainer: startCon,\n              startOffset: startOff,\n              endContainer: endCon,\n              endOffset: endOff\n            };\n          }\n        }\n      } // add tag\n\n\n      _removeCheck.v = false;\n      var el = element;\n      var nNodeArray = [newInnerNode];\n      var pNode = element.cloneNode(false);\n      var isSameNode = startCon === endCon;\n      var startContainer = startCon;\n      var startOffset = startOff;\n      var endContainer = endCon;\n      var endOffset = endOff;\n      var startPass = false;\n      var endPass = false;\n      var pCurrent, newNode, appendNode, cssText, anchorNode;\n      var wRegExp = _w.RegExp;\n\n      function checkCss(vNode) {\n        var regExp = new wRegExp('(?:;|^|\\\\s)(?:' + cssText + 'null)\\\\s*:[^;]*\\\\s*(?:;|$)', 'ig');\n        var style = '';\n\n        if (regExp && vNode.style.cssText.length > 0) {\n          style = regExp.test(vNode.style.cssText);\n        }\n\n        return !style;\n      }\n\n      (function recursionFunc(current, ancestor) {\n        var childNodes = current.childNodes;\n\n        for (var _i12 = 0, _len7 = childNodes.length, vNode; _i12 < _len7; _i12++) {\n          var child = childNodes[_i12];\n          if (!child) continue;\n          var coverNode = ancestor;\n          var cloneNode = void 0; // startContainer\n\n          if (!startPass && child === startContainer) {\n            var line = pNode;\n            anchorNode = _getMaintainedNode(child);\n            var prevNode = util.createTextNode(startContainer.nodeType === 1 ? '' : startContainer.substringData(0, startOffset));\n            var textNode = util.createTextNode(startContainer.nodeType === 1 ? '' : startContainer.substringData(startOffset, isSameNode ? endOffset >= startOffset ? endOffset - startOffset : startContainer.data.length - startOffset : startContainer.data.length - startOffset));\n\n            if (anchorNode) {\n              var a = _getMaintainedNode(ancestor);\n\n              if (a && a.parentNode !== line) {\n                var m = a;\n                var p = null;\n\n                while (m.parentNode !== line) {\n                  ancestor = p = m.parentNode.cloneNode(false);\n\n                  while (m.childNodes[0]) {\n                    p.appendChild(m.childNodes[0]);\n                  }\n\n                  m.appendChild(p);\n                  m = m.parentNode;\n                }\n\n                m.parentNode.appendChild(a);\n              }\n\n              anchorNode = anchorNode.cloneNode(false);\n            }\n\n            if (!util.onlyZeroWidthSpace(prevNode)) {\n              ancestor.appendChild(prevNode);\n            }\n\n            var prevAnchorNode = _getMaintainedNode(ancestor);\n\n            if (!!prevAnchorNode) anchorNode = prevAnchorNode;\n            if (anchorNode) line = anchorNode;\n            newNode = child;\n            pCurrent = [];\n            cssText = '';\n\n            while (newNode !== line && newNode !== el && newNode !== null) {\n              vNode = _isMaintainedNode(newNode) ? null : validation(newNode);\n\n              if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {\n                pCurrent.push(vNode);\n                cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            var childNode = pCurrent.pop() || textNode;\n            appendNode = newNode = childNode;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            newInnerNode.appendChild(childNode);\n            line.appendChild(newInnerNode);\n\n            if (anchorNode && !_getMaintainedNode(endContainer)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              pNode.appendChild(newInnerNode);\n              nNodeArray.push(newInnerNode);\n            }\n\n            startContainer = textNode;\n            startOffset = 0;\n            startPass = true;\n            if (newNode !== textNode) newNode.appendChild(startContainer);\n            if (!isSameNode) continue;\n          } // endContainer\n\n\n          if (!endPass && child === endContainer) {\n            anchorNode = _getMaintainedNode(child);\n            var afterNode = util.createTextNode(endContainer.nodeType === 1 ? '' : endContainer.substringData(endOffset, endContainer.length - endOffset));\n\n            var _textNode = util.createTextNode(isSameNode || endContainer.nodeType === 1 ? '' : endContainer.substringData(0, endOffset));\n\n            if (anchorNode) {\n              anchorNode = anchorNode.cloneNode(false);\n            } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              pNode.appendChild(newInnerNode);\n              nNodeArray.push(newInnerNode);\n            }\n\n            if (!util.onlyZeroWidthSpace(afterNode)) {\n              newNode = child;\n              cssText = '';\n              pCurrent = [];\n              var anchors = [];\n\n              while (newNode !== pNode && newNode !== el && newNode !== null) {\n                if (newNode.nodeType === 1 && checkCss(newNode)) {\n                  if (_isMaintainedNode(newNode)) anchors.push(newNode.cloneNode(false));else pCurrent.push(newNode.cloneNode(false));\n                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';\n                }\n\n                newNode = newNode.parentNode;\n              }\n\n              pCurrent = pCurrent.concat(anchors);\n              cloneNode = appendNode = newNode = pCurrent.pop() || afterNode;\n\n              while (pCurrent.length > 0) {\n                newNode = pCurrent.pop();\n                appendNode.appendChild(newNode);\n                appendNode = newNode;\n              }\n\n              pNode.appendChild(cloneNode);\n              newNode.textContent = afterNode.data;\n            }\n\n            if (anchorNode && cloneNode) {\n              var afterAnchorNode = _getMaintainedNode(cloneNode);\n\n              if (afterAnchorNode) {\n                anchorNode = afterAnchorNode;\n              }\n            }\n\n            newNode = child;\n            pCurrent = [];\n            cssText = '';\n\n            while (newNode !== pNode && newNode !== el && newNode !== null) {\n              vNode = _isMaintainedNode(newNode) ? null : validation(newNode);\n\n              if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {\n                pCurrent.push(vNode);\n                cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            var _childNode = pCurrent.pop() || _textNode;\n\n            appendNode = newNode = _childNode;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            if (anchorNode) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              newInnerNode.appendChild(_childNode);\n              anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);\n              pNode.appendChild(anchorNode);\n              nNodeArray.push(newInnerNode);\n              anchorNode = null;\n            } else {\n              newInnerNode.appendChild(_childNode);\n            }\n\n            endContainer = _textNode;\n            endOffset = _textNode.data.length;\n            endPass = true;\n\n            if (!isRemoveFormat && collapsed) {\n              newInnerNode = _textNode;\n              _textNode.textContent = util.zeroWidthSpace;\n            }\n\n            if (newNode !== _textNode) newNode.appendChild(endContainer);\n            continue;\n          } // other\n\n\n          if (startPass) {\n            if (child.nodeType === 1 && !util.isBreak(child)) {\n              if (util._isIgnoreNodeChange(child)) {\n                pNode.appendChild(child.cloneNode(true));\n\n                if (!collapsed) {\n                  newInnerNode = newInnerNode.cloneNode(false);\n                  pNode.appendChild(newInnerNode);\n                  nNodeArray.push(newInnerNode);\n                }\n              } else {\n                recursionFunc(child, child);\n              }\n\n              continue;\n            }\n\n            newNode = child;\n            pCurrent = [];\n            cssText = '';\n            var _anchors = [];\n\n            while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {\n              vNode = endPass ? newNode.cloneNode(false) : validation(newNode);\n\n              if (newNode.nodeType === 1 && !util.isBreak(child) && vNode && checkCss(newNode)) {\n                if (_isMaintainedNode(newNode)) {\n                  if (!anchorNode) _anchors.push(vNode);\n                } else {\n                  pCurrent.push(vNode);\n                }\n\n                cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            pCurrent = pCurrent.concat(_anchors);\n\n            var _childNode2 = pCurrent.pop() || child;\n\n            appendNode = newNode = _childNode2;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(_childNode2) && !util.onlyZeroWidthSpace(newInnerNode)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              pNode.appendChild(newInnerNode);\n              nNodeArray.push(newInnerNode);\n            }\n\n            if (!endPass && !anchorNode && _isMaintainedNode(_childNode2)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              var aChildren = _childNode2.childNodes;\n\n              for (var _a = 0, aLen = aChildren.length; _a < aLen; _a++) {\n                newInnerNode.appendChild(aChildren[_a]);\n              }\n\n              _childNode2.appendChild(newInnerNode);\n\n              pNode.appendChild(_childNode2);\n              nNodeArray.push(newInnerNode);\n              if (newInnerNode.children.length > 0) ancestor = newNode;else ancestor = newInnerNode;\n            } else if (_childNode2 === child) {\n              if (!endPass) ancestor = newInnerNode;else ancestor = pNode;\n            } else if (endPass) {\n              pNode.appendChild(_childNode2);\n              ancestor = newNode;\n            } else {\n              newInnerNode.appendChild(_childNode2);\n              ancestor = newNode;\n            }\n\n            if (anchorNode && child.nodeType === 3) {\n              if (_getMaintainedNode(child)) {\n                var ancestorAnchorNode = util.getParentElement(ancestor, function (current) {\n                  return this._isMaintainedNode(current.parentNode) || current.parentNode === pNode;\n                }.bind(util));\n                anchorNode.appendChild(ancestorAnchorNode);\n                newInnerNode = ancestorAnchorNode.cloneNode(false);\n                nNodeArray.push(newInnerNode);\n                pNode.appendChild(newInnerNode);\n              } else {\n                anchorNode = null;\n              }\n            }\n          }\n\n          cloneNode = child.cloneNode(false);\n          ancestor.appendChild(cloneNode);\n          if (child.nodeType === 1 && !util.isBreak(child)) coverNode = cloneNode;\n          recursionFunc(child, coverNode);\n        }\n      })(element, pNode); // not remove tag\n\n\n      if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {\n        return {\n          ancestor: element,\n          startContainer: startCon,\n          startOffset: startOff,\n          endContainer: endCon,\n          endOffset: endOff\n        };\n      }\n\n      isRemoveFormat = isRemoveFormat && isRemoveNode;\n\n      if (isRemoveFormat) {\n        for (var _i13 = 0; _i13 < nNodeArray.length; _i13++) {\n          var removeNode = nNodeArray[_i13];\n          var textNode = void 0,\n              textNode_s = void 0,\n              textNode_e = void 0;\n\n          if (collapsed) {\n            textNode = util.createTextNode(util.zeroWidthSpace);\n            pNode.replaceChild(textNode, removeNode);\n          } else {\n            var rChildren = removeNode.childNodes;\n            textNode_s = rChildren[0];\n\n            while (rChildren[0]) {\n              textNode_e = rChildren[0];\n              pNode.insertBefore(textNode_e, removeNode);\n            }\n\n            util.removeItem(removeNode);\n          }\n\n          if (_i13 === 0) {\n            if (collapsed) {\n              startContainer = endContainer = textNode;\n            } else {\n              startContainer = textNode_s;\n              endContainer = textNode_e;\n            }\n          }\n        }\n      } else {\n        if (isRemoveNode) {\n          for (var _i14 = 0; _i14 < nNodeArray.length; _i14++) {\n            this._stripRemoveNode(nNodeArray[_i14]);\n          }\n        }\n\n        if (collapsed) {\n          startContainer = endContainer = newInnerNode;\n        }\n      }\n\n      util.removeEmptyNode(pNode, newInnerNode);\n\n      if (collapsed) {\n        startOffset = startContainer.textContent.length;\n        endOffset = endContainer.textContent.length;\n      } // endContainer reset\n\n\n      var endConReset = isRemoveFormat || endContainer.textContent.length === 0;\n\n      if (!util.isBreak(endContainer) && endContainer.textContent.length === 0) {\n        util.removeItem(endContainer);\n        endContainer = startContainer;\n      }\n\n      endOffset = endConReset ? endContainer.textContent.length : endOffset; // node change\n\n      var newStartOffset = {\n        s: 0,\n        e: 0\n      };\n      var startPath = util.getNodePath(startContainer, pNode, newStartOffset);\n      var mergeEndCon = !endContainer.parentNode;\n      if (mergeEndCon) endContainer = startContainer;\n      var newEndOffset = {\n        s: 0,\n        e: 0\n      };\n      var endPath = util.getNodePath(endContainer, pNode, !mergeEndCon && !endConReset ? newEndOffset : null);\n      startOffset += newStartOffset.s;\n      endOffset = collapsed ? startOffset : mergeEndCon ? startContainer.textContent.length : endConReset ? endOffset + newStartOffset.s : endOffset + newEndOffset.s; // tag merge\n\n      var newOffsets = util.mergeSameTags(pNode, [startPath, endPath], true);\n      element.parentNode.replaceChild(pNode, element);\n      startContainer = util.getNodeFromPath(startPath, pNode);\n      endContainer = util.getNodeFromPath(endPath, pNode);\n      return {\n        ancestor: pNode,\n        startContainer: startContainer,\n        startOffset: startOffset + newOffsets[0],\n        endContainer: endContainer,\n        endOffset: endOffset + newOffsets[1]\n      };\n    },\n\n    /**\r\n     * @description wraps first line selected text.\r\n     * @param {Element} element The node of the line that contains the selected text node.\r\n     * @param {Element} newInnerNode The dom that will wrap the selected text area\r\n     * @param {Function} validation Check if the node should be stripped.\r\n     * @param {Node} startCon The startContainer property of the selection object.\r\n     * @param {Number} startOff The startOffset property of the selection object.\r\n     * @param {Boolean} isRemoveFormat Is the remove all formats command?\r\n     * @param {Boolean} isRemoveNode \"newInnerNode\" is remove node?\r\n     * @returns {null|Node} If end container is renewed, returned renewed node\r\n     * @returns {Object} { ancestor, container, offset, endContainer }\r\n     * @private\r\n     */\n    _nodeChange_startLine: function _nodeChange_startLine(element, newInnerNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, _endContainer) {\n      // not add tag\n      var parentCon = startCon.parentNode;\n\n      while (!parentCon.nextSibling && !parentCon.previousSibling && !util.isFormatElement(parentCon.parentNode) && !util.isWysiwygDiv(parentCon.parentNode)) {\n        if (parentCon.nodeName === newInnerNode.nodeName) break;\n        parentCon = parentCon.parentNode;\n      }\n\n      if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util.isFormatElement(parentCon) && !parentCon.nextSibling && util.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff))) {\n        var sameTag = true;\n        var _s4 = startCon.previousSibling;\n\n        while (_s4) {\n          if (!util.onlyZeroWidthSpace(_s4)) {\n            sameTag = false;\n            break;\n          }\n\n          _s4 = _s4.previousSibling;\n        }\n\n        if (sameTag) {\n          util.copyTagAttributes(parentCon, newInnerNode);\n          return {\n            ancestor: element,\n            container: startCon,\n            offset: startOff\n          };\n        }\n      } // add tag\n\n\n      _removeCheck.v = false;\n      var el = element;\n      var nNodeArray = [newInnerNode];\n      var pNode = element.cloneNode(false);\n      var container = startCon;\n      var offset = startOff;\n      var passNode = false;\n      var pCurrent, newNode, appendNode, anchorNode;\n\n      (function recursionFunc(current, ancestor) {\n        var childNodes = current.childNodes;\n\n        for (var i = 0, len = childNodes.length, vNode, cloneChild; i < len; i++) {\n          var child = childNodes[i];\n          if (!child) continue;\n          var coverNode = ancestor;\n\n          if (passNode && !util.isBreak(child)) {\n            if (child.nodeType === 1) {\n              if (util._isIgnoreNodeChange(child)) {\n                newInnerNode = newInnerNode.cloneNode(false);\n                cloneChild = child.cloneNode(true);\n                pNode.appendChild(cloneChild);\n                pNode.appendChild(newInnerNode);\n                nNodeArray.push(newInnerNode); // end container\n\n                if (_endContainer && child.contains(_endContainer)) {\n                  var endPath = util.getNodePath(_endContainer, child);\n                  _endContainer = util.getNodeFromPath(endPath, cloneChild);\n                }\n              } else {\n                recursionFunc(child, child);\n              }\n\n              continue;\n            }\n\n            newNode = child;\n            pCurrent = [];\n            var anchors = [];\n\n            while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {\n              vNode = validation(newNode);\n\n              if (newNode.nodeType === 1 && vNode) {\n                if (_isMaintainedNode(newNode)) {\n                  if (!anchorNode) anchors.push(vNode);\n                } else {\n                  pCurrent.push(vNode);\n                }\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            pCurrent = pCurrent.concat(anchors);\n            var isTopNode = pCurrent.length > 0;\n            var childNode = pCurrent.pop() || child;\n            appendNode = newNode = childNode;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              pNode.appendChild(newInnerNode);\n              nNodeArray.push(newInnerNode);\n            }\n\n            if (!anchorNode && _isMaintainedNode(childNode)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              var aChildren = childNode.childNodes;\n\n              for (var a = 0, aLen = aChildren.length; a < aLen; a++) {\n                newInnerNode.appendChild(aChildren[a]);\n              }\n\n              childNode.appendChild(newInnerNode);\n              pNode.appendChild(childNode);\n              ancestor = !_isMaintainedNode(newNode) ? newNode : newInnerNode;\n              nNodeArray.push(newInnerNode);\n            } else if (isTopNode) {\n              newInnerNode.appendChild(childNode);\n              ancestor = newNode;\n            } else {\n              ancestor = newInnerNode;\n            }\n\n            if (anchorNode && child.nodeType === 3) {\n              if (_getMaintainedNode(child)) {\n                var ancestorAnchorNode = util.getParentElement(ancestor, function (current) {\n                  return this._isMaintainedNode(current.parentNode) || current.parentNode === pNode;\n                }.bind(util));\n                anchorNode.appendChild(ancestorAnchorNode);\n                newInnerNode = ancestorAnchorNode.cloneNode(false);\n                nNodeArray.push(newInnerNode);\n                pNode.appendChild(newInnerNode);\n              } else {\n                anchorNode = null;\n              }\n            }\n          } // startContainer\n\n\n          if (!passNode && child === container) {\n            var line = pNode;\n            anchorNode = _getMaintainedNode(child);\n            var prevNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(0, offset));\n            var textNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(offset, container.length - offset));\n\n            if (anchorNode) {\n              var _a2 = _getMaintainedNode(ancestor);\n\n              if (_a2 && _a2.parentNode !== line) {\n                var m = _a2;\n                var p = null;\n\n                while (m.parentNode !== line) {\n                  ancestor = p = m.parentNode.cloneNode(false);\n\n                  while (m.childNodes[0]) {\n                    p.appendChild(m.childNodes[0]);\n                  }\n\n                  m.appendChild(p);\n                  m = m.parentNode;\n                }\n\n                m.parentNode.appendChild(_a2);\n              }\n\n              anchorNode = anchorNode.cloneNode(false);\n            }\n\n            if (!util.onlyZeroWidthSpace(prevNode)) {\n              ancestor.appendChild(prevNode);\n            }\n\n            var prevAnchorNode = _getMaintainedNode(ancestor);\n\n            if (!!prevAnchorNode) anchorNode = prevAnchorNode;\n            if (anchorNode) line = anchorNode;\n            newNode = ancestor;\n            pCurrent = [];\n\n            while (newNode !== line && newNode !== null) {\n              vNode = validation(newNode);\n\n              if (newNode.nodeType === 1 && vNode) {\n                pCurrent.push(vNode);\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            var _childNode3 = pCurrent.pop() || ancestor;\n\n            appendNode = newNode = _childNode3;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            if (_childNode3 !== ancestor) {\n              newInnerNode.appendChild(_childNode3);\n              ancestor = newNode;\n            } else {\n              ancestor = newInnerNode;\n            }\n\n            if (util.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));\n            line.appendChild(newInnerNode);\n            container = textNode;\n            offset = 0;\n            passNode = true;\n            ancestor.appendChild(container);\n            continue;\n          }\n\n          vNode = !passNode ? child.cloneNode(false) : validation(child);\n\n          if (vNode) {\n            ancestor.appendChild(vNode);\n            if (child.nodeType === 1 && !util.isBreak(child)) coverNode = vNode;\n          }\n\n          recursionFunc(child, coverNode);\n        }\n      })(element, pNode); // not remove tag\n\n\n      if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {\n        return {\n          ancestor: element,\n          container: startCon,\n          offset: startOff,\n          endContainer: _endContainer\n        };\n      }\n\n      isRemoveFormat = isRemoveFormat && isRemoveNode;\n\n      if (isRemoveFormat) {\n        for (var i = 0; i < nNodeArray.length; i++) {\n          var removeNode = nNodeArray[i];\n          var rChildren = removeNode.childNodes;\n          var textNode = rChildren[0];\n\n          while (rChildren[0]) {\n            pNode.insertBefore(rChildren[0], removeNode);\n          }\n\n          util.removeItem(removeNode);\n          if (i === 0) container = textNode;\n        }\n      } else if (isRemoveNode) {\n        newInnerNode = newInnerNode.firstChild;\n\n        for (var _i15 = 0; _i15 < nNodeArray.length; _i15++) {\n          this._stripRemoveNode(nNodeArray[_i15]);\n        }\n      }\n\n      if (!isRemoveFormat && pNode.childNodes.length === 0) {\n        if (element.childNodes) {\n          container = element.childNodes[0];\n        } else {\n          container = util.createTextNode(util.zeroWidthSpace);\n          element.appendChild(container);\n        }\n      } else {\n        util.removeEmptyNode(pNode, newInnerNode);\n\n        if (util.onlyZeroWidthSpace(pNode.textContent)) {\n          container = pNode.firstChild;\n          offset = 0;\n        } // node change\n\n\n        var offsets = {\n          s: 0,\n          e: 0\n        };\n        var path = util.getNodePath(container, pNode, offsets);\n        offset += offsets.s; // tag merge\n\n        var newOffsets = util.mergeSameTags(pNode, [path], true);\n        element.parentNode.replaceChild(pNode, element);\n        container = util.getNodeFromPath(path, pNode);\n        offset += newOffsets[0];\n      }\n\n      return {\n        ancestor: pNode,\n        container: container,\n        offset: offset,\n        endContainer: _endContainer\n      };\n    },\n\n    /**\r\n     * @description wraps mid lines selected text.\r\n     * @param {Element} element The node of the line that contains the selected text node.\r\n     * @param {Element} newInnerNode The dom that will wrap the selected text area\r\n     * @param {Function} validation Check if the node should be stripped.\r\n     * @param {Boolean} isRemoveFormat Is the remove all formats command?\r\n     * @param {Boolean} isRemoveNode \"newInnerNode\" is remove node?\r\n     * @param {Node} _endContainer Offset node of last line already modified (end.container)\r\n     * @returns {Object} { ancestor, endContainer: \"If end container is renewed, returned renewed node\" }\r\n     * @private\r\n     */\n    _nodeChange_middleLine: function _nodeChange_middleLine(element, newInnerNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, _endContainer) {\n      // not add tag\n      if (!isRemoveNode) {\n        // end container path\n        var endPath = null;\n        if (_endContainer && element.contains(_endContainer)) endPath = util.getNodePath(_endContainer, element);\n        var tempNode = element.cloneNode(true);\n        var newNodeName = newInnerNode.nodeName;\n        var newCssText = newInnerNode.style.cssText;\n        var newClass = newInnerNode.className;\n        var children = tempNode.childNodes;\n        var i = 0,\n            len = children.length;\n\n        for (var child; i < len; i++) {\n          child = children[i];\n          if (child.nodeType === 3) break;\n\n          if (child.nodeName === newNodeName) {\n            child.style.cssText += newCssText;\n            util.addClass(child, newClass);\n          } else if (!util.isBreak(child) && util._isIgnoreNodeChange(child)) {\n            continue;\n          } else if (len === 1) {\n            children = child.childNodes;\n            len = children.length;\n            i = -1;\n            continue;\n          } else {\n            break;\n          }\n        }\n\n        if (len > 0 && i === len) {\n          element.innerHTML = tempNode.innerHTML;\n          return {\n            ancestor: element,\n            endContainer: endPath ? util.getNodeFromPath(endPath, element) : null\n          };\n        }\n      } // add tag\n\n\n      _removeCheck.v = false;\n      var pNode = element.cloneNode(false);\n      var nNodeArray = [newInnerNode];\n      var noneChange = true;\n\n      (function recursionFunc(current, ancestor) {\n        var childNodes = current.childNodes;\n\n        for (var _i16 = 0, _len8 = childNodes.length, vNode, cloneChild; _i16 < _len8; _i16++) {\n          var _child = childNodes[_i16];\n          if (!_child) continue;\n          var coverNode = ancestor;\n\n          if (!util.isBreak(_child) && util._isIgnoreNodeChange(_child)) {\n            if (newInnerNode.childNodes.length > 0) {\n              pNode.appendChild(newInnerNode);\n              newInnerNode = newInnerNode.cloneNode(false);\n            }\n\n            cloneChild = _child.cloneNode(true);\n            pNode.appendChild(cloneChild);\n            pNode.appendChild(newInnerNode);\n            nNodeArray.push(newInnerNode);\n            ancestor = newInnerNode; // end container\n\n            if (_endContainer && _child.contains(_endContainer)) {\n              var _endPath = util.getNodePath(_endContainer, _child);\n\n              _endContainer = util.getNodeFromPath(_endPath, cloneChild);\n            }\n\n            continue;\n          } else {\n            vNode = validation(_child);\n\n            if (vNode) {\n              noneChange = false;\n              ancestor.appendChild(vNode);\n              if (_child.nodeType === 1) coverNode = vNode;\n            }\n          }\n\n          if (!util.isBreak(_child)) recursionFunc(_child, coverNode);\n        }\n      })(element, newInnerNode); // not remove tag\n\n\n      if (noneChange || isRemoveNode && !isRemoveFormat && !_removeCheck.v) return {\n        ancestor: element,\n        endContainer: _endContainer\n      };\n      pNode.appendChild(newInnerNode);\n\n      if (isRemoveFormat && isRemoveNode) {\n        for (var _i17 = 0; _i17 < nNodeArray.length; _i17++) {\n          var removeNode = nNodeArray[_i17];\n          var rChildren = removeNode.childNodes;\n\n          while (rChildren[0]) {\n            pNode.insertBefore(rChildren[0], removeNode);\n          }\n\n          util.removeItem(removeNode);\n        }\n      } else if (isRemoveNode) {\n        newInnerNode = newInnerNode.firstChild;\n\n        for (var _i18 = 0; _i18 < nNodeArray.length; _i18++) {\n          this._stripRemoveNode(nNodeArray[_i18]);\n        }\n      }\n\n      util.removeEmptyNode(pNode, newInnerNode);\n      util.mergeSameTags(pNode, null, true); // node change\n\n      element.parentNode.replaceChild(pNode, element);\n      return {\n        ancestor: pNode,\n        endContainer: _endContainer\n      };\n    },\n\n    /**\r\n     * @description wraps last line selected text.\r\n     * @param {Element} element The node of the line that contains the selected text node.\r\n     * @param {Element} newInnerNode The dom that will wrap the selected text area\r\n     * @param {Function} validation Check if the node should be stripped.\r\n     * @param {Node} endCon The endContainer property of the selection object.\r\n     * @param {Number} endOff The endOffset property of the selection object.\r\n     * @param {Boolean} isRemoveFormat Is the remove all formats command?\r\n     * @param {Boolean} isRemoveNode \"newInnerNode\" is remove node?\r\n     * @returns {Object} { ancestor, container, offset }\r\n     * @private\r\n     */\n    _nodeChange_endLine: function _nodeChange_endLine(element, newInnerNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode) {\n      // not add tag\n      var parentCon = endCon.parentNode;\n\n      while (!parentCon.nextSibling && !parentCon.previousSibling && !util.isFormatElement(parentCon.parentNode) && !util.isWysiwygDiv(parentCon.parentNode)) {\n        if (parentCon.nodeName === newInnerNode.nodeName) break;\n        parentCon = parentCon.parentNode;\n      }\n\n      if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util.isFormatElement(parentCon) && !parentCon.previousSibling && util.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {\n        var sameTag = true;\n        var e = endCon.nextSibling;\n\n        while (e) {\n          if (!util.onlyZeroWidthSpace(e)) {\n            sameTag = false;\n            break;\n          }\n\n          e = e.nextSibling;\n        }\n\n        if (sameTag) {\n          util.copyTagAttributes(parentCon, newInnerNode);\n          return {\n            ancestor: element,\n            container: endCon,\n            offset: endOff\n          };\n        }\n      } // add tag\n\n\n      _removeCheck.v = false;\n      var el = element;\n      var nNodeArray = [newInnerNode];\n      var pNode = element.cloneNode(false);\n      var container = endCon;\n      var offset = endOff;\n      var passNode = false;\n      var pCurrent, newNode, appendNode, anchorNode;\n\n      (function recursionFunc(current, ancestor) {\n        var childNodes = current.childNodes;\n\n        for (var i = childNodes.length - 1, vNode; 0 <= i; i--) {\n          var child = childNodes[i];\n          if (!child) continue;\n          var coverNode = ancestor;\n\n          if (passNode && !util.isBreak(child)) {\n            if (child.nodeType === 1) {\n              if (util._isIgnoreNodeChange(child)) {\n                newInnerNode = newInnerNode.cloneNode(false);\n                var cloneChild = child.cloneNode(true);\n                pNode.insertBefore(cloneChild, ancestor);\n                pNode.insertBefore(newInnerNode, cloneChild);\n                nNodeArray.push(newInnerNode);\n              } else {\n                recursionFunc(child, child);\n              }\n\n              continue;\n            }\n\n            newNode = child;\n            pCurrent = [];\n            var anchors = [];\n\n            while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {\n              vNode = validation(newNode);\n\n              if (vNode && newNode.nodeType === 1) {\n                if (_isMaintainedNode(newNode)) {\n                  if (!anchorNode) anchors.push(vNode);\n                } else {\n                  pCurrent.push(vNode);\n                }\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            pCurrent = pCurrent.concat(anchors);\n            var isTopNode = pCurrent.length > 0;\n            var childNode = pCurrent.pop() || child;\n            appendNode = newNode = childNode;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              pNode.insertBefore(newInnerNode, pNode.firstChild);\n              nNodeArray.push(newInnerNode);\n            }\n\n            if (!anchorNode && _isMaintainedNode(childNode)) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              var aChildren = childNode.childNodes;\n\n              for (var a = 0, aLen = aChildren.length; a < aLen; a++) {\n                newInnerNode.appendChild(aChildren[a]);\n              }\n\n              childNode.appendChild(newInnerNode);\n              pNode.insertBefore(childNode, pNode.firstChild);\n              nNodeArray.push(newInnerNode);\n              if (newInnerNode.children.length > 0) ancestor = newNode;else ancestor = newInnerNode;\n            } else if (isTopNode) {\n              newInnerNode.insertBefore(childNode, newInnerNode.firstChild);\n              ancestor = newNode;\n            } else {\n              ancestor = newInnerNode;\n            }\n\n            if (anchorNode && child.nodeType === 3) {\n              if (_getMaintainedNode(child)) {\n                var ancestorAnchorNode = util.getParentElement(ancestor, function (current) {\n                  return this._isMaintainedNode(current.parentNode) || current.parentNode === pNode;\n                }.bind(util));\n                anchorNode.appendChild(ancestorAnchorNode);\n                newInnerNode = ancestorAnchorNode.cloneNode(false);\n                nNodeArray.push(newInnerNode);\n                pNode.insertBefore(newInnerNode, pNode.firstChild);\n              } else {\n                anchorNode = null;\n              }\n            }\n          } // endContainer\n\n\n          if (!passNode && child === container) {\n            anchorNode = _getMaintainedNode(child);\n            var afterNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(offset, container.length - offset));\n            var textNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(0, offset));\n\n            if (anchorNode) {\n              anchorNode = anchorNode.cloneNode(false);\n\n              var _a3 = _getMaintainedNode(ancestor);\n\n              if (_a3 && _a3.parentNode !== pNode) {\n                var m = _a3;\n                var p = null;\n\n                while (m.parentNode !== pNode) {\n                  ancestor = p = m.parentNode.cloneNode(false);\n\n                  while (m.childNodes[0]) {\n                    p.appendChild(m.childNodes[0]);\n                  }\n\n                  m.appendChild(p);\n                  m = m.parentNode;\n                }\n\n                m.parentNode.insertBefore(_a3, m.parentNode.firstChild);\n              }\n\n              anchorNode = anchorNode.cloneNode(false);\n            } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {\n              newInnerNode = newInnerNode.cloneNode(false);\n              pNode.appendChild(newInnerNode);\n              nNodeArray.push(newInnerNode);\n            }\n\n            if (!util.onlyZeroWidthSpace(afterNode)) {\n              ancestor.insertBefore(afterNode, ancestor.firstChild);\n            }\n\n            newNode = ancestor;\n            pCurrent = [];\n\n            while (newNode !== pNode && newNode !== null) {\n              vNode = _isMaintainedNode(newNode) ? null : validation(newNode);\n\n              if (vNode && newNode.nodeType === 1) {\n                pCurrent.push(vNode);\n              }\n\n              newNode = newNode.parentNode;\n            }\n\n            var _childNode4 = pCurrent.pop() || ancestor;\n\n            appendNode = newNode = _childNode4;\n\n            while (pCurrent.length > 0) {\n              newNode = pCurrent.pop();\n              appendNode.appendChild(newNode);\n              appendNode = newNode;\n            }\n\n            if (_childNode4 !== ancestor) {\n              newInnerNode.insertBefore(_childNode4, newInnerNode.firstChild);\n              ancestor = newNode;\n            } else {\n              ancestor = newInnerNode;\n            }\n\n            if (util.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));\n\n            if (anchorNode) {\n              anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);\n              pNode.insertBefore(anchorNode, pNode.firstChild);\n              anchorNode = null;\n            } else {\n              pNode.insertBefore(newInnerNode, pNode.firstChild);\n            }\n\n            container = textNode;\n            offset = textNode.data.length;\n            passNode = true;\n            ancestor.insertBefore(container, ancestor.firstChild);\n            continue;\n          }\n\n          vNode = !passNode ? child.cloneNode(false) : validation(child);\n\n          if (vNode) {\n            ancestor.insertBefore(vNode, ancestor.firstChild);\n            if (child.nodeType === 1 && !util.isBreak(child)) coverNode = vNode;\n          }\n\n          recursionFunc(child, coverNode);\n        }\n      })(element, pNode); // not remove tag\n\n\n      if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {\n        return {\n          ancestor: element,\n          container: endCon,\n          offset: endOff\n        };\n      }\n\n      isRemoveFormat = isRemoveFormat && isRemoveNode;\n\n      if (isRemoveFormat) {\n        for (var i = 0; i < nNodeArray.length; i++) {\n          var removeNode = nNodeArray[i];\n          var rChildren = removeNode.childNodes;\n          var textNode = null;\n\n          while (rChildren[0]) {\n            textNode = rChildren[0];\n            pNode.insertBefore(textNode, removeNode);\n          }\n\n          util.removeItem(removeNode);\n\n          if (i === nNodeArray.length - 1) {\n            container = textNode;\n            offset = textNode.textContent.length;\n          }\n        }\n      } else if (isRemoveNode) {\n        newInnerNode = newInnerNode.firstChild;\n\n        for (var _i19 = 0; _i19 < nNodeArray.length; _i19++) {\n          this._stripRemoveNode(nNodeArray[_i19]);\n        }\n      }\n\n      if (!isRemoveFormat && pNode.childNodes.length === 0) {\n        if (element.childNodes) {\n          container = element.childNodes[0];\n        } else {\n          container = util.createTextNode(util.zeroWidthSpace);\n          element.appendChild(container);\n        }\n      } else {\n        if (!isRemoveNode && newInnerNode.textContent.length === 0) {\n          util.removeEmptyNode(pNode, null);\n          return {\n            ancestor: null,\n            container: null,\n            offset: 0\n          };\n        }\n\n        util.removeEmptyNode(pNode, newInnerNode);\n\n        if (util.onlyZeroWidthSpace(pNode.textContent)) {\n          container = pNode.firstChild;\n          offset = container.textContent.length;\n        } else if (util.onlyZeroWidthSpace(container)) {\n          container = newInnerNode;\n          offset = 1;\n        } // node change\n\n\n        var offsets = {\n          s: 0,\n          e: 0\n        };\n        var path = util.getNodePath(container, pNode, offsets);\n        offset += offsets.s; // tag merge\n\n        var newOffsets = util.mergeSameTags(pNode, [path], true);\n        element.parentNode.replaceChild(pNode, element);\n        container = util.getNodeFromPath(path, pNode);\n        offset += newOffsets[0];\n      }\n\n      return {\n        ancestor: pNode,\n        container: container,\n        offset: container.nodeType === 1 && offset === 1 ? container.childNodes.length : offset\n      };\n    },\n\n    /**\r\n     * @description Run plugin calls and basic commands.\r\n     * @param {String} command Command string\r\n     * @param {String} display Display type string ('command', 'submenu', 'dialog', 'container')\r\n     * @param {Element} target The element of command button\r\n     */\n    actionCall: function actionCall(command, display, target) {\n      // call plugins\n      if (display) {\n        if (/more/i.test(display)) {\n          if (target !== this._moreLayerActiveButton) {\n            var layer = context.element.toolbar.querySelector('.' + command);\n\n            if (layer) {\n              if (this._moreLayerActiveButton) this.moreLayerOff();\n              this._moreLayerActiveButton = target;\n              layer.style.display = 'block';\n\n              event._showToolbarBalloon();\n\n              event._showToolbarInline();\n            }\n\n            util.addClass(target, 'on');\n          } else {\n            var _layer = context.element.toolbar.querySelector('.' + this._moreLayerActiveButton.getAttribute('data-command'));\n\n            if (_layer) {\n              this.moreLayerOff();\n\n              event._showToolbarBalloon();\n\n              event._showToolbarInline();\n            }\n          }\n\n          return;\n        }\n\n        if (/container/.test(display) && (this._menuTray[command] === null || target !== this.containerActiveButton)) {\n          this.callPlugin(command, this.containerOn.bind(this, target), target);\n          return;\n        }\n\n        if (this.isReadOnly && util.arrayIncludes(this.resizingDisabledButtons, target)) return;\n\n        if (/submenu/.test(display) && (this._menuTray[command] === null || target !== this.submenuActiveButton)) {\n          this.callPlugin(command, this.submenuOn.bind(this, target), target);\n          return;\n        } else if (/dialog/.test(display)) {\n          this.callPlugin(command, this.plugins[command].open.bind(this), target);\n          return;\n        } else if (/command/.test(display)) {\n          this.callPlugin(command, this.plugins[command].action.bind(this), target);\n        } else if (/fileBrowser/.test(display)) {\n          this.callPlugin(command, this.plugins[command].open.bind(this, null), target);\n        }\n      } // default command\n      else if (command) {\n        this.commandHandler(target, command);\n      }\n\n      if (/submenu/.test(display)) {\n        this.submenuOff();\n      } else if (!/command/.test(display)) {\n        this.submenuOff();\n        this.containerOff();\n      }\n    },\n\n    /**\r\n     * @description Execute command of command button(All Buttons except submenu and dialog)\r\n     * (selectAll, codeView, fullScreen, indent, outdent, undo, redo, removeFormat, print, preview, showBlocks, save, bold, underline, italic, strike, subscript, superscript, copy, cut, paste)\r\n     * @param {Element|null} target The element of command button\r\n     * @param {String} command Property of command button (data-value)\r\n     */\n    commandHandler: function commandHandler(target, command) {\n      if (core.isReadOnly && !/copy|cut|selectAll|codeView|fullScreen|print|preview|showBlocks/.test(command)) return;\n\n      switch (command) {\n        case 'copy':\n        case 'cut':\n          this.execCommand(command);\n          break;\n\n        case 'paste':\n          break;\n\n        case 'selectAll':\n          this.containerOff();\n          var wysiwyg = context.element.wysiwyg;\n          var first = util.getChildElement(wysiwyg.firstChild, function (current) {\n            return current.childNodes.length === 0 || current.nodeType === 3;\n          }, false) || wysiwyg.firstChild;\n          var last = util.getChildElement(wysiwyg.lastChild, function (current) {\n            return current.childNodes.length === 0 || current.nodeType === 3;\n          }, true) || wysiwyg.lastChild;\n          if (!first || !last) return;\n\n          if (util.isMedia(first)) {\n            var info = this.getFileComponent(first);\n            var br = util.createElement('BR');\n            var format = util.createElement(options.defaultTag);\n            format.appendChild(br);\n            first = info ? info.component : first;\n            first.parentNode.insertBefore(format, first);\n            first = br;\n          }\n\n          if (util.isMedia(last)) {\n            var _br = util.createElement('BR');\n\n            var _format2 = util.createElement(options.defaultTag);\n\n            _format2.appendChild(_br);\n\n            wysiwyg.appendChild(_format2);\n            last = _br;\n          }\n\n          event._showToolbarBalloon(this.setRange(first, 0, last, last.textContent.length));\n\n          break;\n\n        case 'codeView':\n          this.toggleCodeView();\n          break;\n\n        case 'fullScreen':\n          this.toggleFullScreen(target);\n          break;\n\n        case 'indent':\n        case 'outdent':\n          this.indent(command);\n          break;\n\n        case 'undo':\n          this.history.undo();\n          break;\n\n        case 'redo':\n          this.history.redo();\n          break;\n\n        case 'removeFormat':\n          this.removeFormat();\n          this.focus();\n          break;\n\n        case 'print':\n          this.print();\n          break;\n\n        case 'preview':\n          this.preview();\n          break;\n\n        case 'showBlocks':\n          this.toggleDisplayBlocks();\n          break;\n\n        case 'dir':\n          this.setDir(options.rtl ? 'ltr' : 'rtl');\n          break;\n\n        case 'dir_ltr':\n          this.setDir('ltr');\n          break;\n\n        case 'dir_rtl':\n          this.setDir('rtl');\n          break;\n\n        case 'save':\n          if (typeof options.callBackSave === 'function') {\n            options.callBackSave(this.getContents(false), this._variable.isChanged);\n          } else if (this._variable.isChanged && typeof functions.save === 'function') {\n            functions.save();\n          } else {\n            throw Error('[SUNEDITOR.core.commandHandler.fail] Please register call back function in creation option. (callBackSave : Function)');\n          }\n\n          this._variable.isChanged = false;\n          if (context.tool.save) context.tool.save.setAttribute('disabled', true);\n          break;\n\n        default:\n          // 'STRONG', 'U', 'EM', 'DEL', 'SUB', 'SUP'..\n          command = options._defaultCommand[command.toLowerCase()] || command;\n          if (!this.commandMap[command]) this.commandMap[command] = target;\n          var nodesMap = this._variable.currentNodesMap;\n          var cmd = nodesMap.indexOf(command) > -1 ? null : util.createElement(command);\n          var removeNode = command;\n\n          if (/^SUB$/i.test(command) && nodesMap.indexOf('SUP') > -1) {\n            removeNode = 'SUP';\n          } else if (/^SUP$/i.test(command) && nodesMap.indexOf('SUB') > -1) {\n            removeNode = 'SUB';\n          }\n\n          this.nodeChange(cmd, this._commandMapStyles[command] || null, [removeNode], false);\n          this.focus();\n      }\n    },\n\n    /**\r\n     * @description Remove format of the currently selected range\r\n     */\n    removeFormat: function removeFormat() {\n      this.nodeChange(null, null, null, null);\n    },\n\n    /**\r\n     * @description This method implements indentation to selected range.\r\n     * Setted \"margin-left\" to \"25px\" in the top \"P\" tag of the parameter node.\r\n     * @param {String} command Separator (\"indent\" or \"outdent\")\r\n     */\n    indent: function indent(command) {\n      var range = this.getRange();\n      var rangeLines = this.getSelectedElements(null);\n      var cells = [];\n      var shift = 'indent' !== command;\n      var marginDir = options.rtl ? 'marginRight' : 'marginLeft';\n      var sc = range.startContainer;\n      var ec = range.endContainer;\n      var so = range.startOffset;\n      var eo = range.endOffset;\n\n      for (var i = 0, len = rangeLines.length, f, margin; i < len; i++) {\n        f = rangeLines[i];\n\n        if (!util.isListCell(f) || !this.plugins.list) {\n          margin = /\\d+/.test(f.style[marginDir]) ? util.getNumber(f.style[marginDir], 0) : 0;\n\n          if (shift) {\n            margin -= 25;\n          } else {\n            margin += 25;\n          }\n\n          util.setStyle(f, marginDir, margin <= 0 ? '' : margin + 'px');\n        } else {\n          if (shift || f.previousElementSibling) {\n            cells.push(f);\n          }\n        }\n      } // list cells\n\n\n      if (cells.length > 0) {\n        this.plugins.list.editInsideList.call(this, shift, cells);\n      }\n\n      this.effectNode = null;\n      this.setRange(sc, so, ec, eo); // history stack\n\n      this.history.push(false);\n    },\n\n    /**\r\n     * @description Add or remove the class name of \"body\" so that the code block is visible\r\n     */\n    toggleDisplayBlocks: function toggleDisplayBlocks() {\n      var wysiwyg = context.element.wysiwyg;\n      util.toggleClass(wysiwyg, 'se-show-block');\n\n      if (util.hasClass(wysiwyg, 'se-show-block')) {\n        util.addClass(this._styleCommandMap.showBlocks, 'active');\n      } else {\n        util.removeClass(this._styleCommandMap.showBlocks, 'active');\n      }\n\n      this._resourcesStateChange();\n    },\n\n    /**\r\n     * @description Changes to code view or wysiwyg view\r\n     */\n    toggleCodeView: function toggleCodeView() {\n      var isCodeView = this._variable.isCodeView;\n      this.controllersOff();\n      util.setDisabledButtons(!isCodeView, this.codeViewDisabledButtons);\n\n      if (isCodeView) {\n        if (!util.isNonEditable(context.element.wysiwygFrame)) this._setCodeDataToEditor();\n        context.element.wysiwygFrame.scrollTop = 0;\n        context.element.code.style.display = 'none';\n        context.element.wysiwygFrame.style.display = 'block';\n        this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\\s?display(\\s+)?:(\\s+)?)[a-zA-Z]+(?=;)/, 'display: none');\n        this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\\s?display(\\s+)?:(\\s+)?)[a-zA-Z]+(?=;)/, 'display: block');\n        if (options.height === 'auto' && !options.codeMirrorEditor) context.element.code.style.height = '0px';\n        this._variable.isCodeView = false;\n\n        if (!this._variable.isFullScreen) {\n          this._notHideToolbar = false;\n\n          if (/balloon|balloon-always/i.test(options.mode)) {\n            context.element._arrow.style.display = '';\n            this._isInline = false;\n            this._isBalloon = true;\n\n            event._hideToolbar();\n          }\n        }\n\n        this.nativeFocus();\n        util.removeClass(this._styleCommandMap.codeView, 'active'); // history stack\n\n        if (!util.isNonEditable(context.element.wysiwygFrame)) {\n          this.history.push(false);\n\n          this.history._resetCachingButton();\n        }\n      } else {\n        this._setEditorDataToCodeView();\n\n        this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\\s?display(\\s+)?:(\\s+)?)[a-zA-Z]+(?=;)/, 'display: block');\n        this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\\s?display(\\s+)?:(\\s+)?)[a-zA-Z]+(?=;)/, 'display: none');\n        if (this._variable.isFullScreen) context.element.code.style.height = '100%';else if (options.height === 'auto' && !options.codeMirrorEditor) context.element.code.style.height = context.element.code.scrollHeight > 0 ? context.element.code.scrollHeight + 'px' : 'auto';\n        if (options.codeMirrorEditor) options.codeMirrorEditor.refresh();\n        this._variable.isCodeView = true;\n\n        if (!this._variable.isFullScreen) {\n          this._notHideToolbar = true;\n\n          if (this._isBalloon) {\n            context.element._arrow.style.display = 'none';\n            context.element.toolbar.style.left = '';\n            this._isInline = true;\n            this._isBalloon = false;\n\n            event._showToolbarInline();\n          }\n        }\n\n        this._variable._range = null;\n        context.element.code.focus();\n        util.addClass(this._styleCommandMap.codeView, 'active');\n      }\n\n      this._checkPlaceholder();\n\n      if (this.isReadOnly) util.setDisabledButtons(true, this.resizingDisabledButtons); // user event\n\n      if (typeof functions.toggleCodeView === 'function') functions.toggleCodeView(this._variable.isCodeView, this);\n    },\n\n    /**\r\n     * @description Convert the data of the code view and put it in the WYSIWYG area.\r\n     * @private\r\n     */\n    _setCodeDataToEditor: function _setCodeDataToEditor() {\n      var code_html = this._getCodeView();\n\n      if (options.fullPage) {\n        var parseDocument = this._parser.parseFromString(code_html, 'text/html');\n\n        var headChildren = parseDocument.head.children;\n\n        for (var i = 0, len = headChildren.length; i < len; i++) {\n          if (/^script$/i.test(headChildren[i].tagName)) {\n            parseDocument.head.removeChild(headChildren[i]);\n            i--, len--;\n          }\n        }\n\n        var headers = parseDocument.head.innerHTML;\n\n        if (!parseDocument.head.querySelector('link[rel=\"stylesheet\"]') || this.options.height === 'auto' && !parseDocument.head.querySelector('style')) {\n          headers += util._setIframeCssTags(this.options);\n        }\n\n        this._wd.head.innerHTML = headers;\n        this._wd.body.innerHTML = this.convertContentsForEditor(parseDocument.body.innerHTML);\n        var attrs = parseDocument.body.attributes;\n\n        for (var _i20 = 0, _len9 = attrs.length; _i20 < _len9; _i20++) {\n          if (attrs[_i20].name === 'contenteditable') continue;\n\n          this._wd.body.setAttribute(attrs[_i20].name, attrs[_i20].value);\n        }\n\n        if (!util.hasClass(this._wd.body, 'sun-editor-editable')) {\n          var editableClasses = options._editableClass.split(' ');\n\n          for (var _i21 = 0; _i21 < editableClasses.length; _i21++) {\n            util.addClass(this._wd.body, options._editableClass[_i21]);\n          }\n        }\n      } else {\n        context.element.wysiwyg.innerHTML = code_html.length > 0 ? this.convertContentsForEditor(code_html) : '<' + options.defaultTag + '><br></' + options.defaultTag + '>';\n      }\n    },\n\n    /**\r\n     * @description Convert the data of the WYSIWYG area and put it in the code view area.\r\n     * @private\r\n     */\n    _setEditorDataToCodeView: function _setEditorDataToCodeView() {\n      var codeContents = this.convertHTMLForCodeView(context.element.wysiwyg, false);\n      var codeValue = '';\n\n      if (options.fullPage) {\n        var attrs = util.getAttributesToString(this._wd.body, null);\n        codeValue = '<!DOCTYPE html>\\n<html>\\n' + this._wd.head.outerHTML.replace(/>(?!\\n)/g, '>\\n') + '<body ' + attrs + '>\\n' + codeContents + '</body>\\n</html>';\n      } else {\n        codeValue = codeContents;\n      }\n\n      context.element.code.style.display = 'block';\n      context.element.wysiwygFrame.style.display = 'none';\n\n      this._setCodeView(codeValue);\n    },\n\n    /**\r\n     * @description Changes to full screen or default screen\r\n     * @param {Element|null} element full screen button\r\n     */\n    toggleFullScreen: function toggleFullScreen(element) {\n      var topArea = context.element.topArea;\n      var toolbar = context.element.toolbar;\n      var editorArea = context.element.editorArea;\n      var wysiwygFrame = context.element.wysiwygFrame;\n      var code = context.element.code;\n      var _var = this._variable;\n      this.controllersOff();\n      var wasToolbarHidden = toolbar.style.display === 'none' || this._isInline && !this._inlineToolbarAttr.isShow;\n\n      if (!_var.isFullScreen) {\n        _var.isFullScreen = true;\n        _var._fullScreenAttrs.inline = this._isInline;\n        _var._fullScreenAttrs.balloon = this._isBalloon;\n\n        if (this._isInline || this._isBalloon) {\n          this._isInline = false;\n          this._isBalloon = false;\n        }\n\n        if (!!options.toolbarContainer) context.element.relative.insertBefore(toolbar, editorArea);\n        topArea.style.position = 'fixed';\n        topArea.style.top = '0';\n        topArea.style.left = '0';\n        topArea.style.width = '100%';\n        topArea.style.maxWidth = '100%';\n        topArea.style.height = '100%';\n        topArea.style.zIndex = '2147483647';\n\n        if (context.element._stickyDummy.style.display !== ('none' && '')) {\n          _var._fullScreenAttrs.sticky = true;\n          context.element._stickyDummy.style.display = 'none';\n          util.removeClass(toolbar, 'se-toolbar-sticky');\n        }\n\n        _var._bodyOverflow = _d.body.style.overflow;\n        _d.body.style.overflow = 'hidden';\n        _var._editorAreaOriginCssText = editorArea.style.cssText;\n        _var._wysiwygOriginCssText = wysiwygFrame.style.cssText;\n        _var._codeOriginCssText = code.style.cssText;\n        editorArea.style.cssText = toolbar.style.cssText = '';\n        wysiwygFrame.style.cssText = (wysiwygFrame.style.cssText.match(/\\s?display(\\s+)?:(\\s+)?[a-zA-Z]+;/) || [''])[0];\n        code.style.cssText = (code.style.cssText.match(/\\s?display(\\s+)?:(\\s+)?[a-zA-Z]+;/) || [''])[0];\n        toolbar.style.width = wysiwygFrame.style.height = code.style.height = '100%';\n        toolbar.style.position = 'relative';\n        toolbar.style.display = 'block';\n        _var.innerHeight_fullScreen = _w.innerHeight - toolbar.offsetHeight;\n        editorArea.style.height = _var.innerHeight_fullScreen - options.fullScreenOffset + 'px';\n        if (element) util.changeElement(element.firstElementChild, icons.reduction);\n\n        if (options.iframe && options.height === 'auto') {\n          editorArea.style.overflow = 'auto';\n\n          this._iframeAutoHeight();\n        }\n\n        context.element.topArea.style.marginTop = options.fullScreenOffset + 'px';\n        util.addClass(this._styleCommandMap.fullScreen, 'active');\n      } else {\n        _var.isFullScreen = false;\n        wysiwygFrame.style.cssText = _var._wysiwygOriginCssText;\n        code.style.cssText = _var._codeOriginCssText;\n        toolbar.style.cssText = '';\n        editorArea.style.cssText = _var._editorAreaOriginCssText;\n        topArea.style.cssText = _var._originCssText;\n        _d.body.style.overflow = _var._bodyOverflow;\n        if (options.height === 'auto' && !options.codeMirrorEditor) event._codeViewAutoHeight();\n        if (!!options.toolbarContainer) options.toolbarContainer.appendChild(toolbar);\n\n        if (options.stickyToolbar > -1) {\n          util.removeClass(toolbar, 'se-toolbar-sticky');\n        }\n\n        if (_var._fullScreenAttrs.sticky && !options.toolbarContainer) {\n          _var._fullScreenAttrs.sticky = false;\n          context.element._stickyDummy.style.display = 'block';\n          util.addClass(toolbar, \"se-toolbar-sticky\");\n        }\n\n        this._isInline = _var._fullScreenAttrs.inline;\n        this._isBalloon = _var._fullScreenAttrs.balloon;\n        if (this._isInline) event._showToolbarInline();\n        if (!!options.toolbarContainer) util.removeClass(toolbar, 'se-toolbar-balloon');\n        event.onScroll_window();\n        if (element) util.changeElement(element.firstElementChild, icons.expansion);\n        context.element.topArea.style.marginTop = '';\n        util.removeClass(this._styleCommandMap.fullScreen, 'active');\n      }\n\n      if (wasToolbarHidden) functions.toolbar.hide(); // user event\n\n      if (typeof functions.toggleFullScreen === 'function') functions.toggleFullScreen(this._variable.isFullScreen, this);\n    },\n\n    /**\r\n     * @description Prints the current contents of the editor.\r\n     */\n    print: function print() {\n      var iframe = util.createElement('IFRAME');\n      iframe.style.display = 'none';\n\n      _d.body.appendChild(iframe);\n\n      var contentsHTML = options.printTemplate ? options.printTemplate.replace(/\\{\\{\\s*contents\\s*\\}\\}/i, this.getContents(true)) : this.getContents(true);\n      var printDocument = util.getIframeDocument(iframe);\n      var wDoc = this._wd;\n\n      if (options.iframe) {\n        var arrts = options._printClass !== null ? 'class=\"' + options._printClass + '\"' : options.fullPage ? util.getAttributesToString(wDoc.body, ['contenteditable']) : 'class=\"' + options._editableClass + '\"';\n        printDocument.write('' + '<!DOCTYPE html><html>' + '<head>' + wDoc.head.innerHTML + '</head>' + '<body ' + arrts + '>' + contentsHTML + '</body>' + '</html>');\n      } else {\n        var links = _d.head.getElementsByTagName('link');\n\n        var styles = _d.head.getElementsByTagName('style');\n\n        var linkHTML = '';\n\n        for (var i = 0, len = links.length; i < len; i++) {\n          linkHTML += links[i].outerHTML;\n        }\n\n        for (var _i22 = 0, _len10 = styles.length; _i22 < _len10; _i22++) {\n          linkHTML += styles[_i22].outerHTML;\n        }\n\n        printDocument.write('' + '<!DOCTYPE html><html>' + '<head>' + linkHTML + '</head>' + '<body class=\"' + (options._printClass !== null ? options._printClass : options._editableClass) + '\">' + contentsHTML + '</body>' + '</html>');\n      }\n\n      this.showLoading();\n\n      _w.setTimeout(function () {\n        try {\n          iframe.focus(); // IE or Edge, Chromium\n\n          if (util.isIE_Edge || util.isChromium || !!_d.documentMode || !!_w.StyleMedia) {\n            try {\n              iframe.contentWindow.document.execCommand('print', false, null);\n            } catch (e) {\n              iframe.contentWindow.print();\n            }\n          } else {\n            // Other browsers\n            iframe.contentWindow.print();\n          }\n        } catch (error) {\n          throw Error('[SUNEDITOR.core.print.fail] error: ' + error);\n        } finally {\n          core.closeLoading();\n          util.removeItem(iframe);\n        }\n      }, 1000);\n    },\n\n    /**\r\n     * @description Open the preview window.\r\n     */\n    preview: function preview() {\n      core.submenuOff();\n      core.containerOff();\n      core.controllersOff();\n      var contentsHTML = options.previewTemplate ? options.previewTemplate.replace(/\\{\\{\\s*contents\\s*\\}\\}/i, this.getContents(true)) : this.getContents(true);\n\n      var windowObject = _w.open('', '_blank');\n\n      windowObject.mimeType = 'text/html';\n      var wDoc = this._wd;\n\n      if (options.iframe) {\n        var arrts = options._printClass !== null ? 'class=\"' + options._printClass + '\"' : options.fullPage ? util.getAttributesToString(wDoc.body, ['contenteditable']) : 'class=\"' + options._editableClass + '\"';\n        windowObject.document.write('' + '<!DOCTYPE html><html>' + '<head>' + wDoc.head.innerHTML + '<style>body {overflow:auto !important; margin: 10px auto !important; height:auto !important; outline:1px dashed #ccc;}</style>' + '</head>' + '<body ' + arrts + '>' + contentsHTML + '</body>' + '</html>');\n      } else {\n        var links = _d.head.getElementsByTagName('link');\n\n        var styles = _d.head.getElementsByTagName('style');\n\n        var linkHTML = '';\n\n        for (var i = 0, len = links.length; i < len; i++) {\n          linkHTML += links[i].outerHTML;\n        }\n\n        for (var _i23 = 0, _len11 = styles.length; _i23 < _len11; _i23++) {\n          linkHTML += styles[_i23].outerHTML;\n        }\n\n        windowObject.document.write('' + '<!DOCTYPE html><html>' + '<head>' + '<meta charset=\"utf-8\" />' + '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">' + '<title>' + lang.toolbar.preview + '</title>' + linkHTML + '</head>' + '<body class=\"' + (options._printClass !== null ? options._printClass : options._editableClass) + '\" style=\"margin:10px auto !important; height:auto !important; outline:1px dashed #ccc;\">' + contentsHTML + '</body>' + '</html>');\n      }\n    },\n\n    /**\r\n     * @description Set direction to \"rtl\" or \"ltr\".\r\n     * @param {String} dir \"rtl\" or \"ltr\"\r\n     */\n    setDir: function setDir(dir) {\n      var rtl = dir === 'rtl';\n      var changeDir = this._prevRtl !== rtl;\n      this._prevRtl = options.rtl = rtl;\n\n      if (changeDir) {\n        // align buttons\n        if (this.plugins.align) {\n          this.plugins.align.exchangeDir.call(this);\n        } // indent buttons\n\n\n        if (context.tool.indent) util.changeElement(context.tool.indent.firstElementChild, icons.indent);\n        if (context.tool.outdent) util.changeElement(context.tool.outdent.firstElementChild, icons.outdent);\n      }\n\n      var el = context.element;\n\n      if (rtl) {\n        util.addClass(el.topArea, 'se-rtl');\n        util.addClass(el.wysiwygFrame, 'se-rtl');\n      } else {\n        util.removeClass(el.topArea, 'se-rtl');\n        util.removeClass(el.wysiwygFrame, 'se-rtl');\n      }\n\n      var lineNodes = util.getListChildren(el.wysiwyg, function (current) {\n        return util.isFormatElement(current) && (current.style.marginRight || current.style.marginLeft || current.style.textAlign);\n      });\n\n      for (var i = 0, len = lineNodes.length, n, l, r; i < len; i++) {\n        n = lineNodes[i]; // indent margin\n\n        r = n.style.marginRight;\n        l = n.style.marginLeft;\n\n        if (r || l) {\n          n.style.marginRight = l;\n          n.style.marginLeft = r;\n        } // text align\n\n\n        r = n.style.textAlign;\n        if (r === 'left') n.style.textAlign = 'right';else if (r === 'right') n.style.textAlign = 'left';\n      }\n\n      var tool = context.tool;\n\n      if (tool.dir) {\n        util.changeTxt(tool.dir.querySelector('.se-tooltip-text'), lang.toolbar[options.rtl ? 'dir_ltr' : 'dir_rtl']);\n        util.changeElement(tool.dir.firstElementChild, icons[options.rtl ? 'dir_ltr' : 'dir_rtl']);\n      }\n\n      if (tool.dir_ltr) {\n        if (rtl) util.removeClass(tool.dir_ltr, 'active');else util.addClass(tool.dir_ltr, 'active');\n      }\n\n      if (tool.dir_rtl) {\n        if (rtl) util.addClass(tool.dir_rtl, 'active');else util.removeClass(tool.dir_rtl, 'active');\n      }\n    },\n\n    /**\r\n     * @description Sets the HTML string\r\n     * @param {String|undefined} html HTML string\r\n     */\n    setContents: function setContents(html) {\n      this.removeRange();\n      var convertValue = html === null || html === undefined ? '' : this.convertContentsForEditor(html);\n\n      this._resetComponents();\n\n      if (!this._variable.isCodeView) {\n        context.element.wysiwyg.innerHTML = convertValue; // history stack\n\n        this.history.push(false);\n      } else {\n        var value = this.convertHTMLForCodeView(convertValue, false);\n\n        this._setCodeView(value);\n      }\n    },\n\n    /**\r\n     * @description Sets the contents of the iframe's head tag and body tag when using the \"iframe\" or \"fullPage\" option.\r\n     * @param {Object} ctx { head: HTML string, body: HTML string}\r\n     */\n    setIframeContents: function setIframeContents(ctx) {\n      if (!options.iframe) return false;\n      if (ctx.head) this._wd.head.innerHTML = ctx.head.replace(/<script[\\s\\S]*>[\\s\\S]*<\\/script>/gi, '');\n      if (ctx.body) this._wd.body.innerHTML = this.convertContentsForEditor(ctx.body);\n    },\n\n    /**\r\n     * @description Gets the current contents\r\n     * @param {Boolean} onlyContents Return only the contents of the body without headers when the \"fullPage\" option is true\r\n     * @returns {Object}\r\n     */\n    getContents: function getContents(onlyContents) {\n      var contents = this.convertHTMLForCodeView(context.element.wysiwyg, true);\n      var renderHTML = util.createElement('DIV');\n      renderHTML.innerHTML = contents;\n      var figcaptions = util.getListChildren(renderHTML, function (current) {\n        return /FIGCAPTION/i.test(current.nodeName);\n      });\n\n      for (var i = 0, len = figcaptions.length; i < len; i++) {\n        figcaptions[i].removeAttribute('contenteditable');\n      }\n\n      if (options.fullPage && !onlyContents) {\n        var attrs = util.getAttributesToString(this._wd.body, ['contenteditable']);\n        return '<!DOCTYPE html><html>' + this._wd.head.outerHTML + '<body ' + attrs + '>' + renderHTML.innerHTML + '</body></html>';\n      } else {\n        return renderHTML.innerHTML;\n      }\n    },\n\n    /**\r\n     * @description Gets the current contents with containing parent div(div.sun-editor-editable).\r\n     * <div class=\"sun-editor-editable\">{contents}</div>\r\n     * @param {Boolean} onlyContents Return only the contents of the body without headers when the \"fullPage\" option is true\r\n     * @returns {String}\r\n     */\n    getFullContents: function getFullContents(onlyContents) {\n      return '<div class=\"sun-editor-editable' + (options.rtl ? ' se-rtl' : '') + '\">' + this.getContents(onlyContents) + '</div>';\n    },\n\n    /**\r\n     * @description Returns HTML string according to tag type and configuration.\r\n     * Use only \"cleanHTML\"\r\n     * @param {Node} node Node\r\n     * @param {Boolean} requireFormat If true, text nodes that do not have a format node is wrapped with the format tag.\r\n     * @private\r\n     */\n    _makeLine: function _makeLine(node, requireFormat) {\n      var defaultTag = options.defaultTag; // element\n\n      if (node.nodeType === 1) {\n        if (util._disallowedTags(node)) return '';\n\n        if (!requireFormat || util.isFormatElement(node) || util.isRangeFormatElement(node) || util.isComponent(node) || util.isMedia(node) || util.isAnchor(node) && util.isMedia(node.firstElementChild)) {\n          return node.outerHTML;\n        } else {\n          return '<' + defaultTag + '>' + node.outerHTML + '</' + defaultTag + '>';\n        }\n      } // text\n\n\n      if (node.nodeType === 3) {\n        if (!requireFormat) return util._HTMLConvertor(node.textContent);\n        var textArray = node.textContent.split(/\\n/g);\n        var html = '';\n\n        for (var i = 0, tLen = textArray.length, text; i < tLen; i++) {\n          text = textArray[i].trim();\n          if (text.length > 0) html += '<' + defaultTag + '>' + util._HTMLConvertor(text) + '</' + defaultTag + '>';\n        }\n\n        return html;\n      } // comments\n\n\n      if (node.nodeType === 8 && this._allowHTMLComments) {\n        return '<!--' + node.textContent.trim() + '-->';\n      }\n\n      return '';\n    },\n\n    /**\r\n     * @description Removes attribute values such as style and converts tags that do not conform to the \"html5\" standard.\r\n     * @param {String} text \r\n     * @returns {String} HTML string\r\n     * @private\r\n     */\n    _tagConvertor: function _tagConvertor(text) {\n      if (!this._disallowedTextTagsRegExp) return text;\n      var ec = options._textTagsMap;\n      return text.replace(this._disallowedTextTagsRegExp, function (m, t, n, p) {\n        return t + (typeof ec[n] === 'string' ? ec[n] : n) + (p ? ' ' + p : '');\n      });\n    },\n\n    /**\r\n     * @description Delete disallowed tags\r\n     * @param {String} html HTML string\r\n     * @returns {String}\r\n     * @private\r\n     */\n    _deleteDisallowedTags: function _deleteDisallowedTags(html) {\n      return html.replace(/\\n/g, '').replace(/<(script|style)[\\s\\S]*>[\\s\\S]*<\\/(script|style)>/gi, '').replace(/<[a-z0-9]+\\:[a-z0-9]+[^>^\\/]*>[^>]*<\\/[a-z0-9]+\\:[a-z0-9]+>/gi, '').replace(this.editorTagsWhitelistRegExp, '').replace(this.editorTagsBlacklistRegExp, '');\n    },\n\n    /**\r\n     * @description Tag and tag attribute check RegExp function. (used by \"cleanHTML\" and \"convertContentsForEditor\")\r\n     * @param {Boolean} lowLevelCheck Row level check\r\n     * @param {String} m RegExp value\r\n     * @param {String} t RegExp value\r\n     * @returns {String}\r\n     * @private\r\n     */\n    _cleanTags: function _cleanTags(lowLevelCheck, m, t) {\n      if (/^<[a-z0-9]+\\:[a-z0-9]+/i.test(m)) return m;\n      var v = null;\n      var tagName = t.match(/(?!<)[a-zA-Z0-9\\-]+/)[0].toLowerCase(); // blacklist\n\n      var bAttr = this._attributesTagsBlacklist[tagName];\n      if (bAttr) m = m.replace(bAttr, '');else m = m.replace(this._attributesBlacklistRegExp, ''); // whitelist\n\n      var wAttr = this._attributesTagsWhitelist[tagName];\n      if (wAttr) v = m.match(wAttr);else v = m.match(this._attributesWhitelistRegExp); // anchor\n\n      if (!lowLevelCheck || /<a\\b/i.test(t)) {\n        var sv = m.match(/(?:(?:id|name)\\s*=\\s*(?:\"|')[^\"']*(?:\"|'))/g);\n\n        if (sv) {\n          if (!v) v = [];\n          v.push(sv[0]);\n        }\n      } // span\n\n\n      if ((!lowLevelCheck || /<span/i.test(t)) && (!v || !/style=/i.test(v.toString()))) {\n        var _sv = m.match(/style\\s*=\\s*(?:\"|')[^\"']*(?:\"|')/);\n\n        if (_sv) {\n          if (!v) v = [];\n          v.push(_sv[0]);\n        }\n      } // img\n\n\n      if (/<img/i.test(t)) {\n        var w = '',\n            h = '';\n\n        var _sv2 = m.match(/style\\s*=\\s*(?:\"|')[^\"']*(?:\"|')/);\n\n        if (!v) v = [];\n\n        if (_sv2) {\n          w = _sv2[0].match(/width:(.+);/);\n          w = util.getNumber(w ? w[1] : '', -1) || '';\n          h = _sv2[0].match(/height:(.+);/);\n          h = util.getNumber(h ? h[1] : '', -1) || '';\n        }\n\n        if (!w || !h) {\n          var avw = m.match(/width\\s*=\\s*((?:\"|')[^\"']*(?:\"|'))/);\n          var avh = m.match(/height\\s*=\\s*((?:\"|')[^\"']*(?:\"|'))/);\n\n          if (avw || avh) {\n            w = !w ? util.getNumber(avw ? avw[1] : '') || '' : w;\n            h = !h ? util.getNumber(avh ? avh[1] : '') || '' : h;\n          }\n        }\n\n        v.push('data-origin=\"' + (w + ',' + h) + '\"');\n      }\n\n      if (v) {\n        for (var i = 0, len = v.length; i < len; i++) {\n          if (lowLevelCheck && /^class=\"(?!(__se__|se-|katex))/.test(v[i])) continue;\n          t += ' ' + (/^(?:href|src)\\s*=\\s*('|\"|\\s)*javascript\\s*\\:/i.test(v[i]) ? '' : v[i]);\n        }\n      }\n\n      return t;\n    },\n\n    /**\r\n     * @description Gets the clean HTML code for editor\r\n     * @param {String} html HTML string\r\n     * @param {String|RegExp|null} whitelist Regular expression of allowed tags.\r\n     * RegExp object is create by util.createTagsWhitelist method. (core.pasteTagsWhitelistRegExp)\r\n     * @param {String|RegExp|null} blacklist Regular expression of disallowed tags.\r\n     * RegExp object is create by util.createTagsBlacklist method. (core.pasteTagsBlacklistRegExp)\r\n     * @returns {String}\r\n     */\n    cleanHTML: function cleanHTML(html, whitelist, blacklist) {\n      html = this._deleteDisallowedTags(this._parser.parseFromString(html, 'text/html').body.innerHTML).replace(/(<[a-zA-Z0-9\\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, true));\n\n      var dom = _d.createRange().createContextualFragment(html);\n\n      try {\n        util._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, true);\n      } catch (error) {\n        console.warn('[SUNEDITOR.cleanHTML.consistencyCheck.fail] ' + error);\n      }\n\n      if (this.managedTagsInfo && this.managedTagsInfo.query) {\n        var textCompList = dom.querySelectorAll(this.managedTagsInfo.query);\n\n        for (var i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {\n          classList = [].slice.call(textCompList[i].classList);\n\n          for (var _c3 = 0, cLen = classList.length; _c3 < cLen; _c3++) {\n            initMethod = this.managedTagsInfo.map[classList[_c3]];\n\n            if (initMethod) {\n              initMethod(textCompList[i]);\n              break;\n            }\n          }\n        }\n      }\n\n      var domTree = dom.childNodes;\n      var cleanHTML = '';\n      var requireFormat = false;\n\n      for (var _i24 = 0, _len12 = domTree.length, t; _i24 < _len12; _i24++) {\n        t = domTree[_i24];\n\n        if (t.nodeType === 1 && !util.isTextStyleElement(t) && !util.isBreak(t) && !util._disallowedTags(t)) {\n          requireFormat = true;\n          break;\n        }\n      }\n\n      for (var _i25 = 0, _len13 = domTree.length; _i25 < _len13; _i25++) {\n        cleanHTML += this._makeLine(domTree[_i25], requireFormat);\n      }\n\n      cleanHTML = util.htmlRemoveWhiteSpace(cleanHTML);\n\n      if (!cleanHTML) {\n        cleanHTML = html;\n      } else {\n        if (whitelist) cleanHTML = cleanHTML.replace(typeof whitelist === 'string' ? util.createTagsWhitelist(whitelist) : whitelist, '');\n        if (blacklist) cleanHTML = cleanHTML.replace(typeof blacklist === 'string' ? util.createTagsBlacklist(blacklist) : blacklist, '');\n      }\n\n      return this._tagConvertor(cleanHTML);\n    },\n\n    /**\r\n     * @description Converts contents into a format that can be placed in an editor\r\n     * @param {String} contents contents\r\n     * @returns {String}\r\n     */\n    convertContentsForEditor: function convertContentsForEditor(contents) {\n      contents = this._deleteDisallowedTags(this._parser.parseFromString(contents, 'text/html').body.innerHTML).replace(/(<[a-zA-Z0-9\\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, false));\n\n      var dom = _d.createRange().createContextualFragment(contents);\n\n      try {\n        util._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, false);\n      } catch (error) {\n        console.warn('[SUNEDITOR.convertContentsForEditor.consistencyCheck.fail] ' + error);\n      }\n\n      if (this.managedTagsInfo && this.managedTagsInfo.query) {\n        var textCompList = dom.querySelectorAll(this.managedTagsInfo.query);\n\n        for (var i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {\n          classList = [].slice.call(textCompList[i].classList);\n\n          for (var _c4 = 0, cLen = classList.length; _c4 < cLen; _c4++) {\n            initMethod = this.managedTagsInfo.map[classList[_c4]];\n\n            if (initMethod) {\n              initMethod(textCompList[i]);\n              break;\n            }\n          }\n        }\n      }\n\n      var domTree = dom.childNodes;\n      var cleanHTML = '',\n          p = null;\n\n      for (var _i26 = 0, t; _i26 < domTree.length; _i26++) {\n        t = domTree[_i26];\n\n        if (!util.isFormatElement(t) && !util.isRangeFormatElement(t) && !util.isComponent(t) && !util.isMedia(t)) {\n          if (!p) p = util.createElement(options.defaultTag);\n          p.appendChild(t);\n          _i26--;\n\n          if (domTree[_i26 + 1] && !util.isFormatElement(domTree[_i26 + 1])) {\n            continue;\n          } else {\n            t = p;\n            p = null;\n          }\n        }\n\n        if (p) {\n          cleanHTML += this._makeLine(p, true);\n          p = null;\n        }\n\n        cleanHTML += this._makeLine(t, true);\n      }\n\n      if (p) cleanHTML += this._makeLine(p, true);\n      if (cleanHTML.length === 0) return '<' + options.defaultTag + '><br></' + options.defaultTag + '>';\n      cleanHTML = util.htmlRemoveWhiteSpace(cleanHTML);\n      return this._tagConvertor(cleanHTML);\n    },\n\n    /**\r\n     * @description Converts wysiwyg area element into a format that can be placed in an editor of code view mode\r\n     * @param {Element|String} html WYSIWYG element (context.element.wysiwyg) or HTML string.\r\n     * @param {Boolean} comp If true, does not line break and indentation of tags.\r\n     * @returns {String}\r\n     */\n    convertHTMLForCodeView: function convertHTMLForCodeView(html, comp) {\n      var returnHTML = '';\n      var wRegExp = _w.RegExp;\n      var brReg = new wRegExp('^(BLOCKQUOTE|PRE|TABLE|THEAD|TBODY|TR|TH|TD|OL|UL|IMG|IFRAME|VIDEO|AUDIO|FIGURE|FIGCAPTION|HR|BR|CANVAS|SELECT)$', 'i');\n      var wDoc = typeof html === 'string' ? _d.createRange().createContextualFragment(html) : html;\n\n      var isFormat = function (current) {\n        return this.isFormatElement(current) || this.isComponent(current);\n      }.bind(util);\n\n      var brChar = comp ? '' : '\\n';\n      var indentSize = comp ? 0 : this._variable.codeIndent * 1;\n      indentSize = indentSize > 0 ? new _w.Array(indentSize + 1).join(' ') : '';\n\n      (function recursionFunc(element, indent) {\n        var children = element.childNodes;\n        var elementRegTest = brReg.test(element.nodeName);\n        var elementIndent = elementRegTest ? indent : '';\n\n        for (var i = 0, len = children.length, node, br, lineBR, nodeRegTest, tag, tagIndent; i < len; i++) {\n          node = children[i];\n          nodeRegTest = brReg.test(node.nodeName);\n          br = nodeRegTest ? brChar : '';\n          lineBR = isFormat(node) && !elementRegTest && !/^(TH|TD)$/i.test(element.nodeName) ? brChar : '';\n\n          if (node.nodeType === 8) {\n            returnHTML += '\\n<!-- ' + node.textContent.trim() + ' -->' + br;\n            continue;\n          }\n\n          if (node.nodeType === 3) {\n            if (!util.isList(node.parentElement)) returnHTML += util._HTMLConvertor(/^\\n+$/.test(node.data) ? '' : node.data);\n            continue;\n          }\n\n          if (node.childNodes.length === 0) {\n            returnHTML += (/^HR$/i.test(node.nodeName) ? brChar : '') + (/^PRE$/i.test(node.parentElement.nodeName) && /^BR$/i.test(node.nodeName) ? '' : elementIndent) + node.outerHTML + br;\n            continue;\n          }\n\n          if (!node.outerHTML) {\n            // IE\n            returnHTML += new _w.XMLSerializer().serializeToString(node);\n          } else {\n            tag = node.nodeName.toLowerCase();\n            tagIndent = elementIndent || nodeRegTest ? indent : '';\n            returnHTML += (lineBR || (elementRegTest ? '' : br)) + tagIndent + node.outerHTML.match(wRegExp('<' + tag + '[^>]*>', 'i'))[0] + br;\n            recursionFunc(node, indent + indentSize, '');\n            returnHTML += (/\\n$/.test(returnHTML) ? tagIndent : '') + '</' + tag + '>' + (lineBR || br || elementRegTest ? brChar : '' || /^(TH|TD)$/i.test(node.nodeName) ? brChar : '');\n          }\n        }\n      })(wDoc, '');\n\n      return returnHTML.trim() + brChar;\n    },\n\n    /**\r\n     * @description Add an event to document.\r\n     * When created as an Iframe, the same event is added to the document in the Iframe.\r\n     * @param {String} type Event type\r\n     * @param {Function} listener Event listener\r\n     * @param {Boolean} useCapture Use event capture\r\n     */\n    addDocEvent: function addDocEvent(type, listener, useCapture) {\n      _d.addEventListener(type, listener, useCapture);\n\n      if (options.iframe) {\n        this._wd.addEventListener(type, listener);\n      }\n    },\n\n    /**\r\n     * @description Remove events from document.\r\n     * When created as an Iframe, the event of the document inside the Iframe is also removed.\r\n     * @param {String} type Event type\r\n     * @param {Function} listener Event listener\r\n     */\n    removeDocEvent: function removeDocEvent(type, listener) {\n      _d.removeEventListener(type, listener);\n\n      if (options.iframe) {\n        this._wd.removeEventListener(type, listener);\n      }\n    },\n\n    /**\r\n     * @description The current number of characters is counted and displayed.\r\n     * @param {String} inputText Text added.\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\n    _charCount: function _charCount(inputText) {\n      var maxCharCount = options.maxCharCount;\n      var countType = options.charCounterType;\n      var nextCharCount = 0;\n      if (!!inputText) nextCharCount = this.getCharLength(inputText, countType);\n\n      this._setCharCount();\n\n      if (maxCharCount > 0) {\n        var over = false;\n        var count = functions.getCharCount(countType);\n\n        if (count > maxCharCount) {\n          over = true;\n\n          if (nextCharCount > 0) {\n            this._editorRange();\n\n            var range = this.getRange();\n            var endOff = range.endOffset - 1;\n            var text = this.getSelectionNode().textContent;\n            var slicePosition = range.endOffset - (count - maxCharCount);\n            this.getSelectionNode().textContent = text.slice(0, slicePosition < 0 ? 0 : slicePosition) + text.slice(range.endOffset, text.length);\n            this.setRange(range.endContainer, endOff, range.endContainer, endOff);\n          }\n        } else if (count + nextCharCount > maxCharCount) {\n          over = true;\n        }\n\n        if (over) {\n          this._callCounterBlink();\n\n          if (nextCharCount > 0) return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\r\n     * @description When \"element\" is added, if it is greater than \"options.maxCharCount\", false is returned.\r\n     * @param {Node|String} element Element node or String.\r\n     * @param {String|null} charCounterType charCounterType. If it is null, the options.charCounterType\r\n     * @returns {Boolean}\r\n     */\n    checkCharCount: function checkCharCount(element, charCounterType) {\n      if (options.maxCharCount) {\n        var countType = charCounterType || options.charCounterType;\n        var length = this.getCharLength(typeof element === 'string' ? element : this._charTypeHTML && element.nodeType === 1 ? element.outerHTML : element.textContent, countType);\n\n        if (length > 0 && length + functions.getCharCount(countType) > options.maxCharCount) {\n          this._callCounterBlink();\n\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\r\n     * @description Get the length of the content.\r\n     * Depending on the option, the length of the character is taken. (charCounterType)\r\n     * @param {String} content Content to count\r\n     * @param {String} charCounterType options.charCounterType\r\n     * @returns {Number}\r\n     */\n    getCharLength: function getCharLength(content, charCounterType) {\n      return /byte/.test(charCounterType) ? util.getByteLength(content) : content.length;\n    },\n\n    /**\r\n     * @description Reset buttons of the responsive toolbar.\r\n     */\n    resetResponsiveToolbar: function resetResponsiveToolbar() {\n      core.controllersOff();\n      var responsiveSize = event._responsiveButtonSize;\n\n      if (responsiveSize) {\n        var w = 0;\n\n        if ((core._isBalloon || core._isInline) && options.toolbarWidth === 'auto') {\n          w = context.element.topArea.offsetWidth;\n        } else {\n          w = context.element.toolbar.offsetWidth;\n        }\n\n        var responsiveWidth = 'default';\n\n        for (var i = 1, len = responsiveSize.length; i < len; i++) {\n          if (w < responsiveSize[i]) {\n            responsiveWidth = responsiveSize[i] + '';\n            break;\n          }\n        }\n\n        if (event._responsiveCurrentSize !== responsiveWidth) {\n          event._responsiveCurrentSize = responsiveWidth;\n          functions.setToolbarButtons(event._responsiveButtons[responsiveWidth]);\n        }\n      }\n    },\n\n    /**\r\n     * @description Set the char count to charCounter element textContent.\r\n     * @private\r\n     */\n    _setCharCount: function _setCharCount() {\n      if (context.element.charCounter) {\n        _w.setTimeout(function () {\n          context.element.charCounter.textContent = functions.getCharCount(options.charCounterType);\n        });\n      }\n    },\n\n    /**\r\n     * @description The character counter blinks.\r\n     * @private\r\n     */\n    _callCounterBlink: function _callCounterBlink() {\n      var charWrapper = context.element.charWrapper;\n\n      if (charWrapper && !util.hasClass(charWrapper, 'se-blink')) {\n        util.addClass(charWrapper, 'se-blink');\n\n        _w.setTimeout(function () {\n          util.removeClass(charWrapper, 'se-blink');\n        }, 600);\n      }\n    },\n\n    /**\r\n     * @description Check the components such as image and video and modify them according to the format.\r\n     * @private\r\n     */\n    _checkComponents: function _checkComponents() {\n      for (var i = 0, len = this._fileInfoPluginsCheck.length; i < len; i++) {\n        this._fileInfoPluginsCheck[i]();\n      }\n    },\n\n    /**\r\n     * @description Initialize the information of the components.\r\n     * @private\r\n     */\n    _resetComponents: function _resetComponents() {\n      for (var i = 0, len = this._fileInfoPluginsReset.length; i < len; i++) {\n        this._fileInfoPluginsReset[i]();\n      }\n    },\n\n    /**\r\n     * @description Set method in the code view area\r\n     * @param {String} value HTML string\r\n     * @private\r\n     */\n    _setCodeView: function _setCodeView(value) {\n      if (options.codeMirrorEditor) {\n        options.codeMirrorEditor.getDoc().setValue(value);\n      } else {\n        context.element.code.value = value;\n      }\n    },\n\n    /**\r\n     * @description Get method in the code view area\r\n     * @private\r\n     */\n    _getCodeView: function _getCodeView() {\n      return options.codeMirrorEditor ? options.codeMirrorEditor.getDoc().getValue() : context.element.code.value;\n    },\n\n    /**\r\n     * @description remove class, display text.\r\n     * @param {Array|null} ignoredList Igonred button list\r\n     */\n    _setKeyEffect: function _setKeyEffect(ignoredList) {\n      var commandMap = this.commandMap;\n      var activePlugins = this.activePlugins;\n\n      for (var key in commandMap) {\n        if (ignoredList.indexOf(key) > -1 || !util.hasOwn(commandMap, key)) continue;\n\n        if (activePlugins.indexOf(key) > -1) {\n          plugins[key].active.call(this, null);\n        } else if (commandMap.OUTDENT && /^OUTDENT$/i.test(key)) {\n          if (!util.isImportantDisabled(commandMap.OUTDENT)) commandMap.OUTDENT.setAttribute('disabled', true);\n        } else if (commandMap.INDENT && /^INDENT$/i.test(key)) {\n          if (!util.isImportantDisabled(commandMap.INDENT)) commandMap.INDENT.removeAttribute('disabled');\n        } else {\n          util.removeClass(commandMap[key], 'active');\n        }\n      }\n    },\n\n    /**\r\n     * @description Initializ core variable\r\n     * @param {Boolean} reload Is relooad?\r\n     * @param {String} _initHTML initial html string\r\n     * @private\r\n     */\n    _init: function _init(reload, _initHTML) {\n      var wRegExp = _w.RegExp;\n      this._ww = options.iframe ? context.element.wysiwygFrame.contentWindow : _w;\n      this._wd = _d;\n      this._charTypeHTML = options.charCounterType === 'byte-html';\n      this.wwComputedStyle = _w.getComputedStyle(context.element.wysiwyg);\n      this._editorHeight = context.element.wysiwygFrame.offsetHeight;\n\n      if (!options.iframe && typeof _w.ShadowRoot === 'function') {\n        var child = context.element.wysiwygFrame;\n\n        while (child) {\n          if (child.shadowRoot) {\n            this._shadowRoot = child.shadowRoot;\n            break;\n          } else if (child instanceof _w.ShadowRoot) {\n            this._shadowRoot = child;\n            break;\n          }\n\n          child = child.parentNode;\n        }\n\n        if (this._shadowRoot) this._shadowRootControllerEventTarget = [];\n      } // set disallow text nodes\n\n\n      var disallowTextTags = _w.Object.keys(options._textTagsMap);\n\n      var allowTextTags = !options.addTagsWhitelist ? [] : options.addTagsWhitelist.split('|').filter(function (v) {\n        return /b|i|ins|s|strike/i.test(v);\n      });\n\n      for (var i = 0; i < allowTextTags.length; i++) {\n        disallowTextTags.splice(disallowTextTags.indexOf(allowTextTags[i].toLowerCase()), 1);\n      }\n\n      this._disallowedTextTagsRegExp = disallowTextTags.length === 0 ? null : new wRegExp('(<\\\\/?)(' + disallowTextTags.join('|') + ')\\\\b\\\\s*([^>^<]+)?\\\\s*(?=>)', 'gi'); // set whitelist\n\n      var getRegList = function getRegList(str, str2) {\n        return !str ? '^' : str === '*' ? '[a-z-]+' : !str2 ? str : str + '|' + str2;\n      }; // tags\n\n\n      var defaultAttr = 'contenteditable|colspan|rowspan|target|href|download|rel|src|alt|class|type|controls|data-format|data-size|data-file-size|data-file-name|data-origin|data-align|data-image-link|data-rotate|data-proportion|data-percentage|origin-size|data-exp|data-font-size';\n      this._allowHTMLComments = options._editorTagsWhitelist.indexOf('//') > -1 || options._editorTagsWhitelist === '*'; // html check\n\n      this._htmlCheckWhitelistRegExp = new wRegExp('^(' + getRegList(options._editorTagsWhitelist.replace('|//', ''), '') + ')$', 'i');\n      this._htmlCheckBlacklistRegExp = new wRegExp('^(' + (options.tagsBlacklist || '^') + ')$', 'i'); // tags\n\n      this.editorTagsWhitelistRegExp = util.createTagsWhitelist(getRegList(options._editorTagsWhitelist.replace('|//', '|<!--|-->'), ''));\n      this.editorTagsBlacklistRegExp = util.createTagsBlacklist(options.tagsBlacklist.replace('|//', '|<!--|-->')); // paste tags\n\n      this.pasteTagsWhitelistRegExp = util.createTagsWhitelist(getRegList(options.pasteTagsWhitelist, ''));\n      this.pasteTagsBlacklistRegExp = util.createTagsBlacklist(options.pasteTagsBlacklist); // attributes\n\n      var regEndStr = '\\\\s*=\\\\s*(\\\")[^\\\"]*\\\\1';\n      var _wAttr = options.attributesWhitelist;\n      var tagsAttr = {};\n      var allAttr = '';\n\n      if (!!_wAttr) {\n        for (var k in _wAttr) {\n          if (!util.hasOwn(_wAttr, k) || /^on[a-z]+$/i.test(_wAttr[k])) continue;\n\n          if (k === 'all') {\n            allAttr = getRegList(_wAttr[k], defaultAttr);\n          } else {\n            tagsAttr[k] = new wRegExp('\\\\s(?:' + getRegList(_wAttr[k], '') + ')' + regEndStr, 'ig');\n          }\n        }\n      }\n\n      this._attributesWhitelistRegExp = new wRegExp('\\\\s(?:' + (allAttr || defaultAttr) + ')' + regEndStr, 'ig');\n      this._attributesTagsWhitelist = tagsAttr; // blacklist\n\n      var _bAttr = options.attributesBlacklist;\n      tagsAttr = {};\n      allAttr = '';\n\n      if (!!_bAttr) {\n        for (var _k in _bAttr) {\n          if (!util.hasOwn(_bAttr, _k)) continue;\n\n          if (_k === 'all') {\n            allAttr = getRegList(_bAttr[_k], '');\n          } else {\n            tagsAttr[_k] = new wRegExp('\\\\s(?:' + getRegList(_bAttr[_k], '') + ')' + regEndStr, 'ig');\n          }\n        }\n      }\n\n      this._attributesBlacklistRegExp = new wRegExp('\\\\s(?:' + (allAttr || '^') + ')' + regEndStr, 'ig');\n      this._attributesTagsBlacklist = tagsAttr; // set modes\n\n      this._isInline = /inline/i.test(options.mode);\n      this._isBalloon = /balloon|balloon-always/i.test(options.mode);\n      this._isBalloonAlways = /balloon-always/i.test(options.mode); // caching buttons\n\n      this._cachingButtons(); // file components\n\n\n      this._fileInfoPluginsCheck = [];\n      this._fileInfoPluginsReset = []; // text components\n\n      this.managedTagsInfo = {\n        query: '',\n        map: {}\n      };\n      var managedClass = []; // Command and file plugins registration\n\n      this.activePlugins = [];\n      this._fileManager.tags = [];\n      this._fileManager.pluginMap = {};\n      var filePluginRegExp = [];\n      var plugin, button;\n\n      for (var key in plugins) {\n        if (!util.hasOwn(plugins, key)) continue;\n        plugin = plugins[key];\n        button = pluginCallButtons[key];\n\n        if ((plugin.active || plugin.action) && button) {\n          this.callPlugin(key, null, button);\n        }\n\n        if (typeof plugin.checkFileInfo === 'function' && typeof plugin.resetFileInfo === 'function') {\n          this.callPlugin(key, null, button);\n\n          this._fileInfoPluginsCheck.push(plugin.checkFileInfo.bind(this));\n\n          this._fileInfoPluginsReset.push(plugin.resetFileInfo.bind(this));\n        }\n\n        if (_w.Array.isArray(plugin.fileTags)) {\n          var fileTags = plugin.fileTags;\n          this.callPlugin(key, null, button);\n          this._fileManager.tags = this._fileManager.tags.concat(fileTags);\n          filePluginRegExp.push(key);\n\n          for (var tag = 0, tLen = fileTags.length; tag < tLen; tag++) {\n            this._fileManager.pluginMap[fileTags[tag].toLowerCase()] = key;\n          }\n        }\n\n        if (plugin.managedTags) {\n          var info = plugin.managedTags();\n          managedClass.push('.' + info.className);\n          this.managedTagsInfo.map[info.className] = info.method.bind(this);\n        }\n      }\n\n      this.managedTagsInfo.query = managedClass.toString();\n      this._fileManager.queryString = this._fileManager.tags.join(',');\n      this._fileManager.regExp = new wRegExp('^(' + (this._fileManager.tags.join('|') || '^') + ')$', 'i');\n      this._fileManager.pluginRegExp = new wRegExp('^(' + (filePluginRegExp.length === 0 ? '^' : filePluginRegExp.join('|')) + ')$', 'i'); // cache editor's element\n\n      this._variable._originCssText = context.element.topArea.style.cssText;\n      this._placeholder = context.element.placeholder;\n      this._lineBreaker = context.element.lineBreaker;\n      this._lineBreakerButton = this._lineBreaker.querySelector('button'); // Excute history function\n\n      this.history = _history(this, this._onChange_historyStack.bind(this)); // register notice module\n\n      this.addModule([_notice]); // Init, validate\n\n      if (options.iframe) {\n        this._wd = context.element.wysiwygFrame.contentDocument;\n        context.element.wysiwyg = this._wd.body;\n        if (options._editorStyles.editor) context.element.wysiwyg.style.cssText = options._editorStyles.editor;\n        if (options.height === 'auto') this._iframeAuto = this._wd.body;\n      }\n\n      this._initWysiwygArea(reload, _initHTML);\n\n      this.setDir(options.rtl ? 'rtl' : 'ltr');\n    },\n\n    /**\r\n     * @description Caching basic buttons to use\r\n     * @private\r\n     */\n    _cachingButtons: function _cachingButtons() {\n      this.codeViewDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~=\"se-code-view-enabled\"]):not([data-display=\"MORE\"])');\n      this.resizingDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~=\"se-resizing-enabled\"]):not([data-display=\"MORE\"])');\n\n      this._saveButtonStates();\n\n      var tool = context.tool;\n      this.commandMap = {\n        OUTDENT: tool.outdent,\n        INDENT: tool.indent\n      };\n      this.commandMap[options.textTags.bold.toUpperCase()] = tool.bold;\n      this.commandMap[options.textTags.underline.toUpperCase()] = tool.underline;\n      this.commandMap[options.textTags.italic.toUpperCase()] = tool.italic;\n      this.commandMap[options.textTags.strike.toUpperCase()] = tool.strike;\n      this.commandMap[options.textTags.sub.toUpperCase()] = tool.subscript;\n      this.commandMap[options.textTags.sup.toUpperCase()] = tool.superscript;\n      this._styleCommandMap = {\n        fullScreen: tool.fullScreen,\n        showBlocks: tool.showBlocks,\n        codeView: tool.codeView\n      };\n    },\n\n    /**\r\n     * @description Initializ wysiwyg area (Only called from core._init)\r\n     * @param {Boolean} reload Is relooad?\r\n     * @param {String} _initHTML initial html string\r\n     * @private\r\n     */\n    _initWysiwygArea: function _initWysiwygArea(reload, _initHTML) {\n      context.element.wysiwyg.innerHTML = reload ? _initHTML : this.convertContentsForEditor(typeof _initHTML === 'string' ? _initHTML : context.element.originElement.value);\n    },\n\n    /**\r\n     * @description Called when there are changes to tags in the wysiwyg region.\r\n     * @private\r\n     */\n    _resourcesStateChange: function _resourcesStateChange() {\n      this._iframeAutoHeight();\n\n      this._checkPlaceholder();\n    },\n\n    /**\r\n     * @description Called when after execute \"history.push\"\r\n     * @private\r\n     */\n    _onChange_historyStack: function _onChange_historyStack() {\n      if (this.hasFocus) event._applyTagEffects();\n      this._variable.isChanged = true;\n      if (context.tool.save) context.tool.save.removeAttribute('disabled'); // user event\n\n      if (functions.onChange) functions.onChange(this.getContents(true), this);\n      if (context.element.toolbar.style.display === 'block') event._showToolbarBalloon();\n    },\n\n    /**\r\n     * @description Modify the height value of the iframe when the height of the iframe is automatic.\r\n     * @private\r\n     */\n    _iframeAutoHeight: function _iframeAutoHeight() {\n      if (this._iframeAuto) {\n        _w.setTimeout(function () {\n          var h = core._iframeAuto.offsetHeight;\n          context.element.wysiwygFrame.style.height = h + 'px';\n          if (util.isIE) core.__callResizeFunction(h, null);\n        });\n      } else if (util.isIE) {\n        core.__callResizeFunction(context.element.wysiwygFrame.offsetHeight, null);\n      }\n    },\n    __callResizeFunction: function __callResizeFunction(h, resizeObserverEntry) {\n      h = h === -1 ? resizeObserverEntry.borderBoxSize[0].blockSize : h;\n\n      if (this._editorHeight !== h) {\n        if (typeof functions.onResizeEditor === 'function') functions.onResizeEditor(h, this._editorHeight, core, resizeObserverEntry);\n        this._editorHeight = h;\n      }\n    },\n\n    /**\r\n     * @description Set display property when there is placeholder.\r\n     * @private\r\n     */\n    _checkPlaceholder: function _checkPlaceholder() {\n      if (this._placeholder) {\n        if (this._variable.isCodeView) {\n          this._placeholder.style.display = 'none';\n          return;\n        }\n\n        var wysiwyg = context.element.wysiwyg;\n\n        if (!util.onlyZeroWidthSpace(wysiwyg.textContent) || wysiwyg.querySelector(util._allowedEmptyNodeList) || (wysiwyg.innerText.match(/\\n/g) || '').length > 1) {\n          this._placeholder.style.display = 'none';\n        } else {\n          this._placeholder.style.display = 'block';\n        }\n      }\n    },\n\n    /**\r\n     * @description If there is no default format, add a format and move \"selection\".\r\n     * @param {String|null} formatName Format tag name (default: 'P')\r\n     * @returns {undefined|null}\r\n     * @private\r\n     */\n    _setDefaultFormat: function _setDefaultFormat(formatName) {\n      if (this._fileManager.pluginRegExp.test(this.currentControllerName)) return;\n      var range = this.getRange();\n      var commonCon = range.commonAncestorContainer;\n      var startCon = range.startContainer;\n      var rangeEl = util.getRangeFormatElement(commonCon, null);\n      var focusNode, offset, format;\n      var fileComponent = util.getParentElement(commonCon, util.isComponent);\n\n      if (fileComponent && !util.isTable(fileComponent)) {\n        return;\n      } else if (commonCon.nodeType === 1 && commonCon.getAttribute('data-se-embed') === 'true') {\n        var el = commonCon.nextElementSibling;\n        if (!util.isFormatElement(el)) el = this.appendFormatTag(commonCon, options.defaultTag);\n        this.setRange(el.firstChild, 0, el.firstChild, 0);\n        return;\n      }\n\n      if ((util.isRangeFormatElement(startCon) || util.isWysiwygDiv(startCon)) && (util.isComponent(startCon.children[range.startOffset]) || util.isComponent(startCon.children[range.startOffset - 1]))) return;\n      if (util.getParentElement(commonCon, util.isNotCheckingNode)) return null;\n\n      if (rangeEl) {\n        format = util.createElement(formatName || options.defaultTag);\n        format.innerHTML = rangeEl.innerHTML;\n        if (format.childNodes.length === 0) format.innerHTML = util.zeroWidthSpace;\n        rangeEl.innerHTML = format.outerHTML;\n        format = rangeEl.firstChild;\n        focusNode = util.getEdgeChildNodes(format, null).sc;\n\n        if (!focusNode) {\n          focusNode = util.createTextNode(util.zeroWidthSpace);\n          format.insertBefore(focusNode, format.firstChild);\n        }\n\n        offset = focusNode.textContent.length;\n        this.setRange(focusNode, offset, focusNode, offset);\n        return;\n      }\n\n      if (util.isRangeFormatElement(commonCon) && commonCon.childNodes.length <= 1) {\n        var br = null;\n\n        if (commonCon.childNodes.length === 1 && util.isBreak(commonCon.firstChild)) {\n          br = commonCon.firstChild;\n        } else {\n          br = util.createTextNode(util.zeroWidthSpace);\n          commonCon.appendChild(br);\n        }\n\n        this.setRange(br, 1, br, 1);\n        return;\n      }\n\n      this.execCommand('formatBlock', false, formatName || options.defaultTag);\n      focusNode = util.getEdgeChildNodes(commonCon, commonCon);\n      focusNode = focusNode ? focusNode.ec : commonCon;\n      format = util.getFormatElement(focusNode, null);\n\n      if (!format) {\n        this.removeRange();\n\n        this._editorRange();\n\n        return;\n      }\n\n      if (util.isBreak(format.nextSibling)) util.removeItem(format.nextSibling);\n      if (util.isBreak(format.previousSibling)) util.removeItem(format.previousSibling);\n\n      if (util.isBreak(focusNode)) {\n        var zeroWidth = util.createTextNode(util.zeroWidthSpace);\n        focusNode.parentNode.insertBefore(zeroWidth, focusNode);\n        focusNode = zeroWidth;\n      }\n\n      this.effectNode = null;\n      this.nativeFocus();\n    },\n\n    /**\r\n     * @description Initialization after \"setOptions\"\r\n     * @param {Object} el context.element\r\n     * @param {String} _initHTML Initial html string\r\n     * @private\r\n     */\n    _setOptionsInit: function _setOptionsInit(el, _initHTML) {\n      this.context = context = _Context(el.originElement, this._getConstructed(el), options);\n      this._componentsInfoReset = true;\n\n      this._editorInit(true, _initHTML);\n    },\n\n    /**\r\n     * @description Initializ editor\r\n     * @param {Boolean} reload Is relooad?\r\n     * @param {String} _initHTML initial html string\r\n     * @private\r\n     */\n    _editorInit: function _editorInit(reload, _initHTML) {\n      // initialize core and add event listeners\n      this._init(reload, _initHTML);\n\n      event._addEvent();\n\n      this._setCharCount();\n\n      event._offStickyToolbar();\n\n      event.onResize_window(); // toolbar visibility\n\n      context.element.toolbar.style.visibility = '';\n\n      this._checkComponents();\n\n      this._componentsInfoInit = false;\n      this._componentsInfoReset = false;\n      this.history.reset(true);\n\n      this._resourcesStateChange();\n\n      _w.setTimeout(function () {\n        // observer\n        if (event._resizeObserver) event._resizeObserver.observe(context.element.wysiwygFrame);\n        if (event._toolbarObserver) event._toolbarObserver.observe(context.element._toolbarShadow); // user event\n\n        if (typeof functions.onload === 'function') functions.onload(core, reload);\n      });\n    },\n\n    /**\r\n     * @description Create and return an object to cache the new context.\r\n     * @param {Element} contextEl context.element\r\n     * @returns {Object}\r\n     * @private\r\n     */\n    _getConstructed: function _getConstructed(contextEl) {\n      return {\n        _top: contextEl.topArea,\n        _relative: contextEl.relative,\n        _toolBar: contextEl.toolbar,\n        _toolbarShadow: contextEl._toolbarShadow,\n        _menuTray: contextEl._menuTray,\n        _editorArea: contextEl.editorArea,\n        _wysiwygArea: contextEl.wysiwygFrame,\n        _codeArea: contextEl.code,\n        _placeholder: contextEl.placeholder,\n        _resizingBar: contextEl.resizingBar,\n        _navigation: contextEl.navigation,\n        _charCounter: contextEl.charCounter,\n        _charWrapper: contextEl.charWrapper,\n        _loading: contextEl.loading,\n        _lineBreaker: contextEl.lineBreaker,\n        _lineBreaker_t: contextEl.lineBreaker_t,\n        _lineBreaker_b: contextEl.lineBreaker_b,\n        _resizeBack: contextEl.resizeBackground,\n        _stickyDummy: contextEl._stickyDummy,\n        _arrow: contextEl._arrow\n      };\n    }\n  };\n  /**\r\n   * @description event function\r\n   */\n\n  var event = {\n    _IEisComposing: false,\n    // In IE, there is no \"e.isComposing\" in the key-up event.\n    _lineBreakerBind: null,\n    _responsiveCurrentSize: 'default',\n    _responsiveButtonSize: null,\n    _responsiveButtons: null,\n    _directionKeyCode: new _w.RegExp('^(8|13|3[2-9]|40|46)$'),\n    _nonTextKeyCode: new _w.RegExp('^(8|13|1[6-9]|20|27|3[3-9]|40|45|46|11[2-9]|12[0-3]|144|145)$'),\n    _historyIgnoreKeyCode: new _w.RegExp('^(1[6-9]|20|27|3[3-9]|40|45|11[2-9]|12[0-3]|144|145)$'),\n    _onButtonsCheck: new _w.RegExp('^(' + _w.Object.keys(options._textTagsMap).join('|') + ')$', 'i'),\n    _frontZeroWidthReg: new _w.RegExp(util.zeroWidthSpace + '+', ''),\n    _keyCodeShortcut: {\n      65: 'A',\n      66: 'B',\n      83: 'S',\n      85: 'U',\n      73: 'I',\n      89: 'Y',\n      90: 'Z',\n      219: '[',\n      221: ']'\n    },\n    _shortcutCommand: function _shortcutCommand(keyCode, shift) {\n      var command = null;\n      var keyStr = event._keyCodeShortcut[keyCode];\n\n      switch (keyStr) {\n        case 'A':\n          command = 'selectAll';\n          break;\n\n        case 'B':\n          if (options.shortcutsDisable.indexOf('bold') === -1) {\n            command = 'bold';\n          }\n\n          break;\n\n        case 'S':\n          if (shift && options.shortcutsDisable.indexOf('strike') === -1) {\n            command = 'strike';\n          } else if (!shift && options.shortcutsDisable.indexOf('save') === -1) {\n            command = 'save';\n          }\n\n          break;\n\n        case 'U':\n          if (options.shortcutsDisable.indexOf('underline') === -1) {\n            command = 'underline';\n          }\n\n          break;\n\n        case 'I':\n          if (options.shortcutsDisable.indexOf('italic') === -1) {\n            command = 'italic';\n          }\n\n          break;\n\n        case 'Z':\n          if (options.shortcutsDisable.indexOf('undo') === -1) {\n            if (shift) {\n              command = 'redo';\n            } else {\n              command = 'undo';\n            }\n          }\n\n          break;\n\n        case 'Y':\n          if (options.shortcutsDisable.indexOf('undo') === -1) {\n            command = 'redo';\n          }\n\n          break;\n\n        case '[':\n          if (options.shortcutsDisable.indexOf('indent') === -1) {\n            command = options.rtl ? 'indent' : 'outdent';\n          }\n\n          break;\n\n        case ']':\n          if (options.shortcutsDisable.indexOf('indent') === -1) {\n            command = options.rtl ? 'outdent' : 'indent';\n          }\n\n          break;\n      }\n\n      if (!command) return !!keyStr;\n      core.commandHandler(core.commandMap[command], command);\n      return true;\n    },\n    _applyTagEffects: function _applyTagEffects() {\n      var selectionNode = core.getSelectionNode();\n      if (selectionNode === core.effectNode) return;\n      core.effectNode = selectionNode;\n      var marginDir = options.rtl ? 'marginRight' : 'marginLeft';\n      var commandMap = core.commandMap;\n      var classOnCheck = event._onButtonsCheck;\n      var commandMapNodes = [];\n      var currentNodes = [];\n      var activePlugins = core.activePlugins;\n      var cLen = activePlugins.length;\n      var nodeName = '';\n\n      while (selectionNode.firstChild) {\n        selectionNode = selectionNode.firstChild;\n      }\n\n      for (var element = selectionNode; !util.isWysiwygDiv(element); element = element.parentNode) {\n        if (!element) break;\n        if (element.nodeType !== 1 || util.isBreak(element)) continue;\n        nodeName = element.nodeName.toUpperCase();\n        currentNodes.push(nodeName);\n        /* Active plugins */\n\n        if (!core.isReadOnly) {\n          for (var _c5 = 0, name; _c5 < cLen; _c5++) {\n            name = activePlugins[_c5];\n\n            if (commandMapNodes.indexOf(name) === -1 && plugins[name].active.call(core, element)) {\n              commandMapNodes.push(name);\n            }\n          }\n        }\n\n        if (util.isFormatElement(element)) {\n          /* Outdent */\n          if (commandMapNodes.indexOf('OUTDENT') === -1 && commandMap.OUTDENT && !util.isImportantDisabled(commandMap.OUTDENT)) {\n            if (util.isListCell(element) || element.style[marginDir] && util.getNumber(element.style[marginDir], 0) > 0) {\n              commandMapNodes.push('OUTDENT');\n              commandMap.OUTDENT.removeAttribute('disabled');\n            }\n          }\n          /* Indent */\n\n\n          if (commandMapNodes.indexOf('INDENT') === -1 && commandMap.INDENT && !util.isImportantDisabled(commandMap.INDENT)) {\n            commandMapNodes.push('INDENT');\n\n            if (util.isListCell(element) && !element.previousElementSibling) {\n              commandMap.INDENT.setAttribute('disabled', true);\n            } else {\n              commandMap.INDENT.removeAttribute('disabled');\n            }\n          }\n\n          continue;\n        }\n        /** default active buttons [strong, ins, em, del, sub, sup] */\n\n\n        if (classOnCheck && classOnCheck.test(nodeName)) {\n          commandMapNodes.push(nodeName);\n          util.addClass(commandMap[nodeName], 'active');\n        }\n      }\n\n      core._setKeyEffect(commandMapNodes);\n      /** save current nodes */\n\n\n      core._variable.currentNodes = currentNodes.reverse();\n      core._variable.currentNodesMap = commandMapNodes;\n      /**  Displays the current node structure to resizingBar */\n\n      if (options.showPathLabel) context.element.navigation.textContent = core._variable.currentNodes.join(' > ');\n    },\n    _cancelCaptionEdit: function _cancelCaptionEdit() {\n      this.setAttribute('contenteditable', false);\n      this.removeEventListener('blur', event._cancelCaptionEdit);\n    },\n    _buttonsEventHandler: function _buttonsEventHandler(e) {\n      var target = e.target;\n      if (core._bindControllersOff) e.stopPropagation();\n\n      if (/^(input|textarea|select|option)$/i.test(target.nodeName)) {\n        core._antiBlur = false;\n      } else {\n        e.preventDefault();\n      }\n\n      if (util.getParentElement(target, '.se-submenu')) {\n        e.stopPropagation();\n        core._notHideToolbar = true;\n      } else {\n        var command = target.getAttribute('data-command');\n        var className = target.className;\n\n        while (!command && !/se-menu-list/.test(className) && !/sun-editor-common/.test(className)) {\n          target = target.parentNode;\n          command = target.getAttribute('data-command');\n          className = target.className;\n        }\n\n        if (command === core._submenuName || command === core._containerName) {\n          e.stopPropagation();\n        }\n      }\n    },\n    onClick_toolbar: function onClick_toolbar(e) {\n      var target = e.target;\n      var display = target.getAttribute('data-display');\n      var command = target.getAttribute('data-command');\n      var className = target.className;\n      core.controllersOff();\n\n      while (target.parentNode && !command && !/se-menu-list/.test(className) && !/se-toolbar/.test(className)) {\n        target = target.parentNode;\n        command = target.getAttribute('data-command');\n        display = target.getAttribute('data-display');\n        className = target.className;\n      }\n\n      if (!command && !display) return;\n      if (target.disabled) return;\n      if (!core.isReadOnly && !core.hasFocus) core.nativeFocus();\n      if (!core.isReadOnly && !core._variable.isCodeView) core._editorRange();\n      core.actionCall(command, display, target);\n    },\n    onMouseDown_wysiwyg: function onMouseDown_wysiwyg(e) {\n      if (core.isReadOnly || util.isNonEditable(context.element.wysiwyg)) return;\n\n      core._editorRange(); // user event\n\n\n      if (typeof functions.onMouseDown === 'function' && functions.onMouseDown(e, core) === false) return;\n      var tableCell = util.getParentElement(e.target, util.isCell);\n\n      if (tableCell) {\n        var tablePlugin = core.plugins.table;\n\n        if (tablePlugin && tableCell !== tablePlugin._fixedCell && !tablePlugin._shift) {\n          core.callPlugin('table', function () {\n            tablePlugin.onTableCellMultiSelect.call(core, tableCell, false);\n          }, null);\n        }\n      }\n\n      if (core._isBalloon) {\n        event._hideToolbar();\n      }\n\n      if (/FIGURE/i.test(e.target.nodeName)) e.preventDefault();\n    },\n    onClick_wysiwyg: function onClick_wysiwyg(e) {\n      var targetElement = e.target;\n\n      if (core.isReadOnly) {\n        e.preventDefault();\n\n        if (util.isAnchor(targetElement)) {\n          _w.open(targetElement.href, targetElement.target);\n        }\n\n        return false;\n      }\n\n      if (util.isNonEditable(context.element.wysiwyg)) return; // user event\n\n      if (typeof functions.onClick === 'function' && functions.onClick(e, core) === false) return;\n      var fileComponentInfo = core.getFileComponent(targetElement);\n\n      if (fileComponentInfo) {\n        e.preventDefault();\n        core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);\n        return;\n      }\n\n      var figcaption = util.getParentElement(targetElement, 'FIGCAPTION');\n\n      if (figcaption && (util.isNonEditable(figcaption) || !figcaption.getAttribute(\"contenteditable\"))) {\n        e.preventDefault();\n        figcaption.setAttribute('contenteditable', true);\n        figcaption.focus();\n\n        if (core._isInline && !core._inlineToolbarAttr.isShow) {\n          event._showToolbarInline();\n\n          var hideToolbar = function hideToolbar() {\n            event._hideToolbar();\n\n            figcaption.removeEventListener('blur', hideToolbar);\n          };\n\n          figcaption.addEventListener('blur', hideToolbar);\n        }\n      }\n\n      _w.setTimeout(core._editorRange.bind(core));\n\n      core._editorRange();\n\n      var selectionNode = core.getSelectionNode();\n      var formatEl = util.getFormatElement(selectionNode, null);\n      var rangeEl = util.getRangeFormatElement(selectionNode, null);\n\n      if (!formatEl && !util.isNonEditable(targetElement) && !util.isList(rangeEl)) {\n        var range = core.getRange();\n\n        if (util.getFormatElement(range.startContainer) === util.getFormatElement(range.endContainer)) {\n          if (util.isList(rangeEl)) {\n            e.preventDefault();\n            var oLi = util.createElement('LI');\n            var prevLi = selectionNode.nextElementSibling;\n            oLi.appendChild(selectionNode);\n            rangeEl.insertBefore(oLi, prevLi);\n            core.focus();\n          } else if (!util.isWysiwygDiv(selectionNode) && !util.isComponent(selectionNode) && (!util.isTable(selectionNode) || util.isCell(selectionNode)) && core._setDefaultFormat(util.isRangeFormatElement(rangeEl) ? 'DIV' : options.defaultTag) !== null) {\n            e.preventDefault();\n            core.focus();\n          } else {\n            event._applyTagEffects();\n          }\n        }\n      } else {\n        event._applyTagEffects();\n      }\n\n      if (core._isBalloon) _w.setTimeout(event._toggleToolbarBalloon);\n    },\n    _balloonDelay: null,\n    _showToolbarBalloonDelay: function _showToolbarBalloonDelay() {\n      if (event._balloonDelay) {\n        _w.clearTimeout(event._balloonDelay);\n      }\n\n      event._balloonDelay = _w.setTimeout(function () {\n        _w.clearTimeout(this._balloonDelay);\n\n        this._balloonDelay = null;\n\n        this._showToolbarBalloon();\n      }.bind(event), 350);\n    },\n    _toggleToolbarBalloon: function _toggleToolbarBalloon() {\n      core._editorRange();\n\n      var range = core.getRange();\n      if (core._bindControllersOff || !core._isBalloonAlways && range.collapsed) event._hideToolbar();else event._showToolbarBalloon(range);\n    },\n    _showToolbarBalloon: function _showToolbarBalloon(rangeObj) {\n      if (!core._isBalloon) return;\n      var range = rangeObj || core.getRange();\n      var toolbar = context.element.toolbar;\n      var topArea = context.element.topArea;\n      var selection = core.getSelection();\n      var isDirTop;\n\n      if (core._isBalloonAlways && range.collapsed) {\n        isDirTop = true;\n      } else if (selection.focusNode === selection.anchorNode) {\n        isDirTop = selection.focusOffset < selection.anchorOffset;\n      } else {\n        var childNodes = util.getListChildNodes(range.commonAncestorContainer, null);\n        isDirTop = util.getArrayIndex(childNodes, selection.focusNode) < util.getArrayIndex(childNodes, selection.anchorNode);\n      }\n\n      var rects = range.getClientRects();\n      rects = rects[isDirTop ? 0 : rects.length - 1];\n      var globalScroll = core.getGlobalScrollOffset();\n      var scrollLeft = globalScroll.left;\n      var scrollTop = globalScroll.top;\n      var editorWidth = topArea.offsetWidth;\n\n      var offsets = event._getEditorOffsets(null);\n\n      var stickyTop = offsets.top;\n      var editorLeft = offsets.left;\n      toolbar.style.top = '-10000px';\n      toolbar.style.visibility = 'hidden';\n      toolbar.style.display = 'block';\n\n      if (!rects) {\n        var node = core.getSelectionNode();\n\n        if (util.isFormatElement(node)) {\n          var zeroWidth = util.createTextNode(util.zeroWidthSpace);\n          core.insertNode(zeroWidth, null, false);\n          core.setRange(zeroWidth, 1, zeroWidth, 1);\n\n          core._editorRange();\n\n          rects = core.getRange().getClientRects();\n          rects = rects[isDirTop ? 0 : rects.length - 1];\n        }\n\n        if (!rects) {\n          var nodeOffset = util.getOffset(node, context.element.wysiwygFrame);\n          rects = {\n            left: nodeOffset.left,\n            top: nodeOffset.top,\n            right: nodeOffset.left,\n            bottom: nodeOffset.top + node.offsetHeight,\n            noText: true\n          };\n          scrollLeft = 0;\n          scrollTop = 0;\n        }\n\n        isDirTop = true;\n      }\n\n      var arrowMargin = _w.Math.round(context.element._arrow.offsetWidth / 2);\n\n      var toolbarWidth = toolbar.offsetWidth;\n      var toolbarHeight = toolbar.offsetHeight;\n      var iframeRects = /iframe/i.test(context.element.wysiwygFrame.nodeName) ? context.element.wysiwygFrame.getClientRects()[0] : null;\n\n      if (iframeRects) {\n        rects = {\n          left: rects.left + iframeRects.left,\n          top: rects.top + iframeRects.top,\n          right: rects.right + iframeRects.right - iframeRects.width,\n          bottom: rects.bottom + iframeRects.bottom - iframeRects.height\n        };\n      }\n\n      event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);\n\n      if (toolbarWidth !== toolbar.offsetWidth || toolbarHeight !== toolbar.offsetHeight) {\n        event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);\n      }\n\n      if (options.toolbarContainer) {\n        var editorParent = topArea.parentElement;\n        var container = options.toolbarContainer;\n        var left = container.offsetLeft;\n        var top = container.offsetTop;\n\n        while (!container.parentElement.contains(editorParent) || !/^(BODY|HTML)$/i.test(container.parentElement.nodeName)) {\n          container = container.offsetParent;\n          left += container.offsetLeft;\n          top += container.offsetTop;\n        }\n\n        toolbar.style.left = toolbar.offsetLeft - left + topArea.offsetLeft + 'px';\n        toolbar.style.top = toolbar.offsetTop - top + topArea.offsetTop + 'px';\n      }\n\n      toolbar.style.visibility = '';\n    },\n    _setToolbarOffset: function _setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin) {\n      var padding = 1;\n      var toolbarWidth = toolbar.offsetWidth;\n      var toolbarHeight = rects.noText && !isDirTop ? 0 : toolbar.offsetHeight;\n      var absoluteLeft = (isDirTop ? rects.left : rects.right) - editorLeft - toolbarWidth / 2 + scrollLeft;\n      var overRight = absoluteLeft + toolbarWidth - editorWidth;\n      var t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;\n      var l = absoluteLeft < 0 ? padding : overRight < 0 ? absoluteLeft : absoluteLeft - overRight - padding - 1;\n      var resetTop = false;\n      var space = t + (isDirTop ? event._getEditorOffsets(null).top : toolbar.offsetHeight - context.element.wysiwyg.offsetHeight);\n\n      if (!isDirTop && space > 0 && event._getPageBottomSpace() < space) {\n        isDirTop = true;\n        resetTop = true;\n      } else if (isDirTop && _d.documentElement.offsetTop > space) {\n        isDirTop = false;\n        resetTop = true;\n      }\n\n      if (resetTop) t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;\n      toolbar.style.left = _w.Math.floor(l) + 'px';\n      toolbar.style.top = _w.Math.floor(t) + 'px';\n\n      if (isDirTop) {\n        util.removeClass(context.element._arrow, 'se-arrow-up');\n        util.addClass(context.element._arrow, 'se-arrow-down');\n        context.element._arrow.style.top = toolbarHeight + 'px';\n      } else {\n        util.removeClass(context.element._arrow, 'se-arrow-down');\n        util.addClass(context.element._arrow, 'se-arrow-up');\n        context.element._arrow.style.top = -arrowMargin + 'px';\n      }\n\n      var arrow_left = _w.Math.floor(toolbarWidth / 2 + (absoluteLeft - l));\n\n      context.element._arrow.style.left = (arrow_left + arrowMargin > toolbar.offsetWidth ? toolbar.offsetWidth - arrowMargin : arrow_left < arrowMargin ? arrowMargin : arrow_left) + 'px';\n    },\n    _showToolbarInline: function _showToolbarInline() {\n      if (!core._isInline) return;\n      var toolbar = context.element.toolbar;\n      if (options.toolbarContainer) toolbar.style.position = 'relative';else toolbar.style.position = 'absolute';\n      toolbar.style.visibility = 'hidden';\n      toolbar.style.display = 'block';\n      core._inlineToolbarAttr.width = toolbar.style.width = options.toolbarWidth;\n      core._inlineToolbarAttr.top = toolbar.style.top = (options.toolbarContainer ? 0 : -1 - toolbar.offsetHeight) + 'px';\n      if (typeof functions.showInline === 'function') functions.showInline(toolbar, context, core);\n      event.onScroll_window();\n      core._inlineToolbarAttr.isShow = true;\n      toolbar.style.visibility = '';\n    },\n    _hideToolbar: function _hideToolbar() {\n      if (!core._notHideToolbar && !core._variable.isFullScreen) {\n        context.element.toolbar.style.display = 'none';\n        core._inlineToolbarAttr.isShow = false;\n      }\n    },\n    onInput_wysiwyg: function onInput_wysiwyg(e) {\n      if (core.isReadOnly || core.isDisabled) {\n        e.preventDefault();\n        e.stopPropagation();\n        core.history.go(core.history.getCurrentIndex());\n        return false;\n      }\n\n      core._editorRange(); // user event\n\n\n      if (typeof functions.onInput === 'function' && functions.onInput(e, core) === false) return;\n      var data = (e.data === null ? '' : e.data === undefined ? ' ' : e.data) || '';\n\n      if (!core._charCount(data)) {\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n      } // history stack\n\n\n      core.history.push(true);\n    },\n    _isUneditableNode: function _isUneditableNode(range, isFront) {\n      var container = isFront ? range.startContainer : range.endContainer;\n      var offset = isFront ? range.startOffset : range.endOffset;\n      var siblingKey = isFront ? 'previousSibling' : 'nextSibling';\n      var isElement = container.nodeType === 1;\n      var siblingNode;\n\n      if (isElement) {\n        siblingNode = event._isUneditableNode_getSibling(container.childNodes[offset], siblingKey, container);\n        return siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute('contenteditable') === 'false';\n      } else {\n        siblingNode = event._isUneditableNode_getSibling(container, siblingKey, container);\n        return core.isEdgePoint(container, offset, isFront ? 'front' : 'end') && siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute('contenteditable') === 'false';\n      }\n    },\n    _isUneditableNode_getSibling: function _isUneditableNode_getSibling(selectNode, siblingKey, container) {\n      if (!selectNode) return null;\n      var siblingNode = selectNode[siblingKey];\n\n      if (!siblingNode) {\n        siblingNode = util.getFormatElement(container);\n        siblingNode = siblingNode ? siblingNode[siblingKey] : null;\n        if (siblingNode && !util.isComponent(siblingNode)) siblingNode = siblingKey === 'previousSibling' ? siblingNode.firstElementChild : siblingNode.lastElementChild;else return null;\n      }\n\n      return siblingNode;\n    },\n    _onShortcutKey: false,\n    onKeyDown_wysiwyg: function onKeyDown_wysiwyg(e) {\n      var keyCode = e.keyCode;\n      var shift = e.shiftKey;\n      var ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;\n      var alt = e.altKey;\n      event._IEisComposing = keyCode === 229;\n\n      if (!ctrl && core.isReadOnly && !event._directionKeyCode.test(keyCode)) {\n        e.preventDefault();\n        return false;\n      }\n\n      core.submenuOff();\n\n      if (core._isBalloon) {\n        event._hideToolbar();\n      } // user event\n\n\n      if (typeof functions.onKeyDown === 'function' && functions.onKeyDown(e, core) === false) return;\n      /** Shortcuts */\n\n      if (ctrl && event._shortcutCommand(keyCode, shift)) {\n        event._onShortcutKey = true;\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n      } else if (event._onShortcutKey) {\n        event._onShortcutKey = false;\n      }\n      /** default key action */\n\n\n      var selectionNode = core.getSelectionNode();\n      var range = core.getRange();\n      var selectRange = !range.collapsed || range.startContainer !== range.endContainer;\n      var fileComponentName = core._fileManager.pluginRegExp.test(core.currentControllerName) ? core.currentControllerName : '';\n      var formatEl = util.getFormatElement(selectionNode, null) || selectionNode;\n      var rangeEl = util.getRangeFormatElement(formatEl, null);\n\n      switch (keyCode) {\n        case 8:\n          /** backspace key */\n          if (!selectRange) {\n            if (fileComponentName) {\n              e.preventDefault();\n              e.stopPropagation();\n              core.plugins[fileComponentName].destroy.call(core);\n              break;\n            }\n          }\n\n          if (selectRange && event._hardDelete()) {\n            e.preventDefault();\n            e.stopPropagation();\n            break;\n          }\n\n          if (!util.isFormatElement(formatEl) && !context.element.wysiwyg.firstElementChild && !util.isComponent(selectionNode) && core._setDefaultFormat(options.defaultTag) !== null) {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n          }\n\n          if (!selectRange && !formatEl.previousElementSibling && range.startOffset === 0 && !selectionNode.previousSibling && !util.isListCell(formatEl) && util.isFormatElement(formatEl) && (!util.isFreeFormatElement(formatEl) || util.isClosureFreeFormatElement(formatEl))) {\n            // closure range\n            if (util.isClosureRangeFormatElement(formatEl.parentNode)) {\n              e.preventDefault();\n              e.stopPropagation();\n              return false;\n            } // maintain default format\n\n\n            if (util.isWysiwygDiv(formatEl.parentNode) && formatEl.childNodes.length <= 1 && (!formatEl.firstChild || util.onlyZeroWidthSpace(formatEl.textContent))) {\n              e.preventDefault();\n              e.stopPropagation();\n\n              if (formatEl.nodeName.toUpperCase() === options.defaultTag.toUpperCase()) {\n                formatEl.innerHTML = '<br>';\n                var attrs = formatEl.attributes;\n\n                while (attrs[0]) {\n                  formatEl.removeAttribute(attrs[0].name);\n                }\n              } else {\n                var defaultFormat = util.createElement(options.defaultTag);\n                defaultFormat.innerHTML = '<br>';\n                formatEl.parentElement.replaceChild(defaultFormat, formatEl);\n              }\n\n              core.nativeFocus();\n              return false;\n            }\n          } // clean remove tag\n\n\n          if (formatEl && range.startContainer === range.endContainer && selectionNode.nodeType === 3 && !util.isFormatElement(selectionNode.parentNode)) {\n            if (range.collapsed ? selectionNode.textContent.length === 1 : range.endOffset - range.startOffset === selectionNode.textContent.length) {\n              e.preventDefault();\n              var offset = null;\n              var prev = selectionNode.parentNode.previousSibling;\n              var next = selectionNode.parentNode.nextSibling;\n\n              if (!prev) {\n                if (!next) {\n                  prev = util.createElement('BR');\n                  formatEl.appendChild(prev);\n                } else {\n                  prev = next;\n                  offset = 0;\n                }\n              }\n\n              selectionNode.textContent = '';\n              util.removeItemAllParents(selectionNode, null, formatEl);\n              offset = typeof offset === 'number' ? offset : prev.nodeType === 3 ? prev.textContent.length : 1;\n              core.setRange(prev, offset, prev, offset);\n              break;\n            }\n          } // tag[contenteditable=\"false\"]\n\n\n          if (event._isUneditableNode(range, true)) {\n            e.preventDefault();\n            e.stopPropagation();\n            break;\n          } // nested list\n\n\n          var commonCon = range.commonAncestorContainer;\n          formatEl = util.getFormatElement(range.startContainer, null);\n          rangeEl = util.getRangeFormatElement(formatEl, null);\n\n          if (rangeEl && formatEl && !util.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {\n            if (util.isListCell(formatEl) && util.isList(rangeEl) && (util.isListCell(rangeEl.parentNode) || formatEl.previousElementSibling) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.previousSibling || util.isList(selectionNode.previousSibling))) && (util.getFormatElement(range.startContainer, null) !== util.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.startContainer) : range.startOffset === 0 && range.collapsed)) {\n              if (range.startContainer !== range.endContainer) {\n                e.preventDefault();\n                core.removeNode();\n\n                if (range.startContainer.nodeType === 3) {\n                  core.setRange(range.startContainer, range.startContainer.textContent.length, range.startContainer, range.startContainer.textContent.length);\n                } // history stack\n\n\n                core.history.push(true);\n              } else {\n                var _prev = formatEl.previousElementSibling || rangeEl.parentNode;\n\n                if (util.isListCell(_prev)) {\n                  e.preventDefault();\n                  var prevLast = _prev;\n\n                  if (!_prev.contains(formatEl) && util.isListCell(prevLast) && util.isList(prevLast.lastElementChild)) {\n                    prevLast = prevLast.lastElementChild.lastElementChild;\n\n                    while (util.isListCell(prevLast) && util.isList(prevLast.lastElementChild)) {\n                      prevLast = prevLast.lastElementChild && prevLast.lastElementChild.lastElementChild;\n                    }\n\n                    _prev = prevLast;\n                  }\n\n                  var con = _prev === rangeEl.parentNode ? rangeEl.previousSibling : _prev.lastChild;\n\n                  if (!con) {\n                    con = util.createTextNode(util.zeroWidthSpace);\n                    rangeEl.parentNode.insertBefore(con, rangeEl.parentNode.firstChild);\n                  }\n\n                  var _offset = con.nodeType === 3 ? con.textContent.length : 1;\n\n                  var children = formatEl.childNodes;\n                  var after = con;\n                  var child = children[0];\n\n                  while (child = children[0]) {\n                    _prev.insertBefore(child, after.nextSibling);\n\n                    after = child;\n                  }\n\n                  util.removeItem(formatEl);\n                  if (rangeEl.children.length === 0) util.removeItem(rangeEl);\n                  core.setRange(con, _offset, con, _offset); // history stack\n\n                  core.history.push(true);\n                }\n              }\n\n              break;\n            } // detach range\n\n\n            if (!selectRange && range.startOffset === 0) {\n              var detach = true;\n              var comm = commonCon;\n\n              while (comm && comm !== rangeEl && !util.isWysiwygDiv(comm)) {\n                if (comm.previousSibling) {\n                  if (comm.previousSibling.nodeType === 1 || !util.onlyZeroWidthSpace(comm.previousSibling.textContent.trim())) {\n                    detach = false;\n                    break;\n                  }\n                }\n\n                comm = comm.parentNode;\n              }\n\n              if (detach && rangeEl.parentNode) {\n                e.preventDefault();\n                core.detachRangeFormatElement(rangeEl, util.isListCell(formatEl) ? [formatEl] : null, null, false, false); // history stack\n\n                core.history.push(true);\n                break;\n              }\n            }\n          } // component\n\n\n          if (!selectRange && formatEl && (range.startOffset === 0 || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {\n            var sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] : selectionNode;\n            var _prev2 = formatEl.previousSibling; // select file component\n\n            var ignoreZWS = (commonCon.nodeType === 3 || util.isBreak(commonCon)) && !commonCon.previousSibling && range.startOffset === 0;\n\n            if (!sel.previousSibling && (util.isComponent(commonCon.previousSibling) || ignoreZWS && util.isComponent(_prev2))) {\n              var fileComponentInfo = core.getFileComponent(_prev2);\n\n              if (fileComponentInfo) {\n                e.preventDefault();\n                e.stopPropagation();\n                if (formatEl.textContent.length === 0) util.removeItem(formatEl);\n                if (core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName) === false) core.blur();\n              } else if (util.isComponent(_prev2)) {\n                e.preventDefault();\n                e.stopPropagation();\n                util.removeItem(_prev2);\n              }\n\n              break;\n            } // delete nonEditable\n\n\n            if (util.isNonEditable(sel.previousSibling)) {\n              e.preventDefault();\n              e.stopPropagation();\n              util.removeItem(sel.previousSibling);\n              break;\n            }\n          }\n\n          break;\n\n        case 46:\n          /** delete key */\n          if (fileComponentName) {\n            e.preventDefault();\n            e.stopPropagation();\n            core.plugins[fileComponentName].destroy.call(core);\n            break;\n          }\n\n          if (selectRange && event._hardDelete()) {\n            e.preventDefault();\n            e.stopPropagation();\n            break;\n          } // tag[contenteditable=\"false\"]\n\n\n          if (event._isUneditableNode(range, false)) {\n            e.preventDefault();\n            e.stopPropagation();\n            break;\n          } // component\n\n\n          if ((util.isFormatElement(selectionNode) || selectionNode.nextSibling === null || util.onlyZeroWidthSpace(selectionNode.nextSibling) && selectionNode.nextSibling.nextSibling === null) && range.startOffset === selectionNode.textContent.length) {\n            var nextEl = formatEl.nextElementSibling;\n            if (!nextEl) break;\n\n            if (util.isComponent(nextEl)) {\n              e.preventDefault();\n\n              if (util.onlyZeroWidthSpace(formatEl)) {\n                util.removeItem(formatEl); // table component\n\n                if (util.isTable(nextEl)) {\n                  var cell = util.getChildElement(nextEl, util.isCell, false);\n                  cell = cell.firstElementChild || cell;\n                  core.setRange(cell, 0, cell, 0);\n                  break;\n                }\n              } // select file component\n\n\n              var _fileComponentInfo = core.getFileComponent(nextEl);\n\n              if (_fileComponentInfo) {\n                e.stopPropagation();\n                if (core.selectComponent(_fileComponentInfo.target, _fileComponentInfo.pluginName) === false) core.blur();\n              } else if (util.isComponent(nextEl)) {\n                e.stopPropagation();\n                util.removeItem(nextEl);\n              }\n\n              break;\n            }\n          }\n\n          if (!selectRange && (core.isEdgePoint(range.endContainer, range.endOffset) || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {\n            var _sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] || selectionNode : selectionNode; // delete nonEditable\n\n\n            if (_sel && util.isNonEditable(_sel.nextSibling)) {\n              e.preventDefault();\n              e.stopPropagation();\n              util.removeItem(_sel.nextSibling);\n              break;\n            } else if (util.isComponent(_sel)) {\n              e.preventDefault();\n              e.stopPropagation();\n              util.removeItem(_sel);\n              break;\n            }\n          } // nested list\n\n\n          formatEl = util.getFormatElement(range.startContainer, null);\n          rangeEl = util.getRangeFormatElement(formatEl, null);\n\n          if (util.isListCell(formatEl) && util.isList(rangeEl) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.nextSibling || util.isList(selectionNode.nextSibling)) && (util.getFormatElement(range.startContainer, null) !== util.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.endContainer) : range.endOffset === selectionNode.textContent.length && range.collapsed))) {\n            if (range.startContainer !== range.endContainer) core.removeNode();\n\n            var _next = util.getArrayItem(formatEl.children, util.isList, false);\n\n            _next = _next || formatEl.nextElementSibling || rangeEl.parentNode.nextElementSibling;\n\n            if (_next && (util.isList(_next) || util.getArrayItem(_next.children, util.isList, false))) {\n              e.preventDefault();\n\n              var _con, _children;\n\n              if (util.isList(_next)) {\n                var _child2 = _next.firstElementChild;\n                _children = _child2.childNodes;\n                _con = _children[0];\n\n                while (_children[0]) {\n                  formatEl.insertBefore(_children[0], _next);\n                }\n\n                util.removeItem(_child2);\n              } else {\n                _con = _next.firstChild;\n                _children = _next.childNodes;\n\n                while (_children[0]) {\n                  formatEl.appendChild(_children[0]);\n                }\n\n                util.removeItem(_next);\n              }\n\n              core.setRange(_con, 0, _con, 0); // history stack\n\n              core.history.push(true);\n            }\n\n            break;\n          }\n\n          break;\n\n        case 9:\n          /** tab key */\n          if (fileComponentName || options.tabDisable) break;\n          e.preventDefault();\n          if (ctrl || alt || util.isWysiwygDiv(selectionNode)) break;\n          var isEdge = !range.collapsed || core.isEdgePoint(range.startContainer, range.startOffset);\n          var selectedFormats = core.getSelectedElements(null);\n          selectionNode = core.getSelectionNode();\n          var cells = [];\n          var lines = [];\n          var fc = util.isListCell(selectedFormats[0]),\n              lc = util.isListCell(selectedFormats[selectedFormats.length - 1]);\n          var r = {\n            sc: range.startContainer,\n            so: range.startOffset,\n            ec: range.endContainer,\n            eo: range.endOffset\n          };\n\n          for (var i = 0, len = selectedFormats.length, f; i < len; i++) {\n            f = selectedFormats[i];\n\n            if (util.isListCell(f)) {\n              if (!f.previousElementSibling && !shift) {\n                continue;\n              } else {\n                cells.push(f);\n              }\n            } else {\n              lines.push(f);\n            }\n          } // Nested list\n\n\n          if (cells.length > 0 && isEdge && core.plugins.list) {\n            r = core.plugins.list.editInsideList.call(core, shift, cells);\n          } else {\n            // table\n            var tableCell = util.getParentElement(selectionNode, util.isCell);\n\n            if (tableCell && isEdge) {\n              var table = util.getParentElement(tableCell, 'table');\n\n              var _cells = util.getListChildren(table, util.isCell);\n\n              var idx = shift ? util.prevIdx(_cells, tableCell) : util.nextIdx(_cells, tableCell);\n              if (idx === _cells.length && !shift) idx = 0;\n              if (idx === -1 && shift) idx = _cells.length - 1;\n              var moveCell = _cells[idx];\n              if (!moveCell) break;\n              moveCell = moveCell.firstElementChild || moveCell;\n              core.setRange(moveCell, 0, moveCell, 0);\n              break;\n            }\n\n            lines = lines.concat(cells);\n            fc = lc = null;\n          } // Lines tab(4)\n\n\n          if (lines.length > 0) {\n            if (!shift) {\n              var tabText = util.createTextNode(new _w.Array(core._variable.tabSize + 1).join(\"\\xA0\"));\n\n              if (lines.length === 1) {\n                var textRange = core.insertNode(tabText, null, true);\n                if (!textRange) return false;\n\n                if (!fc) {\n                  r.sc = tabText;\n                  r.so = textRange.endOffset;\n                }\n\n                if (!lc) {\n                  r.ec = tabText;\n                  r.eo = textRange.endOffset;\n                }\n              } else {\n                var _len14 = lines.length - 1;\n\n                for (var _i27 = 0, _child3; _i27 <= _len14; _i27++) {\n                  _child3 = lines[_i27].firstChild;\n                  if (!_child3) continue;\n\n                  if (util.isBreak(_child3)) {\n                    lines[_i27].insertBefore(tabText.cloneNode(false), _child3);\n                  } else {\n                    _child3.textContent = tabText.textContent + _child3.textContent;\n                  }\n                }\n\n                var firstChild = util.getChildElement(lines[0], 'text', false);\n                var endChild = util.getChildElement(lines[_len14], 'text', true);\n\n                if (!fc && firstChild) {\n                  r.sc = firstChild;\n                  r.so = 0;\n                }\n\n                if (!lc && endChild) {\n                  r.ec = endChild;\n                  r.eo = endChild.textContent.length;\n                }\n              }\n            } else {\n              var _len15 = lines.length - 1;\n\n              for (var _i28 = 0, line; _i28 <= _len15; _i28++) {\n                line = lines[_i28].childNodes;\n\n                for (var _c6 = 0, cLen = line.length, _child4; _c6 < cLen; _c6++) {\n                  _child4 = line[_c6];\n                  if (!_child4) break;\n                  if (util.onlyZeroWidthSpace(_child4)) continue;\n\n                  if (/^\\s{1,4}$/.test(_child4.textContent)) {\n                    util.removeItem(_child4);\n                  } else if (/^\\s{1,4}/.test(_child4.textContent)) {\n                    _child4.textContent = _child4.textContent.replace(/^\\s{1,4}/, '');\n                  }\n\n                  break;\n                }\n              }\n\n              var _firstChild = util.getChildElement(lines[0], 'text', false);\n\n              var _endChild = util.getChildElement(lines[_len15], 'text', true);\n\n              if (!fc && _firstChild) {\n                r.sc = _firstChild;\n                r.so = 0;\n              }\n\n              if (!lc && _endChild) {\n                r.ec = _endChild;\n                r.eo = _endChild.textContent.length;\n              }\n            }\n          }\n\n          core.setRange(r.sc, r.so, r.ec, r.eo); // history stack\n\n          core.history.push(false);\n          break;\n\n        case 13:\n          /** enter key */\n          var freeFormatEl = util.getFreeFormatElement(selectionNode, null);\n\n          if (core._charTypeHTML) {\n            var enterHTML = '';\n\n            if (!shift && freeFormatEl || shift) {\n              enterHTML = '<br>';\n            } else {\n              enterHTML = '<' + formatEl.nodeName + '><br></' + formatEl.nodeName + '>';\n            }\n\n            if (!core.checkCharCount(enterHTML, 'byte-html')) {\n              e.preventDefault();\n              return false;\n            }\n          }\n\n          if (!shift) {\n            var formatInners = core._isEdgeFormat(range.endContainer, range.endOffset, 'end');\n\n            if (formatInners && /^H[1-6]$/i.test(formatEl.nodeName) || /^HR$/i.test(formatEl.nodeName)) {\n              e.preventDefault();\n              var temp = null;\n              var newFormat = core.appendFormatTag(formatEl, options.defaultTag);\n\n              if (formatInners && formatInners.length > 0) {\n                temp = formatInners.pop();\n                var innerNode = temp;\n\n                while (formatInners.length > 0) {\n                  temp = temp.appendChild(formatInners.pop());\n                }\n\n                newFormat.appendChild(innerNode);\n              }\n\n              temp = !temp ? newFormat.firstChild : temp.appendChild(newFormat.firstChild);\n              core.setRange(temp, 0, temp, 0);\n              break;\n            } else if (options.lineAttrReset && formatEl && !util.isListCell(formatEl)) {\n              e.preventDefault();\n              e.stopPropagation();\n              var newEl;\n\n              if (!range.collapsed) {\n                var isMultiLine = util.getFormatElement(range.startContainer, null) !== util.getFormatElement(range.endContainer, null);\n\n                var _r2 = core.removeNode();\n\n                if (isMultiLine) {\n                  newEl = util.getFormatElement(_r2.container, null);\n\n                  if (!_r2.prevContainer) {\n                    var _newFormat = formatEl.cloneNode(false);\n\n                    _newFormat.innerHTML = '<br>';\n                    newEl.parentNode.insertBefore(_newFormat, newEl);\n                  } else if (newEl !== formatEl && newEl.nextElementSibling === formatEl) {\n                    newEl = formatEl;\n                  }\n                } else {\n                  newEl = util.splitElement(_r2.container, _r2.offset, 0);\n                }\n              } else {\n                if (util.onlyZeroWidthSpace(formatEl)) newEl = core.appendFormatTag(formatEl, formatEl.cloneNode(false));else newEl = util.splitElement(range.endContainer, range.endOffset, 0);\n              }\n\n              var resetAttr = options.lineAttrReset === '*' ? null : options.lineAttrReset;\n              var _attrs = newEl.attributes;\n              var _i29 = 0;\n\n              while (_attrs[_i29]) {\n                if (resetAttr && resetAttr.test(_attrs[_i29].name)) {\n                  _i29++;\n                  continue;\n                }\n\n                newEl.removeAttribute(_attrs[_i29].name);\n              }\n\n              core.setRange(newEl.firstChild, 0, newEl.firstChild, 0);\n              break;\n            }\n\n            if (freeFormatEl) {\n              e.preventDefault();\n              var selectionFormat = selectionNode === freeFormatEl;\n              var wSelection = core.getSelection();\n              var _children2 = selectionNode.childNodes,\n                  _offset2 = wSelection.focusOffset,\n                  _prev3 = selectionNode.previousElementSibling,\n                  _next2 = selectionNode.nextSibling;\n\n              if (!util.isClosureFreeFormatElement(freeFormatEl) && !!_children2 && (selectionFormat && range.collapsed && _children2.length - 1 <= _offset2 + 1 && util.isBreak(_children2[_offset2]) && (!_children2[_offset2 + 1] || (!_children2[_offset2 + 2] || util.onlyZeroWidthSpace(_children2[_offset2 + 2].textContent)) && _children2[_offset2 + 1].nodeType === 3 && util.onlyZeroWidthSpace(_children2[_offset2 + 1].textContent)) && _offset2 > 0 && util.isBreak(_children2[_offset2 - 1]) || !selectionFormat && util.onlyZeroWidthSpace(selectionNode.textContent) && util.isBreak(_prev3) && (util.isBreak(_prev3.previousSibling) || !util.onlyZeroWidthSpace(_prev3.previousSibling.textContent)) && (!_next2 || !util.isBreak(_next2) && util.onlyZeroWidthSpace(_next2.textContent)))) {\n                if (selectionFormat) util.removeItem(_children2[_offset2 - 1]);else util.removeItem(selectionNode);\n\n                var _newEl = core.appendFormatTag(freeFormatEl, util.isFormatElement(freeFormatEl.nextElementSibling) && !util.isRangeFormatElement(freeFormatEl.nextElementSibling) ? freeFormatEl.nextElementSibling : null);\n\n                util.copyFormatAttributes(_newEl, freeFormatEl);\n                core.setRange(_newEl, 1, _newEl, 1);\n                break;\n              }\n\n              if (selectionFormat) {\n                functions.insertHTML(range.collapsed && util.isBreak(range.startContainer.childNodes[range.startOffset - 1]) ? '<br>' : '<br><br>', true, false);\n                var focusNode = wSelection.focusNode;\n                var wOffset = wSelection.focusOffset;\n\n                if (freeFormatEl === focusNode) {\n                  focusNode = focusNode.childNodes[wOffset - _offset2 > 1 ? wOffset - 1 : wOffset];\n                }\n\n                core.setRange(focusNode, 1, focusNode, 1);\n              } else {\n                var focusNext = wSelection.focusNode.nextSibling;\n                var br = util.createElement('BR');\n                core.insertNode(br, null, false);\n                var brPrev = br.previousSibling,\n                    brNext = br.nextSibling;\n\n                if (!util.isBreak(focusNext) && !util.isBreak(brPrev) && (!brNext || util.onlyZeroWidthSpace(brNext))) {\n                  br.parentNode.insertBefore(br.cloneNode(false), br);\n                  core.setRange(br, 1, br, 1);\n                } else {\n                  core.setRange(brNext, 0, brNext, 0);\n                }\n              }\n\n              event._onShortcutKey = true;\n              break;\n            }\n          }\n\n          if (selectRange) break;\n\n          if (rangeEl && formatEl && !util.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {\n            var _range = core.getRange();\n\n            if (core.isEdgePoint(_range.endContainer, _range.endOffset) && util.isList(selectionNode.nextSibling)) {\n              e.preventDefault();\n\n              var _newEl2 = util.createElement('LI');\n\n              var _br2 = util.createElement('BR');\n\n              _newEl2.appendChild(_br2);\n\n              formatEl.parentNode.insertBefore(_newEl2, formatEl.nextElementSibling);\n\n              _newEl2.appendChild(selectionNode.nextSibling);\n\n              core.setRange(_br2, 1, _br2, 1);\n              break;\n            }\n\n            if ((_range.commonAncestorContainer.nodeType === 3 ? !_range.commonAncestorContainer.nextElementSibling : true) && util.onlyZeroWidthSpace(formatEl.innerText.trim())) {\n              e.preventDefault();\n              var _newEl3 = null;\n\n              if (util.isListCell(rangeEl.parentNode)) {\n                rangeEl = formatEl.parentNode.parentNode.parentNode;\n                _newEl3 = util.splitElement(formatEl, null, util.getElementDepth(formatEl) - 2);\n\n                if (!_newEl3) {\n                  var newListCell = util.createElement('LI');\n                  newListCell.innerHTML = '<br>';\n                  rangeEl.insertBefore(newListCell, _newEl3);\n                  _newEl3 = newListCell;\n                }\n              } else {\n                var _newFormat2 = util.isCell(rangeEl.parentNode) ? 'DIV' : util.isList(rangeEl.parentNode) ? 'LI' : util.isFormatElement(rangeEl.nextElementSibling) && !util.isRangeFormatElement(rangeEl.nextElementSibling) ? rangeEl.nextElementSibling.nodeName : util.isFormatElement(rangeEl.previousElementSibling) && !util.isRangeFormatElement(rangeEl.previousElementSibling) ? rangeEl.previousElementSibling.nodeName : options.defaultTag;\n\n                _newEl3 = util.createElement(_newFormat2);\n                var edge = core.detachRangeFormatElement(rangeEl, [formatEl], null, true, true);\n                edge.cc.insertBefore(_newEl3, edge.ec);\n              }\n\n              _newEl3.innerHTML = '<br>';\n              util.removeItemAllParents(formatEl, null, null);\n              core.setRange(_newEl3, 1, _newEl3, 1);\n              break;\n            }\n          }\n\n          if (rangeEl && util.getParentElement(rangeEl, 'FIGCAPTION') && util.getParentElement(rangeEl, util.isList)) {\n            e.preventDefault();\n            formatEl = core.appendFormatTag(formatEl, null);\n            core.setRange(formatEl, 0, formatEl, 0);\n          }\n\n          if (fileComponentName) {\n            e.preventDefault();\n            e.stopPropagation();\n            var compContext = context[fileComponentName];\n            var container = compContext._container;\n            var sibling = container.previousElementSibling || container.nextElementSibling;\n            var _newEl4 = null;\n\n            if (util.isListCell(container.parentNode)) {\n              _newEl4 = util.createElement('BR');\n            } else {\n              _newEl4 = util.createElement(util.isFormatElement(sibling) && !util.isRangeFormatElement(sibling) ? sibling.nodeName : options.defaultTag);\n              _newEl4.innerHTML = '<br>';\n            }\n\n            container.parentNode.insertBefore(_newEl4, container);\n            core.callPlugin(fileComponentName, function () {\n              if (core.selectComponent(compContext._element, fileComponentName) === false) core.blur();\n            }, null);\n          }\n\n          break;\n\n        case 27:\n          if (fileComponentName) {\n            e.preventDefault();\n            e.stopPropagation();\n            core.controllersOff();\n            return false;\n          }\n\n          break;\n      }\n\n      if (shift && keyCode === 16) {\n        e.preventDefault();\n        e.stopPropagation();\n        var tablePlugin = core.plugins.table;\n\n        if (tablePlugin && !tablePlugin._shift && !tablePlugin._ref) {\n          var _cell = util.getParentElement(formatEl, util.isCell);\n\n          if (_cell) {\n            tablePlugin.onTableCellMultiSelect.call(core, _cell, true);\n            return;\n          }\n        }\n      } else if (shift && (util.isOSX_IOS ? alt : ctrl) && keyCode === 32) {\n        e.preventDefault();\n        e.stopPropagation();\n        var nbsp = core.insertNode(util.createTextNode(\"\\xA0\"));\n\n        if (nbsp && nbsp.container) {\n          core.setRange(nbsp.container, nbsp.endOffset, nbsp.container, nbsp.endOffset);\n          return;\n        }\n      }\n\n      var textKey = !ctrl && !alt && !selectRange && !event._nonTextKeyCode.test(keyCode);\n\n      if (textKey && range.collapsed && range.startContainer === range.endContainer && util.isBreak(range.commonAncestorContainer)) {\n        var zeroWidth = util.createTextNode(util.zeroWidthSpace);\n        core.insertNode(zeroWidth, null, false);\n        core.setRange(zeroWidth, 1, zeroWidth, 1);\n      }\n    },\n    onKeyUp_wysiwyg: function onKeyUp_wysiwyg(e) {\n      if (event._onShortcutKey) return;\n\n      core._editorRange();\n\n      var keyCode = e.keyCode;\n      var ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;\n      var alt = e.altKey;\n\n      if (core.isReadOnly) {\n        if (!ctrl && event._directionKeyCode.test(keyCode)) event._applyTagEffects();\n        return;\n      }\n\n      var range = core.getRange();\n      var selectionNode = core.getSelectionNode();\n\n      if (core._isBalloon && (core._isBalloonAlways && keyCode !== 27 || !range.collapsed)) {\n        if (core._isBalloonAlways) {\n          if (keyCode !== 27) event._showToolbarBalloonDelay();\n        } else {\n          event._showToolbarBalloon();\n\n          return;\n        }\n      }\n      /** when format tag deleted */\n\n\n      if (keyCode === 8 && util.isWysiwygDiv(selectionNode) && selectionNode.textContent === '' && selectionNode.children.length === 0) {\n        e.preventDefault();\n        e.stopPropagation();\n        selectionNode.innerHTML = '';\n        var oFormatTag = util.createElement(util.isFormatElement(core._variable.currentNodes[0]) ? core._variable.currentNodes[0] : options.defaultTag);\n        oFormatTag.innerHTML = '<br>';\n        selectionNode.appendChild(oFormatTag);\n        core.setRange(oFormatTag, 0, oFormatTag, 0);\n\n        event._applyTagEffects();\n\n        core.history.push(false);\n        return;\n      }\n\n      var formatEl = util.getFormatElement(selectionNode, null);\n      var rangeEl = util.getRangeFormatElement(selectionNode, null);\n\n      if (!formatEl && range.collapsed && !util.isComponent(selectionNode) && !util.isList(selectionNode) && core._setDefaultFormat(util.isRangeFormatElement(rangeEl) ? 'DIV' : options.defaultTag) !== null) {\n        selectionNode = core.getSelectionNode();\n      }\n\n      if (event._directionKeyCode.test(keyCode)) {\n        event._applyTagEffects();\n      }\n\n      var textKey = !ctrl && !alt && !event._nonTextKeyCode.test(keyCode);\n\n      if (textKey && selectionNode.nodeType === 3 && util.zeroWidthRegExp.test(selectionNode.textContent) && !(e.isComposing !== undefined ? e.isComposing : event._IEisComposing)) {\n        var so = range.startOffset,\n            eo = range.endOffset;\n        var frontZeroWidthCnt = (selectionNode.textContent.substring(0, eo).match(event._frontZeroWidthReg) || '').length;\n        so = range.startOffset - frontZeroWidthCnt;\n        eo = range.endOffset - frontZeroWidthCnt;\n        selectionNode.textContent = selectionNode.textContent.replace(util.zeroWidthRegExp, '');\n        core.setRange(selectionNode, so < 0 ? 0 : so, selectionNode, eo < 0 ? 0 : eo);\n      }\n\n      core._charCount(''); // user event\n\n\n      if (typeof functions.onKeyUp === 'function' && functions.onKeyUp(e, core) === false) return; // history stack\n\n      if (!ctrl && !alt && !event._historyIgnoreKeyCode.test(keyCode)) {\n        core.history.push(true);\n      }\n    },\n    onScroll_wysiwyg: function onScroll_wysiwyg(e) {\n      core.controllersOff();\n      if (core._isBalloon) event._hideToolbar(); // user event\n\n      if (typeof functions.onScroll === 'function') functions.onScroll(e, core);\n    },\n    onFocus_wysiwyg: function onFocus_wysiwyg(e) {\n      if (core._antiBlur) return;\n      core.hasFocus = true;\n\n      _w.setTimeout(event._applyTagEffects);\n\n      if (core._isInline) event._showToolbarInline(); // user event\n\n      if (typeof functions.onFocus === 'function') functions.onFocus(e, core);\n    },\n    onBlur_wysiwyg: function onBlur_wysiwyg(e) {\n      if (core._antiBlur || core._variable.isCodeView) return;\n      core.hasFocus = false;\n      core.effectNode = null;\n      core.controllersOff();\n      if (core._isInline || core._isBalloon) event._hideToolbar();\n\n      core._setKeyEffect([]);\n\n      core._variable.currentNodes = [];\n      core._variable.currentNodesMap = [];\n      if (options.showPathLabel) context.element.navigation.textContent = ''; // user event\n\n      if (typeof functions.onBlur === 'function') functions.onBlur(e, core);\n    },\n    onMouseDown_resizingBar: function onMouseDown_resizingBar(e) {\n      e.stopPropagation();\n      core.submenuOff();\n      core.controllersOff();\n      core._variable.resizeClientY = e.clientY;\n      context.element.resizeBackground.style.display = 'block';\n\n      function closureFunc() {\n        context.element.resizeBackground.style.display = 'none';\n\n        _d.removeEventListener('mousemove', event._resize_editor);\n\n        _d.removeEventListener('mouseup', closureFunc);\n      }\n\n      _d.addEventListener('mousemove', event._resize_editor);\n\n      _d.addEventListener('mouseup', closureFunc);\n    },\n    _resize_editor: function _resize_editor(e) {\n      var resizeInterval = context.element.editorArea.offsetHeight + (e.clientY - core._variable.resizeClientY);\n      var h = resizeInterval < core._variable.minResizingSize ? core._variable.minResizingSize : resizeInterval;\n      context.element.wysiwygFrame.style.height = context.element.code.style.height = h + 'px';\n      core._variable.resizeClientY = e.clientY;\n      if (util.isIE) core.__callResizeFunction(h, null);\n    },\n    onResize_window: function onResize_window() {\n      if (util.isIE) core.resetResponsiveToolbar();\n      if (context.element.toolbar.offsetWidth === 0) return;\n\n      if (context.fileBrowser && context.fileBrowser.area.style.display === 'block') {\n        context.fileBrowser.body.style.maxHeight = _w.innerHeight - context.fileBrowser.header.offsetHeight - 50 + 'px';\n      }\n\n      if (core.submenuActiveButton && core.submenu) {\n        core._setMenuPosition(core.submenuActiveButton, core.submenu);\n      }\n\n      if (core._variable.isFullScreen) {\n        core._variable.innerHeight_fullScreen += _w.innerHeight - context.element.toolbar.offsetHeight - core._variable.innerHeight_fullScreen;\n        context.element.editorArea.style.height = core._variable.innerHeight_fullScreen + 'px';\n        return;\n      }\n\n      if (core._variable.isCodeView && core._isInline) {\n        event._showToolbarInline();\n\n        return;\n      }\n\n      core._iframeAutoHeight();\n\n      if (core._sticky) {\n        context.element.toolbar.style.width = context.element.topArea.offsetWidth - 2 + 'px';\n        event.onScroll_window();\n      }\n    },\n    onScroll_window: function onScroll_window() {\n      if (core._variable.isFullScreen || context.element.toolbar.offsetWidth === 0 || options.stickyToolbar < 0) return;\n      var element = context.element;\n      var editorHeight = element.editorArea.offsetHeight;\n      var y = (this.scrollY || _d.documentElement.scrollTop) + options.stickyToolbar;\n      var editorTop = event._getEditorOffsets(options.toolbarContainer).top - (core._isInline ? element.toolbar.offsetHeight : 0);\n      var inlineOffset = core._isInline && y - editorTop > 0 ? y - editorTop - context.element.toolbar.offsetHeight : 0;\n\n      if (y < editorTop) {\n        event._offStickyToolbar();\n      } else if (y + core._variable.minResizingSize >= editorHeight + editorTop) {\n        if (!core._sticky) event._onStickyToolbar(inlineOffset);\n        element.toolbar.style.top = inlineOffset + editorHeight + editorTop + options.stickyToolbar - y - core._variable.minResizingSize + 'px';\n      } else if (y >= editorTop) {\n        event._onStickyToolbar(inlineOffset);\n      }\n    },\n    _getEditorOffsets: function _getEditorOffsets(container) {\n      var offsetEl = container || context.element.topArea;\n      var t = 0,\n          l = 0,\n          s = 0;\n\n      while (offsetEl) {\n        t += offsetEl.offsetTop;\n        l += offsetEl.offsetLeft;\n        s += offsetEl.scrollTop;\n        offsetEl = offsetEl.offsetParent;\n      }\n\n      return {\n        top: t,\n        left: l,\n        scroll: s\n      };\n    },\n    _getPageBottomSpace: function _getPageBottomSpace() {\n      return _d.documentElement.scrollHeight - (event._getEditorOffsets(null).top + context.element.topArea.offsetHeight);\n    },\n    _onStickyToolbar: function _onStickyToolbar(inlineOffset) {\n      var element = context.element;\n\n      if (!core._isInline && !options.toolbarContainer) {\n        element._stickyDummy.style.height = element.toolbar.offsetHeight + 'px';\n        element._stickyDummy.style.display = 'block';\n      }\n\n      element.toolbar.style.top = options.stickyToolbar + inlineOffset + 'px';\n      element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : element.toolbar.offsetWidth + 'px';\n      util.addClass(element.toolbar, 'se-toolbar-sticky');\n      core._sticky = true;\n    },\n    _offStickyToolbar: function _offStickyToolbar() {\n      var element = context.element;\n      element._stickyDummy.style.display = 'none';\n      element.toolbar.style.top = core._isInline ? core._inlineToolbarAttr.top : '';\n      element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : '';\n      element.editorArea.style.marginTop = '';\n      util.removeClass(element.toolbar, 'se-toolbar-sticky');\n      core._sticky = false;\n    },\n    _codeViewAutoHeight: function _codeViewAutoHeight() {\n      if (core._variable.isFullScreen) return;\n      context.element.code.style.height = context.element.code.scrollHeight + 'px';\n    },\n    // FireFox - table delete, Chrome - image, video, audio\n    _hardDelete: function _hardDelete() {\n      var range = core.getRange();\n      var sc = range.startContainer;\n      var ec = range.endContainer; // table\n\n      var sCell = util.getRangeFormatElement(sc);\n      var eCell = util.getRangeFormatElement(ec);\n      var sIsCell = util.isCell(sCell);\n      var eIsCell = util.isCell(eCell);\n      var ancestor = range.commonAncestorContainer;\n\n      if ((sIsCell && !sCell.previousElementSibling && !sCell.parentElement.previousElementSibling || eIsCell && !eCell.nextElementSibling && !eCell.parentElement.nextElementSibling) && sCell !== eCell) {\n        if (!sIsCell) {\n          util.removeItem(util.getParentElement(eCell, function (current) {\n            return ancestor === current.parentNode;\n          }));\n        } else if (!eIsCell) {\n          util.removeItem(util.getParentElement(sCell, function (current) {\n            return ancestor === current.parentNode;\n          }));\n        } else {\n          util.removeItem(util.getParentElement(sCell, function (current) {\n            return ancestor === current.parentNode;\n          }));\n          core.nativeFocus();\n          return true;\n        }\n      } // component\n\n\n      var sComp = sc.nodeType === 1 ? util.getParentElement(sc, '.se-component') : null;\n      var eComp = ec.nodeType === 1 ? util.getParentElement(ec, '.se-component') : null;\n      if (sComp) util.removeItem(sComp);\n      if (eComp) util.removeItem(eComp);\n      return false;\n    },\n    onPaste_wysiwyg: function onPaste_wysiwyg(e) {\n      var clipboardData = util.isIE ? _w.clipboardData : e.clipboardData;\n      if (!clipboardData) return true;\n      return event._dataTransferAction('paste', e, clipboardData);\n    },\n    _setClipboardComponent: function _setClipboardComponent(e, info, clipboardData) {\n      e.preventDefault();\n      e.stopPropagation();\n      clipboardData.setData('text/html', info.component.outerHTML);\n    },\n    onCopy_wysiwyg: function onCopy_wysiwyg(e) {\n      var clipboardData = util.isIE ? _w.clipboardData : e.clipboardData; // user event\n\n      if (typeof functions.onCopy === 'function' && !functions.onCopy(e, clipboardData, core)) {\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n      }\n\n      var info = core.currentFileComponentInfo;\n\n      if (info && !util.isIE) {\n        event._setClipboardComponent(e, info, clipboardData);\n\n        util.addClass(info.component, 'se-component-copy'); // copy effect\n\n        _w.setTimeout(function () {\n          util.removeClass(info.component, 'se-component-copy');\n        }, 150);\n      }\n    },\n    onSave_wysiwyg: function onSave_wysiwyg(content) {\n      // user event\n      if (typeof functions.onSave === 'function') {\n        functions.onSave(content, core);\n        return;\n      }\n    },\n    onCut_wysiwyg: function onCut_wysiwyg(e) {\n      var clipboardData = util.isIE ? _w.clipboardData : e.clipboardData; // user event\n\n      if (typeof functions.onCut === 'function' && !functions.onCut(e, clipboardData, core)) {\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n      }\n\n      var info = core.currentFileComponentInfo;\n\n      if (info && !util.isIE) {\n        event._setClipboardComponent(e, info, clipboardData);\n\n        util.removeItem(info.component);\n        core.controllersOff();\n      }\n\n      _w.setTimeout(function () {\n        // history stack\n        core.history.push(false);\n      });\n    },\n    onDrop_wysiwyg: function onDrop_wysiwyg(e) {\n      if (core.isReadOnly || util.isIE) {\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n      }\n\n      var dataTransfer = e.dataTransfer;\n      if (!dataTransfer) return true;\n      core.removeNode();\n\n      event._setDropLocationSelection(e);\n\n      return event._dataTransferAction('drop', e, dataTransfer);\n    },\n    _setDropLocationSelection: function _setDropLocationSelection(e) {\n      if (e.rangeParent) {\n        core.setRange(e.rangeParent, e.rangeOffset, e.rangeParent, e.rangeOffset);\n      } else if (core._wd.caretRangeFromPoint) {\n        var r = core._wd.caretRangeFromPoint(e.clientX, e.clientY);\n\n        core.setRange(r.startContainer, r.startOffset, r.endContainer, r.endOffset);\n      } else {\n        var _r3 = core.getRange();\n\n        core.setRange(_r3.startContainer, _r3.startOffset, _r3.endContainer, _r3.endOffset);\n      }\n    },\n    _dataTransferAction: function _dataTransferAction(type, e, data) {\n      var plainText, cleanData;\n\n      if (util.isIE) {\n        plainText = data.getData('Text');\n        var range = core.getRange();\n        var tempDiv = util.createElement('DIV');\n        var tempRange = {\n          sc: range.startContainer,\n          so: range.startOffset,\n          ec: range.endContainer,\n          eo: range.endOffset\n        };\n        tempDiv.setAttribute('contenteditable', true);\n        tempDiv.style.cssText = 'position:absolute; top:0; left:0; width:1px; height:1px; overflow:hidden;';\n        context.element.relative.appendChild(tempDiv);\n        tempDiv.focus();\n\n        _w.setTimeout(function () {\n          cleanData = tempDiv.innerHTML;\n          util.removeItem(tempDiv);\n          core.setRange(tempRange.sc, tempRange.so, tempRange.ec, tempRange.eo);\n\n          event._setClipboardData(type, e, plainText, cleanData, data);\n        });\n\n        return true;\n      } else {\n        plainText = data.getData('text/plain');\n        cleanData = data.getData('text/html');\n\n        if (event._setClipboardData(type, e, plainText, cleanData, data) === false) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      }\n    },\n    _setClipboardData: function _setClipboardData(type, e, plainText, cleanData, data) {\n      // MS word, OneNode, Excel\n      var MSData = /class=[\"']*Mso(Normal|List)/i.test(cleanData) || /content=[\"']*Word.Document/i.test(cleanData) || /content=[\"']*OneNote.File/i.test(cleanData) || /content=[\"']*Excel.Sheet/i.test(cleanData);\n      var onlyText = !cleanData;\n\n      if (!onlyText) {\n        if (MSData) {\n          cleanData = cleanData.replace(/\\n/g, ' ');\n          plainText = plainText.replace(/\\n/g, ' ');\n        } else {\n          cleanData = (plainText === cleanData ? plainText : cleanData).replace(/\\n/g, '<br>');\n        }\n\n        cleanData = core.cleanHTML(cleanData, core.pasteTagsWhitelistRegExp, core.pasteTagsBlacklistRegExp);\n      } else {\n        cleanData = util._HTMLConvertor(plainText).replace(/\\n/g, '<br>');\n      }\n\n      var maxCharCount = core._charCount(core._charTypeHTML ? cleanData : plainText); // user event - paste\n\n\n      if (type === 'paste' && typeof functions.onPaste === 'function') {\n        var value = functions.onPaste(e, cleanData, maxCharCount, core);\n        if (!value) return false;\n        if (typeof value === 'string') cleanData = value;\n      } // user event - drop\n\n\n      if (type === 'drop' && typeof functions.onDrop === 'function') {\n        var _value = functions.onDrop(e, cleanData, maxCharCount, core);\n\n        if (!_value) return false;\n        if (typeof _value === 'string') cleanData = _value;\n      } // files\n\n\n      var files = data.files;\n\n      if (files.length > 0 && !MSData) {\n        if (/^image/.test(files[0].type) && core.plugins.image) {\n          functions.insertImage(files);\n        }\n\n        return false;\n      }\n\n      if (!maxCharCount) {\n        return false;\n      }\n\n      if (cleanData) {\n        if (util.isListCell(util.getFormatElement(core.getSelectionNode(), null))) {\n          var dom = _d.createRange().createContextualFragment(cleanData);\n\n          var domTree = dom.childNodes;\n          if (domTree.length > 1 && domTree[0].nodeType === 1) cleanData = event._convertListCell(domTree);\n        }\n\n        functions.insertHTML(cleanData, true, false);\n        return false;\n      }\n    },\n    _convertListCell: function _convertListCell(domTree) {\n      var html = '';\n\n      for (var i = 0, len = domTree.length, node; i < len; i++) {\n        node = domTree[i];\n\n        if (node.nodeType === 1) {\n          if (util.isListCell(node) || util.isList(node)) {\n            html += node.outerHTML;\n          } else if (util.isFormatElement(node)) {\n            html += '<li>' + (node.innerHTML.trim() || '<br>') + '</li>';\n          } else if (util.isRangeFormatElement(node) && !util.isTable(node)) {\n            html += event._convertListCell(node);\n          } else {\n            html += '<li>' + node.outerHTML + '</li>';\n          }\n        } else {\n          html += '<li>' + (node.textContent || '<br>') + '</li>';\n        }\n      }\n\n      return html;\n    },\n    onMouseMove_wysiwyg: function onMouseMove_wysiwyg(e) {\n      if (core.isDisabled || core.isReadOnly) return false;\n      var component = util.getParentElement(e.target, util.isComponent);\n      var lineBreakerStyle = core._lineBreaker.style;\n\n      if (component && !core.currentControllerName) {\n        var ctxEl = context.element;\n        var scrollTop = 0;\n        var el = ctxEl.wysiwyg;\n\n        do {\n          scrollTop += el.scrollTop;\n          el = el.parentElement;\n        } while (el && !/^(BODY|HTML)$/i.test(el.nodeName));\n\n        var wScroll = ctxEl.wysiwyg.scrollTop;\n\n        var offsets = event._getEditorOffsets(null);\n\n        var componentTop = util.getOffset(component, ctxEl.wysiwygFrame).top + wScroll;\n        var y = e.pageY + scrollTop + (options.iframe && !options.toolbarContainer ? ctxEl.toolbar.offsetHeight : 0);\n\n        var _c7 = componentTop + (options.iframe ? scrollTop : offsets.top);\n\n        var isList = util.isListCell(component.parentNode);\n        var dir = '',\n            top = '';\n\n        if ((isList ? !component.previousSibling : !util.isFormatElement(component.previousElementSibling)) && y < _c7 + 20) {\n          top = componentTop;\n          dir = 't';\n        } else if ((isList ? !component.nextSibling : !util.isFormatElement(component.nextElementSibling)) && y > _c7 + component.offsetHeight - 20) {\n          top = componentTop + component.offsetHeight;\n          dir = 'b';\n        } else {\n          lineBreakerStyle.display = 'none';\n          return;\n        }\n\n        core._variable._lineBreakComp = component;\n        core._variable._lineBreakDir = dir;\n        lineBreakerStyle.top = top - wScroll + 'px';\n        core._lineBreakerButton.style.left = util.getOffset(component).left + component.offsetWidth / 2 - 15 + 'px';\n        lineBreakerStyle.display = 'block';\n      } // off line breaker\n      else if (lineBreakerStyle.display !== 'none') {\n        lineBreakerStyle.display = 'none';\n      }\n    },\n    _onMouseDown_lineBreak: function _onMouseDown_lineBreak(e) {\n      e.preventDefault();\n    },\n    _onLineBreak: function _onLineBreak(e) {\n      e.preventDefault();\n      var component = core._variable._lineBreakComp;\n      var dir = !this ? core._variable._lineBreakDir : this;\n      var isList = util.isListCell(component.parentNode);\n      var format = util.createElement(isList ? 'BR' : util.isCell(component.parentNode) ? 'DIV' : options.defaultTag);\n      if (!isList) format.innerHTML = '<br>';\n      if (core._charTypeHTML && !core.checkCharCount(format.outerHTML, 'byte-html')) return;\n      component.parentNode.insertBefore(format, dir === 't' ? component : component.nextSibling);\n      core._lineBreaker.style.display = 'none';\n      core._variable._lineBreakComp = null;\n      var focusEl = isList ? format : format.firstChild;\n      core.setRange(focusEl, 1, focusEl, 1); // history stack\n\n      core.history.push(false);\n    },\n    _resizeObserver: null,\n    _toolbarObserver: null,\n    _addEvent: function _addEvent() {\n      var eventWysiwyg = options.iframe ? core._ww : context.element.wysiwyg;\n\n      if (!util.isIE) {\n        this._resizeObserver = new _w.ResizeObserver(function (entries) {\n          core.__callResizeFunction(-1, entries[0]);\n        });\n      }\n      /** toolbar event */\n\n\n      context.element.toolbar.addEventListener('mousedown', event._buttonsEventHandler, false);\n\n      context.element._menuTray.addEventListener('mousedown', event._buttonsEventHandler, false);\n\n      context.element.toolbar.addEventListener('click', event.onClick_toolbar, false);\n      /** editor area */\n\n      eventWysiwyg.addEventListener('mousedown', event.onMouseDown_wysiwyg, false);\n      eventWysiwyg.addEventListener('click', event.onClick_wysiwyg, false);\n      eventWysiwyg.addEventListener(util.isIE ? 'textinput' : 'input', event.onInput_wysiwyg, false);\n      eventWysiwyg.addEventListener('keydown', event.onKeyDown_wysiwyg, false);\n      eventWysiwyg.addEventListener('keyup', event.onKeyUp_wysiwyg, false);\n      eventWysiwyg.addEventListener('paste', event.onPaste_wysiwyg, false);\n      eventWysiwyg.addEventListener('copy', event.onCopy_wysiwyg, false);\n      eventWysiwyg.addEventListener('cut', event.onCut_wysiwyg, false);\n      eventWysiwyg.addEventListener('drop', event.onDrop_wysiwyg, false);\n      eventWysiwyg.addEventListener('scroll', event.onScroll_wysiwyg, false);\n      eventWysiwyg.addEventListener('focus', event.onFocus_wysiwyg, false);\n      eventWysiwyg.addEventListener('blur', event.onBlur_wysiwyg, false);\n      /** line breaker */\n\n      event._lineBreakerBind = {\n        a: event._onLineBreak.bind(''),\n        t: event._onLineBreak.bind('t'),\n        b: event._onLineBreak.bind('b')\n      };\n      eventWysiwyg.addEventListener('mousemove', event.onMouseMove_wysiwyg, false);\n\n      core._lineBreakerButton.addEventListener('mousedown', event._onMouseDown_lineBreak, false);\n\n      core._lineBreakerButton.addEventListener('click', event._lineBreakerBind.a, false);\n\n      context.element.lineBreaker_t.addEventListener('mousedown', event._lineBreakerBind.t, false);\n      context.element.lineBreaker_b.addEventListener('mousedown', event._lineBreakerBind.b, false);\n      /** Events are registered only when there is a table plugin.  */\n\n      if (core.plugins.table) {\n        eventWysiwyg.addEventListener('touchstart', event.onMouseDown_wysiwyg, {\n          passive: true,\n          useCapture: false\n        });\n      }\n      /** code view area auto line */\n\n\n      if (options.height === 'auto' && !options.codeMirrorEditor) {\n        context.element.code.addEventListener('keydown', event._codeViewAutoHeight, false);\n        context.element.code.addEventListener('keyup', event._codeViewAutoHeight, false);\n        context.element.code.addEventListener('paste', event._codeViewAutoHeight, false);\n      }\n      /** resizingBar */\n\n\n      if (context.element.resizingBar) {\n        if (/\\d+/.test(options.height) && options.resizeEnable) {\n          context.element.resizingBar.addEventListener('mousedown', event.onMouseDown_resizingBar, false);\n        } else {\n          util.addClass(context.element.resizingBar, 'se-resizing-none');\n        }\n      }\n      /** set response toolbar */\n\n\n      event._setResponsiveToolbar();\n      /** responsive toolbar observer */\n\n\n      if (!util.isIE) this._toolbarObserver = new _w.ResizeObserver(core.resetResponsiveToolbar);\n      /** window event */\n\n      _w.addEventListener('resize', event.onResize_window, false);\n\n      if (options.stickyToolbar > -1) {\n        _w.addEventListener('scroll', event.onScroll_window, false);\n      }\n    },\n    _removeEvent: function _removeEvent() {\n      var eventWysiwyg = options.iframe ? core._ww : context.element.wysiwyg;\n      context.element.toolbar.removeEventListener('mousedown', event._buttonsEventHandler);\n\n      context.element._menuTray.removeEventListener('mousedown', event._buttonsEventHandler);\n\n      context.element.toolbar.removeEventListener('click', event.onClick_toolbar);\n      eventWysiwyg.removeEventListener('mousedown', event.onMouseDown_wysiwyg);\n      eventWysiwyg.removeEventListener('click', event.onClick_wysiwyg);\n      eventWysiwyg.removeEventListener(util.isIE ? 'textinput' : 'input', event.onInput_wysiwyg);\n      eventWysiwyg.removeEventListener('keydown', event.onKeyDown_wysiwyg);\n      eventWysiwyg.removeEventListener('keyup', event.onKeyUp_wysiwyg);\n      eventWysiwyg.removeEventListener('paste', event.onPaste_wysiwyg);\n      eventWysiwyg.removeEventListener('copy', event.onCopy_wysiwyg);\n      eventWysiwyg.removeEventListener('cut', event.onCut_wysiwyg);\n      eventWysiwyg.removeEventListener('drop', event.onDrop_wysiwyg);\n      eventWysiwyg.removeEventListener('scroll', event.onScroll_wysiwyg);\n      eventWysiwyg.removeEventListener('mousemove', event.onMouseMove_wysiwyg);\n\n      core._lineBreakerButton.removeEventListener('mousedown', event._onMouseDown_lineBreak);\n\n      core._lineBreakerButton.removeEventListener('click', event._lineBreakerBind.a);\n\n      context.element.lineBreaker_t.removeEventListener('mousedown', event._lineBreakerBind.t);\n      context.element.lineBreaker_b.removeEventListener('mousedown', event._lineBreakerBind.b);\n      event._lineBreakerBind = null;\n      eventWysiwyg.removeEventListener('touchstart', event.onMouseDown_wysiwyg, {\n        passive: true,\n        useCapture: false\n      });\n      eventWysiwyg.removeEventListener('focus', event.onFocus_wysiwyg);\n      eventWysiwyg.removeEventListener('blur', event.onBlur_wysiwyg);\n      context.element.code.removeEventListener('keydown', event._codeViewAutoHeight);\n      context.element.code.removeEventListener('keyup', event._codeViewAutoHeight);\n      context.element.code.removeEventListener('paste', event._codeViewAutoHeight);\n\n      if (context.element.resizingBar) {\n        context.element.resizingBar.removeEventListener('mousedown', event.onMouseDown_resizingBar);\n      }\n\n      if (event._resizeObserver) {\n        event._resizeObserver.unobserve(context.element.wysiwygFrame);\n\n        event._resizeObserver = null;\n      }\n\n      if (event._toolbarObserver) {\n        event._toolbarObserver.unobserve(context.element._toolbarShadow);\n\n        event._toolbarObserver = null;\n      }\n\n      _w.removeEventListener('resize', event.onResize_window);\n\n      _w.removeEventListener('scroll', event.onScroll_window);\n    },\n    _setResponsiveToolbar: function _setResponsiveToolbar() {\n      if (_responsiveButtons.length === 0) {\n        _responsiveButtons = null;\n        return;\n      }\n\n      event._responsiveCurrentSize = 'default';\n      var sizeArray = event._responsiveButtonSize = [];\n      var buttonsObj = event._responsiveButtons = {\n        default: _responsiveButtons[0]\n      };\n\n      for (var i = 1, len = _responsiveButtons.length, size, buttonGroup; i < len; i++) {\n        buttonGroup = _responsiveButtons[i];\n        size = buttonGroup[0] * 1;\n        sizeArray.push(size);\n        buttonsObj[size] = buttonGroup[1];\n      }\n\n      sizeArray.sort(function (a, b) {\n        return a - b;\n      }).unshift('default');\n    }\n  };\n  /** functions */\n\n  var functions = {\n    /**\r\n     * @description Core, Util object\r\n     */\n    core: core,\n    util: util,\n\n    /**\r\n     * @description Event functions\r\n     * @param {Object} e Event Object\r\n     * @param {Object} core Core object\r\n     */\n    onload: null,\n    onScroll: null,\n    onMouseDown: null,\n    onClick: null,\n    onInput: null,\n    onKeyDown: null,\n    onKeyUp: null,\n    onCopy: null,\n    onCut: null,\n    onFocus: null,\n    onBlur: null,\n\n    /**\r\n     * @description Event functions\r\n     * @param {String} contents Current contents\r\n     * @param {Object} core Core object\r\n     */\n    onChange: null,\n\n    /**\r\n    * @description Event functions\r\n    * @param {String} contents Current contents\r\n    * @param {Object} core Core object\r\n    */\n    onSave: null,\n\n    /**\r\n     * @description Event functions (drop, paste)\r\n     * When false is returned, the default behavior is stopped.\r\n     * If the string is returned, the cleanData value is modified to the return value.\r\n     * @param {Object} e Event object.\r\n     * @param {String} cleanData HTML string modified for editor format.\r\n     * @param {Boolean} maxChartCount option (true if max character is exceeded)\r\n     * @param {Object} core Core object\r\n     * @returns {Boolean|String}\r\n     */\n    onDrop: null,\n    onPaste: null,\n\n    /**\r\n     * @description Called just before the inline toolbar is positioned and displayed on the screen.\r\n     * @param {Element} toolbar Toolbar Element\r\n     * @param {Object} context The editor's context object (editor.getContext())\r\n     * @param {Object} core Core object\r\n     */\n    showInline: null,\n\n    /**\r\n     * @description Called just after the controller is positioned and displayed on the screen.\r\n     * controller - editing elements displayed on the screen [image resizing, table editor, link editor..]]\r\n     * @param {String} name The name of the plugin that called the controller\r\n     * @param {Array} controllers Array of Controller elements\r\n     * @param {Object} core Core object\r\n     */\n    showController: null,\n\n    /**\r\n     * @description An event when toggling between code view and wysiwyg view.\r\n     * @param {Boolean} isCodeView Whether the current code view mode\r\n     * @param {Object} core Core object\r\n     */\n    toggleCodeView: null,\n\n    /**\r\n     * @description An event when toggling full screen.\r\n     * @param {Boolean} isFullScreen Whether the current full screen mode\r\n     * @param {Object} core Core object\r\n     */\n    toggleFullScreen: null,\n\n    /**\r\n     * @description It replaces the default callback function of the image upload\r\n     * @param {Object} response Response object\r\n     * @param {Object} info Input information\r\n     * - linkValue: Link url value\r\n     * - linkNewWindow: Open in new window Check Value\r\n     * - inputWidth: Value of width input\r\n     * - inputHeight: Value of height input\r\n     * - align: Align Check Value\r\n     * - isUpdate: Update image if true, create image if false\r\n     * - element: If isUpdate is true, the currently selected image.\r\n     * @param {Object} core Core object\r\n     */\n    imageUploadHandler: null,\n\n    /**\r\n     * @description It replaces the default callback function of the video upload\r\n     * @param xmlHttp xmlHttpRequest object\r\n     * @param info Input information\r\n     * - inputWidth: Value of width input\r\n     * - inputHeight: Value of height input\r\n     * - align: Align Check Value\r\n     * - isUpdate: Update video if true, create video if false\r\n     * - element: If isUpdate is true, the currently selected video.\r\n     * @param core Core object\r\n     */\n    videoUploadHandler: null,\n\n    /**\r\n     * @description It replaces the default callback function of the audio upload\r\n     * @param xmlHttp xmlHttpRequest object\r\n     * @param info Input information\r\n     * - isUpdate: Update audio if true, create audio if false\r\n     * - element: If isUpdate is true, the currently selected audio.\r\n     * @param core Core object\r\n     */\n    audioUploadHandler: null,\n\n    /**\r\n     * @description Called before the image is uploaded\r\n     * If true is returned, the internal upload process runs normally.\r\n     * If false is returned, no image upload is performed.\r\n     * If new fileList are returned,  replaced the previous fileList\r\n     * If undefined is returned, it waits until \"uploadHandler\" is executed.\r\n     * @param {Array} files Files array\r\n     * @param {Object} info info: {\r\n     * - linkValue: Link url value\r\n     * - linkNewWindow: Open in new window Check Value\r\n     * - inputWidth: Value of width input\r\n     * - inputHeight: Value of height input\r\n     * - align: Align Check Value\r\n     * - isUpdate: Update image if true, create image if false\r\n     * - element: If isUpdate is true, the currently selected image.\r\n     * }\r\n     * @param {Object} core Core object\r\n     * @param {Function} uploadHandler If undefined is returned, it waits until \"uploadHandler\" is executed.\r\n     *                \"uploadHandler\" is an upload function with \"core\" and \"info\" bound.\r\n     *                [upload files] : uploadHandler(files or [new File(...),])\r\n     *                [error]        : uploadHandler(\"Error message\")\r\n     *                [Just finish]  : uploadHandler()\r\n     *                [directly register] : uploadHandler(response) // Same format as \"imageUploadUrl\" response\r\n     *                                   ex) {\r\n     *                                      // \"errorMessage\": \"insert error message\",\r\n     *                                      \"result\": [ { \"url\": \"...\", \"name\": \"...\", \"size\": \"999\" }, ]\r\n     *                                   }\r\n     * @returns {Boolean|Array|undefined}\r\n     */\n    onImageUploadBefore: null,\n\n    /**\r\n     * @description Called before the video is uploaded\r\n     * If true is returned, the internal upload process runs normally.\r\n     * If false is returned, no video(iframe, video) upload is performed.\r\n     * If new fileList are returned,  replaced the previous fileList\r\n     * If undefined is returned, it waits until \"uploadHandler\" is executed.\r\n     * @param {Array} files Files array\r\n     * @param {Object} info info: {\r\n     * - inputWidth: Value of width input\r\n     * - inputHeight: Value of height input\r\n     * - align: Align Check Value\r\n     * - isUpdate: Update video if true, create video if false\r\n     * - element: If isUpdate is true, the currently selected video.\r\n     * }\r\n     * @param {Object} core Core object\r\n     * @param {Function} uploadHandler If undefined is returned, it waits until \"uploadHandler\" is executed.\r\n     *                \"uploadHandler\" is an upload function with \"core\" and \"info\" bound.\r\n     *                [upload files] : uploadHandler(files or [new File(...),])\r\n     *                [error]        : uploadHandler(\"Error message\")\r\n     *                [Just finish]  : uploadHandler()\r\n     *                [directly register] : uploadHandler(response) // Same format as \"videoUploadUrl\" response\r\n     *                                   ex) {\r\n     *                                      // \"errorMessage\": \"insert error message\",\r\n     *                                      \"result\": [ { \"url\": \"...\", \"name\": \"...\", \"size\": \"999\" }, ]\r\n     *                                   }\r\n     * @returns {Boolean|Array|undefined}\r\n     */\n    onVideoUploadBefore: null,\n\n    /**\r\n     * @description Called before the audio is uploaded\r\n     * If true is returned, the internal upload process runs normally.\r\n     * If false is returned, no audio upload is performed.\r\n     * If new fileList are returned,  replaced the previous fileList\r\n     * If undefined is returned, it waits until \"uploadHandler\" is executed.\r\n     * @param {Array} files Files array\r\n     * @param {Object} info info: {\r\n     * - isUpdate: Update audio if true, create audio if false\r\n     * - element: If isUpdate is true, the currently selected audio.\r\n     * }\r\n     * @param {Object} core Core object\r\n     * @param {Function} uploadHandler If undefined is returned, it waits until \"uploadHandler\" is executed.\r\n     *                \"uploadHandler\" is an upload function with \"core\" and \"info\" bound.\r\n     *                [upload files] : uploadHandler(files or [new File(...),])\r\n     *                [error]        : uploadHandler(\"Error message\")\r\n     *                [Just finish]  : uploadHandler()\r\n     *                [directly register] : uploadHandler(response) // Same format as \"audioUploadUrl\" response\r\n     *                                   ex) {\r\n     *                                      // \"errorMessage\": \"insert error message\",\r\n     *                                      \"result\": [ { \"url\": \"...\", \"name\": \"...\", \"size\": \"999\" }, ]\r\n     *                                   }\r\n     * @returns {Boolean|Array|undefined}\r\n     */\n    onAudioUploadBefore: null,\n\n    /**\r\n     * @description Called when the image is uploaded, updated, deleted\r\n     * @param {Element} targetElement Target element\r\n     * @param {Number} index Uploaded index\r\n     * @param {String} state Upload status ('create', 'update', 'delete')\r\n     * @param {Object} info Image info object\r\n     * - index: data index\r\n     * - name: file name\r\n     * - size: file size\r\n     * - select: select function\r\n     * - delete: delete function\r\n     * - element: target element\r\n     * - src: src attribute of tag\r\n     * @param {Number} remainingFilesCount Count of remaining files to upload (0 when added as a url)\r\n     * @param {Object} core Core object\r\n     */\n    onImageUpload: null,\n\n    /**\r\n    * @description Called when the video(iframe, video) is is uploaded, updated, deleted\r\n    * -- arguments is same \"onImageUpload\" --\r\n    */\n    onVideoUpload: null,\n\n    /**\r\n    * @description Called when the audio is is uploaded, updated, deleted\r\n    * -- arguments is same \"onImageUpload\" --\r\n    */\n    onAudioUpload: null,\n\n    /**\r\n     * @description Called when the image is upload failed\r\n     * @param {String} errorMessage Error message\r\n     * @param {Object} result Response Object\r\n     * @param {Object} core Core object\r\n     * @returns {Boolean}\r\n     */\n    onImageUploadError: null,\n\n    /**\r\n     * @description Called when the video(iframe, video) upload failed\r\n     * -- arguments is same \"onImageUploadError\" --\r\n     */\n    onVideoUploadError: null,\n\n    /**\r\n     * @description Called when the audio upload failed\r\n     * -- arguments is same \"onImageUploadError\" --\r\n     */\n    onAudioUploadError: null,\n\n    /**\r\n     * @description Called when the editor is resized using the bottom bar\r\n     */\n    onResizeEditor: null,\n\n    /**\r\n     * @description Called after the \"setToolbarButtons\" invocation.\r\n     * Can be used to tweak buttons properties (useful for custom buttons)\r\n     * @param {Array} buttonList Button list \r\n     * @param {Object} core Core object\r\n     */\n    onSetToolbarButtons: null,\n\n    /**\r\n     * @description Reset the buttons on the toolbar. (Editor is not reloaded)\r\n     * You cannot set a new plugin for the button.\r\n     * @param {Array} buttonList Button list \r\n     */\n    setToolbarButtons: function setToolbarButtons(buttonList) {\n      core.submenuOff();\n      core.containerOff();\n      core.moreLayerOff();\n\n      var newToolbar = _Constructor._createToolBar(_d, buttonList, core.plugins, options);\n\n      _responsiveButtons = newToolbar.responsiveButtons;\n\n      event._setResponsiveToolbar();\n\n      context.element.toolbar.replaceChild(newToolbar._buttonTray, context.element._buttonTray);\n\n      var newContext = _Context(context.element.originElement, core._getConstructed(context.element), options);\n\n      context.element = newContext.element;\n      context.tool = newContext.tool;\n      if (options.iframe) context.element.wysiwyg = core._wd.body;\n\n      core._recoverButtonStates();\n\n      core._cachingButtons();\n\n      core.history._resetCachingButton();\n\n      core.effectNode = null;\n      if (core.hasFocus) event._applyTagEffects();\n      if (core.isReadOnly) util.setDisabledButtons(true, core.resizingDisabledButtons);\n      if (typeof functions.onSetToolbarButtons === 'function') functions.onSetToolbarButtons(newToolbar._buttonTray.querySelectorAll('button'), core);\n    },\n\n    /**\r\n     * @description Add or reset option property (Editor is reloaded)\r\n     * @param {Object} _options Options\r\n     */\n    setOptions: function setOptions(_options) {\n      event._removeEvent();\n\n      core._resetComponents();\n\n      util.removeClass(core._styleCommandMap.showBlocks, 'active');\n      util.removeClass(core._styleCommandMap.codeView, 'active');\n      core._variable.isCodeView = false;\n      core._iframeAuto = null;\n      core.plugins = _options.plugins || core.plugins;\n      var mergeOptions = [options, _options].reduce(function (init, option) {\n        for (var key in option) {\n          if (!util.hasOwn(option, key)) continue;\n\n          if (key === 'plugins' && option[key] && init[key]) {\n            (function () {\n              var i = init[key],\n                  o = option[key];\n              i = i.length ? i : _w.Object.keys(i).map(function (name) {\n                return i[name];\n              });\n              o = o.length ? o : _w.Object.keys(o).map(function (name) {\n                return o[name];\n              });\n              init[key] = o.filter(function (val) {\n                return i.indexOf(val) === -1;\n              }).concat(i);\n            })();\n          } else {\n            init[key] = option[key];\n          }\n        }\n\n        return init;\n      }, {});\n      var el = context.element;\n      var _initHTML = el.wysiwyg.innerHTML; // set option\n\n      var cons = _Constructor._setOptions(mergeOptions, context, options);\n\n      if (cons.callButtons) {\n        pluginCallButtons = cons.callButtons;\n        core.initPlugins = {};\n      }\n\n      if (cons.plugins) {\n        core.plugins = plugins = cons.plugins;\n      } // reset context\n\n\n      if (el._menuTray.children.length === 0) this._menuTray = {};\n      _responsiveButtons = cons.toolbar.responsiveButtons;\n      core.options = options = mergeOptions;\n      core.lang = lang = options.lang;\n\n      if (options.iframe) {\n        el.wysiwygFrame.addEventListener('load', function () {\n          util._setIframeDocument(this, options);\n\n          core._setOptionsInit(el, _initHTML);\n        });\n      }\n\n      el.editorArea.appendChild(el.wysiwygFrame);\n\n      if (!options.iframe) {\n        core._setOptionsInit(el, _initHTML);\n      }\n    },\n\n    /**\r\n     * @description Set \"options.defaultStyle\" style.\r\n     * Define the style of the edit area\r\n     * It can also be defined with the \"setOptions\" method, but the \"setDefaultStyle\" method does not render the editor again.\r\n     * @param {String} style Style string\r\n     */\n    setDefaultStyle: function setDefaultStyle(style) {\n      var newStyles = options._editorStyles = util._setDefaultOptionStyle(options, style);\n\n      var el = context.element; // top area\n\n      el.topArea.style.cssText = newStyles.top; // code view\n\n      el.code.style.cssText = options._editorStyles.frame;\n      el.code.style.display = 'none';\n\n      if (options.height === 'auto') {\n        el.code.style.overflow = 'hidden';\n      } else {\n        el.code.style.overflow = '';\n      } // wysiwyg frame\n\n\n      if (!options.iframe) {\n        el.wysiwygFrame.style.cssText = newStyles.frame + newStyles.editor;\n      } else {\n        el.wysiwygFrame.style.cssText = newStyles.frame;\n        el.wysiwyg.style.cssText = newStyles.editor;\n      }\n    },\n\n    /**\r\n     * @description Open a notice area\r\n     * @param {String} message Notice message\r\n     */\n    noticeOpen: function noticeOpen(message) {\n      core.notice.open.call(core, message);\n    },\n\n    /**\r\n     * @description Close a notice area\r\n     */\n    noticeClose: function noticeClose() {\n      core.notice.close.call(core);\n    },\n\n    /**\r\n     * @description Copying the contents of the editor to the original textarea and execute onSave callback\r\n     */\n    save: function save() {\n      var contents = core.getContents(false);\n      context.element.originElement.value = contents;\n      event.onSave_wysiwyg(contents, core);\n    },\n\n    /**\r\n     * @description Gets the suneditor's context object. Contains settings, plugins, and cached element objects\r\n     * @returns {Object}\r\n     */\n    getContext: function getContext() {\n      return context;\n    },\n\n    /**\r\n     * @description Gets the contents of the suneditor\r\n     * @param {Boolean} onlyContents - Return only the contents of the body without headers when the \"fullPage\" option is true\r\n     * @returns {String}\r\n     */\n    getContents: function getContents(onlyContents) {\n      return core.getContents(onlyContents);\n    },\n\n    /**\r\n     * @description Gets only the text of the suneditor contents\r\n     * @returns {String}\r\n     */\n    getText: function getText() {\n      return context.element.wysiwyg.textContent;\n    },\n\n    /**\r\n     * @description Get the editor's number of characters or binary data size.\r\n     * You can use the \"charCounterType\" option format.\r\n     * @param {String|null} charCounterType options - charCounterType ('char', 'byte', 'byte-html')\r\n     * If argument is no value, the currently set \"charCounterType\" option is used.\r\n     * @returns {Number}\r\n     */\n    getCharCount: function getCharCount(charCounterType) {\n      charCounterType = typeof charCounterType === 'string' ? charCounterType : options.charCounterType;\n      return core.getCharLength(core._charTypeHTML ? context.element.wysiwyg.innerHTML : context.element.wysiwyg.textContent, charCounterType);\n    },\n\n    /**\r\n     * @description Gets uploaded images informations\r\n     * - index: data index\r\n     * - name: file name\r\n     * - size: file size\r\n     * - select: select function\r\n     * - delete: delete function\r\n     * - element: target element\r\n     * - src: src attribute of tag\r\n     * @returns {Array}\r\n     */\n    getImagesInfo: function getImagesInfo() {\n      return context.image ? context.image._infoList : [];\n    },\n\n    /**\r\n     * @description Gets uploaded files(plugin using fileManager) information list.\r\n     * image: [img], video: [video, iframe], audio: [audio]\r\n     * When the argument value is 'image', it is the same function as \"getImagesInfo\".\r\n     * - index: data index\r\n     * - name: file name\r\n     * - size: file size\r\n     * - select: select function\r\n     * - delete: delete function\r\n     * - element: target element\r\n     * - src: src attribute of tag\r\n     * @param {String} pluginName Plugin name (image, video, audio)\r\n     * @returns {Array}\r\n     */\n    getFilesInfo: function getFilesInfo(pluginName) {\n      return context[pluginName] ? context[pluginName]._infoList : [];\n    },\n\n    /**\r\n     * @description Upload images using image plugin\r\n     * @param {FileList} files FileList\r\n     */\n    insertImage: function insertImage(files) {\n      if (!core.plugins.image || !files) return;\n      if (!core.initPlugins.image) core.callPlugin('image', core.plugins.image.submitAction.bind(core, files), null);else core.plugins.image.submitAction.call(core, files);\n      core.focus();\n    },\n\n    /**\r\n     * @description Inserts an HTML element or HTML string or plain string at the current cursor position\r\n     * @param {Element|String} html HTML Element or HTML string or plain string\r\n     * @param {Boolean} notCleaningData If true, inserts the HTML string without refining it with core.cleanHTML.\r\n     * @param {Boolean} checkCharCount If true, if \"options.maxCharCount\" is exceeded when \"element\" is added, null is returned without addition.\r\n     * @param {Boolean} rangeSelection If true, range select the inserted node.\r\n     */\n    insertHTML: function insertHTML(html, notCleaningData, checkCharCount, rangeSelection) {\n      if (!context.element.wysiwygFrame.contains(core.getSelection().focusNode)) core.focus();\n\n      if (typeof html === 'string') {\n        if (!notCleaningData) html = core.cleanHTML(html, null, null);\n\n        try {\n          var dom = _d.createRange().createContextualFragment(html);\n\n          var domTree = dom.childNodes;\n\n          if (checkCharCount) {\n            var type = core._charTypeHTML ? 'outerHTML' : 'textContent';\n            var checkHTML = '';\n\n            for (var i = 0, len = domTree.length; i < len; i++) {\n              checkHTML += domTree[i][type];\n            }\n\n            if (!core.checkCharCount(checkHTML, null)) return;\n          }\n\n          var _c8, a, t, prev, firstCon;\n\n          while (_c8 = domTree[0]) {\n            if (prev && prev.nodeType === 3 && a && a.nodeType === 1 && util.isBreak(_c8)) {\n              prev = _c8;\n              util.removeItem(_c8);\n              continue;\n            }\n\n            t = core.insertNode(_c8, a, false);\n            a = t.container || t;\n            if (!firstCon) firstCon = t;\n            prev = _c8;\n          }\n\n          if (prev.nodeType === 3 && a.nodeType === 1) a = prev;\n          var offset = a.nodeType === 3 ? t.endOffset || a.textContent.length : a.childNodes.length;\n          if (rangeSelection) core.setRange(firstCon.container || firstCon, firstCon.startOffset || 0, a, offset);else core.setRange(a, offset, a, offset);\n        } catch (error) {\n          if (core.isDisabled || core.isReadOnly) return;\n          console.warn('[SUNEDITOR.insertHTML.fail] ' + error);\n          core.execCommand('insertHTML', false, html);\n        }\n      } else {\n        if (util.isComponent(html)) {\n          core.insertComponent(html, false, checkCharCount, false);\n        } else {\n          var afterNode = null;\n\n          if (util.isFormatElement(html) || util.isMedia(html)) {\n            afterNode = util.getFormatElement(core.getSelectionNode(), null);\n          }\n\n          core.insertNode(html, afterNode, checkCharCount);\n        }\n      }\n\n      core.effectNode = null;\n      core.focus(); // history stack\n\n      core.history.push(false);\n    },\n\n    /**\r\n     * @description Change the contents of the suneditor\r\n     * @param {String|undefined} contents Contents to Input\r\n     */\n    setContents: function setContents(contents) {\n      core.setContents(contents);\n    },\n\n    /**\r\n     * @description Add contents to the suneditor\r\n     * @param {String} contents Contents to Input\r\n     */\n    appendContents: function appendContents(contents) {\n      var convertValue = core.convertContentsForEditor(contents);\n\n      if (!core._variable.isCodeView) {\n        var temp = util.createElement('DIV');\n        temp.innerHTML = convertValue;\n        var wysiwyg = context.element.wysiwyg;\n        var children = temp.children;\n\n        for (var i = 0, len = children.length; i < len; i++) {\n          if (children[i]) {\n            wysiwyg.appendChild(children[i]);\n          }\n        }\n      } else {\n        core._setCodeView(core._getCodeView() + '\\n' + core.convertHTMLForCodeView(convertValue, false));\n      } // history stack\n\n\n      core.history.push(false);\n    },\n\n    /**\r\n     * @description Switch to or off \"ReadOnly\" mode.\r\n     * @param {Boolean} value \"readOnly\" boolean value.\r\n     */\n    readOnly: function readOnly(value) {\n      core.isReadOnly = value;\n      util.setDisabledButtons(!!value, core.resizingDisabledButtons);\n\n      if (value) {\n        /** off menus */\n        core.controllersOff();\n        if (core.submenuActiveButton && core.submenuActiveButton.disabled) core.submenuOff();\n        if (core._moreLayerActiveButton && core._moreLayerActiveButton.disabled) core.moreLayerOff();\n        if (core.containerActiveButton && core.containerActiveButton.disabled) core.containerOff();\n        if (core.modalForm) core.plugins.dialog.close.call(core);\n        context.element.code.setAttribute(\"readOnly\", \"true\");\n        util.addClass(context.element.wysiwygFrame, 'se-read-only');\n      } else {\n        context.element.code.removeAttribute(\"readOnly\");\n        util.removeClass(context.element.wysiwygFrame, 'se-read-only');\n      }\n\n      if (options.codeMirrorEditor) options.codeMirrorEditor.setOption('readOnly', !!value);\n    },\n\n    /**\r\n     * @description Disable the suneditor\r\n     */\n    disable: function disable() {\n      this.toolbar.disable();\n      this.wysiwyg.disable();\n    },\n\n    /**\r\n     * @description Provided for backward compatibility and will be removed in 3.0.0 version\r\n     */\n    disabled: function disabled() {\n      this.disable();\n    },\n\n    /**\r\n     * @description Enable the suneditor\r\n     */\n    enable: function enable() {\n      this.toolbar.enable();\n      this.wysiwyg.enable();\n    },\n\n    /**\r\n     * @description Provided for backward compatibility and will be removed in 3.0.0 version\r\n     */\n    enabled: function enabled() {\n      this.enable();\n    },\n\n    /**\r\n     * @description Show the suneditor\r\n     */\n    show: function show() {\n      var topAreaStyle = context.element.topArea.style;\n      if (topAreaStyle.display === 'none') topAreaStyle.display = options.display;\n    },\n\n    /**\r\n     * @description Hide the suneditor\r\n     */\n    hide: function hide() {\n      context.element.topArea.style.display = 'none';\n    },\n\n    /**\r\n     * @description Destroy the suneditor\r\n     */\n    destroy: function destroy() {\n      /** off menus */\n      core.submenuOff();\n      core.containerOff();\n      core.controllersOff();\n      if (core.notice) core.notice.close.call(core);\n      if (core.modalForm) core.plugins.dialog.close.call(core);\n      /** remove history */\n\n      core.history._destroy();\n      /** remove event listeners */\n\n\n      event._removeEvent();\n      /** remove element */\n\n\n      util.removeItem(context.element.toolbar);\n      util.removeItem(context.element.topArea);\n      /** remove object reference */\n\n      for (var k in core.functions) {\n        if (util.hasOwn(core, k)) delete core.functions[k];\n      }\n\n      for (var _k2 in core) {\n        if (util.hasOwn(core, _k2)) delete core[_k2];\n      }\n\n      for (var _k3 in event) {\n        if (util.hasOwn(event, _k3)) delete event[_k3];\n      }\n\n      for (var _k4 in context) {\n        if (util.hasOwn(context, _k4)) delete context[_k4];\n      }\n\n      for (var _k5 in pluginCallButtons) {\n        if (util.hasOwn(pluginCallButtons, _k5)) delete pluginCallButtons[_k5];\n      }\n      /** remove user object */\n\n\n      for (var _k6 in this) {\n        if (util.hasOwn(this, _k6)) delete this[_k6];\n      }\n    },\n\n    /**\r\n     * @description Toolbar methods\r\n     */\n    toolbar: {\n      /**\r\n       * @description Disable the toolbar\r\n       */\n      disable: function disable() {\n        /** off menus */\n        core.submenuOff();\n        core.moreLayerOff();\n        core.containerOff();\n        context.tool.cover.style.display = 'block';\n      },\n\n      /**\r\n       * @description Provided for backward compatibility and will be removed in 3.0.0 version\r\n       */\n      disabled: function disabled() {\n        this.disable();\n      },\n\n      /**\r\n       * @description Enable the toolbar\r\n       */\n      enable: function enable() {\n        context.tool.cover.style.display = 'none';\n      },\n\n      /**\r\n       * @description Provided for backward compatibility and will be removed in 3.0.0 version\r\n       */\n      enabled: function enabled() {\n        this.enable();\n      },\n\n      /**\r\n       * @description Show the toolbar\r\n       */\n      show: function show() {\n        if (core._isInline) {\n          event._showToolbarInline();\n        } else {\n          context.element.toolbar.style.display = '';\n          context.element._stickyDummy.style.display = '';\n        }\n      },\n\n      /**\r\n       * @description Hide the toolbar\r\n       */\n      hide: function hide() {\n        if (core._isInline) {\n          event._hideToolbar();\n        } else {\n          context.element.toolbar.style.display = 'none';\n          context.element._stickyDummy.style.display = 'none';\n        }\n      }\n    },\n\n    /**\r\n     * @description Wysiwyg methods\r\n     */\n    wysiwyg: {\n      /**\r\n       * @description Disable the wysiwyg area\r\n       */\n      disable: function disable() {\n        /** off menus */\n        core.controllersOff();\n        if (core.modalForm) core.plugins.dialog.close.call(core);\n        context.element.wysiwyg.setAttribute('contenteditable', false);\n        core.isDisabled = true;\n\n        if (options.codeMirrorEditor) {\n          options.codeMirrorEditor.setOption('readOnly', true);\n        } else {\n          context.element.code.setAttribute('disabled', 'disabled');\n        }\n      },\n\n      /**\r\n       * @description Enable the wysiwyg area\r\n       */\n      enable: function enable() {\n        context.element.wysiwyg.setAttribute('contenteditable', true);\n        core.isDisabled = false;\n\n        if (options.codeMirrorEditor) {\n          options.codeMirrorEditor.setOption('readOnly', false);\n        } else {\n          context.element.code.removeAttribute('disabled');\n        }\n      }\n    }\n  };\n  /************ Core init ************/\n  // functions\n\n  core.functions = functions;\n  core.options = options; // Create to sibling node\n\n  var contextEl = context.element;\n  var originEl = contextEl.originElement;\n  var topEl = contextEl.topArea;\n  originEl.style.display = 'none';\n  topEl.style.display = 'block'; // init\n\n  if (options.iframe) {\n    contextEl.wysiwygFrame.addEventListener('load', function () {\n      util._setIframeDocument(this, options);\n\n      core._editorInit(false, options.value);\n\n      options.value = null;\n    });\n  } // insert editor element\n\n\n  if (typeof originEl.nextElementSibling === 'object') {\n    originEl.parentNode.insertBefore(topEl, originEl.nextElementSibling);\n  } else {\n    originEl.parentNode.appendChild(topEl);\n  }\n\n  contextEl.editorArea.appendChild(contextEl.wysiwygFrame);\n  contextEl = originEl = topEl = null; // init\n\n  if (!options.iframe) {\n    core._editorInit(false, options.value);\n\n    options.value = null;\n  }\n\n  return functions;\n}","map":null,"metadata":{},"sourceType":"module"}