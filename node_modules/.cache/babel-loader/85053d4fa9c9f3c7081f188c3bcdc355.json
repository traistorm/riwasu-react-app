{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/inputcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The input command. Used by the {@link module:typing/input~Input input feature} to handle typing.\n *\n * @extends module:core/command~Command\n */\n\nvar InputCommand = /*#__PURE__*/function (_Command) {\n  _inherits(InputCommand, _Command);\n\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {Number} undoStepSize The maximum number of atomic changes\n   * which can be contained in one batch in the command buffer.\n   */\n  function InputCommand(editor, undoStepSize) {\n    var _this;\n\n    _classCallCheck(this, InputCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InputCommand).call(this, editor));\n    /**\n     * Typing's change buffer used to group subsequent changes into batches.\n     *\n     * @readonly\n     * @private\n     * @member {module:typing/utils/changebuffer~ChangeBuffer} #_buffer\n     */\n\n    _this._buffer = new ChangeBuffer(editor.model, undoStepSize);\n    return _this;\n  }\n  /**\n   * The current change buffer.\n   *\n   * @type {module:typing/utils/changebuffer~ChangeBuffer}\n   */\n\n\n  _createClass(InputCommand, [{\n    key: \"destroy\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function destroy() {\n      _get(_getPrototypeOf(InputCommand.prototype), \"destroy\", this).call(this);\n\n      this._buffer.destroy();\n    }\n    /**\n     * Executes the input command. It replaces the content within the given range with the given text.\n     * Replacing is a two step process, first the content within the range is removed and then the new text is inserted\n     * at the beginning of the range (which after the removal is a collapsed range).\n     *\n     * @fires execute\n     * @param {Object} [options] The command options.\n     * @param {String} [options.text=''] The text to be inserted.\n     * @param {module:engine/model/range~Range} [options.range] The range in which the text is inserted. Defaults\n     * to the first range in the current selection.\n     * @param {module:engine/model/range~Range} [options.resultRange] The range where the selection\n     * should be placed after the insertion. If not specified, the selection will be placed right after\n     * the inserted text.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.editor.model;\n      var doc = model.document;\n      var text = options.text || '';\n      var textInsertions = text.length;\n      var selection = options.range ? model.createSelection(options.range) : doc.selection;\n      var resultRange = options.resultRange;\n      model.enqueueChange(this._buffer.batch, function (writer) {\n        _this2._buffer.lock();\n\n        model.deleteContent(selection);\n\n        if (text) {\n          model.insertContent(writer.createText(text, doc.selection.getAttributes()), selection);\n        }\n\n        if (resultRange) {\n          writer.setSelection(resultRange);\n        } else if (!selection.is('documentSelection')) {\n          writer.setSelection(selection);\n        }\n\n        _this2._buffer.unlock();\n\n        _this2._buffer.input(textInsertions);\n      });\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buffer;\n    }\n  }]);\n\n  return InputCommand;\n}(Command);\n\nexport { InputCommand as default };","map":null,"metadata":{},"sourceType":"module"}