{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module upload/filerepository\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport PendingActions from '@ckeditor/ckeditor5-core/src/pendingactions';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport FileReader from './filereader.js';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid.js';\n/**\n * File repository plugin. A central point for managing file upload.\n *\n * To use it, first you need an upload adapter. Upload adapter's job is to handle communication with the server\n * (sending the file and handling server's response). You can use one of the existing plugins introducing upload adapters\n * (e.g. {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter} or\n * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}) or write your own one â€“ see\n * the {@glink framework/guides/deep-dive/upload-adapter Custom image upload adapter deep dive guide}.\n *\n * Then, you can use {@link module:upload/filerepository~FileRepository#createLoader `createLoader()`} and the returned\n * {@link module:upload/filerepository~FileLoader} instance to load and upload files.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar FileRepository = /*#__PURE__*/function (_Plugin) {\n  _inherits(FileRepository, _Plugin);\n\n  function FileRepository() {\n    _classCallCheck(this, FileRepository);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FileRepository).apply(this, arguments));\n  }\n\n  _createClass(FileRepository, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      /**\n       * Collection of loaders associated with this repository.\n       *\n       * @member {module:utils/collection~Collection} #loaders\n       */\n      this.loaders = new Collection(); // Keeps upload in a sync with pending actions.\n\n      this.loaders.on('add', function () {\n        return _this._updatePendingAction();\n      });\n      this.loaders.on('remove', function () {\n        return _this._updatePendingAction();\n      });\n      /**\n       * Loaders mappings used to retrieve loaders references.\n       *\n       * @private\n       * @member {Map<File|Promise, FileLoader>} #_loadersMap\n       */\n\n      this._loadersMap = new Map();\n      /**\n       * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin\n       * while upload is in progress. When there is no upload then value is `null`.\n       *\n       * @private\n       * @member {Object} #_pendingAction\n       */\n\n      this._pendingAction = null;\n      /**\n       * A factory function which should be defined before using `FileRepository`.\n       *\n       * It should return a new instance of {@link module:upload/filerepository~UploadAdapter} that will be used to upload files.\n       * {@link module:upload/filerepository~FileLoader} instance associated with the adapter\n       * will be passed to that function.\n       *\n       * For more information and example see {@link module:upload/filerepository~UploadAdapter}.\n       *\n       * @member {Function} #createUploadAdapter\n       */\n\n      /**\n       * Number of bytes uploaded.\n       *\n       * @readonly\n       * @observable\n       * @member {Number} #uploaded\n       */\n\n      this.set('uploaded', 0);\n      /**\n       * Number of total bytes to upload.\n       *\n       * It might be different than the file size because of headers and additional data.\n       * It contains `null` if value is not available yet, so it's better to use {@link #uploadedPercent} to monitor\n       * the progress.\n       *\n       * @readonly\n       * @observable\n       * @member {Number|null} #uploadTotal\n       */\n\n      this.set('uploadTotal', null);\n      /**\n       * Upload progress in percents.\n       *\n       * @readonly\n       * @observable\n       * @member {Number} #uploadedPercent\n       */\n\n      this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', function (uploaded, total) {\n        return total ? uploaded / total * 100 : 0;\n      });\n    }\n    /**\n     * Returns the loader associated with specified file or promise.\n     *\n     * To get loader by id use `fileRepository.loaders.get( id )`.\n     *\n     * @param {File|Promise.<File>} fileOrPromise Native file or promise handle.\n     * @returns {module:upload/filerepository~FileLoader|null}\n     */\n\n  }, {\n    key: \"getLoader\",\n    value: function getLoader(fileOrPromise) {\n      return this._loadersMap.get(fileOrPromise) || null;\n    }\n    /**\n     * Creates a loader instance for the given file.\n     *\n     * Requires {@link #createUploadAdapter} factory to be defined.\n     *\n     * @param {File|Promise.<File>} fileOrPromise Native File object or native Promise object which resolves to a File.\n     * @returns {module:upload/filerepository~FileLoader|null}\n     */\n\n  }, {\n    key: \"createLoader\",\n    value: function createLoader(fileOrPromise) {\n      var _this2 = this;\n\n      if (!this.createUploadAdapter) {\n        /**\n         * You need to enable an upload adapter in order to be able to upload files.\n         *\n         * This warning shows up when {@link module:upload/filerepository~FileRepository} is being used\n         * without {@link #createUploadAdapter defining an upload adapter}.\n         *\n         * **If you see this warning when using one of the {@glink installation/advanced/alternative-setups/predefined-builds\n         * CKEditor 5 Builds}**\n         * it means that you did not configure any of the upload adapters available by default in those builds.\n         *\n         * See the {@glink features/images/image-upload/image-upload comprehensive \"Image upload overview\"} to learn which upload\n         * adapters are available in the builds and how to configure them.\n         *\n         * **If you see this warning when using a custom build** there is a chance that you enabled\n         * a feature like {@link module:image/imageupload~ImageUpload},\n         * or {@link module:image/imageupload/imageuploadui~ImageUploadUI} but you did not enable any upload adapter.\n         * You can choose one of the existing upload adapters listed in the\n         * {@glink features/images/image-upload/image-upload \"Image upload overview\"}.\n         *\n         * You can also implement your {@glink framework/guides/deep-dive/upload-adapter own image upload adapter}.\n         *\n         * @error filerepository-no-upload-adapter\n         */\n        logWarning('filerepository-no-upload-adapter');\n        return null;\n      }\n\n      var loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);\n      this.loaders.add(loader);\n\n      this._loadersMap.set(fileOrPromise, loader); // Store also file => loader mapping so loader can be retrieved by file instance returned upon Promise resolution.\n\n\n      if (fileOrPromise instanceof Promise) {\n        loader.file.then(function (file) {\n          _this2._loadersMap.set(file, loader);\n        }) // Every then() must have a catch().\n        // File loader state (and rejections) are handled in read() and upload().\n        // Also, see the \"does not swallow the file promise rejection\" test.\n        .catch(function () {});\n      }\n\n      loader.on('change:uploaded', function () {\n        var aggregatedUploaded = 0;\n\n        var _iterator = _createForOfIteratorHelper(_this2.loaders),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _loader = _step.value;\n            aggregatedUploaded += _loader.uploaded;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        _this2.uploaded = aggregatedUploaded;\n      });\n      loader.on('change:uploadTotal', function () {\n        var aggregatedTotal = 0;\n\n        var _iterator2 = _createForOfIteratorHelper(_this2.loaders),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _loader2 = _step2.value;\n\n            if (_loader2.uploadTotal) {\n              aggregatedTotal += _loader2.uploadTotal;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        _this2.uploadTotal = aggregatedTotal;\n      });\n      return loader;\n    }\n    /**\n     * Destroys the given loader.\n     *\n     * @param {File|Promise|module:upload/filerepository~FileLoader} fileOrPromiseOrLoader File or Promise associated\n     * with that loader or loader itself.\n     */\n\n  }, {\n    key: \"destroyLoader\",\n    value: function destroyLoader(fileOrPromiseOrLoader) {\n      var _this3 = this;\n\n      var loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);\n\n      loader._destroy();\n\n      this.loaders.remove(loader);\n\n      this._loadersMap.forEach(function (value, key) {\n        if (value === loader) {\n          _this3._loadersMap.delete(key);\n        }\n      });\n    }\n    /**\n     * Registers or deregisters pending action bound with upload progress.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updatePendingAction\",\n    value: function _updatePendingAction() {\n      var pendingActions = this.editor.plugins.get(PendingActions);\n\n      if (this.loaders.length) {\n        if (!this._pendingAction) {\n          var t = this.editor.t;\n\n          var getMessage = function getMessage(value) {\n            return \"\".concat(t('Upload in progress'), \" \").concat(parseInt(value), \"%.\");\n          };\n\n          this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));\n\n          this._pendingAction.bind('message').to(this, 'uploadedPercent', getMessage);\n        }\n      } else {\n        pendingActions.remove(this._pendingAction);\n        this._pendingAction = null;\n      }\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'FileRepository';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"requires\",\n    get: function get() {\n      return [PendingActions];\n    }\n  }]);\n\n  return FileRepository;\n}(Plugin);\n\nexport { FileRepository as default };\nmix(FileRepository, ObservableMixin);\n/**\n * File loader class.\n *\n * It is used to control the process of reading the file and uploading it using the specified upload adapter.\n */\n\nvar FileLoader = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of `FileLoader`.\n   *\n   * @param {Promise.<File>} filePromise A promise which resolves to a file instance.\n   * @param {Function} uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.\n   */\n  function FileLoader(filePromise, uploadAdapterCreator) {\n    _classCallCheck(this, FileLoader);\n\n    /**\n     * Unique id of FileLoader instance.\n     *\n     * @readonly\n     * @member {Number}\n     */\n    this.id = uid();\n    /**\n     * Additional wrapper over the initial file promise passed to this loader.\n     *\n     * @protected\n     * @member {module:upload/filerepository~FilePromiseWrapper}\n     */\n\n    this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);\n    /**\n     * Adapter instance associated with this file loader.\n     *\n     * @private\n     * @member {module:upload/filerepository~UploadAdapter}\n     */\n\n    this._adapter = uploadAdapterCreator(this);\n    /**\n     * FileReader used by FileLoader.\n     *\n     * @protected\n     * @member {module:upload/filereader~FileReader}\n     */\n\n    this._reader = new FileReader();\n    /**\n     * Current status of FileLoader. It can be one of the following:\n     *\n     * * 'idle',\n     * * 'reading',\n     * * 'uploading',\n     * * 'aborted',\n     * * 'error'.\n     *\n     * When reading status can change in a following way:\n     *\n     * `idle` -> `reading` -> `idle`\n     * `idle` -> `reading -> `aborted`\n     * `idle` -> `reading -> `error`\n     *\n     * When uploading status can change in a following way:\n     *\n     * `idle` -> `uploading` -> `idle`\n     * `idle` -> `uploading` -> `aborted`\n     * `idle` -> `uploading` -> `error`\n     *\n     * @readonly\n     * @observable\n     * @member {String} #status\n     */\n\n    this.set('status', 'idle');\n    /**\n     * Number of bytes uploaded.\n     *\n     * @readonly\n     * @observable\n     * @member {Number} #uploaded\n     */\n\n    this.set('uploaded', 0);\n    /**\n     * Number of total bytes to upload.\n     *\n     * @readonly\n     * @observable\n     * @member {Number|null} #uploadTotal\n     */\n\n    this.set('uploadTotal', null);\n    /**\n     * Upload progress in percents.\n     *\n     * @readonly\n     * @observable\n     * @member {Number} #uploadedPercent\n     */\n\n    this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', function (uploaded, total) {\n      return total ? uploaded / total * 100 : 0;\n    });\n    /**\n     * Response of the upload.\n     *\n     * @readonly\n     * @observable\n     * @member {Object|null} #uploadResponse\n     */\n\n    this.set('uploadResponse', null);\n  }\n  /**\n   * A `Promise` which resolves to a `File` instance associated with this file loader.\n   *\n   * @type {Promise.<File|null>}\n   */\n\n\n  _createClass(FileLoader, [{\n    key: \"read\",\n\n    /**\n     * Reads file using {@link module:upload/filereader~FileReader}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status\n     * is different than `idle`.\n     *\n     * Example usage:\n     *\n     *\tfileLoader.read()\n     *\t\t.then( data => { ... } )\n     *\t\t.catch( err => {\n     *\t\t\tif ( err === 'aborted' ) {\n     *\t\t\t\tconsole.log( 'Reading aborted.' );\n     *\t\t\t} else {\n     *\t\t\t\tconsole.log( 'Reading error.', err );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @returns {Promise.<String>} Returns promise that will be resolved with read data. Promise will be rejected if error\n     * occurs or if read process is aborted.\n     */\n    value: function read() {\n      var _this4 = this;\n\n      if (this.status != 'idle') {\n        /**\n         * You cannot call read if the status is different than idle.\n         *\n         * @error filerepository-read-wrong-status\n         */\n        throw new CKEditorError('filerepository-read-wrong-status', this);\n      }\n\n      this.status = 'reading';\n      return this.file.then(function (file) {\n        return _this4._reader.read(file);\n      }).then(function (data) {\n        // Edge case: reader was aborted after file was read - double check for proper status.\n        // It can happen when image was deleted during its upload.\n        if (_this4.status !== 'reading') {\n          throw _this4.status;\n        }\n\n        _this4.status = 'idle';\n        return data;\n      }).catch(function (err) {\n        if (err === 'aborted') {\n          _this4.status = 'aborted';\n          throw 'aborted';\n        }\n\n        _this4.status = 'error';\n        throw _this4._reader.error ? _this4._reader.error : err;\n      });\n    }\n    /**\n     * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status\n     * is different than `idle`.\n     * Example usage:\n     *\n     *\tfileLoader.upload()\n     *\t\t.then( data => { ... } )\n     *\t\t.catch( e => {\n     *\t\t\tif ( e === 'aborted' ) {\n     *\t\t\t\tconsole.log( 'Uploading aborted.' );\n     *\t\t\t} else {\n     *\t\t\t\tconsole.log( 'Uploading error.', e );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @returns {Promise.<Object>} Returns promise that will be resolved with response data. Promise will be rejected if error\n     * occurs or if read process is aborted.\n     */\n\n  }, {\n    key: \"upload\",\n    value: function upload() {\n      var _this5 = this;\n\n      if (this.status != 'idle') {\n        /**\n         * You cannot call upload if the status is different than idle.\n         *\n         * @error filerepository-upload-wrong-status\n         */\n        throw new CKEditorError('filerepository-upload-wrong-status', this);\n      }\n\n      this.status = 'uploading';\n      return this.file.then(function () {\n        return _this5._adapter.upload();\n      }).then(function (data) {\n        _this5.uploadResponse = data;\n        _this5.status = 'idle';\n        return data;\n      }).catch(function (err) {\n        if (_this5.status === 'aborted') {\n          throw 'aborted';\n        }\n\n        _this5.status = 'error';\n        throw err;\n      });\n    }\n    /**\n     * Aborts loading process.\n     */\n\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      var status = this.status;\n      this.status = 'aborted';\n\n      if (!this._filePromiseWrapper.isFulfilled) {\n        // Edge case: file loader is aborted before read() is called\n        // so it might happen that no one handled the rejection of this promise.\n        // See https://github.com/ckeditor/ckeditor5-upload/pull/100\n        this._filePromiseWrapper.promise.catch(function () {});\n\n        this._filePromiseWrapper.rejecter('aborted');\n      } else if (status == 'reading') {\n        this._reader.abort();\n      } else if (status == 'uploading' && this._adapter.abort) {\n        this._adapter.abort();\n      }\n\n      this._destroy();\n    }\n    /**\n     * Performs cleanup.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this._filePromiseWrapper = undefined;\n      this._reader = undefined;\n      this._adapter = undefined;\n      this.uploadResponse = undefined;\n    }\n    /**\n     * Wraps a given file promise into another promise giving additional\n     * control (resolving, rejecting, checking if fulfilled) over it.\n     *\n     * @private\n     * @param filePromise The initial file promise to be wrapped.\n     * @returns {module:upload/filerepository~FilePromiseWrapper}\n     */\n\n  }, {\n    key: \"_createFilePromiseWrapper\",\n    value: function _createFilePromiseWrapper(filePromise) {\n      var wrapper = {};\n      wrapper.promise = new Promise(function (resolve, reject) {\n        wrapper.rejecter = reject;\n        wrapper.isFulfilled = false;\n        filePromise.then(function (file) {\n          wrapper.isFulfilled = true;\n          resolve(file);\n        }).catch(function (err) {\n          wrapper.isFulfilled = true;\n          reject(err);\n        });\n      });\n      return wrapper;\n    }\n  }, {\n    key: \"file\",\n    get: function get() {\n      var _this6 = this;\n\n      if (!this._filePromiseWrapper) {\n        // Loader was destroyed, return promise which resolves to null.\n        return Promise.resolve(null);\n      } else {\n        // The `this._filePromiseWrapper.promise` is chained and not simply returned to handle a case when:\n        //\n        //\t\t* The `loader.file.then( ... )` is called by external code (returned promise is pending).\n        //\t\t* Then `loader._destroy()` is called (call is synchronous) which destroys the `loader`.\n        //\t\t* Promise returned by the first `loader.file.then( ... )` call is resolved.\n        //\n        // Returning `this._filePromiseWrapper.promise` will still resolve to a `File` instance so there\n        // is an additional check needed in the chain to see if `loader` was destroyed in the meantime.\n        return this._filePromiseWrapper.promise.then(function (file) {\n          return _this6._filePromiseWrapper ? file : null;\n        });\n      }\n    }\n    /**\n     * Returns the file data. To read its data, you need for first load the file\n     * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.\n     *\n     * @type {File|undefined}\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._reader.data;\n    }\n  }]);\n\n  return FileLoader;\n}();\n\nmix(FileLoader, ObservableMixin);\n/**\n * Upload adapter interface used by the {@link module:upload/filerepository~FileRepository file repository}\n * to handle file upload. An upload adapter is a bridge between the editor and server that handles file uploads.\n * It should contain a logic necessary to initiate an upload process and monitor its progress.\n *\n * Learn how to develop your own upload adapter for CKEditor 5 in the\n * {@glink framework/guides/deep-dive/upload-adapter \"Custom upload adapter\" guide}.\n *\n * @interface UploadAdapter\n */\n\n/**\n * Executes the upload process.\n * This method should return a promise that will resolve when data will be uploaded to server. Promise should be\n * resolved with an object containing information about uploaded file:\n *\n *\t\t{\n *\t\t\tdefault: 'http://server/default-size.image.png'\n *\t\t}\n *\n * Additionally, other image sizes can be provided:\n *\n *\t\t{\n *\t\t\tdefault: 'http://server/default-size.image.png',\n *\t\t\t'160': 'http://server/size-160.image.png',\n *\t\t\t'500': 'http://server/size-500.image.png',\n *\t\t\t'1000': 'http://server/size-1000.image.png',\n *\t\t\t'1052': 'http://server/default-size.image.png'\n *\t\t}\n *\n * You can also pass additional properties from the server. In this case you need to wrap URLs\n * in the `urls` object and pass additional properties along the `urls` property.\n *\n * \t\t{\n * \t\t\tmyCustomProperty: 'foo',\n * \t\t\turls: {\n *\t\t\t\tdefault: 'http://server/default-size.image.png',\n *\t\t\t\t'160': 'http://server/size-160.image.png',\n *\t\t\t\t'500': 'http://server/size-500.image.png',\n *\t\t\t\t'1000': 'http://server/size-1000.image.png',\n *\t\t\t\t'1052': 'http://server/default-size.image.png'\n *\t\t\t}\n *\t\t}\n *\n * NOTE: When returning multiple images, the widest returned one should equal the default one. It is essential to\n * correctly set `width` attribute of the image. See this discussion:\n * https://github.com/ckeditor/ckeditor5-easy-image/issues/4 for more information.\n *\n * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and\n * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.\n *\n * @method module:upload/filerepository~UploadAdapter#upload\n * @returns {Promise.<Object>} Promise that should be resolved when data is uploaded.\n */\n\n/**\n * Aborts the upload process.\n * After aborting it should reject promise returned from {@link #upload upload()}.\n *\n * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and\n * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.\n *\n * @method module:upload/filerepository~UploadAdapter#abort\n */\n\n/**\n * Object returned by {@link module:upload/filerepository~FileLoader#_createFilePromiseWrapper} method\n * to add more control over the initial file promise passed to {@link module:upload/filerepository~FileLoader}.\n *\n * @protected\n * @typedef {Object} module:upload/filerepository~FilePromiseWrapper\n * @property {Promise.<File>} promise Wrapper promise which can be chained for further processing.\n * @property {Function} rejecter Rejects the promise when called.\n * @property {Boolean} isFulfilled Whether original promise is already fulfilled.\n */","map":null,"metadata":{},"sourceType":"module"}