{"ast":null,"code":"import _objectSpread from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module undo/basecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { transformSets } from '@ckeditor/ckeditor5-engine/src/model/operation/transform';\n/**\n * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n *\n * @protected\n * @extends module:core/command~Command\n */\n\nvar BaseCommand = /*#__PURE__*/function (_Command) {\n  _inherits(BaseCommand, _Command);\n\n  function BaseCommand(editor) {\n    var _this;\n\n    _classCallCheck(this, BaseCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseCommand).call(this, editor));\n    /**\n     * Stack of items stored by the command. These are pairs of:\n     *\n     * * {@link module:engine/model/batch~Batch batch} saved by the command,\n     * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n     *\n     * @protected\n     * @member {Array} #_stack\n     */\n\n    _this._stack = [];\n    /**\n     * Stores all batches that were created by this command.\n     *\n     * @protected\n     * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches\n     */\n\n    _this._createdBatches = new WeakSet(); // Refresh state, so the command is inactive right after initialization.\n\n    _this.refresh(); // Set the transparent batch for the `editor.data.set()` call if the\n    // batch type is not set already.\n\n\n    _this.listenTo(editor.data, 'set', function (evt, data) {\n      // Create a shallow copy of the options to not change the original args.\n      // And make sure that an object is assigned to data[ 1 ].\n      data[1] = _objectSpread({}, data[1]);\n      var options = data[1]; // If batch type is not set, default to non-undoable batch.\n\n      if (!options.batchType) {\n        options.batchType = {\n          isUndoable: false\n        };\n      }\n    }, {\n      priority: 'high'\n    }); // Clear the stack for the `transparent` batches.\n\n\n    _this.listenTo(editor.data, 'set', function (evt, data) {\n      // We can assume that the object exists and it has a `batchType` property.\n      // It was ensured with a higher priority listener before.\n      var options = data[1];\n\n      if (!options.batchType.isUndoable) {\n        _this.clearStack();\n      }\n    });\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(BaseCommand, [{\n    key: \"refresh\",\n    value: function refresh() {\n      this.isEnabled = this._stack.length > 0;\n    }\n    /**\n     * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n     * created by the editor which this command is registered to.\n     *\n     * @param {module:engine/model/batch~Batch} batch The batch to add.\n     */\n\n  }, {\n    key: \"addBatch\",\n    value: function addBatch(batch) {\n      var docSelection = this.editor.model.document.selection;\n      var selection = {\n        ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],\n        isBackward: docSelection.isBackward\n      };\n\n      this._stack.push({\n        batch: batch,\n        selection: selection\n      });\n\n      this.refresh();\n    }\n    /**\n     * Removes all items from the stack.\n     */\n\n  }, {\n    key: \"clearStack\",\n    value: function clearStack() {\n      this._stack = [];\n      this.refresh();\n    }\n    /**\n     * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n     *\n     * @protected\n     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.\n     * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.\n     * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations which has been applied\n     * since selection has been stored.\n     */\n\n  }, {\n    key: \"_restoreSelection\",\n    value: function _restoreSelection(ranges, isBackward, operations) {\n      var model = this.editor.model;\n      var document = model.document; // This will keep the transformed selection ranges.\n\n      var selectionRanges = []; // Transform all ranges from the restored selection.\n\n      var transformedRangeGroups = ranges.map(function (range) {\n        return range.getTransformedByOperations(operations);\n      });\n      var allRanges = transformedRangeGroups.flat();\n\n      var _iterator = _createForOfIteratorHelper(transformedRangeGroups),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rangeGroup = _step.value;\n          // While transforming there could appear ranges that are contained by other ranges, we shall ignore them.\n          var transformed = rangeGroup.filter(function (range) {\n            return range.root != document.graveyard;\n          }).filter(function (range) {\n            return !isRangeContainedByAnyOtherRange(range, allRanges);\n          }); // All the transformed ranges ended up in graveyard.\n\n          if (!transformed.length) {\n            continue;\n          } // After the range got transformed, we have an array of ranges. Some of those\n          // ranges may be \"touching\" -- they can be next to each other and could be merged.\n\n\n          normalizeRanges(transformed); // For each `range` from `ranges`, we take only one transformed range.\n          // This is because we want to prevent situation where single-range selection\n          // got transformed to multi-range selection.\n\n          selectionRanges.push(transformed[0]);\n        } // @if CK_DEBUG_ENGINE // console.log( `Restored selection by undo: ${ selectionRanges.join( ', ' ) }` );\n        // `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (selectionRanges.length) {\n        model.change(function (writer) {\n          writer.setSelection(selectionRanges, {\n            backward: isBackward\n          });\n        });\n      }\n    }\n    /**\n     * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n     * This is a helper method for {@link #execute}.\n     *\n     * @protected\n     * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.\n     * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.\n     */\n\n  }, {\n    key: \"_undo\",\n    value: function _undo(batchToUndo, undoingBatch) {\n      var model = this.editor.model;\n      var document = model.document; // All changes done by the command execution will be saved as one batch.\n\n      this._createdBatches.add(undoingBatch);\n\n      var operationsToUndo = batchToUndo.operations.slice().filter(function (operation) {\n        return operation.isDocumentOperation;\n      });\n      operationsToUndo.reverse(); // We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,\n      // we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n\n      var _iterator2 = _createForOfIteratorHelper(operationsToUndo),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operationToUndo = _step2.value;\n          var nextBaseVersion = operationToUndo.baseVersion + 1;\n          var historyOperations = Array.from(document.history.getOperations(nextBaseVersion));\n          var transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {\n            useRelations: true,\n            document: this.editor.model.document,\n            padWithNoOps: false,\n            forceWeakRemove: true\n          });\n          var reversedOperations = transformedSets.operationsA; // After reversed operation has been transformed by all history operations, apply it.\n\n          var _iterator3 = _createForOfIteratorHelper(reversedOperations),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var operation = _step3.value;\n              // Before applying, add the operation to the `undoingBatch`.\n              undoingBatch.addOperation(operation);\n              model.applyOperation(operation);\n              document.history.setOperationAsUndone(operationToUndo, operation);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return BaseCommand;\n}(Command); // Normalizes list of ranges by joining intersecting or \"touching\" ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges\n//\n\n\nexport { BaseCommand as default };\n\nfunction normalizeRanges(ranges) {\n  ranges.sort(function (a, b) {\n    return a.start.isBefore(b.start) ? -1 : 1;\n  });\n\n  for (var i = 1; i < ranges.length; i++) {\n    var previousRange = ranges[i - 1];\n    var joinedRange = previousRange.getJoined(ranges[i], true);\n\n    if (joinedRange) {\n      // Replace the ranges on the list with the new joined range.\n      i--;\n      ranges.splice(i, 2, joinedRange);\n    }\n  }\n}\n\nfunction isRangeContainedByAnyOtherRange(range, ranges) {\n  return ranges.some(function (otherRange) {\n    return otherRange !== range && otherRange.containsRange(range, true);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}