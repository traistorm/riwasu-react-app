{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module clipboard/dragdrop\n */\n\n/* globals setTimeout, clearTimeout */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport LiveRange from '@ckeditor/ckeditor5-engine/src/model/liverange';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport Widget from '@ckeditor/ckeditor5-widget/src/widget';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport { isWidget } from '@ckeditor/ckeditor5-widget/src/utils';\nimport ClipboardPipeline from './clipboardpipeline';\nimport ClipboardObserver from './clipboardobserver';\nimport { throttle } from 'lodash-es';\nimport '../theme/clipboard.css'; // Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/guides/deep-dive/clipboard clipboard deep dive guide}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar DragDrop = /*#__PURE__*/function (_Plugin) {\n  _inherits(DragDrop, _Plugin);\n\n  function DragDrop() {\n    _classCallCheck(this, DragDrop);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DragDrop).apply(this, arguments));\n  }\n\n  _createClass(DragDrop, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor;\n      var view = editor.editing.view;\n      /**\n       * The live range over the original content that is being dragged.\n       *\n       * @private\n       * @type {module:engine/model/liverange~LiveRange}\n       */\n\n      this._draggedRange = null;\n      /**\n       * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.\n       *\n       * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).\n       *\n       * @private\n       * @type {String}\n       */\n\n      this._draggingUid = '';\n      /**\n       * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).\n       *\n       * @private\n       * @type {module:engine/model/element~Element}\n       */\n\n      this._draggableElement = null;\n      /**\n       * A throttled callback updating the drop marker.\n       *\n       * @private\n       * @type {Function}\n       */\n\n      this._updateDropMarkerThrottled = throttle(function (targetRange) {\n        return _this._updateDropMarker(targetRange);\n      }, 40);\n      /**\n       * A delayed callback removing the drop marker.\n       *\n       * @private\n       * @type {Function}\n       */\n\n      this._removeDropMarkerDelayed = delay(function () {\n        return _this._removeDropMarker();\n      }, 40);\n      /**\n       * A delayed callback removing draggable attributes.\n       *\n       * @private\n       * @type {Function}\n       */\n\n      this._clearDraggableAttributesDelayed = delay(function () {\n        return _this._clearDraggableAttributes();\n      }, 40);\n      view.addObserver(ClipboardObserver);\n      view.addObserver(MouseObserver);\n\n      this._setupDragging();\n\n      this._setupContentInsertionIntegration();\n\n      this._setupClipboardInputIntegration();\n\n      this._setupDropMarker();\n\n      this._setupDraggableAttributeHandling();\n\n      this.listenTo(editor, 'change:isReadOnly', function (evt, name, isReadOnly) {\n        if (isReadOnly) {\n          _this.forceDisabled('readOnlyMode');\n        } else {\n          _this.clearForceDisabled('readOnlyMode');\n        }\n      });\n      this.on('change:isEnabled', function (evt, name, isEnabled) {\n        if (!isEnabled) {\n          _this._finalizeDragging(false);\n        }\n      });\n\n      if (env.isAndroid) {\n        this.forceDisabled('noAndroidSupport');\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._draggedRange) {\n        this._draggedRange.detach();\n\n        this._draggedRange = null;\n      }\n\n      this._updateDropMarkerThrottled.cancel();\n\n      this._removeDropMarkerDelayed.cancel();\n\n      this._clearDraggableAttributesDelayed.cancel();\n\n      return _get(_getPrototypeOf(DragDrop.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Drag and drop events handling.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupDragging\",\n    value: function _setupDragging() {\n      var _this2 = this;\n\n      var editor = this.editor;\n      var model = editor.model;\n      var modelDocument = model.document;\n      var view = editor.editing.view;\n      var viewDocument = view.document; // The handler for the drag start; it is responsible for setting data transfer object.\n\n      this.listenTo(viewDocument, 'dragstart', function (evt, data) {\n        var selection = modelDocument.selection; // Don't drag the editable element itself.\n\n        if (data.target && data.target.is('editableElement')) {\n          data.preventDefault();\n          return;\n        } // TODO we could clone this node somewhere and style it to match editing view but without handles,\n        //  selection outline, WTA buttons, etc.\n        // data.dataTransfer._native.setDragImage( data.domTarget, 0, 0 );\n        // Check if this is dragstart over the widget (but not a nested editable).\n\n\n        var draggableWidget = data.target ? findDraggableWidget(data.target) : null;\n\n        if (draggableWidget) {\n          var modelElement = editor.editing.mapper.toModelElement(draggableWidget);\n          _this2._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement)); // Disable toolbars so they won't obscure the drop area.\n\n          if (editor.plugins.has('WidgetToolbarRepository')) {\n            editor.plugins.get('WidgetToolbarRepository').forceDisabled('dragDrop');\n          }\n        } // If this was not a widget we should check if we need to drag some text content.\n        else if (!viewDocument.selection.isCollapsed) {\n          var selectedElement = viewDocument.selection.getSelectedElement();\n\n          if (!selectedElement || !isWidget(selectedElement)) {\n            _this2._draggedRange = LiveRange.fromRange(selection.getFirstRange());\n          }\n        }\n\n        if (!_this2._draggedRange) {\n          data.preventDefault();\n          return;\n        }\n\n        _this2._draggingUid = uid();\n        data.dataTransfer.effectAllowed = _this2.isEnabled ? 'copyMove' : 'copy';\n        data.dataTransfer.setData('application/ckeditor5-dragging-uid', _this2._draggingUid);\n        var draggedSelection = model.createSelection(_this2._draggedRange.toRange());\n        var content = editor.data.toView(model.getSelectedContent(draggedSelection));\n        viewDocument.fire('clipboardOutput', {\n          dataTransfer: data.dataTransfer,\n          content: content,\n          method: evt.name\n        });\n\n        if (!_this2.isEnabled) {\n          _this2._draggedRange.detach();\n\n          _this2._draggedRange = null;\n          _this2._draggingUid = '';\n        }\n      }, {\n        priority: 'low'\n      }); // The handler for finalizing drag and drop. It should always be triggered after dragging completes\n      // even if it was completed in a different application.\n      // Note: This is not fired if source text node got removed while downcasting a marker.\n\n      this.listenTo(viewDocument, 'dragend', function (evt, data) {\n        _this2._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');\n      }, {\n        priority: 'low'\n      }); // Dragging over the editable.\n\n      this.listenTo(viewDocument, 'dragenter', function () {\n        if (!_this2.isEnabled) {\n          return;\n        }\n\n        view.focus();\n      }); // Dragging out of the editable.\n\n      this.listenTo(viewDocument, 'dragleave', function () {\n        // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n        // to check if 'dragover' is not fired.\n        _this2._removeDropMarkerDelayed();\n      }); // Handler for moving dragged content over the target area.\n\n      this.listenTo(viewDocument, 'dragging', function (evt, data) {\n        if (!_this2.isEnabled) {\n          data.dataTransfer.dropEffect = 'none';\n          return;\n        }\n\n        _this2._removeDropMarkerDelayed.cancel();\n\n        var targetRange = findDropTargetRange(editor, data.targetRanges, data.target); // If this is content being dragged from another editor, moving out of current editor instance\n        // is not possible until 'dragend' event case will be fixed.\n\n        if (!_this2._draggedRange) {\n          data.dataTransfer.dropEffect = 'copy';\n        } // In Firefox it is already set and effect allowed remains the same as originally set.\n\n\n        if (!env.isGecko) {\n          if (data.dataTransfer.effectAllowed == 'copy') {\n            data.dataTransfer.dropEffect = 'copy';\n          } else if (['all', 'copyMove'].includes(data.dataTransfer.effectAllowed)) {\n            data.dataTransfer.dropEffect = 'move';\n          }\n        }\n        /* istanbul ignore else */\n\n\n        if (targetRange) {\n          _this2._updateDropMarkerThrottled(targetRange);\n        }\n      }, {\n        priority: 'low'\n      });\n    }\n    /**\n     * Integration with the `clipboardInput` event.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupClipboardInputIntegration\",\n    value: function _setupClipboardInputIntegration() {\n      var _this3 = this;\n\n      var editor = this.editor;\n      var view = editor.editing.view;\n      var viewDocument = view.document; // Update the event target ranges and abort dropping if dropping over itself.\n\n      this.listenTo(viewDocument, 'clipboardInput', function (evt, data) {\n        if (data.method != 'drop') {\n          return;\n        }\n\n        var targetRange = findDropTargetRange(editor, data.targetRanges, data.target); // The dragging markers must be removed after searching for the target range because sometimes\n        // the target lands on the marker itself.\n\n        _this3._removeDropMarker();\n        /* istanbul ignore if */\n\n\n        if (!targetRange) {\n          _this3._finalizeDragging(false);\n\n          evt.stop();\n          return;\n        } // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n        // or it is from some previous not cleared one.\n\n\n        if (_this3._draggedRange && _this3._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {\n          _this3._draggedRange.detach();\n\n          _this3._draggedRange = null;\n          _this3._draggingUid = '';\n        } // Do not do anything if some content was dragged within the same document to the same position.\n\n\n        var isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n\n        if (isMove && _this3._draggedRange && _this3._draggedRange.containsRange(targetRange, true)) {\n          _this3._finalizeDragging(false);\n\n          evt.stop();\n          return;\n        } // Override the target ranges with the one adjusted to the best one for a drop.\n\n\n        data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * Integration with the `contentInsertion` event of the clipboard pipeline.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupContentInsertionIntegration\",\n    value: function _setupContentInsertionIntegration() {\n      var _this4 = this;\n\n      var clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);\n      clipboardPipeline.on('contentInsertion', function (evt, data) {\n        if (!_this4.isEnabled || data.method !== 'drop') {\n          return;\n        } // Update the selection to the target range in the same change block to avoid selection post-fixing\n        // and to be able to clone text attributes for plain text dropping.\n\n\n        var ranges = data.targetRanges.map(function (viewRange) {\n          return _this4.editor.editing.mapper.toModelRange(viewRange);\n        });\n\n        _this4.editor.model.change(function (writer) {\n          return writer.setSelection(ranges);\n        });\n      }, {\n        priority: 'high'\n      });\n      clipboardPipeline.on('contentInsertion', function (evt, data) {\n        if (!_this4.isEnabled || data.method !== 'drop') {\n          return;\n        } // Remove dragged range content, remove markers, clean after dragging.\n\n\n        var isMove = getFinalDropEffect(data.dataTransfer) == 'move'; // Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n        // (for example an image caption allows only the content of a block but not blocks themselves.\n        // Some integrations might not return valid range (i.e., table pasting).\n\n        var isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n\n        _this4._finalizeDragging(isSuccess && isMove);\n      }, {\n        priority: 'lowest'\n      });\n    }\n    /**\n     * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupDraggableAttributeHandling\",\n    value: function _setupDraggableAttributeHandling() {\n      var _this5 = this;\n\n      var editor = this.editor;\n      var view = editor.editing.view;\n      var viewDocument = view.document; // Add the 'draggable' attribute to the widget while pressing the selection handle.\n      // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n\n      this.listenTo(viewDocument, 'mousedown', function (evt, data) {\n        // The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n        // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n        if (env.isAndroid || !data) {\n          return;\n        }\n\n        _this5._clearDraggableAttributesDelayed.cancel(); // Check if this is a mousedown over the widget (but not a nested editable).\n\n\n        var draggableElement = findDraggableWidget(data.target); // Note: There is a limitation that if more than a widget is selected (a widget and some text)\n        // and dragging starts on the widget, then only the widget is dragged.\n        // If this was not a widget then we should check if we need to drag some text content.\n        // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n        // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n        // Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n        // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n\n        if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {\n          var selectedElement = viewDocument.selection.getSelectedElement();\n\n          if (!selectedElement || !isWidget(selectedElement)) {\n            draggableElement = viewDocument.selection.editableElement;\n          }\n        }\n\n        if (draggableElement) {\n          view.change(function (writer) {\n            writer.setAttribute('draggable', 'true', draggableElement);\n          }); // Keep the reference to the model element in case the view element gets removed while dragging.\n\n          _this5._draggableElement = editor.editing.mapper.toModelElement(draggableElement);\n        }\n      }); // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n\n      this.listenTo(viewDocument, 'mouseup', function () {\n        if (!env.isAndroid) {\n          _this5._clearDraggableAttributesDelayed();\n        }\n      });\n    }\n    /**\n     * Removes the `draggable` attribute from the element that was used for dragging.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_clearDraggableAttributes\",\n    value: function _clearDraggableAttributes() {\n      var _this6 = this;\n\n      var editing = this.editor.editing;\n      editing.view.change(function (writer) {\n        // Remove 'draggable' attribute.\n        if (_this6._draggableElement && _this6._draggableElement.root.rootName != '$graveyard') {\n          writer.removeAttribute('draggable', editing.mapper.toViewElement(_this6._draggableElement));\n        }\n\n        _this6._draggableElement = null;\n      });\n    }\n    /**\n     * Creates downcast conversion for the drop target marker.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupDropMarker\",\n    value: function _setupDropMarker() {\n      var editor = this.editor; // Drop marker conversion for hovering over widgets.\n\n      editor.conversion.for('editingDowncast').markerToHighlight({\n        model: 'drop-target',\n        view: {\n          classes: ['ck-clipboard-drop-target-range']\n        }\n      }); // Drop marker conversion for in text drop target.\n\n      editor.conversion.for('editingDowncast').markerToElement({\n        model: 'drop-target',\n        view: function view(data, _ref) {\n          var writer = _ref.writer;\n          var inText = editor.model.schema.checkChild(data.markerRange.start, '$text');\n\n          if (!inText) {\n            return;\n          }\n\n          return writer.createUIElement('span', {\n            class: 'ck ck-clipboard-drop-target-position'\n          }, function (domDocument) {\n            var domElement = this.toDomElement(domDocument); // Using word joiner to make this marker as high as text and also making text not break on marker.\n\n            domElement.innerHTML = '&NoBreak;<span></span>&NoBreak;';\n            return domElement;\n          });\n        }\n      });\n    }\n    /**\n     * Updates the drop target marker to the provided range.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} targetRange The range to set the marker to.\n     */\n\n  }, {\n    key: \"_updateDropMarker\",\n    value: function _updateDropMarker(targetRange) {\n      var editor = this.editor;\n      var markers = editor.model.markers;\n      editor.model.change(function (writer) {\n        if (markers.has('drop-target')) {\n          if (!markers.get('drop-target').getRange().isEqual(targetRange)) {\n            writer.updateMarker('drop-target', {\n              range: targetRange\n            });\n          }\n        } else {\n          writer.addMarker('drop-target', {\n            range: targetRange,\n            usingOperation: false,\n            affectsData: false\n          });\n        }\n      });\n    }\n    /**\n     * Removes the drop target marker.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeDropMarker\",\n    value: function _removeDropMarker() {\n      var model = this.editor.model;\n\n      this._removeDropMarkerDelayed.cancel();\n\n      this._updateDropMarkerThrottled.cancel();\n\n      if (model.markers.has('drop-target')) {\n        model.change(function (writer) {\n          writer.removeMarker('drop-target');\n        });\n      }\n    }\n    /**\n     * Deletes the dragged content from its original range and clears the dragging state.\n     *\n     * @private\n     * @param {Boolean} moved Whether the move succeeded.\n     */\n\n  }, {\n    key: \"_finalizeDragging\",\n    value: function _finalizeDragging(moved) {\n      var editor = this.editor;\n      var model = editor.model;\n\n      this._removeDropMarker();\n\n      this._clearDraggableAttributes();\n\n      if (editor.plugins.has('WidgetToolbarRepository')) {\n        editor.plugins.get('WidgetToolbarRepository').clearForceDisabled('dragDrop');\n      }\n\n      this._draggingUid = '';\n\n      if (!this._draggedRange) {\n        return;\n      } // Delete moved content.\n\n\n      if (moved && this.isEnabled) {\n        model.deleteContent(model.createSelection(this._draggedRange), {\n          doNotAutoparagraph: true\n        });\n      }\n\n      this._draggedRange.detach();\n\n      this._draggedRange = null;\n    }\n  }], [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'DragDrop';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"requires\",\n    get: function get() {\n      return [ClipboardPipeline, Widget];\n    }\n  }]);\n\n  return DragDrop;\n}(Plugin); // Returns fixed selection range for given position and target element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {Array.<module:engine/view/range~Range>} targetViewRanges\n// @param {module:engine/view/element~Element} targetViewElement\n// @returns {module:engine/model/range~Range|null}\n\n\nexport { DragDrop as default };\n\nfunction findDropTargetRange(editor, targetViewRanges, targetViewElement) {\n  var model = editor.model;\n  var mapper = editor.editing.mapper;\n  var range = null;\n  var targetViewPosition = targetViewRanges ? targetViewRanges[0].start : null; // A UIElement is not a valid drop element, use parent (this could be a drop marker or any other UIElement).\n\n  if (targetViewElement.is('uiElement')) {\n    targetViewElement = targetViewElement.parent;\n  } // Quick win if the target is a widget (but not a nested editable).\n\n\n  range = findDropTargetRangeOnWidget(editor, targetViewElement);\n\n  if (range) {\n    return range;\n  } // The easiest part is over, now we need to move to the model space.\n  // Find target model element and position.\n\n\n  var targetModelElement = getClosestMappedModelElement(editor, targetViewElement);\n  var targetModelPosition = targetViewPosition ? mapper.toModelPosition(targetViewPosition) : null; // There is no target position while hovering over an empty table cell.\n  // In Safari, target position can be empty while hovering over a widget (e.g., a page-break).\n  // Find the drop position inside the element.\n\n  if (!targetModelPosition) {\n    return findDropTargetRangeInElement(editor, targetModelElement);\n  } // Check if target position is between blocks and adjust drop position to the next object.\n  // This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n\n\n  range = findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement);\n\n  if (range) {\n    return range;\n  } // Try fixing selection position.\n  // In Firefox, the target position lands before widgets but in other browsers it tends to land after a widget.\n\n\n  range = model.schema.getNearestSelectionRange(targetModelPosition, env.isGecko ? 'forward' : 'backward');\n\n  if (range) {\n    return range;\n  } // There is no valid selection position inside the current limit element so find a closest object ancestor.\n  // This happens if the model position lands directly in the <table> element itself (view target element was a `<td>`\n  // so a nested editable, but view target position was directly in the `<figure>` element).\n\n\n  return findDropTargetRangeOnAncestorObject(editor, targetModelPosition.parent);\n} // Returns fixed selection range for a given position and a target element if it is over the widget but not over its nested editable.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/view/element~Element} targetViewElement\n// @returns {module:engine/model/range~Range|null}\n\n\nfunction findDropTargetRangeOnWidget(editor, targetViewElement) {\n  var model = editor.model;\n  var mapper = editor.editing.mapper; // Quick win if the target is a widget.\n\n  if (isWidget(targetViewElement)) {\n    return model.createRangeOn(mapper.toModelElement(targetViewElement));\n  } // Check if we are deeper over a widget (but not over a nested editable).\n\n\n  if (!targetViewElement.is('editableElement')) {\n    // Find a closest ancestor that is either a widget or an editable element...\n    var ancestor = targetViewElement.findAncestor(function (node) {\n      return isWidget(node) || node.is('editableElement');\n    }); // ...and if the widget was closer then it is a drop target.\n\n    if (isWidget(ancestor)) {\n      return model.createRangeOn(mapper.toModelElement(ancestor));\n    }\n  }\n\n  return null;\n} // Returns fixed selection range inside a model element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/element~Element} targetModelElement\n// @returns {module:engine/model/range~Range}\n\n\nfunction findDropTargetRangeInElement(editor, targetModelElement) {\n  var model = editor.model;\n  var schema = model.schema;\n  var positionAtElementStart = model.createPositionAt(targetModelElement, 0);\n  return schema.getNearestSelectionRange(positionAtElementStart, 'forward');\n} // Returns fixed selection range for a given position and a target element if the drop is between blocks.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/position~Position} targetModelPosition\n// @param {module:engine/model/element~Element} targetModelElement\n// @returns {module:engine/model/range~Range|null}\n\n\nfunction findDropTargetRangeBetweenBlocks(editor, targetModelPosition, targetModelElement) {\n  var model = editor.model; // Check if target is between blocks.\n\n  if (!model.schema.checkChild(targetModelElement, '$block')) {\n    return null;\n  } // Find position between blocks.\n\n\n  var positionAtElementStart = model.createPositionAt(targetModelElement, 0); // Get the common part of the path (inside the target element and the target position).\n\n  var commonPath = targetModelPosition.path.slice(0, positionAtElementStart.path.length); // Position between the blocks.\n\n  var betweenBlocksPosition = model.createPositionFromPath(targetModelPosition.root, commonPath);\n  var nodeAfter = betweenBlocksPosition.nodeAfter; // Adjust drop position to the next object.\n  // This is because while hovering over a root element next to a widget the target position can jump in crazy places.\n\n  if (nodeAfter && model.schema.isObject(nodeAfter)) {\n    return model.createRangeOn(nodeAfter);\n  }\n\n  return null;\n} // Returns a selection range on the ancestor object.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/range~Range}\n\n\nfunction findDropTargetRangeOnAncestorObject(editor, element) {\n  var model = editor.model;\n\n  while (element) {\n    if (model.schema.isObject(element)) {\n      return model.createRangeOn(element);\n    }\n\n    element = element.parent;\n  }\n} // Returns the closest model element for the specified view element.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {module:engine/view/element~Element} element\n// @returns {module:engine/model/element~Element}\n\n\nfunction getClosestMappedModelElement(editor, element) {\n  var mapper = editor.editing.mapper;\n  var view = editor.editing.view;\n  var targetModelElement = mapper.toModelElement(element);\n\n  if (targetModelElement) {\n    return targetModelElement;\n  } // Find mapped ancestor if the target is inside not mapped element (for example inline code element).\n\n\n  var viewPosition = view.createPositionBefore(element);\n  var viewElement = mapper.findMappedViewAncestor(viewPosition);\n  return mapper.toModelElement(viewElement);\n} // Returns the drop effect that should be a result of dragging the content.\n// This function is handling a quirk when checking the effect in the 'drop' DOM event.\n\n\nfunction getFinalDropEffect(dataTransfer) {\n  if (env.isGecko) {\n    return dataTransfer.dropEffect;\n  }\n\n  return ['all', 'copyMove'].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';\n} // Returns a function wrapper that will trigger a function after a specified wait time.\n// The timeout can be canceled by calling the cancel function on the returned wrapped function.\n//\n// @param {Function} func The function to wrap.\n// @param {Number} wait The timeout in ms.\n// @returns {Function}\n\n\nfunction delay(func, wait) {\n  var timer;\n\n  function delayed() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    delayed.cancel();\n    timer = setTimeout(function () {\n      return func.apply(void 0, args);\n    }, wait);\n  }\n\n  delayed.cancel = function () {\n    clearTimeout(timer);\n  };\n\n  return delayed;\n} // Returns a widget element that should be dragged.\n//\n// @param {module:engine/view/element~Element} target\n// @returns {module:engine/view/element~Element}\n\n\nfunction findDraggableWidget(target) {\n  // This is directly an editable so not a widget for sure.\n  if (target.is('editableElement')) {\n    return null;\n  } // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n\n\n  if (target.hasClass('ck-widget__selection-handle')) {\n    return target.findAncestor(isWidget);\n  } // Direct hit on a widget.\n\n\n  if (isWidget(target)) {\n    return target;\n  } // Find closest ancestor that is either a widget or an editable element...\n\n\n  var ancestor = target.findAncestor(function (node) {\n    return isWidget(node) || node.is('editableElement');\n  }); // ...and if closer was the widget then enable dragging it.\n\n  if (isWidget(ancestor)) {\n    return ancestor;\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}