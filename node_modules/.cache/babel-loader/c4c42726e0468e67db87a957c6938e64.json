{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/selection\n */\nimport Position from './position';\nimport Node from './node';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n/**\n * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}\n * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).\n * Additionally, selection may have its own attributes (think – whether text typed in in this selection\n * should have those attributes – e.g. whether you type a bolded text).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar Selection = /*#__PURE__*/function () {\n  /**\n   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n   * or creates an empty selection if no arguments were passed.\n   *\n   *\t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the given document selection.\n   *\t\t// Note: It doesn't copies selection attributes.\n   *\t\tconst documentSelection = model.document.selection;\n   *\t\tconst selection = writer.createSelection( documentSelection );\n   *\n   *\t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates selection at the given offset in the given element.\n   *\t\tconst paragraph = writer.createElement( 'paragraph' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * @param {module:engine/model/selection~Selectable} [selectable]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n  function Selection(selectable, placeOrOffset, options) {\n    _classCallCheck(this, Selection);\n\n    /**\n     * Specifies whether the last added range was added as a backward or forward range.\n     *\n     * @private\n     * @type {Boolean}\n     */\n    this._lastRangeBackward = false;\n    /**\n     * Stores selection ranges.\n     *\n     * @protected\n     * @type {Array.<module:engine/model/range~Range>}\n     */\n\n    this._ranges = [];\n    /**\n     * List of attributes set on current selection.\n     *\n     * @protected\n     * @type {Map.<String,*>}\n     */\n\n    this._attrs = new Map();\n\n    if (selectable) {\n      this.setTo(selectable, placeOrOffset, options);\n    }\n  }\n  /**\n   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection\n   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).\n   *\n   * Anchor and {@link #focus} define the direction of the selection, which is important\n   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.\n   *\n   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or\n   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is\n   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.\n   *\n   * May be set to `null` if there are no ranges in the selection.\n   *\n   * @see #focus\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"isEqual\",\n\n    /**\n     * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,\n     * the same number of ranges and all ranges from one selection equal to ranges from the another selection.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n     * Selection to compare with.\n     * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n     */\n    value: function isEqual(otherSelection) {\n      if (this.rangeCount != otherSelection.rangeCount) {\n        return false;\n      } else if (this.rangeCount === 0) {\n        return true;\n      }\n\n      if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {\n        return false;\n      }\n\n      var _iterator = _createForOfIteratorHelper(this._ranges),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var thisRange = _step.value;\n          var found = false;\n\n          var _iterator2 = _createForOfIteratorHelper(otherSelection._ranges),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var otherRange = _step2.value;\n\n              if (thisRange.isEqual(otherRange)) {\n                found = true;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          if (!found) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n    /**\n     * Returns an iterable object that iterates over copies of selection ranges.\n     *\n     * @returns {Iterable.<module:engine/model/range~Range>}\n     */\n\n  }, {\n    key: \"getRanges\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getRanges() {\n      var _iterator3, _step3, range;\n\n      return _regeneratorRuntime.wrap(function getRanges$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper(this._ranges);\n              _context.prev = 1;\n\n              _iterator3.s();\n\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 9;\n                break;\n              }\n\n              range = _step3.value;\n              _context.next = 7;\n              return new Range(range.start, range.end);\n\n            case 7:\n              _context.next = 3;\n              break;\n\n            case 9:\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](1);\n\n              _iterator3.e(_context.t0);\n\n            case 14:\n              _context.prev = 14;\n\n              _iterator3.f();\n\n              return _context.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getRanges, this, [[1, 11, 14, 17]]);\n    })\n    /**\n     * Returns a copy of the first range in the selection.\n     * First range is the one which {@link module:engine/model/range~Range#start start} position\n     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n     * (not to confuse with the first range added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getFirstRange\",\n    value: function getFirstRange() {\n      var first = null;\n\n      var _iterator4 = _createForOfIteratorHelper(this._ranges),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var range = _step4.value;\n\n          if (!first || range.start.isBefore(first.start)) {\n            first = range;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return first ? new Range(first.start, first.end) : null;\n    }\n    /**\n     * Returns a copy of the last range in the selection.\n     * Last range is the one which {@link module:engine/model/range~Range#end end} position\n     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n     * recently added to the selection).\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getLastRange\",\n    value: function getLastRange() {\n      var last = null;\n\n      var _iterator5 = _createForOfIteratorHelper(this._ranges),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var range = _step5.value;\n\n          if (!last || range.end.isAfter(last.end)) {\n            last = range;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return last ? new Range(last.start, last.end) : null;\n    }\n    /**\n     * Returns the first position in the selection.\n     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"getFirstPosition\",\n    value: function getFirstPosition() {\n      var first = this.getFirstRange();\n      return first ? first.start.clone() : null;\n    }\n    /**\n     * Returns the last position in the selection.\n     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n     * any other position in the selection.\n     *\n     * Returns `null` if there are no ranges in selection.\n     *\n     * @returns {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"getLastPosition\",\n    value: function getLastPosition() {\n      var lastRange = this.getLastRange();\n      return lastRange ? lastRange.end.clone() : null;\n    }\n    /**\n     * Sets this selection's ranges and direction to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable}.\n     *\n     *\t\t// Removes all selection's ranges.\n     *\t\tselection.setTo( null );\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tselection.setTo( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tselection.setTo( ranges );\n     *\n     *\t\t// Sets selection to other selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tselection.setTo( otherSelection );\n     *\n     *\t\t// Sets selection to the given document selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst documentSelection = new DocumentSelection( doc );\n     *\t\tselection.setTo( documentSelection );\n     *\n     *\t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tselection.setTo( position );\n     *\n     *\t\t// Sets collapsed selection at the position of the given node and an offset.\n     *\t\tselection.setTo( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n    \t * that element and ends after the last child of that element.\n     *\n     *\t\tselection.setTo( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\tselection.setTo( paragraph, 'on' );\n     *\n     * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n     *\n     *\t\t// Sets backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(selectable, placeOrOffset, options) {\n      if (selectable === null) {\n        this._setRanges([]);\n      } else if (selectable instanceof Selection) {\n        this._setRanges(selectable.getRanges(), selectable.isBackward);\n      } else if (selectable && typeof selectable.getRanges == 'function') {\n        // We assume that the selectable is a DocumentSelection.\n        // It can't be imported here, because it would lead to circular imports.\n        this._setRanges(selectable.getRanges(), selectable.isBackward);\n      } else if (selectable instanceof Range) {\n        this._setRanges([selectable], !!placeOrOffset && !!placeOrOffset.backward);\n      } else if (selectable instanceof Position) {\n        this._setRanges([new Range(selectable)]);\n      } else if (selectable instanceof Node) {\n        var backward = !!options && !!options.backward;\n        var range;\n\n        if (placeOrOffset == 'in') {\n          range = Range._createIn(selectable);\n        } else if (placeOrOffset == 'on') {\n          range = Range._createOn(selectable);\n        } else if (placeOrOffset !== undefined) {\n          range = new Range(Position._createAt(selectable, placeOrOffset));\n        } else {\n          /**\n           * selection.setTo requires the second parameter when the first parameter is a node.\n           *\n           * @error model-selection-setto-required-second-parameter\n           */\n          throw new CKEditorError('model-selection-setto-required-second-parameter', [this, selectable]);\n        }\n\n        this._setRanges([range], backward);\n      } else if (isIterable(selectable)) {\n        // We assume that the selectable is an iterable of ranges.\n        this._setRanges(selectable, placeOrOffset && !!placeOrOffset.backward);\n      } else {\n        /**\n         * Cannot set the selection to the given place.\n         *\n         * Invalid parameters were specified when setting the selection. Common issues:\n         *\n         * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of\n         * a real {@link module:engine/model/text~Text}.\n         * * View nodes were passed instead of model nodes.\n         * * `null`/`undefined` was passed.\n         *\n         * @error model-selection-setto-not-selectable\n         */\n        throw new CKEditorError('model-selection-setto-not-selectable', [this, selectable]);\n      }\n    }\n    /**\n     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n     * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n     * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n     *\n     * @protected\n     * @fires change:range\n     * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n     * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n     * or backward - from end to start (`true`).\n     */\n\n  }, {\n    key: \"_setRanges\",\n    value: function _setRanges(newRanges) {\n      var _this = this;\n\n      var isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      newRanges = Array.from(newRanges); // Check whether there is any range in new ranges set that is different than all already added ranges.\n\n      var anyNewRange = newRanges.some(function (newRange) {\n        if (!(newRange instanceof Range)) {\n          /**\n           * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.\n           *\n           * Only {@link module:engine/model/range~Range} instances can be used to set a selection.\n           * Common mistakes leading to this error are:\n           *\n           * * using DOM `Range` object,\n           * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.\n           *\n           * @error model-selection-set-ranges-not-range\n           */\n          throw new CKEditorError('model-selection-set-ranges-not-range', [_this, newRanges]);\n        }\n\n        return _this._ranges.every(function (oldRange) {\n          return !oldRange.isEqual(newRange);\n        });\n      }); // Don't do anything if nothing changed.\n\n      if (newRanges.length === this._ranges.length && !anyNewRange) {\n        return;\n      }\n\n      this._removeAllRanges();\n\n      var _iterator6 = _createForOfIteratorHelper(newRanges),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var range = _step6.value;\n\n          this._pushRange(range);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      this._lastRangeBackward = !!isLastBackward;\n      this.fire('change:range', {\n        directChange: true\n      });\n    }\n    /**\n     * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n     *\n     * The location can be specified in the same form as\n     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n     *\n     * @fires change:range\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"setFocus\",\n    value: function setFocus(itemOrPosition, offset) {\n      if (this.anchor === null) {\n        /**\n         * Cannot set selection focus if there are no ranges in selection.\n         *\n         * @error model-selection-setfocus-no-ranges\n         */\n        throw new CKEditorError('model-selection-setfocus-no-ranges', [this, itemOrPosition]);\n      }\n\n      var newFocus = Position._createAt(itemOrPosition, offset);\n\n      if (newFocus.compareWith(this.focus) == 'same') {\n        return;\n      }\n\n      var anchor = this.anchor;\n\n      if (this._ranges.length) {\n        this._popRange();\n      }\n\n      if (newFocus.compareWith(anchor) == 'before') {\n        this._pushRange(new Range(newFocus, anchor));\n\n        this._lastRangeBackward = true;\n      } else {\n        this._pushRange(new Range(anchor, newFocus));\n\n        this._lastRangeBackward = false;\n      }\n\n      this.fire('change:range', {\n        directChange: true\n      });\n    }\n    /**\n     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n     *\n     * @param {String} key Key of attribute to look for.\n     * @returns {*} Attribute value or `undefined`.\n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return this._attrs.get(key);\n    }\n    /**\n     * Returns iterable that iterates over this selection's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this._attrs.entries();\n    }\n    /**\n     * Returns iterable that iterates over this selection's attribute keys.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getAttributeKeys\",\n    value: function getAttributeKeys() {\n      return this._attrs.keys();\n    }\n    /**\n     * Checks if the selection has an attribute for given key.\n     *\n     * @param {String} key Key of attribute to check.\n     * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return this._attrs.has(key);\n    }\n    /**\n     * Removes an attribute with given key from the selection.\n     *\n     * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n     * removed attribute key.\n     *\n     * @fires change:attribute\n     * @param {String} key Key of attribute to remove.\n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key) {\n      if (this.hasAttribute(key)) {\n        this._attrs.delete(key);\n\n        this.fire('change:attribute', {\n          attributeKeys: [key],\n          directChange: true\n        });\n      }\n    }\n    /**\n     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n     *\n     * If the attribute value has changed, fires the {@link #event:change:range} event with\n     * the attribute key.\n     *\n     * @fires change:attribute\n     * @param {String} key Key of attribute to set.\n     * @param {*} value Attribute value.\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value) {\n      if (this.getAttribute(key) !== value) {\n        this._attrs.set(key, value);\n\n        this.fire('change:attribute', {\n          attributeKeys: [key],\n          directChange: true\n        });\n      }\n    }\n    /**\n     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n     * one range in the selection, and that range contains exactly one element.\n     * Returns `null` if there is no selected element.\n     *\n     * @returns {module:engine/model/element~Element|null}\n     */\n\n  }, {\n    key: \"getSelectedElement\",\n    value: function getSelectedElement() {\n      if (this.rangeCount !== 1) {\n        return null;\n      }\n\n      return this.getFirstRange().getContainedElement();\n    }\n    /**\n     * Checks whether this object is of the given.\n     *\n     *\t\tselection.is( 'selection' ); // -> true\n     *\t\tselection.is( 'model:selection' ); // -> true\n     *\n     *\t\tselection.is( 'view:selection' ); // -> false\n     *\t\tselection.is( 'range' ); // -> false\n     *\n     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type === 'selection' || type === 'model:selection';\n    }\n    /**\n     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n     *\n     * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n     *\n     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n     * but will not return blocks nested in other blocks.\n     *\n     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<blockQuote>\n     *\t\t\t<paragraph>b</paragraph>\n     *\t\t</blockQuote>\n     *\t\t<paragraph>c]d</paragraph>\n     *\n     * In this case the paragraph will also be returned, despite the collapsed selection:\n     *\n     *\t\t<paragraph>[]a</paragraph>\n     *\n     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n     *\n     *\t\t[<blockA></blockA>\n     *\t\t<blockB>\n     *\t\t\t<blockC></blockC>\n     *\t\t\t<blockD></blockD>\n     *\t\t</blockB>\n     *\t\t<blockE></blockE>]\n     *\n     * If the selection is inside a block all the inner blocks (A & B) are returned:\n     *\n     * \t\t<block>\n     *\t\t\t<blockA>[a</blockA>\n     * \t\t\t<blockB>b]</blockB>\n     * \t\t</block>\n     *\n     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n     *\n     *\t\t<paragraph>[a</paragraph>\n     *\t\t<paragraph>b</paragraph>\n     *\t\t<paragraph>]c</paragraph> // this block will not be returned\n     *\n     * @returns {Iterable.<module:engine/model/element~Element>}\n     */\n\n  }, {\n    key: \"getSelectedBlocks\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getSelectedBlocks() {\n      var visited, _iterator7, _step7, range, startBlock, _iterator8, _step8, value, block, endBlock;\n\n      return _regeneratorRuntime.wrap(function getSelectedBlocks$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              visited = new WeakSet();\n              _iterator7 = _createForOfIteratorHelper(this.getRanges());\n              _context2.prev = 2;\n\n              _iterator7.s();\n\n            case 4:\n              if ((_step7 = _iterator7.n()).done) {\n                _context2.next = 35;\n                break;\n              }\n\n              range = _step7.value;\n              // Get start block of range in case of a collapsed range.\n              startBlock = getParentBlock(range.start, visited);\n\n              if (!(startBlock && isTopBlockInRange(startBlock, range))) {\n                _context2.next = 10;\n                break;\n              }\n\n              _context2.next = 10;\n              return startBlock;\n\n            case 10:\n              _iterator8 = _createForOfIteratorHelper(range.getWalker());\n              _context2.prev = 11;\n\n              _iterator8.s();\n\n            case 13:\n              if ((_step8 = _iterator8.n()).done) {\n                _context2.next = 21;\n                break;\n              }\n\n              value = _step8.value;\n              block = value.item;\n\n              if (!(value.type == 'elementEnd' && isUnvisitedTopBlock(block, visited, range))) {\n                _context2.next = 19;\n                break;\n              }\n\n              _context2.next = 19;\n              return block;\n\n            case 19:\n              _context2.next = 13;\n              break;\n\n            case 21:\n              _context2.next = 26;\n              break;\n\n            case 23:\n              _context2.prev = 23;\n              _context2.t0 = _context2[\"catch\"](11);\n\n              _iterator8.e(_context2.t0);\n\n            case 26:\n              _context2.prev = 26;\n\n              _iterator8.f();\n\n              return _context2.finish(26);\n\n            case 29:\n              endBlock = getParentBlock(range.end, visited); // #984. Don't return the end block if the range ends right at its beginning.\n\n              if (!(endBlock && !range.end.isTouching(Position._createAt(endBlock, 0)) && isTopBlockInRange(endBlock, range))) {\n                _context2.next = 33;\n                break;\n              }\n\n              _context2.next = 33;\n              return endBlock;\n\n            case 33:\n              _context2.next = 4;\n              break;\n\n            case 35:\n              _context2.next = 40;\n              break;\n\n            case 37:\n              _context2.prev = 37;\n              _context2.t1 = _context2[\"catch\"](2);\n\n              _iterator7.e(_context2.t1);\n\n            case 40:\n              _context2.prev = 40;\n\n              _iterator7.f();\n\n              return _context2.finish(40);\n\n            case 43:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getSelectedBlocks, this, [[2, 37, 40, 43], [11, 23, 26, 29]]);\n    })\n    /**\n     * Checks whether the selection contains the entire content of the given element. This means that selection must start\n     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n     * touching the element's end.\n     *\n     * By default, this method will check whether the entire content of the selection's current root is selected.\n     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n     *\n     * @param {module:engine/model/element~Element} [element=this.anchor.root]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"containsEntireContent\",\n    value: function containsEntireContent() {\n      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.anchor.root;\n\n      var limitStartPosition = Position._createAt(element, 0);\n\n      var limitEndPosition = Position._createAt(element, 'end');\n\n      return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());\n    }\n    /**\n     * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n     * if given range is intersecting with any range that is already stored in this selection.\n     *\n     * @protected\n     * @param {module:engine/model/range~Range} range Range to add.\n     */\n\n  }, {\n    key: \"_pushRange\",\n    value: function _pushRange(range) {\n      this._checkRange(range);\n\n      this._ranges.push(new Range(range.start, range.end));\n    }\n    /**\n     * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n     *\n     * @protected\n     * @param {module:engine/model/range~Range} range Range to check.\n     */\n\n  }, {\n    key: \"_checkRange\",\n    value: function _checkRange(range) {\n      for (var i = 0; i < this._ranges.length; i++) {\n        if (range.isIntersecting(this._ranges[i])) {\n          /**\n           * Trying to add a range that intersects with another range in the selection.\n           *\n           * @error model-selection-range-intersects\n           * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n           * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.\n           */\n          throw new CKEditorError('model-selection-range-intersects', [this, range], {\n            addedRange: range,\n            intersectingRange: this._ranges[i]\n          });\n        }\n      }\n    }\n    /**\n     * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n     * ensure proper ranges removal.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_removeAllRanges\",\n    value: function _removeAllRanges() {\n      while (this._ranges.length > 0) {\n        this._popRange();\n      }\n    }\n    /**\n     * Removes most recently added range from the selection.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_popRange\",\n    value: function _popRange() {\n      this._ranges.pop();\n    }\n    /**\n     * Fired when selection range(s) changed.\n     *\n     * @event change:range\n     * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n     * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n     * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n     * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n     * changed because the structure of the model has been changed (which means an indirect change).\n     * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n     * which mean that they are not updated once the document changes.\n     */\n\n    /**\n     * Fired when selection attribute changed.\n     *\n     * @event change:attribute\n     * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n     * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n     * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n     * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n     * changed in the model and its attributes were refreshed (which means an indirect change).\n     * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n     * which mean that they are not updated once the document changes.\n     * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n     */\n\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      if (this._ranges.length > 0) {\n        var range = this._ranges[this._ranges.length - 1];\n        return this._lastRangeBackward ? range.end : range.start;\n      }\n\n      return null;\n    }\n    /**\n     * Selection focus. Focus is the position where the selection ends. If a user is making a selection\n     * by dragging the mouse, the focus is where the mouse cursor is.\n     *\n     * May be set to `null` if there are no ranges in the selection.\n     *\n     * @see #anchor\n     * @readonly\n     * @type {module:engine/model/position~Position|null}\n     */\n\n  }, {\n    key: \"focus\",\n    get: function get() {\n      if (this._ranges.length > 0) {\n        var range = this._ranges[this._ranges.length - 1];\n        return this._lastRangeBackward ? range.start : range.end;\n      }\n\n      return null;\n    }\n    /**\n     * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it\n     * and it is collapsed.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      var length = this._ranges.length;\n\n      if (length === 1) {\n        return this._ranges[0].isCollapsed;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Returns the number of ranges in the selection.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"rangeCount\",\n    get: function get() {\n      return this._ranges.length;\n    }\n    /**\n     * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isBackward\",\n    get: function get() {\n      return !this.isCollapsed && this._lastRangeBackward;\n    }\n  }]);\n\n  return Selection;\n}();\n\nexport { Selection as default };\nmix(Selection, EmitterMixin); // Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\n\nfunction isUnvisitedBlock(element, visited) {\n  if (visited.has(element)) {\n    return false;\n  }\n\n  visited.add(element);\n  return element.root.document.model.schema.isBlock(element) && element.parent;\n} // Checks if the given element is a $block was not previously visited and is a top block in a range.\n\n\nfunction isUnvisitedTopBlock(element, visited, range) {\n  return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);\n} // Finds the lowest element in position's ancestors which is a block.\n// It will search until first ancestor that is a limit element.\n// Marks all ancestors as already visited to not include any of them later on.\n\n\nfunction getParentBlock(position, visited) {\n  var element = position.parent;\n  var schema = element.root.document.model.schema;\n  var ancestors = position.parent.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n  var hasParentLimit = false;\n  var block = ancestors.find(function (element) {\n    // Stop searching after first parent node that is limit element.\n    if (hasParentLimit) {\n      return false;\n    }\n\n    hasParentLimit = schema.isLimit(element);\n    return !hasParentLimit && isUnvisitedBlock(element, visited);\n  }); // Mark all ancestors of this position's parent, because find() might've stopped early and\n  // the found block may be a child of another block.\n\n  ancestors.forEach(function (element) {\n    return visited.add(element);\n  });\n  return block;\n} // Checks if the blocks is not nested in other block inside a range.\n//\n// @param {module:engine/model/element~Element} block Block to check.\n// @param {module:engine/model/range~Range} range Range to check.\n\n\nfunction isTopBlockInRange(block, range) {\n  var parentBlock = findAncestorBlock(block);\n\n  if (!parentBlock) {\n    return true;\n  } // Add loose flag to check as parentRange can be equal to range.\n\n\n  var isParentInRange = range.containsRange(Range._createOn(parentBlock), true);\n  return !isParentInRange;\n} // Returns first ancestor block of a node.\n//\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/node~Node|undefined}\n\n\nfunction findAncestorBlock(node) {\n  var schema = node.root.document.model.schema;\n  var parent = node.parent;\n\n  while (parent) {\n    if (schema.isBlock(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n}\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/model/selection~Selection#setTo}\n *\n * @typedef {\n *     module:engine/model/selection~Selection|\n *     module:engine/model/documentselection~DocumentSelection|\n *     module:engine/model/position~Position|\n *     module:engine/model/range~Range|\n *     module:engine/model/node~Node|\n *     Iterable.<module:engine/model/range~Range>|\n *     null\n * } module:engine/model/selection~Selectable\n */","map":null,"metadata":{},"sourceType":"module"}