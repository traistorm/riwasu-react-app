{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\nimport Position from '../position';\nimport TreeWalker from '../treewalker';\nimport Range from '../range';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from '../documentselection';\nvar wordBoundaryCharacters = ' ,.?!:;\"-()';\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\n\nexport default function modifySelection(model, selection) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var schema = model.schema;\n  var isForward = options.direction != 'backward';\n  var unit = options.unit ? options.unit : 'character';\n  var treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n  var focus = selection.focus;\n  var walker = new TreeWalker({\n    boundaries: getSearchRange(focus, isForward),\n    singleCharacters: true,\n    direction: isForward ? 'forward' : 'backward'\n  });\n  var data = {\n    walker: walker,\n    schema: schema,\n    isForward: isForward,\n    unit: unit,\n    treatEmojiAsSingleUnit: treatEmojiAsSingleUnit\n  };\n  var next;\n\n  var _loop = function _loop() {\n    if (next.done) {\n      return {\n        v: void 0\n      };\n    }\n\n    var position = tryExtendingTo(data, next.value);\n\n    if (position) {\n      if (selection instanceof DocumentSelection) {\n        model.change(function (writer) {\n          writer.setSelectionFocus(position);\n        });\n      } else {\n        selection.setFocus(position);\n      }\n\n      return {\n        v: void 0\n      };\n    }\n  };\n\n  while (next = walker.next()) {\n    var _ret = _loop();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n} // Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\n\nfunction tryExtendingTo(data, value) {\n  var isForward = data.isForward,\n      walker = data.walker,\n      unit = data.unit,\n      schema = data.schema,\n      treatEmojiAsSingleUnit = data.treatEmojiAsSingleUnit;\n  var type = value.type,\n      item = value.item,\n      nextPosition = value.nextPosition; // If found text, we can certainly put the focus in it. Let's just find a correct position\n  // based on the unit.\n\n  if (type == 'text') {\n    if (data.unit === 'word') {\n      return getCorrectWordBreakPosition(walker, isForward);\n    }\n\n    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);\n  } // Entering an element.\n\n\n  if (type == (isForward ? 'elementStart' : 'elementEnd')) {\n    // If it's a selectable, we can select it now.\n    if (schema.isSelectable(item)) {\n      return Position._createAt(item, isForward ? 'after' : 'before');\n    } // If text allowed on this position, extend to this place.\n\n\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  } // Leaving an element.\n  else {\n    // If leaving a limit element, stop.\n    if (schema.isLimit(item)) {\n      // NOTE: Fast-forward the walker until the end.\n      walker.skip(function () {\n        return true;\n      });\n      return;\n    } // If text allowed on this position, extend to this place.\n\n\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n} // Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\n\n\nfunction getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {\n  var textNode = walker.position.textNode;\n\n  if (textNode) {\n    var data = textNode.data;\n    var offset = walker.position.offset - textNode.startOffset;\n\n    while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {\n      walker.next();\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n} // Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction getCorrectWordBreakPosition(walker, isForward) {\n  var textNode = walker.position.textNode;\n\n  if (textNode) {\n    var offset = walker.position.offset - textNode.startOffset;\n\n    while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {\n      walker.next(); // Check of adjacent text nodes with different attributes (like BOLD).\n      // Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n      // should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\n      var nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore; // Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\n      if (nextNode && nextNode.is('$text')) {\n        // Check boundary char of an adjacent text node.\n        var boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1); // Go to the next node if the character at the boundary of that node belongs to the same word.\n\n        if (!wordBoundaryCharacters.includes(boundaryChar)) {\n          // If adjacent text node belongs to the same word go to it & reset values.\n          walker.next();\n          textNode = walker.position.textNode;\n        }\n      }\n\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n}\n\nfunction getSearchRange(start, isForward) {\n  var root = start.root;\n\n  var searchEnd = Position._createAt(root, isForward ? 'end' : 0);\n\n  if (isForward) {\n    return new Range(start, searchEnd);\n  } else {\n    return new Range(searchEnd, start);\n  }\n} // Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtWordBoundary(data, offset, isForward) {\n  // The offset to check depends on direction.\n  var offsetToCheck = offset + (isForward ? 0 : -1);\n  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));\n} // Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtNodeBoundary(textNode, offset, isForward) {\n  return offset === (isForward ? textNode.endOffset : 0);\n}","map":null,"metadata":{},"sourceType":"module"}