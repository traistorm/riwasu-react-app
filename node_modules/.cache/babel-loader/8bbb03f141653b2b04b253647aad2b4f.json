{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport Enter from '@ckeditor/ckeditor5-enter/src/enter';\nimport Delete from '@ckeditor/ckeditor5-typing/src/delete';\nimport { isForwardArrowKeyCode, keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { isTypeAroundWidget, getClosestTypeAroundDomButton, getTypeAroundButtonPosition, getClosestWidgetViewElement, getTypeAroundFakeCaretPosition, TYPE_AROUND_SELECTION_ATTRIBUTE } from './utils';\nimport { isNonTypingKeystroke } from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\nimport { isWidget } from '../utils';\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\nvar POSSIBLE_INSERTION_POSITIONS = ['before', 'after']; // Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\n\nvar RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, 'image/svg+xml').firstChild;\nvar PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar WidgetTypeAround = /*#__PURE__*/function (_Plugin) {\n  _inherits(WidgetTypeAround, _Plugin);\n\n  _createClass(WidgetTypeAround, null, [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'WidgetTypeAround';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"requires\",\n    get: function get() {\n      return [Enter, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function WidgetTypeAround(editor) {\n    var _this;\n\n    _classCallCheck(this, WidgetTypeAround);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WidgetTypeAround).call(this, editor));\n    /**\n     * A reference to the model widget element that has the fake caret active\n     * on either side of it. It is later used to remove CSS classes associated with the fake caret\n     * when the widget no longer needs it.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|null}\n     */\n\n    _this._currentFakeCaretModelElement = null;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(WidgetTypeAround, [{\n    key: \"init\",\n    value: function init() {\n      var editor = this.editor;\n      var editingView = editor.editing.view; // Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n      // and lines visually disappear. All the interactions are disabled in individual plugin methods.\n\n      this.on('change:isEnabled', function (evt, data, isEnabled) {\n        editingView.change(function (writer) {\n          var _iterator = _createForOfIteratorHelper(editingView.document.roots),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var root = _step.value;\n\n              if (isEnabled) {\n                writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n              } else {\n                writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n\n        if (!isEnabled) {\n          editor.model.change(function (writer) {\n            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n          });\n        }\n      });\n\n      this._enableTypeAroundUIInjection();\n\n      this._enableInsertingParagraphsOnButtonClick();\n\n      this._enableInsertingParagraphsOnEnterKeypress();\n\n      this._enableInsertingParagraphsOnTypingKeystroke();\n\n      this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n\n      this._enableDeleteIntegration();\n\n      this._enableInsertContentIntegration();\n\n      this._enableInsertObjectIntegration();\n\n      this._enableDeleteContentIntegration();\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._currentFakeCaretModelElement = null;\n    }\n    /**\n     * Inserts a new paragraph next to a widget element with the selection anchored in it.\n     *\n     * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n     * the viewport to the selection in the inserted paragraph.\n     *\n     * @protected\n     * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n     * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n     */\n\n  }, {\n    key: \"_insertParagraph\",\n    value: function _insertParagraph(widgetModelElement, position) {\n      var editor = this.editor;\n      var editingView = editor.editing.view;\n      var attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, 'copyOnReplace', true);\n      editor.execute('insertParagraph', {\n        position: editor.model.createPositionAt(widgetModelElement, position),\n        attributes: attributesToCopy\n      });\n      editingView.focus();\n      editingView.scrollToTheSelection();\n    }\n    /**\n     * A wrapper for the {@link module:utils/emittermixin~EmitterMixin#listenTo} method that executes the callbacks only\n     * when the plugin {@link #isEnabled is enabled}.\n     *\n     * @private\n     * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n     * @param {String} event The name of the event.\n     * @param {Function} callback The function to be called on event.\n     * @param {Object} [options={}] Additional options.\n     * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n     * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n     * order they were added.\n     */\n\n  }, {\n    key: \"_listenToIfEnabled\",\n    value: function _listenToIfEnabled(emitter, event, callback, options) {\n      var _this2 = this;\n\n      this.listenTo(emitter, event, function () {\n        // Do not respond if the plugin is disabled.\n        if (_this2.isEnabled) {\n          callback.apply(void 0, arguments);\n        }\n      }, options);\n    }\n    /**\n     * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n     * does not expect a position. Instead, it performs the insertion next to a selected widget\n     * according to the `widget-type-around` model selection attribute value (fake caret position).\n     *\n     * Because this method requires the `widget-type-around` attribute to be set,\n     * the insertion can only happen when the widget's fake caret is active (e.g. activated\n     * using the keyboard).\n     *\n     * @private\n     * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n     */\n\n  }, {\n    key: \"_insertParagraphAccordingToFakeCaretPosition\",\n    value: function _insertParagraphAccordingToFakeCaretPosition() {\n      var editor = this.editor;\n      var model = editor.model;\n      var modelSelection = model.document.selection;\n      var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n\n      if (!typeAroundFakeCaretPosition) {\n        return false;\n      }\n\n      var selectedModelElement = modelSelection.getSelectedElement();\n\n      this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);\n\n      return true;\n    }\n    /**\n     * Creates a listener in the editing conversion pipeline that injects the widget type around\n     * UI into every single widget instance created in the editor.\n     *\n     * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n     * wrapper which renders DOM buttons that users can use to insert paragraphs.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableTypeAroundUIInjection\",\n    value: function _enableTypeAroundUIInjection() {\n      var editor = this.editor;\n      var schema = editor.model.schema;\n      var t = editor.locale.t;\n      var buttonTitles = {\n        before: t('Insert paragraph before block'),\n        after: t('Insert paragraph after block')\n      };\n      editor.editing.downcastDispatcher.on('insert', function (evt, data, conversionApi) {\n        var viewElement = conversionApi.mapper.toViewElement(data.item); // Filter out non-widgets and inline widgets.\n\n        if (isTypeAroundWidget(viewElement, data.item, schema)) {\n          injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);\n        }\n      }, {\n        priority: 'low'\n      });\n    }\n    /**\n     * Brings support for the fake caret that appears when either:\n     *\n     * * the selection moves to a widget from a position next to it using arrow keys,\n     * * the arrow key is pressed when the widget is already selected.\n     *\n     * The fake caret lets the user know that they can start typing or just press\n     * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n     *\n     * The fake caret disappears when the user changes the selection or the editor\n     * gets blurred.\n     *\n     * The whole idea is as follows:\n     *\n     * 1. A user does one of the 2 scenarios described at the beginning.\n     * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n     * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n     *    on which side of the widget it should appear.\n     * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n     *    fake caret on the view widget.\n     * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n     *    does the CSS class clean-up in the view.\n     * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n     *    attribute (the former also removes widget CSS classes).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableTypeAroundFakeCaretActivationUsingKeyboardArrows\",\n    value: function _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n      var _this3 = this;\n\n      var editor = this.editor;\n      var model = editor.model;\n      var modelSelection = model.document.selection;\n      var schema = model.schema;\n      var editingView = editor.editing.view; // This is the main listener responsible for the fake caret.\n      // Note: The priority must precede the default Widget class keydown handler (\"high\").\n\n      this._listenToIfEnabled(editingView.document, 'arrowKey', function (evt, domEventData) {\n        _this3._handleArrowKeyPress(evt, domEventData);\n      }, {\n        context: [isWidget, '$text'],\n        priority: 'high'\n      }); // This listener makes sure the widget type around selection attribute will be gone from the model\n      // selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n      // (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n      // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n\n\n      this._listenToIfEnabled(modelSelection, 'change:range', function (evt, data) {\n        // Do not reset the selection attribute when the change was indirect.\n        if (!data.directChange) {\n          return;\n        } // Get rid of the widget type around attribute of the selection on every change:range.\n        // If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n\n\n        editor.model.change(function (writer) {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }); // Get rid of the widget type around attribute of the selection on every document change\n      // that makes widget not selected any more (i.e. widget was removed).\n\n\n      this._listenToIfEnabled(model.document, 'change:data', function () {\n        var selectedModelElement = modelSelection.getSelectedElement();\n\n        if (selectedModelElement) {\n          var selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n\n          if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n            return;\n          }\n        }\n\n        editor.model.change(function (writer) {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }); // React to changes of the model selection attribute made by the arrow keys listener.\n      // If the block widget is selected and the attribute changes, downcast the attribute to special\n      // CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n\n\n      this._listenToIfEnabled(editor.editing.downcastDispatcher, 'selection', function (evt, data, conversionApi) {\n        var writer = conversionApi.writer;\n\n        if (_this3._currentFakeCaretModelElement) {\n          var _selectedViewElement = conversionApi.mapper.toViewElement(_this3._currentFakeCaretModelElement);\n\n          if (_selectedViewElement) {\n            // Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n            writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), _selectedViewElement);\n            _this3._currentFakeCaretModelElement = null;\n          }\n        }\n\n        var selectedModelElement = data.selection.getSelectedElement();\n\n        if (!selectedModelElement) {\n          return;\n        }\n\n        var selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);\n\n        if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n          return;\n        }\n\n        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);\n\n        if (!typeAroundFakeCaretPosition) {\n          return;\n        }\n\n        writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement); // Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n        // selection changes\n\n        _this3._currentFakeCaretModelElement = selectedModelElement;\n      });\n\n      this._listenToIfEnabled(editor.ui.focusTracker, 'change:isFocused', function (evt, name, isFocused) {\n        if (!isFocused) {\n          editor.model.change(function (writer) {\n            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n          });\n        }\n      });\n\n      function positionToWidgetCssClass(position) {\n        return \"ck-widget_type-around_show-fake-caret_\".concat(position);\n      }\n    }\n    /**\n     * A listener executed on each \"keydown\" in the view document, a part of\n     * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n     *\n     * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n     * be deactivated).\n     *\n     * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n     * in this listener, and stopping and preventing the event that would normally be handled by the widget\n     * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n     * includes inline widgets, which are ignored by the widget type around plugin).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_handleArrowKeyPress\",\n    value: function _handleArrowKeyPress(evt, domEventData) {\n      var editor = this.editor;\n      var model = editor.model;\n      var modelSelection = model.document.selection;\n      var schema = model.schema;\n      var editingView = editor.editing.view;\n      var keyCode = domEventData.keyCode;\n      var isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);\n      var selectedViewElement = editingView.document.selection.getSelectedElement();\n      var selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n      var shouldStopAndPreventDefault; // Handle keyboard navigation when a type-around-compatible widget is currently selected.\n\n      if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n        shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);\n      } // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n      // and the widget is about to be selected.\n      else if (modelSelection.isCollapsed) {\n        shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);\n      } // Handle collapsing a non-collapsed selection that is wider than on a single widget.\n      else if (!domEventData.shiftKey) {\n        shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);\n      }\n\n      if (shouldStopAndPreventDefault) {\n        domEventData.preventDefault();\n        evt.stop();\n      }\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n     * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n     * selection attribute and the direction of the pressed arrow key.\n     *\n     * @private\n     * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n\n  }, {\n    key: \"_handleArrowKeyPressOnSelectedWidget\",\n    value: function _handleArrowKeyPressOnSelectedWidget(isForward) {\n      var editor = this.editor;\n      var model = editor.model;\n      var modelSelection = model.document.selection;\n      var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n      return model.change(function (writer) {\n        // If the fake caret is displayed...\n        if (typeAroundFakeCaretPosition) {\n          var isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before'); // If the keyboard arrow works against the value of the selection attribute...\n          // then remove the selection attribute but prevent default DOM actions\n          // and do not let the Widget plugin listener move the selection. This brings\n          // the widget back to the state, for instance, like if was selected using the mouse.\n          //\n          // **Note**: If leaving the widget when the fake caret is active, then the default\n          // Widget handler will change the selection and, in turn, this will automatically discard\n          // the selection attribute.\n\n          if (!isLeavingWidget) {\n            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n            return true;\n          }\n        } // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n        // key press. This also means we cannot let the Widget plugin listener move the selection.\n        else {\n          writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n          return true;\n        }\n\n        return false;\n      });\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n     * to one and upon the fake caret should become active for this widget upon arrow keypress\n     * (AKA entering/selecting the widget).\n     *\n     * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n     * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n     * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n     *\n     * @private\n     * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n\n  }, {\n    key: \"_handleArrowKeyPressWhenSelectionNextToAWidget\",\n    value: function _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {\n      var editor = this.editor;\n      var model = editor.model;\n      var schema = model.schema;\n      var widgetPlugin = editor.plugins.get('Widget'); // This is the widget the selection is about to be set on.\n\n      var modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);\n\n      var viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);\n\n      if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {\n        model.change(function (writer) {\n          widgetPlugin._setSelectionOverElement(modelElementNextToSelection);\n\n          writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');\n        }); // The change() block above does the same job as the Widget plugin. The event can\n        // be safely canceled.\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n     * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n     *\n     * @private\n     * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns {Boolean} Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n\n  }, {\n    key: \"_handleArrowKeyPressWhenNonCollapsedSelection\",\n    value: function _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {\n      var editor = this.editor;\n      var model = editor.model;\n      var schema = model.schema;\n      var mapper = editor.editing.mapper;\n      var modelSelection = model.document.selection;\n      var selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;\n      var selectedViewNode = mapper.toViewElement(selectedModelNode); // There is a widget at the collapse position so collapse the selection to the fake caret on it.\n\n      if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {\n        model.change(function (writer) {\n          writer.setSelection(selectedModelNode, 'on');\n          writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n        });\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Registers a `mousedown` listener for the view document which intercepts events\n     * coming from the widget type around UI, which happens when a user clicks one of the buttons\n     * that insert a paragraph next to a widget.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableInsertingParagraphsOnButtonClick\",\n    value: function _enableInsertingParagraphsOnButtonClick() {\n      var _this4 = this;\n\n      var editor = this.editor;\n      var editingView = editor.editing.view;\n\n      this._listenToIfEnabled(editingView.document, 'mousedown', function (evt, domEventData) {\n        var button = getClosestTypeAroundDomButton(domEventData.domTarget);\n\n        if (!button) {\n          return;\n        }\n\n        var buttonPosition = getTypeAroundButtonPosition(button);\n        var widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);\n        var widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);\n\n        _this4._insertParagraph(widgetModelElement, buttonPosition);\n\n        domEventData.preventDefault();\n        evt.stop();\n      });\n    }\n    /**\n     * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n     * near the widget when either:\n     *\n     * * The fake caret was first activated using the arrow keys,\n     * * The entire widget is selected in the model.\n     *\n     * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n     * attribute (see {@link #_handleArrowKeyPress}).\n     *\n     * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n     * was pressed or not.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableInsertingParagraphsOnEnterKeypress\",\n    value: function _enableInsertingParagraphsOnEnterKeypress() {\n      var _this5 = this;\n\n      var editor = this.editor;\n      var selection = editor.model.document.selection;\n      var editingView = editor.editing.view;\n\n      this._listenToIfEnabled(editingView.document, 'enter', function (evt, domEventData) {\n        // This event could be triggered from inside the widget but we are interested\n        // only when the widget is selected itself.\n        if (evt.eventPhase != 'atTarget') {\n          return;\n        }\n\n        var selectedModelElement = selection.getSelectedElement();\n        var selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n        var schema = editor.model.schema;\n        var wasHandled; // First check if the widget is selected and there's a type around selection attribute associated\n        // with the fake caret that would tell where to insert a new paragraph.\n\n        if (_this5._insertParagraphAccordingToFakeCaretPosition()) {\n          wasHandled = true;\n        } // Then, if there is no selection attribute associated with the fake caret, check if the widget\n        // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n        else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n          _this5._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');\n\n          wasHandled = true;\n        }\n\n        if (wasHandled) {\n          domEventData.preventDefault();\n          evt.stop();\n        }\n      }, {\n        context: isWidget\n      });\n    }\n    /**\n     * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n     * to insert a paragraph next to a widget when the fake caret was activated using arrow\n     * keys but it responds to typing keystrokes instead of <kbd>Enter</kbd>.\n     *\n     * \"Typing keystrokes\" are keystrokes that insert new content into the document,\n     * for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n     * will insert a new paragraph according to the `widget-type-around` model selection attribute\n     * as the user simply starts typing, which creates the impression that the fake caret\n     * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n     *\n     * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n     * and another one for actual typing. It is not a disaster but this may need to be fixed\n     * sooner or later.\n     *\n     * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableInsertingParagraphsOnTypingKeystroke\",\n    value: function _enableInsertingParagraphsOnTypingKeystroke() {\n      var _this6 = this;\n\n      var editor = this.editor;\n      var editingView = editor.editing.view;\n      var keyCodesHandledSomewhereElse = [keyCodes.enter, keyCodes.delete, keyCodes.backspace]; // Note: The priority must precede the default observers.\n\n      this._listenToIfEnabled(editingView.document, 'keydown', function (evt, domEventData) {\n        // Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n        if (!keyCodesHandledSomewhereElse.includes(domEventData.keyCode) && !isNonTypingKeystroke(domEventData)) {\n          _this6._insertParagraphAccordingToFakeCaretPosition();\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n     * is pressed and the fake caret is currently active.\n     *\n     * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n     * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n     * before or after a widget (depending on the content surrounding the widget).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableDeleteIntegration\",\n    value: function _enableDeleteIntegration() {\n      var editor = this.editor;\n      var editingView = editor.editing.view;\n      var model = editor.model;\n      var schema = model.schema;\n\n      this._listenToIfEnabled(editingView.document, 'delete', function (evt, domEventData) {\n        // This event could be triggered from inside the widget but we are interested\n        // only when the widget is selected itself.\n        if (evt.eventPhase != 'atTarget') {\n          return;\n        }\n\n        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection); // This listener handles only these cases when the fake caret is active.\n\n        if (!typeAroundFakeCaretPosition) {\n          return;\n        }\n\n        var direction = domEventData.direction;\n        var selectedModelWidget = model.document.selection.getSelectedElement();\n        var isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n        var isDeleteForward = direction == 'forward';\n        var shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n\n        if (shouldDeleteEntireWidget) {\n          editor.execute('delete', {\n            selection: model.createSelection(selectedModelWidget, 'on')\n          });\n        } else {\n          var range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction); // If there is somewhere to move selection to, then there will be something to delete.\n\n          if (range) {\n            // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n            if (!range.isCollapsed) {\n              model.change(function (writer) {\n                writer.setSelection(range);\n                editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n              });\n            } else {\n              var probe = model.createSelection(range.start);\n              model.modifySelection(probe, {\n                direction: direction\n              }); // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n              // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n\n              if (!probe.focus.isEqual(range.start)) {\n                model.change(function (writer) {\n                  writer.setSelection(range);\n                  editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n                });\n              } // If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n              // next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n              // so calling Model#deleteContent here manually.\n              else {\n                var deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);\n                model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {\n                  doNotAutoparagraph: true\n                });\n              }\n            }\n          }\n        } // If some content was deleted, don't let the handler from the Widget plugin kick in.\n        // If nothing was deleted, then the default handler will have nothing to do anyway.\n\n\n        domEventData.preventDefault();\n        evt.stop();\n      }, {\n        context: isWidget\n      });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n     * content near a widget when the fake caret is first activated using the arrow keys.\n     *\n     * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableInsertContentIntegration\",\n    value: function _enableInsertContentIntegration() {\n      var editor = this.editor;\n      var model = this.editor.model;\n      var documentSelection = model.document.selection;\n\n      this._listenToIfEnabled(editor.model, 'insertContent', function (evt, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            content = _ref2[0],\n            selectable = _ref2[1];\n\n        if (selectable && !selectable.is('documentSelection')) {\n          return;\n        }\n\n        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n\n        if (!typeAroundFakeCaretPosition) {\n          return;\n        }\n\n        evt.stop();\n        return model.change(function (writer) {\n          var selectedElement = documentSelection.getSelectedElement();\n          var position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);\n          var selection = writer.createSelection(position);\n          var result = model.insertContent(content, selection);\n          writer.setSelection(selection);\n          return result;\n        });\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the\n     * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element\n     * to reflect user's intent of desired insertion position.\n     *\n     * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableInsertObjectIntegration\",\n    value: function _enableInsertObjectIntegration() {\n      var editor = this.editor;\n      var model = this.editor.model;\n      var documentSelection = model.document.selection;\n\n      this._listenToIfEnabled(editor.model, 'insertObject', function (evt, args) {\n        var _args = _slicedToArray(args, 4),\n            selectable = _args[1],\n            _args$ = _args[3],\n            options = _args$ === void 0 ? {} : _args$;\n\n        if (selectable && !selectable.is('documentSelection')) {\n          return;\n        }\n\n        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n\n        if (!typeAroundFakeCaretPosition) {\n          return;\n        }\n\n        options.findOptimalPosition = typeAroundFakeCaretPosition;\n        args[3] = options;\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n     * caret is active.\n     *\n     * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n     * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n     * plain text pasting.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableDeleteContentIntegration\",\n    value: function _enableDeleteContentIntegration() {\n      var editor = this.editor;\n      var model = this.editor.model;\n      var documentSelection = model.document.selection;\n\n      this._listenToIfEnabled(editor.model, 'deleteContent', function (evt, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            selection = _ref4[0];\n\n        if (selection && !selection.is('documentSelection')) {\n          return;\n        }\n\n        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection); // Disable removing the selection content while pasting plain text.\n\n        if (typeAroundFakeCaretPosition) {\n          evt.stop();\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n  }]);\n\n  return WidgetTypeAround;\n}(Plugin); // Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\n\n\nexport { WidgetTypeAround as default };\n\nfunction injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {\n  var typeAroundWrapper = viewWriter.createUIElement('div', {\n    class: 'ck ck-reset_all ck-widget__type-around'\n  }, function (domDocument) {\n    var wrapperDomElement = this.toDomElement(domDocument);\n    injectButtons(wrapperDomElement, buttonTitles);\n    injectFakeCaret(wrapperDomElement);\n    return wrapperDomElement;\n  }); // Inject the type around wrapper into the widget's wrapper.\n\n  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);\n} // FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\n\n\nfunction injectButtons(wrapperDomElement, buttonTitles) {\n  var _iterator2 = _createForOfIteratorHelper(POSSIBLE_INSERTION_POSITIONS),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var position = _step2.value;\n      var buttonTemplate = new Template({\n        tag: 'div',\n        attributes: {\n          class: ['ck', 'ck-widget__type-around__button', \"ck-widget__type-around__button_\".concat(position)],\n          title: buttonTitles[position]\n        },\n        children: [wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)]\n      });\n      wrapperDomElement.appendChild(buttonTemplate.render());\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n} // @param {HTMLElement} wrapperDomElement\n\n\nfunction injectFakeCaret(wrapperDomElement) {\n  var caretTemplate = new Template({\n    tag: 'div',\n    attributes: {\n      class: ['ck', 'ck-widget__type-around__fake-caret']\n    }\n  });\n  wrapperDomElement.appendChild(caretTemplate.render());\n} // Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\n\n\nfunction getDeepestEmptyElementAncestor(schema, element) {\n  var deepestEmptyAncestor = element;\n\n  var _iterator3 = _createForOfIteratorHelper(element.getAncestors({\n    parentFirst: true\n  })),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var ancestor = _step3.value;\n\n      if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {\n        break;\n      }\n\n      deepestEmptyAncestor = ancestor;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return deepestEmptyAncestor;\n}","map":null,"metadata":{},"sourceType":"module"}