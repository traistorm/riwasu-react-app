{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/writer\n */\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport MergeOperation from './operation/mergeoperation';\nimport DocumentFragment from './documentfragment';\nimport Text from './text';\nimport Element from './element';\nimport RootElement from './rootelement';\nimport Position from './position';\nimport Range from './range.js';\nimport DocumentSelection from './documentselection';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\n\nvar Writer = /*#__PURE__*/function () {\n  /**\n   * Creates a writer instance.\n   *\n   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n   *\n   * @protected\n   * @param {module:engine/model/model~Model} model\n   * @param {module:engine/model/batch~Batch} batch\n   */\n  function Writer(model, batch) {\n    _classCallCheck(this, Writer);\n\n    /**\n     * Instance of the model on which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The batch to which this writer will add changes.\n     *\n     * @readonly\n     * @type {module:engine/model/batch~Batch}\n     */\n\n    this.batch = batch;\n  }\n  /**\n   * Creates a new {@link module:engine/model/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\t\twriter.createText( 'foo', { bold: true } );\n   *\n   * @param {String} data Text data.\n   * @param {Object} [attributes] Text attributes.\n   * @returns {module:engine/model/text~Text} Created text node.\n   */\n\n\n  _createClass(Writer, [{\n    key: \"createText\",\n    value: function createText(data, attributes) {\n      return new Text(data, attributes);\n    }\n    /**\n     * Creates a new {@link module:engine/model/element~Element element}.\n     *\n     *\t\twriter.createElement( 'paragraph' );\n     *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @returns {module:engine/model/element~Element} Created element.\n     */\n\n  }, {\n    key: \"createElement\",\n    value: function createElement(name, attributes) {\n      return new Element(name, attributes);\n    }\n    /**\n     * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n     *\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n     */\n\n  }, {\n    key: \"createDocumentFragment\",\n    value: function createDocumentFragment() {\n      return new DocumentFragment();\n    }\n    /**\n     * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.\n     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n     *\n     * @param {module:engine/model/element~Element} element The element to clone.\n     * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,\n     * element will be cloned without any child.\n     */\n\n  }, {\n    key: \"cloneElement\",\n    value: function cloneElement(element) {\n      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return element._clone(deep);\n    }\n    /**\n     * Inserts item on given position.\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.insert( paragraph, position );\n     *\n     * Instead of using position you can use parent and offset:\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\twriter.insert( text, paragraph, 5 );\n     *\n     * You can also use `end` instead of the offset to insert at the end:\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\twriter.insert( text, paragraph, 'end' );\n     *\n     * Or insert before or after another element:\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * Note that if the item already has parent it will be removed from the previous parent.\n     *\n     * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n     * `model-writer-insert-forbidden-move` is thrown.\n     *\n     * If you want to move {@link module:engine/model/range~Range range} instead of an\n     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n     *\n     * **Note:** For a paste-like content insertion mechanism see\n     * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n     * fragment to insert.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * second parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(item, itemOrPosition) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      this._assertWriterUsedCorrectly();\n\n      if (item instanceof Text && item.data == '') {\n        return;\n      }\n\n      var position = Position._createAt(itemOrPosition, offset); // If item has a parent already.\n\n\n      if (item.parent) {\n        // We need to check if item is going to be inserted within the same document.\n        if (isSameTree(item.root, position.root)) {\n          // If it's we just need to move it.\n          this.move(Range._createOn(item), position);\n          return;\n        } // If it isn't the same root.\n        else {\n          if (item.root.document) {\n            /**\n             * Cannot move a node from a document to a different tree.\n             * It is forbidden to move a node that was already in a document outside of it.\n             *\n             * @error model-writer-insert-forbidden-move\n             */\n            throw new CKEditorError('model-writer-insert-forbidden-move', this);\n          } else {\n            // Move between two different document fragments or from document fragment to a document is possible.\n            // In that case, remove the item from it's original parent.\n            this.remove(item);\n          }\n        }\n      }\n\n      var version = position.root.document ? position.root.document.version : null;\n      var insert = new InsertOperation(position, item, version);\n\n      if (item instanceof Text) {\n        insert.shouldReceiveAttributes = true;\n      }\n\n      this.batch.addOperation(insert);\n      this.model.applyOperation(insert); // When element is a DocumentFragment we need to move its markers to Document#markers.\n\n      if (item instanceof DocumentFragment) {\n        var _iterator = _createForOfIteratorHelper(item.markers),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                markerName = _step$value[0],\n                markerRange = _step$value[1];\n\n            // We need to migrate marker range from DocumentFragment to Document.\n            var rangeRootPosition = Position._createAt(markerRange.root, 0);\n\n            var range = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));\n            var options = {\n              range: range,\n              usingOperation: true,\n              affectsData: true\n            };\n\n            if (this.model.markers.has(markerName)) {\n              this.updateMarker(markerName, options);\n            } else {\n              this.addMarker(markerName, options);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\n     * Creates and inserts text on given position. You can optionally set text attributes:\n     *\n     *\t\twriter.insertText( 'foo', position );\n     *\t\twriter.insertText( 'foo', { bold: true }, position );\n     *\n     * Instead of using position you can use parent and offset or define that text should be inserted at the end\n     * or before or after other node:\n     *\n     *\t\t// Inserts 'foo' in paragraph, at offset 5:\n     *\t\twriter.insertText( 'foo', paragraph, 5 );\n     *\t\t// Inserts 'foo' at the end of a paragraph:\n     *\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t// Inserts 'foo' after an image:\n     *\t\twriter.insertText( 'foo', image, 'after' );\n     *\n     * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * @param {String} data Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * third parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"insertText\",\n    value: function insertText(text, attributes, itemOrPosition, offset) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n        this.insert(this.createText(text), attributes, itemOrPosition);\n      } else {\n        this.insert(this.createText(text, attributes), itemOrPosition, offset);\n      }\n    }\n    /**\n     * Creates and inserts element on given position. You can optionally set attributes:\n     *\n     *\t\twriter.insertElement( 'paragraph', position );\n     *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n     *\n     * Instead of using position you can use parent and offset or define that text should be inserted at the end\n     * or before or after other node:\n     *\n     *\t\t// Inserts paragraph in the root at offset 5:\n     *\t\twriter.insertElement( 'paragraph', root, 5 );\n     *\t\t// Inserts paragraph at the end of a blockquote:\n     *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n     *\t\t// Inserts after an image:\n     *\t\twriter.insertElement( 'paragraph', image, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * third parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"insertElement\",\n    value: function insertElement(name, attributes, itemOrPosition, offset) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {\n        this.insert(this.createElement(name), attributes, itemOrPosition);\n      } else {\n        this.insert(this.createElement(name, attributes), itemOrPosition, offset);\n      }\n    }\n    /**\n     * Inserts item at the end of the given parent.\n     *\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\twriter.append( paragraph, root );\n     *\n     * Note that if the item already has parent it will be removed from the previous parent.\n     *\n     * If you want to move {@link module:engine/model/range~Range range} instead of an\n     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n     * item Item or document fragment to insert.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n\n  }, {\n    key: \"append\",\n    value: function append(item, parent) {\n      this.insert(item, parent, 'end');\n    }\n    /**\n     * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n     *\n     *\t\twriter.appendText( 'foo', paragraph );\n     *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n     *\n     * @param {String} text Text data.\n     * @param {Object} [attributes] Text attributes.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n\n  }, {\n    key: \"appendText\",\n    value: function appendText(text, attributes, parent) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n        this.insert(this.createText(text), attributes, 'end');\n      } else {\n        this.insert(this.createText(text, attributes), parent, 'end');\n      }\n    }\n    /**\n     * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n     *\n     *\t\twriter.appendElement( 'paragraph', root );\n     *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n     */\n\n  }, {\n    key: \"appendElement\",\n    value: function appendElement(name, attributes, parent) {\n      if (attributes instanceof DocumentFragment || attributes instanceof Element) {\n        this.insert(this.createElement(name), attributes, 'end');\n      } else {\n        this.insert(this.createElement(name, attributes), parent, 'end');\n      }\n    }\n    /**\n     * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n     * or on a {@link module:engine/model/range~Range range}.\n     *\n     * @param {String} key Attribute key.\n     * @param {*} value Attribute new value.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range on which the attribute will be set.\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value, itemOrRange) {\n      this._assertWriterUsedCorrectly();\n\n      if (itemOrRange instanceof Range) {\n        var ranges = itemOrRange.getMinimalFlatRanges();\n\n        var _iterator2 = _createForOfIteratorHelper(ranges),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var range = _step2.value;\n            setAttributeOnRange(this, key, value, range);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        setAttributeOnItem(this, key, value, itemOrRange);\n      }\n    }\n    /**\n     * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n     * or on a {@link module:engine/model/range~Range range}.\n     *\n     *\t\twriter.setAttributes( {\n     *\t\t\tbold: true,\n     *\t\t\titalic: true\n     *\t\t}, range );\n     *\n     * @param {Object} attributes Attributes keys and values.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range on which the attributes will be set.\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes, itemOrRange) {\n      var _iterator3 = _createForOfIteratorHelper(toMap(attributes)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              key = _step3$value[0],\n              val = _step3$value[1];\n\n          this.setAttribute(key, val, itemOrRange);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n     * or from a {@link module:engine/model/range~Range range}.\n     *\n     * @param {String} key Attribute key.\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range from which the attribute will be removed.\n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key, itemOrRange) {\n      this._assertWriterUsedCorrectly();\n\n      if (itemOrRange instanceof Range) {\n        var ranges = itemOrRange.getMinimalFlatRanges();\n\n        var _iterator4 = _createForOfIteratorHelper(ranges),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var range = _step4.value;\n            setAttributeOnRange(this, key, null, range);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        setAttributeOnItem(this, key, null, itemOrRange);\n      }\n    }\n    /**\n     * Removes all attributes from all elements in the range or from the given item.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n     * Model item or range from which all attributes will be removed.\n     */\n\n  }, {\n    key: \"clearAttributes\",\n    value: function clearAttributes(itemOrRange) {\n      var _this = this;\n\n      this._assertWriterUsedCorrectly();\n\n      var removeAttributesFromItem = function removeAttributesFromItem(item) {\n        var _iterator5 = _createForOfIteratorHelper(item.getAttributeKeys()),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var attribute = _step5.value;\n\n            _this.removeAttribute(attribute, item);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      };\n\n      if (!(itemOrRange instanceof Range)) {\n        removeAttributesFromItem(itemOrRange);\n      } else {\n        var _iterator6 = _createForOfIteratorHelper(itemOrRange.getItems()),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var item = _step6.value;\n            removeAttributesFromItem(item);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n    }\n    /**\n     * Moves all items in the source range to the target position.\n     *\n     *\t\twriter.move( sourceRange, targetPosition );\n     *\n     * Instead of the target position you can use parent and offset or define that range should be moved to the end\n     * or before or after chosen item:\n     *\n     *\t\t// Moves all items in the range to the paragraph at offset 5:\n     *\t\twriter.move( sourceRange, paragraph, 5 );\n     *\t\t// Moves all items in the range to the end of a blockquote:\n     *\t\twriter.move( sourceRange, blockquote, 'end' );\n     *\t\t// Moves all items in the range to a position after an image:\n     *\t\twriter.move( sourceRange, image, 'after' );\n     *\n     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n     *\n     * Note that items can be moved only within the same tree. It means that you can move items within the same root\n     * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n     * but you can not move items from document fragment to the document or from one detached element to another. Use\n     * {@link module:engine/model/writer~Writer#insert} in such cases.\n     *\n     * @param {module:engine/model/range~Range} range Source range.\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * second parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(range, itemOrPosition, offset) {\n      this._assertWriterUsedCorrectly();\n\n      if (!(range instanceof Range)) {\n        /**\n         * Invalid range to move.\n         *\n         * @error writer-move-invalid-range\n         */\n        throw new CKEditorError('writer-move-invalid-range', this);\n      }\n\n      if (!range.isFlat) {\n        /**\n         * Range to move is not flat.\n         *\n         * @error writer-move-range-not-flat\n         */\n        throw new CKEditorError('writer-move-range-not-flat', this);\n      }\n\n      var position = Position._createAt(itemOrPosition, offset); // Do not move anything if the move target is same as moved range start.\n\n\n      if (position.isEqual(range.start)) {\n        return;\n      } // If part of the marker is removed, create additional marker operation for undo purposes.\n\n\n      this._addOperationForAffectedMarkers('move', range);\n\n      if (!isSameTree(range.root, position.root)) {\n        /**\n         * Range is going to be moved within not the same document. Please use\n         * {@link module:engine/model/writer~Writer#insert insert} instead.\n         *\n         * @error writer-move-different-document\n         */\n        throw new CKEditorError('writer-move-different-document', this);\n      }\n\n      var version = range.root.document ? range.root.document.version : null;\n      var operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version);\n      this.batch.addOperation(operation);\n      this.model.applyOperation(operation);\n    }\n    /**\n     * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(itemOrRange) {\n      this._assertWriterUsedCorrectly();\n\n      var rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);\n      var ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n\n      var _iterator7 = _createForOfIteratorHelper(ranges),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var flat = _step7.value;\n\n          // If part of the marker is removed, create additional marker operation for undo purposes.\n          this._addOperationForAffectedMarkers('move', flat);\n\n          applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n    /**\n     * Merges two siblings at the given position.\n     *\n     * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n     * `writer-merge-no-element-after` error will be thrown.\n     *\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(position) {\n      this._assertWriterUsedCorrectly();\n\n      var nodeBefore = position.nodeBefore;\n      var nodeAfter = position.nodeAfter; // If part of the marker is removed, create additional marker operation for undo purposes.\n\n      this._addOperationForAffectedMarkers('merge', position);\n\n      if (!(nodeBefore instanceof Element)) {\n        /**\n         * Node before merge position must be an element.\n         *\n         * @error writer-merge-no-element-before\n         */\n        throw new CKEditorError('writer-merge-no-element-before', this);\n      }\n\n      if (!(nodeAfter instanceof Element)) {\n        /**\n         * Node after merge position must be an element.\n         *\n         * @error writer-merge-no-element-after\n         */\n        throw new CKEditorError('writer-merge-no-element-after', this);\n      }\n\n      if (!position.root.document) {\n        this._mergeDetached(position);\n      } else {\n        this._merge(position);\n      }\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionFromPath\",\n    value: function createPositionFromPath(root, path, stickiness) {\n      return this.model.createPositionFromPath(root, path, stickiness);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return this.model.createPositionAt(itemOrPosition, offset);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return this.model.createPositionAfter(item);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return this.model.createPositionBefore(item);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n     *\n     * @param {module:engine/model/position~Position} start Start position.\n     * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return this.model.createRange(start, end);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return this.model.createRangeIn(element);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(element) {\n      return this.model.createRangeOn(element);\n    }\n    /**\n     * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @returns {module:engine/model/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return this.model.createSelection(selectable, placeOrOffset, options);\n    }\n    /**\n     * Performs merge action in a detached tree.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n\n  }, {\n    key: \"_mergeDetached\",\n    value: function _mergeDetached(position) {\n      var nodeBefore = position.nodeBefore;\n      var nodeAfter = position.nodeAfter;\n      this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, 'end'));\n      this.remove(nodeAfter);\n    }\n    /**\n     * Performs merge action in a non-detached tree.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position Position between merged elements.\n     */\n\n  }, {\n    key: \"_merge\",\n    value: function _merge(position) {\n      var targetPosition = Position._createAt(position.nodeBefore, 'end');\n\n      var sourcePosition = Position._createAt(position.nodeAfter, 0);\n\n      var graveyard = position.root.document.graveyard;\n      var graveyardPosition = new Position(graveyard, [0]);\n      var version = position.root.document.version;\n      var merge = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);\n      this.batch.addOperation(merge);\n      this.model.applyOperation(merge);\n    }\n    /**\n     * Renames the given element.\n     *\n     * @param {module:engine/model/element~Element} element The element to rename.\n     * @param {String} newName New element name.\n     */\n\n  }, {\n    key: \"rename\",\n    value: function rename(element, newName) {\n      this._assertWriterUsedCorrectly();\n\n      if (!(element instanceof Element)) {\n        /**\n         * Trying to rename an object which is not an instance of Element.\n         *\n         * @error writer-rename-not-element-instance\n         */\n        throw new CKEditorError('writer-rename-not-element-instance', this);\n      }\n\n      var version = element.root.document ? element.root.document.version : null;\n      var renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version);\n      this.batch.addOperation(renameOperation);\n      this.model.applyOperation(renameOperation);\n    }\n    /**\n     * Splits elements starting from the given position and going to the top of the model tree as long as given\n     * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n     *\n     * The element needs to have a parent. It cannot be a root element nor a document fragment.\n     * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n     *\n     * @param {module:engine/model/position~Position} position Position of split.\n     * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n     * @returns {Object} result Split result.\n     * @returns {module:engine/model/position~Position} result.position Position between split elements.\n     * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n     * at the beginning of the first copy element.\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(position, limitElement) {\n      this._assertWriterUsedCorrectly();\n\n      var splitElement = position.parent;\n\n      if (!splitElement.parent) {\n        /**\n         * Element with no parent can not be split.\n         *\n         * @error writer-split-element-no-parent\n         */\n        throw new CKEditorError('writer-split-element-no-parent', this);\n      } // When limit element is not defined lets set splitElement parent as limit.\n\n\n      if (!limitElement) {\n        limitElement = splitElement.parent;\n      }\n\n      if (!position.parent.getAncestors({\n        includeSelf: true\n      }).includes(limitElement)) {\n        /**\n         * Limit element is not a position ancestor.\n         *\n         * @error writer-split-invalid-limit-element\n         */\n        throw new CKEditorError('writer-split-invalid-limit-element', this);\n      } // We need to cache elements that will be created as a result of the first split because\n      // we need to create a range from the end of the first split element to the beginning of the\n      // first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\n\n      var firstSplitElement, firstCopyElement;\n\n      do {\n        var version = splitElement.root.document ? splitElement.root.document.version : null;\n        var howMany = splitElement.maxOffset - position.offset;\n        var insertionPosition = SplitOperation.getInsertionPosition(position);\n        var split = new SplitOperation(position, howMany, insertionPosition, null, version);\n        this.batch.addOperation(split);\n        this.model.applyOperation(split); // Cache result of the first split.\n\n        if (!firstSplitElement && !firstCopyElement) {\n          firstSplitElement = splitElement;\n          firstCopyElement = position.parent.nextSibling;\n        }\n\n        position = this.createPositionAfter(position.parent);\n        splitElement = position.parent;\n      } while (splitElement !== limitElement);\n\n      return {\n        position: position,\n        range: new Range(Position._createAt(firstSplitElement, 'end'), Position._createAt(firstCopyElement, 0))\n      };\n    }\n    /**\n     * Wraps the given range with the given element or with a new element (if a string was passed).\n     *\n     * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n     * If not, an error will be thrown.\n     *\n     * @param {module:engine/model/range~Range} range Range to wrap.\n     * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n     */\n\n  }, {\n    key: \"wrap\",\n    value: function wrap(range, elementOrString) {\n      this._assertWriterUsedCorrectly();\n\n      if (!range.isFlat) {\n        /**\n         * Range to wrap is not flat.\n         *\n         * @error writer-wrap-range-not-flat\n         */\n        throw new CKEditorError('writer-wrap-range-not-flat', this);\n      }\n\n      var element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);\n\n      if (element.childCount > 0) {\n        /**\n         * Element to wrap with is not empty.\n         *\n         * @error writer-wrap-element-not-empty\n         */\n        throw new CKEditorError('writer-wrap-element-not-empty', this);\n      }\n\n      if (element.parent !== null) {\n        /**\n         * Element to wrap with is already attached to a tree model.\n         *\n         * @error writer-wrap-element-attached\n         */\n        throw new CKEditorError('writer-wrap-element-attached', this);\n      }\n\n      this.insert(element, range.start); // Shift the range-to-wrap because we just inserted an element before that range.\n\n      var shiftedRange = new Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));\n      this.move(shiftedRange, Position._createAt(element, 0));\n    }\n    /**\n     * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n     * Throws error if you try to unwrap an element which does not have a parent.\n     *\n     * @param {module:engine/model/element~Element} element Element to unwrap.\n     */\n\n  }, {\n    key: \"unwrap\",\n    value: function unwrap(element) {\n      this._assertWriterUsedCorrectly();\n\n      if (element.parent === null) {\n        /**\n         * Trying to unwrap an element which has no parent.\n         *\n         * @error writer-unwrap-element-no-parent\n         */\n        throw new CKEditorError('writer-unwrap-element-no-parent', this);\n      }\n\n      this.move(Range._createIn(element), this.createPositionAfter(element));\n      this.remove(element);\n    }\n    /**\n     * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n     * changes in the document and updates its range automatically, when model tree changes.\n     *\n     * As the first parameter you can set marker name.\n     *\n     * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n     * markers managed by operations and not-managed by operations.\n     *\n     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n     * `true` when the marker change changes the data returned by the\n     * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n     *\n     * Create marker directly base on marker's name:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: false } );\n     *\n     * Create marker using operation:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: true } );\n     *\n     * Create marker that affects the editor data:\n     *\n     *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n     *\n     * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n     *\n     * @see module:engine/model/markercollection~Marker\n     * @param {String} name Name of a marker to create - must be unique.\n     * @param {Object} options\n     * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n     * @param {module:engine/model/range~Range} options.range Marker range.\n     * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n     * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n     */\n\n  }, {\n    key: \"addMarker\",\n    value: function addMarker(name, options) {\n      this._assertWriterUsedCorrectly();\n\n      if (!options || typeof options.usingOperation != 'boolean') {\n        /**\n         * The `options.usingOperation` parameter is required when adding a new marker.\n         *\n         * @error writer-addmarker-no-usingoperation\n         */\n        throw new CKEditorError('writer-addmarker-no-usingoperation', this);\n      }\n\n      var usingOperation = options.usingOperation;\n      var range = options.range;\n      var affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n      if (this.model.markers.has(name)) {\n        /**\n         * Marker with provided name already exists.\n         *\n         * @error writer-addmarker-marker-exists\n         */\n        throw new CKEditorError('writer-addmarker-marker-exists', this);\n      }\n\n      if (!range) {\n        /**\n         * Range parameter is required when adding a new marker.\n         *\n         * @error writer-addmarker-no-range\n         */\n        throw new CKEditorError('writer-addmarker-no-range', this);\n      }\n\n      if (!usingOperation) {\n        return this.model.markers._set(name, range, usingOperation, affectsData);\n      }\n\n      applyMarkerOperation(this, name, null, range, affectsData);\n      return this.model.markers.get(name);\n    }\n    /**\n     * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n     * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n     * marker's range directly using this method.\n     *\n     * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n     * name is created and returned.\n     *\n     * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model\n     * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.\n     *\n     * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n     * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n     *\n     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n     * `true` when the marker change changes the data returned by\n     * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n     *\n     * Update marker directly base on marker's name:\n     *\n     *\t\tupdateMarker( markerName, { range } );\n     *\n     * Update marker using operation:\n     *\n     *\t\tupdateMarker( marker, { range, usingOperation: true } );\n     *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n     *\n     * Change marker's option (start using operations to manage it):\n     *\n     *\t\tupdateMarker( marker, { usingOperation: true } );\n     *\n     * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n     *\n     *\t\tupdateMarker( markerName, { affectsData: false } );\n     *\n     * @see module:engine/model/markercollection~Marker\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n     * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n     * downcast conversion for this marker with the same data.\n     * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n     * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n     * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n     */\n\n  }, {\n    key: \"updateMarker\",\n    value: function updateMarker(markerOrName, options) {\n      this._assertWriterUsedCorrectly();\n\n      var markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n      var currentMarker = this.model.markers.get(markerName);\n\n      if (!currentMarker) {\n        /**\n         * Marker with provided name does not exist and will not be updated.\n         *\n         * @error writer-updatemarker-marker-not-exists\n         */\n        throw new CKEditorError('writer-updatemarker-marker-not-exists', this);\n      }\n\n      if (!options) {\n        /**\n         * The usage of `writer.updateMarker()` only to reconvert (refresh) a\n         * {@link module:engine/model/markercollection~Marker model marker} was deprecated and may not work in the future.\n         * Please update your code to use\n         * {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker `editor.editing.reconvertMarker()`}\n         * instead.\n         *\n         * @error writer-updatemarker-reconvert-using-editingcontroller\n         * @param {String} markerName The name of the updated marker.\n         */\n        logWarning('writer-updatemarker-reconvert-using-editingcontroller', {\n          markerName: markerName\n        });\n\n        this.model.markers._refresh(currentMarker);\n\n        return;\n      }\n\n      var hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n      var affectsDataDefined = typeof options.affectsData == 'boolean'; // Use previously defined marker's affectsData if the property is not provided.\n\n      var affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n      if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {\n        /**\n         * One of the options is required - provide range, usingOperations or affectsData.\n         *\n         * @error writer-updatemarker-wrong-options\n         */\n        throw new CKEditorError('writer-updatemarker-wrong-options', this);\n      }\n\n      var currentRange = currentMarker.getRange();\n      var updatedRange = options.range ? options.range : currentRange;\n\n      if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {\n        // The marker type is changed so it's necessary to create proper operations.\n        if (options.usingOperation) {\n          // If marker changes to a managed one treat this as synchronizing existing marker.\n          // Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n          applyMarkerOperation(this, markerName, null, updatedRange, affectsData);\n        } else {\n          // If marker changes to a marker that do not use operations then we need to create additional operation\n          // that removes that marker first.\n          applyMarkerOperation(this, markerName, currentRange, null, affectsData); // Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\n          this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n        }\n\n        return;\n      } // Marker's type doesn't change so update it accordingly.\n\n\n      if (currentMarker.managedUsingOperations) {\n        applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);\n      } else {\n        this.model.markers._set(markerName, updatedRange, undefined, affectsData);\n      }\n    }\n    /**\n     * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n     * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n     * it will be destroyed using operation.\n     *\n     * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n     */\n\n  }, {\n    key: \"removeMarker\",\n    value: function removeMarker(markerOrName) {\n      this._assertWriterUsedCorrectly();\n\n      var name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n      if (!this.model.markers.has(name)) {\n        /**\n         * Trying to remove marker which does not exist.\n         *\n         * @error writer-removemarker-no-marker\n         */\n        throw new CKEditorError('writer-removemarker-no-marker', this);\n      }\n\n      var marker = this.model.markers.get(name);\n\n      if (!marker.managedUsingOperations) {\n        this.model.markers._remove(name);\n\n        return;\n      }\n\n      var oldRange = marker.getRange();\n      applyMarkerOperation(this, name, oldRange, null, marker.affectsData);\n    }\n    /**\n     * Sets the document's selection (ranges and direction) to the specified location based on the given\n     * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n     *\n     *\t\t// Sets selection to the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\twriter.setSelection( range );\n     *\n     *\t\t// Sets selection to given ranges.\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\twriter.setSelection( ranges );\n     *\n     *\t\t// Sets selection to other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\twriter.setSelection( otherSelection );\n     *\n     *\t\t// Sets selection to the given document selection.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\twriter.setSelection( documentSelection );\n     *\n     *\t\t// Sets collapsed selection at the given position.\n     *\t\tconst position = writer.createPosition( root, path );\n     *\t\twriter.setSelection( position );\n     *\n     *\t\t// Sets collapsed selection at the position of the given node and an offset.\n     *\t\twriter.setSelection( paragraph, offset );\n     *\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n    \t * that element and ends after the last child of that element.\n     *\n     *\t\twriter.setSelection( paragraph, 'in' );\n     *\n     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n     *\n     *\t\twriter.setSelection( paragraph, 'on' );\n     *\n     *\t\t// Removes all selection's ranges.\n     *\t\twriter.setSelection( null );\n     *\n     * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n     *\n     *\t\t// Sets selection as backward.\n     *\t\twriter.setSelection( range, { backward: true } );\n     *\n     * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     */\n\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selectable, placeOrOffset, options) {\n      this._assertWriterUsedCorrectly();\n\n      this.model.document.selection._setTo(selectable, placeOrOffset, options);\n    }\n    /**\n     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n     *\n     * The location can be specified in the same form as\n     * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"setSelectionFocus\",\n    value: function setSelectionFocus(itemOrPosition, offset) {\n      this._assertWriterUsedCorrectly();\n\n      this.model.document.selection._setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n     *\n     * Using key and value pair:\n     *\n     * \twriter.setSelectionAttribute( 'italic', true );\n     *\n     * Using key-value object:\n     *\n     * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n     *\n     * Using iterable object:\n     *\n     * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n     *\n     * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n     * or object / iterable of key => value attribute pairs.\n     * @param {*} [value] Attribute value.\n     */\n\n  }, {\n    key: \"setSelectionAttribute\",\n    value: function setSelectionAttribute(keyOrObjectOrIterable, value) {\n      this._assertWriterUsedCorrectly();\n\n      if (typeof keyOrObjectOrIterable === 'string') {\n        this._setSelectionAttribute(keyOrObjectOrIterable, value);\n      } else {\n        var _iterator8 = _createForOfIteratorHelper(toMap(keyOrObjectOrIterable)),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var _step8$value = _slicedToArray(_step8.value, 2),\n                key = _step8$value[0],\n                _value = _step8$value[1];\n\n            this._setSelectionAttribute(key, _value);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n    }\n    /**\n     * Removes attribute(s) with given key(s) from the selection.\n     *\n     * Remove one attribute:\n     *\n     *\t\twriter.removeSelectionAttribute( 'italic' );\n     *\n     * Remove multiple attributes:\n     *\n     *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n     *\n     * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n     */\n\n  }, {\n    key: \"removeSelectionAttribute\",\n    value: function removeSelectionAttribute(keyOrIterableOfKeys) {\n      this._assertWriterUsedCorrectly();\n\n      if (typeof keyOrIterableOfKeys === 'string') {\n        this._removeSelectionAttribute(keyOrIterableOfKeys);\n      } else {\n        var _iterator9 = _createForOfIteratorHelper(keyOrIterableOfKeys),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var key = _step9.value;\n\n            this._removeSelectionAttribute(key);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n    }\n    /**\n     * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n     * of the selection from left to right.\n     *\n     * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n     * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n     * This method allows to temporarily override this behavior by forcing the gravity to the right.\n     *\n     * For the following model fragment:\n     *\n     *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n     *\n     * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n     * * Overridden gravity: selection will have `bold` attribute.\n     *\n     * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n     * of the process.\n     *\n     * @returns {String} The unique id which allows restoring the gravity.\n     */\n\n  }, {\n    key: \"overrideSelectionGravity\",\n    value: function overrideSelectionGravity() {\n      return this.model.document.selection._overrideGravity();\n    }\n    /**\n     * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n     *\n     * Restoring the gravity is only possible using the unique identifier returned by\n     * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n     * the same number of times it was overridden.\n     *\n     * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n     */\n\n  }, {\n    key: \"restoreSelectionGravity\",\n    value: function restoreSelectionGravity(uid) {\n      this.model.document.selection._restoreGravity(uid);\n    }\n    /**\n     * @private\n     * @param {String} key Key of the attribute to remove.\n     * @param {*} value Attribute value.\n     */\n\n  }, {\n    key: \"_setSelectionAttribute\",\n    value: function _setSelectionAttribute(key, value) {\n      var selection = this.model.document.selection; // Store attribute in parent element if the selection is collapsed in an empty node.\n\n      if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n        var storeKey = DocumentSelection._getStoreAttributeKey(key);\n\n        this.setAttribute(storeKey, value, selection.anchor.parent);\n      }\n\n      selection._setAttribute(key, value);\n    }\n    /**\n     * @private\n     * @param {String} key Key of the attribute to remove.\n     */\n\n  }, {\n    key: \"_removeSelectionAttribute\",\n    value: function _removeSelectionAttribute(key) {\n      var selection = this.model.document.selection; // Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\n      if (selection.isCollapsed && selection.anchor.parent.isEmpty) {\n        var storeKey = DocumentSelection._getStoreAttributeKey(key);\n\n        this.removeAttribute(storeKey, selection.anchor.parent);\n      }\n\n      selection._removeAttribute(key);\n    }\n    /**\n     * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_assertWriterUsedCorrectly\",\n    value: function _assertWriterUsedCorrectly() {\n      /**\n       * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n       * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n       *\n       * The writer can only be used inside these blocks which ensures that the model\n       * can only be changed during such \"sessions\".\n       *\n       * @error writer-incorrect-use\n       */\n      if (this.model._currentWriter !== this) {\n        throw new CKEditorError('writer-incorrect-use', this);\n      }\n    }\n    /**\n     * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n     * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n     * can be later correctly processed during undo.\n     *\n     * @private\n     * @param {'move'|'merge'} type Writer action type.\n     * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n     * where the writer action happens.\n     */\n\n  }, {\n    key: \"_addOperationForAffectedMarkers\",\n    value: function _addOperationForAffectedMarkers(type, positionOrRange) {\n      var _iterator10 = _createForOfIteratorHelper(this.model.markers),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var marker = _step10.value;\n\n          if (!marker.managedUsingOperations) {\n            continue;\n          }\n\n          var markerRange = marker.getRange();\n          var isAffected = false;\n\n          if (type === 'move') {\n            isAffected = positionOrRange.containsPosition(markerRange.start) || positionOrRange.start.isEqual(markerRange.start) || positionOrRange.containsPosition(markerRange.end) || positionOrRange.end.isEqual(markerRange.end);\n          } else {\n            // if type === 'merge'.\n            var elementBefore = positionOrRange.nodeBefore;\n            var elementAfter = positionOrRange.nodeAfter; //               Start:  <p>Foo[</p><p>Bar]</p>\n            //         After merge:  <p>Foo[Bar]</p>\n            // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd; //               Start:  <p>[Foo</p><p>]Bar</p>\n            //         After merge:  <p>[Foo]Bar</p>\n            // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0; //               Start:  <p>[Foo</p>]<p>Bar</p>\n            //         After merge:  <p>[Foo]Bar</p>\n            // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter; //               Start:  <p>Foo</p>[<p>Bar]</p>\n            //         After merge:  <p>Foo[Bar]</p>\n            // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n            //\n\n            var affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n            isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n          }\n\n          if (isAffected) {\n            this.updateMarker(marker.name, {\n              range: markerRange\n            });\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }]);\n\n  return Writer;\n}(); // Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\n\n\nexport { Writer as default };\n\nfunction setAttributeOnRange(writer, key, value, range) {\n  var model = writer.model;\n  var doc = model.document; // Position of the last split, the beginning of the new range.\n\n  var lastSplitPosition = range.start; // Currently position in the scanning range. Because we need value after the position, it is not a current\n  // position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\n  var position; // Value before the currently position.\n\n  var valueBefore; // Value after the currently position.\n\n  var valueAfter;\n\n  var _iterator11 = _createForOfIteratorHelper(range.getWalker({\n    shallow: true\n  })),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var val = _step11.value;\n      valueAfter = val.item.getAttribute(key); // At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n      // because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\n      if (position && valueBefore != valueAfter) {\n        // if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n        if (valueBefore != value) {\n          addOperation();\n        }\n\n        lastSplitPosition = position;\n      }\n\n      position = val.nextPosition;\n      valueBefore = valueAfter;\n    } // Because position in the loop is not the iterator position (see let position comment), the last position in\n    // the while loop will be last but one position in the range. We need to check the last position manually.\n\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {\n    addOperation();\n  }\n\n  function addOperation() {\n    var range = new Range(lastSplitPosition, position);\n    var version = range.root.document ? doc.version : null;\n    var operation = new AttributeOperation(range, key, valueBefore, value, version);\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n} // Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\n\n\nfunction setAttributeOnItem(writer, key, value, item) {\n  var model = writer.model;\n  var doc = model.document;\n  var previousValue = item.getAttribute(key);\n  var range, operation;\n\n  if (previousValue != value) {\n    var isRootChanged = item.root === item;\n\n    if (isRootChanged) {\n      // If we change attributes of root element, we have to use `RootAttributeOperation`.\n      var version = item.document ? doc.version : null;\n      operation = new RootAttributeOperation(item, key, previousValue, value, version);\n    } else {\n      range = new Range(Position._createBefore(item), writer.createPositionAfter(item));\n\n      var _version = range.root.document ? doc.version : null;\n\n      operation = new AttributeOperation(range, key, previousValue, value, _version);\n    }\n\n    writer.batch.addOperation(operation);\n    model.applyOperation(operation);\n  }\n} // Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\n\n\nfunction applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {\n  var model = writer.model;\n  var doc = model.document;\n  var operation = new MarkerOperation(name, oldRange, newRange, model.markers, affectsData, doc.version);\n  writer.batch.addOperation(operation);\n  model.applyOperation(operation);\n} // Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\n\n\nfunction applyRemoveOperation(position, howMany, batch, model) {\n  var operation;\n\n  if (position.root.document) {\n    var doc = model.document;\n    var graveyardPosition = new Position(doc.graveyard, [0]);\n    operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);\n  } else {\n    operation = new DetachOperation(position, howMany);\n  }\n\n  batch.addOperation(operation);\n  model.applyOperation(operation);\n} // Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\n\n\nfunction isSameTree(rootA, rootB) {\n  // If it is the same root this is the same tree.\n  if (rootA === rootB) {\n    return true;\n  } // If both roots are documents root it is operation within the document what we still treat as the same tree.\n\n\n  if (rootA instanceof RootElement && rootB instanceof RootElement) {\n    return true;\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"module"}