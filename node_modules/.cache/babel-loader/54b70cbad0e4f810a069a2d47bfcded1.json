{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from './element';\nimport ModelRange from './range';\nimport ModelPosition from './position';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\nimport _insertContent from './utils/insertcontent';\nimport _insertObject from './utils/insertobject';\nimport _deleteContent from './utils/deletecontent';\nimport _modifySelection from './utils/modifyselection';\nimport _getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport { autoParagraphEmptyRoots } from './utils/autoparagraphing';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror'; // @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Model = /*#__PURE__*/function () {\n  function Model() {\n    var _this = this;\n\n    _classCallCheck(this, Model);\n\n    /**\n     * Model's marker collection.\n     *\n     * @readonly\n     * @member {module:engine/model/markercollection~MarkerCollection}\n     */\n    this.markers = new MarkerCollection();\n    /**\n     * Model's document.\n     *\n     * @readonly\n     * @member {module:engine/model/document~Document}\n     */\n\n    this.document = new Document(this);\n    /**\n     * Model's schema.\n     *\n     * @readonly\n     * @member {module:engine/model/schema~Schema}\n     */\n\n    this.schema = new Schema();\n    /**\n     * All callbacks added by {@link module:engine/model/model~Model#change} or\n     * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n     *\n     * @private\n     * @type {Array.<Function>}\n     */\n\n    this._pendingChanges = [];\n    /**\n     * The last created and currently used writer instance.\n     *\n     * @private\n     * @member {module:engine/model/writer~Writer}\n     */\n\n    this._currentWriter = null;\n    ['insertContent', 'insertObject', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(function (methodName) {\n      return _this.decorate(methodName);\n    }); // Adding operation validation with `highest` priority, so it is called before any other feature would like\n    // to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\n    this.on('applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      operation._validate();\n    }, {\n      priority: 'highest'\n    }); // Register some default abstract entities.\n\n    this.schema.register('$root', {\n      isLimit: true\n    });\n    this.schema.register('$container', {\n      allowIn: ['$root', '$container']\n    });\n    this.schema.register('$block', {\n      allowIn: ['$root', '$container'],\n      isBlock: true\n    });\n    this.schema.register('$blockObject', {\n      allowWhere: '$block',\n      isBlock: true,\n      isObject: true\n    });\n    this.schema.register('$inlineObject', {\n      allowWhere: '$text',\n      allowAttributesOf: '$text',\n      isInline: true,\n      isObject: true\n    });\n    this.schema.register('$text', {\n      allowIn: '$block',\n      isInline: true,\n      isContent: true\n    });\n    this.schema.register('$clipboardHolder', {\n      allowContentOf: '$root',\n      allowChildren: '$text',\n      isLimit: true\n    });\n    this.schema.register('$documentFragment', {\n      allowContentOf: '$root',\n      allowChildren: '$text',\n      isLimit: true\n    }); // An element needed by the `upcastElementToMarker` converter.\n    // This element temporarily represents a marker boundary during the conversion process and is removed\n    // at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n    // better place for this registration but both know nothing about `Schema`.\n\n    this.schema.register('$marker');\n    this.schema.addChildCheck(function (context, childDefinition) {\n      if (childDefinition.name === '$marker') {\n        return true;\n      }\n    });\n    injectSelectionPostFixer(this); // Post-fixer which takes care of adding empty paragraph elements to the empty roots.\n\n    this.document.registerPostFixer(autoParagraphEmptyRoots); // @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n    // @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n    // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n  }\n  /**\n   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n   * (including detached nodes â€“ i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n   * the {@link module:engine/model/document~Document#selection document's selection}, and\n   * {@link module:engine/model/model~Model#markers model markers}.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n   *\t\t} );\n   *\n   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n   * into a single undo step.\n   *\n   *\t\tmodel.change( writer => {\n   *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n   *\n   *\t\t\tmodel.change( writer => {\n   *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n   *\t\t\t} );\n   *\n   * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n   *\t\t} );\n   *\n   * The callback of the `change()` block is executed synchronously.\n   *\n   * You can also return a value from the change block.\n   *\n   *\t\tconst img = model.change( writer => {\n   *\t\t\treturn writer.createElement( 'img' );\n   *\t\t} );\n   *\n   * @see #enqueueChange\n   * @param {Function} callback Callback function which may modify the model.\n   * @returns {*} Value returned by the callback.\n   */\n\n\n  _createClass(Model, [{\n    key: \"change\",\n    value: function change(callback) {\n      try {\n        if (this._pendingChanges.length === 0) {\n          // If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n          this._pendingChanges.push({\n            batch: new Batch(),\n            callback: callback\n          });\n\n          return this._runPendingChanges()[0];\n        } else {\n          // If this is not the outermost block, just execute the callback.\n          return callback(this._currentWriter);\n        }\n      } catch (err) {\n        // @if CK_DEBUG // throw err;\n\n        /* istanbul ignore next */\n        CKEditorError.rethrowUnexpectedError(err, this);\n      }\n    }\n    /**\n     * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n     *\n     * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n     * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n     * it will be delayed and executed after the outermost block.\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconsole.log( 1 );\n     *\n     *\t\t\tmodel.enqueueChange( writer => {\n     *\t\t\t\tconsole.log( 2 );\n     *\t\t\t} );\n     *\n     * \t\t\tconsole.log( 3 );\n     *\t\t} ); // Will log: 1, 3, 2.\n     *\n     * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes\n     * done in the outer `change()` block.\n     *\n     * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n     * By default, a new batch with the default {@link module:engine/model/batch~Batch#constructor batch type} is created.\n     * In the sample above, the `change` and `enqueueChange` blocks will use a different batch (and a different\n     * {@link module:engine/model/writer~Writer} instance since each of them operates on a separate batch).\n     *\n     *\t\tmodel.enqueueChange( { isUndoable: false }, writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t} );\n     *\n     * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n     *\n     *\t\tmodel.enqueueChange( batch, writer => {\n     *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n     *\t\t} );\n     *\n     * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`\n     * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.\n     *\n     * @param {module:engine/model/batch~Batch|Object} [batchOrType] A batch or a\n     * {@link module:engine/model/batch~Batch#constructor batch type} that should be used in the callback. If not defined, a new batch with\n     * the default type will be created.\n     * @param {Function} callback Callback function which may modify the model.\n     */\n\n  }, {\n    key: \"enqueueChange\",\n    value: function enqueueChange(batchOrType, callback) {\n      try {\n        if (!batchOrType) {\n          batchOrType = new Batch();\n        } else if (typeof batchOrType === 'function') {\n          callback = batchOrType;\n          batchOrType = new Batch();\n        } else if (!(batchOrType instanceof Batch)) {\n          batchOrType = new Batch(batchOrType);\n        }\n\n        this._pendingChanges.push({\n          batch: batchOrType,\n          callback: callback\n        });\n\n        if (this._pendingChanges.length == 1) {\n          this._runPendingChanges();\n        }\n      } catch (err) {\n        // @if CK_DEBUG // throw err;\n\n        /* istanbul ignore next */\n        CKEditorError.rethrowUnexpectedError(err, this);\n      }\n    }\n    /**\n     * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n     * {@link module:engine/model/operation/operation~Operation operations} to the model.\n     *\n     * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n     * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n     * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n     * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n     */\n\n  }, {\n    key: \"applyOperation\",\n    value: function applyOperation(operation) {\n      // @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n      // @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n      // @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n      // @if CK_DEBUG_ENGINE // }\n      // @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n      // @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n      // @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n      // @if CK_DEBUG_ENGINE //}\n      // @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n      operation._execute();\n    } // @if CK_DEBUG_ENGINE // getAppliedOperation() {\n    // @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n    // @if CK_DEBUG_ENGINE //\t\treturn '';\n    // @if CK_DEBUG_ENGINE //\t}\n    // @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n    // @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n    // @if CK_DEBUG_ENGINE // }\n\n    /**\n     * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n     * functionality to work.\n     *\n     * **Note**: If you want to insert an {@glink framework/guides/deep-dive/schema#object-elements object element}\n     * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.\n     *\n     * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n     * the content, clears the given selection's content before inserting nodes and moves the selection\n     * to its target position at the end of the process.\n     * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n     * pasting feature should do.\n     *\n     * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n     *\n     * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n     * inside a {@link #change `change()` block}.\n     *\n     * # Conversion and schema\n     *\n     * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n     * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n     * is only adding nodes to the model. Additionally, you need to define\n     * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n     * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n     *\n     * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n     * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n     * unless converters are defined for all elements and attributes in that HTML.\n     *\n     * # Examples\n     *\n     * Using `insertContent()` with a manually created model structure:\n     *\n     *\t\t// Let's create a document fragment containing such content as:\n     *\t\t//\n     *\t\t// <paragraph>foo</paragraph>\n     *\t\t// <blockQuote>\n     *\t\t//    <paragraph>bar</paragraph>\n     *\t\t// </blockQuote>\n     *\t\tconst docFrag = editor.model.change( writer => {\n     *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n     *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n     *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n     *\t\t\tconst docFrag = writer.createDocumentFragment();\n     *\n     *\t\t\twriter.append( p1, docFrag );\n     *\t\t\twriter.append( blockQuote, docFrag );\n     *\t\t\twriter.append( p2, blockQuote );\n     *\t\t\twriter.insertText( 'foo', p1 );\n     *\t\t\twriter.insertText( 'bar', p2 );\n     *\n     *\t\t\treturn docFrag;\n     *\t\t} );\n     *\n     *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n     *\t\t// so this code could be moved to the callback defined above.\n     *\t\teditor.model.insertContent( docFrag );\n     *\n     * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n     *\n     *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n     *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n     *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n     *\n     *\t\t// Convert an HTML string to a view document fragment:\n     *\t\tconst viewFragment = htmlDP.toView( htmlString );\n     *\n     *\t\t// Convert the view document fragment to a model document fragment\n     *\t\t// in the context of $root. This conversion takes the schema into\n     *\t\t// account so if, for example, the view document fragment contained a bare text node,\n     *\t\t// this text node cannot be a child of $root, so it will be automatically\n     *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n     *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n     *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n     *\t\t// which has a loosened schema.\n     *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n     *\n     *\t\teditor.model.insertContent( modelFragment );\n     *\n     * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n     *\n     *\t\t// Insert text at the current document selection position.\n     *\t\teditor.model.change( writer => {\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n     *\t\t} );\n     *\n     *\t\t// Insert text at a given position - the document selection will not be modified.\n     *\t\teditor.model.change( writer => {\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n     *\n     *\t\t\t// Which is a shorthand for:\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n     *\t\t} );\n     *\n     * If you want the document selection to be moved to the inserted content, use the\n     * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting\n     * the content:\n     *\n     *\t\teditor.model.change( writer => {\n     *\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\n     *\t\t\t// Insert an empty paragraph at the beginning of the root.\n     *\t\t\teditor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );\n     *\n     *\t\t\t// Move the document selection to the inserted paragraph.\n     *\t\t\twriter.setSelection( paragraph, 'in' );\n     *\t\t} );\n     *\n     * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,\n     * the new content will be inserted at the passed selection (instead of document selection):\n     *\n     *\t\teditor.model.change( writer => {\n     *\t\t\t// Create a selection in a paragraph that will be used as a place of insertion.\n     *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t\t// Insert the new text at the created selection.\n     *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n     *\n     *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n     *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n     *\t\t\twriter.setSelection( selection );\n     *\t\t} );\n     *\n     * @fires insertContent\n     * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n     * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n     * This param defines a position in relation to that item.\n     * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n     * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n     * at the insertion position.\n     */\n\n  }, {\n    key: \"insertContent\",\n    value: function insertContent(content, selectable, placeOrOffset) {\n      return _insertContent(this, content, selectable, placeOrOffset);\n    }\n    /**\n     * Inserts an {@glink framework/guides/deep-dive/schema#object-elements object element} at a specific position in the editor content.\n     *\n     * This is a high-level API:\n     * * It takes the {@link #schema schema} into consideration,\n     * * It clears the content of passed `selectable` before inserting,\n     * * It can move the selection at the end of the process,\n     * * It will copy the selected block's attributes to preserve them upon insertion,\n     * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,\n     * * etc.\n     *\n     * # Notes\n     *\n     * * If you want to insert a non-object content, see {@link #insertContent} instead.\n     * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.\n     * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside\n     * a {@link #change `change()` block}.\n     * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.\n     * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does\n     * is only adding nodes to the model. Additionally, you need to define\n     * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n     * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n     *\n     * # Examples\n     *\n     * Use the following code to insert an object at the current selection and keep the selection on the inserted element:\n     *\n     *\t\tconst rawHtmlEmbedElement = writer.createElement( 'rawHtml' );\n     *\n     *\t\tmodel.insertObject( rawHtmlEmbedElement, null, null, {\n     *\t\t\tsetSelection: 'on'\n     *\t\t} );\n     *\n     * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:\n     *\n     *\t\tconst pageBreakElement = writer.createElement( 'pageBreak' );\n    \t *\n     *\t\tmodel.insertObject( pageBreakElement, null, null, {\n     *\t\t\tsetSelection: 'after'\n     *\t\t} );\n     *\n     * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):\n     *\n     *\t\tconst tableElement = writer.createElement( 'table' );\n    \t *\n     *\t\tmodel.insertObject( tableElement, null, null, {\n     *\t\t\tfindOptimalPosition: 'auto'\n     *\t\t} );\n     *\n     * Use the following code to insert an object at the specific range (also: replace the content of the range):\n     *\n     *\t\tconst tableElement = writer.createElement( 'table' );\n     *\t\tconst range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );\n    \t *\n     *\t\tmodel.insertObject( tableElement, range );\n     *\n     * @param {module:engine/model/element~Element} object An object to be inserted into the model document.\n     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n     * A selectable where the content should be inserted. If not specified, the current\n     * {@link module:engine/model/document~Document#selection document selection} will be used instead.\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} placeOrOffset Specifies the exact place or offset for the insertion to take place,\n     * relative to `selectable`.\n     * @param {Object} [options] Additional options.\n     * @param {'auto'|'before'|'after'} [options.findOptimalPosition] An option that, when set, adjusts the insertion position (relative to\n     * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).\n     * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.\n     * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.\n     * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.\n     *\n     * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.\n     * @param {'on'|'after'} [options.setSelection] An option that, when set, moves the\n     * {@link module:engine/model/document~Document#selection document selection} after inserting the object.\n     * * When `'on'`, the document selection will be set on the inserted object.\n     * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no\n     * such text node, a paragraph will be created and the document selection will be moved inside it.\n     * @returns {module:engine/model/range~Range} A range which contains all the performed changes. This is a range that, if removed,\n     * would return the model to the state before the insertion. If no changes were preformed by `insertObject()`, returns a range collapsed\n     * at the insertion position.\n     */\n\n  }, {\n    key: \"insertObject\",\n    value: function insertObject(object, selectable, placeOrOffset, options) {\n      return _insertObject(this, object, selectable, placeOrOffset, options);\n    }\n    /**\n     * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n     *\n     * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n     * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n     * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n     * then that behavior should be implemented in the view's listener. At the same time, the table feature\n     * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n     * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n     * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n     *\n     * @fires deleteContent\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * Selection of which the content should be deleted.\n     * @param {Object} [options]\n     * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n     *\n     * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n     *\n     * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n     * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n     *\n     * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n     * elements will not be merged.\n     *\n     * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n     * paragraph when the entire content was selected.\n     *\n     * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n     *\n     * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n     * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n     *\n     * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n     * to a place where text cannot be inserted.\n     *\n     * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n     *\n     * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n     * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n     *\n     * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n     *\n     * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n     *\n     * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n     * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n     * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n     */\n\n  }, {\n    key: \"deleteContent\",\n    value: function deleteContent(selection, options) {\n      _deleteContent(this, selection, options);\n    }\n    /**\n     * Modifies the selection. Currently, the supported modifications are:\n     *\n     * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n     * Possible values for `unit` are:\n     *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n     *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n     *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `qÌ‡Ì£` is a normal\n     *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n     *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n     *  why `'character'` value is most natural and common method of modifying selection.\n     *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n     *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n     *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n     *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n     *  For example `ð¨­Ž` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n     *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n     *  extension will include whole \"surrogate pair\".\n     *  * `'word'` - moves selection by a whole word.\n     *\n     * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n     *\n     * @fires modifySelection\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * The selection to modify.\n     * @param {Object} [options]\n     * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n     * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n     * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n     */\n\n  }, {\n    key: \"modifySelection\",\n    value: function modifySelection(selection, options) {\n      _modifySelection(this, selection, options);\n    }\n    /**\n     * Gets a clone of the selected content.\n     *\n     * For example, for the following selection:\n     *\n     * ```html\n     * <paragraph>x</paragraph>\n     * <blockQuote>\n     *\t<paragraph>y</paragraph>\n     *\t<heading1>fir[st</heading1>\n     * </blockQuote>\n     * <paragraph>se]cond</paragraph>\n     * <paragraph>z</paragraph>\n     * ```\n     *\n     * It will return a document fragment with such a content:\n     *\n     * ```html\n     * <blockQuote>\n     *\t<heading1>st</heading1>\n     * </blockQuote>\n     * <paragraph>se</paragraph>\n     * ```\n     *\n     * @fires getSelectedContent\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * The selection of which content will be returned.\n     * @returns {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"getSelectedContent\",\n    value: function getSelectedContent(selection) {\n      return _getSelectedContent(this, selection);\n    }\n    /**\n     * Checks whether the given {@link module:engine/model/range~Range range} or\n     * {@link module:engine/model/element~Element element} has any meaningful content.\n     *\n     * Meaningful content is:\n     *\n     * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n     * any non-whitespace characters),\n     * * or any {@link module:engine/model/schema~Schema#isContent content element},\n     * * or any {@link module:engine/model/markercollection~Marker marker} which\n     * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n     *\n     * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n     * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)\n     * is considered non-empty.\n     *\n     * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n     * @param {Object} [options]\n     * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n     * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasContent\",\n    value: function hasContent(rangeOrElement) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var range = rangeOrElement instanceof ModelElement ? ModelRange._createIn(rangeOrElement) : rangeOrElement;\n\n      if (range.isCollapsed) {\n        return false;\n      }\n\n      var _options$ignoreWhites = options.ignoreWhitespaces,\n          ignoreWhitespaces = _options$ignoreWhites === void 0 ? false : _options$ignoreWhites,\n          _options$ignoreMarker = options.ignoreMarkers,\n          ignoreMarkers = _options$ignoreMarker === void 0 ? false : _options$ignoreMarker; // Check if there are any markers which affects data in this given range.\n\n      if (!ignoreMarkers) {\n        var _iterator = _createForOfIteratorHelper(this.markers.getMarkersIntersectingRange(range)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var intersectingMarker = _step.value;\n\n            if (intersectingMarker.affectsData) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(range.getItems()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n\n          if (this.schema.isContent(item)) {\n            if (item.is('$textProxy')) {\n              if (!ignoreWhitespaces) {\n                return true;\n              } else if (item.data.search(/\\S/) !== -1) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    }\n    /**\n     * Creates a position from the given root and path in that root.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * See {@link module:engine/model/position~PositionStickiness}.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionFromPath\",\n    value: function createPositionFromPath(root, path, stickiness) {\n      return new ModelPosition(root, path, stickiness);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/model/position~Position position},\n     * * a parent element and offset in that element,\n     * * a parent element and `'end'` (the position will be set at the end of that element),\n     * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n     * (the position will be set before or after the given model item).\n     *\n     * This method is a shortcut to other factory methods such as:\n     *\n     * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n     * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return ModelPosition._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return ModelPosition._createAfter(item);\n    }\n    /**\n     * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n     *\n     * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return ModelPosition._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from the `start` position to the `end` position.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRange( start, end );\n     *\t\t} );\n     *\n     * @param {module:engine/model/position~Position} start Start position.\n     * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n     * to the `start` position.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return new ModelRange(start, end);\n    }\n    /**\n     * Creates a range inside the given element which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRangeIn( paragraph );\n     *\t\t} );\n     *\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return ModelRange._createIn(element);\n    }\n    /**\n     * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n     *\n     * Note: This method is also available on `writer` instance as\n     * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n     *\n     *\t\tmodel.change( writer => {\n     *\t\t\tconst range = writer.createRangeOn( paragraph );\n     *\t\t} );\n     *\n     * @param {module:engine/model/item~Item} item\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(item) {\n      return ModelRange._createOn(item);\n    }\n    /**\n     * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n     * or creates an empty selection if no arguments were passed.\n     *\n     * Note: This method is also available as\n     * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n     *\n     *\t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the given document selection.\n     *\t\t// Note: It doesn't copies selection attributes.\n     *\t\tconst documentSelection = model.document.selection;\n     *\t\tconst selection = writer.createSelection( documentSelection );\n     *\n     *\t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates selection at the given offset in the given element.\n     *\t\tconst paragraph = writer.createElement( 'paragraph' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * @param {module:engine/model/selection~Selectable} selectable\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @returns {module:engine/model/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return new ModelSelection(selectable, placeOrOffset, options);\n    }\n    /**\n     * Creates a {@link module:engine/model/batch~Batch} instance.\n     *\n     * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n     *\n     * * {@link #change `change()`},\n     * * {@link #enqueueChange `enqueueChange()`}.\n     *\n     * @param {Object} [type] {@link module:engine/model/batch~Batch#constructor The type} of the batch.\n     * @returns {module:engine/model/batch~Batch}\n     */\n\n  }, {\n    key: \"createBatch\",\n    value: function createBatch(type) {\n      return new Batch(type);\n    }\n    /**\n     * Creates an operation instance from a JSON object (parsed JSON string).\n     *\n     * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @returns {module:engine/model/operation/operation~Operation}\n     */\n\n  }, {\n    key: \"createOperationFromJSON\",\n    value: function createOperationFromJSON(json) {\n      return OperationFactory.fromJSON(json, this.document);\n    }\n    /**\n     * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.document.destroy();\n      this.stopListening();\n    }\n    /**\n     * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n     * which calls callbacks and returns array of values returned by these callbacks.\n     *\n     * @private\n     * @returns {Array.<*>} Array of values returned by callbacks.\n     */\n\n  }, {\n    key: \"_runPendingChanges\",\n    value: function _runPendingChanges() {\n      var ret = [];\n      this.fire('_beforeChanges');\n\n      while (this._pendingChanges.length) {\n        // Create a new writer using batch instance created for this chain of changes.\n        var currentBatch = this._pendingChanges[0].batch;\n        this._currentWriter = new Writer(this, currentBatch); // Execute changes callback and gather the returned value.\n\n        var callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);\n\n        ret.push(callbackReturnValue);\n\n        this.document._handleChangeBlock(this._currentWriter);\n\n        this._pendingChanges.shift();\n\n        this._currentWriter = null;\n      }\n\n      this.fire('_afterChanges');\n      return ret;\n    }\n    /**\n     * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n     * {@link module:engine/model/model~Model#change} block.\n     *\n     * @protected\n     * @event _beforeChanges\n     */\n\n    /**\n     * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n     * {@link module:engine/model/model~Model#change} block.\n     *\n     * @protected\n     * @event _afterChanges\n     */\n\n    /**\n     * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n     * using {@link #applyOperation}.\n     *\n     * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n     * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n     * be used.\n     *\n     * A few callbacks are already added to this event by engine internal classes:\n     *\n     * * with `highest` priority operation is validated,\n     * * with `normal` priority operation is executed,\n     * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n     * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n     * update themselves.\n     *\n     * @event applyOperation\n     * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     */\n\n    /**\n     * Event fired when {@link #insertContent} method is called.\n     *\n     * The {@link #insertContent default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n     * {@link module:engine/model/document~Document#selection document selection}.\n     *\n     * @event insertContent\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when the {@link #insertObject} method is called.\n     *\n     * The {@link #insertObject default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * **Note** The `selectable` parameter for the {@link #insertObject} is optional. When `undefined` value is passed the method uses\n     * {@link module:engine/model/document~Document#selection document selection}.\n     *\n     * @event insertObject\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when {@link #deleteContent} method is called.\n     *\n     * The {@link #deleteContent default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * @event deleteContent\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when {@link #modifySelection} method is called.\n     *\n     * The {@link #modifySelection default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * @event modifySelection\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n    /**\n     * Event fired when {@link #getSelectedContent} method is called.\n     *\n     * The {@link #getSelectedContent default action of that method} is implemented as a\n     * listener to this event so it can be fully customized by the features.\n     *\n     * @event getSelectedContent\n     * @param {Array} args The arguments passed to the original method.\n     */\n\n  }]);\n\n  return Model;\n}();\n\nexport { Model as default };\nmix(Model, ObservableMixin);","map":null,"metadata":{},"sourceType":"module"}