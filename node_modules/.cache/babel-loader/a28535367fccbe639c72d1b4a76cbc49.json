{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste functionality to work.\n *\n * It takes care of removing the selected content, splitting elements (if needed), inserting elements and merging elements appropriately.\n *\n * Some examples:\n *\n * \t\t<p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n * \t\t<p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n * \t\t<p>x^y</p> + <img /> => <p>x</p>^<p>y</p> + <img /> => <p>x</p><img /><p>y</p>\n * \t\t<p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p> (no merging)\n * \t\t<p>x</p>[<img />]<p>z</p> + <p>y</p> => <p>x</p>^<p>z</p> + <p>y</p> => <p>x</p><p>y[]</p><p>z</p>\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\n\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n  return model.change(function (writer) {\n    var selection;\n\n    if (!selectable) {\n      selection = model.document.selection;\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      selection = selectable;\n    } else {\n      selection = writer.createSelection(selectable, placeOrOffset);\n    }\n\n    if (!selection.isCollapsed) {\n      model.deleteContent(selection, {\n        doNotAutoparagraph: true\n      });\n    }\n\n    var insertion = new Insertion(model, writer, selection.anchor);\n    var nodesToInsert;\n\n    if (content.is('documentFragment')) {\n      nodesToInsert = content.getChildren();\n    } else {\n      nodesToInsert = [content];\n    }\n\n    insertion.handleNodes(nodesToInsert);\n    var newRange = insertion.getSelectionRange();\n    /* istanbul ignore else */\n\n    if (newRange) {\n      if (selection instanceof DocumentSelection) {\n        writer.setSelection(newRange);\n      } else {\n        selection.setTo(newRange);\n      }\n    } else {// We are not testing else because it's a safe check for unpredictable edge cases:\n      // an insertion without proper range to select.\n      //\n      // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n    }\n\n    var affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);\n    insertion.destroy();\n    return affectedRange;\n  });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\n\nvar Insertion = /*#__PURE__*/function () {\n  function Insertion(model, writer, position) {\n    _classCallCheck(this, Insertion);\n\n    /**\n     * The model in context of which the insertion should be performed.\n     *\n     * @member {module:engine/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * Batch to which operations will be added.\n     *\n     * @member {module:engine/controller/writer~Batch} #writer\n     */\n\n    this.writer = writer;\n    /**\n     * The position at which (or near which) the next node will be inserted.\n     *\n     * @member {module:engine/model/position~Position} #position\n     */\n\n    this.position = position;\n    /**\n     * Elements with which the inserted elements can be merged.\n     *\n     *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n     *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n     *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n     *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n     *\n     *\n     * @member {Set} #canMergeWith\n     */\n\n    this.canMergeWith = new Set([this.position.parent]);\n    /**\n     * Schema of the model.\n     *\n     * @member {module:engine/model/schema~Schema} #schema\n     */\n\n    this.schema = model.schema;\n    /**\n     * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.\n     *\n     * @private\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n    this._documentFragment = writer.createDocumentFragment();\n    /**\n     * The current position in the temporary DocumentFragment.\n     *\n     * @private\n     * @type {module:engine/model/position~Position}\n     */\n\n    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);\n    /**\n     * The reference to the first inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._firstNode = null;\n    /**\n     * The reference to the last inserted node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._lastNode = null;\n    /**\n     * The reference to the last auto paragraph node.\n     *\n     * @private\n     * @type {module:engine/model/node~Node}\n     */\n\n    this._lastAutoParagraph = null;\n    /**\n     * The array of nodes that should be cleaned of not allowed attributes.\n     *\n     * @private\n     * @type {Array.<module:engine/model/node~Node>}\n     */\n\n    this._filterAttributesOf = [];\n    /**\n     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n     */\n\n    this._affectedStart = null;\n    /**\n     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n     */\n\n    this._affectedEnd = null;\n  }\n  /**\n   * Handles insertion of a set of nodes.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n   */\n\n\n  _createClass(Insertion, [{\n    key: \"handleNodes\",\n    value: function handleNodes(nodes) {\n      for (var _i = 0, _Array$from = Array.from(nodes); _i < _Array$from.length; _i++) {\n        var node = _Array$from[_i];\n\n        this._handleNode(node);\n      } // Insert nodes collected in temporary DocumentFragment.\n\n\n      this._insertPartialFragment(); // If there was an auto paragraph then we might need to adjust the end of insertion.\n\n\n      if (this._lastAutoParagraph) {\n        this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);\n      } // After the content was inserted we may try to merge it with its next sibling if the selection was in it initially.\n      // Merging with the previous sibling was performed just after inserting the first node to the document.\n\n\n      this._mergeOnRight(); // TMP this will become a post-fixer.\n\n\n      this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n      this._filterAttributesOf = [];\n    }\n    /**\n     * Updates the last node after the auto paragraphing.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The last auto paragraphing node.\n     */\n\n  }, {\n    key: \"_updateLastNodeFromAutoParagraph\",\n    value: function _updateLastNodeFromAutoParagraph(node) {\n      var positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);\n      var positionAfterNode = this.writer.createPositionAfter(node); // If the real end was after the last auto paragraph then update relevant properties.\n\n      if (positionAfterNode.isAfter(positionAfterLastNode)) {\n        this._lastNode = node;\n        /* istanbul ignore if */\n\n        if (this.position.parent != node || !this.position.isAtEnd) {\n          // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n          // At this point the insertion position should be at the end of the last auto paragraph.\n          // Note: This error is documented in other place in this file.\n          throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n        }\n\n        this.position = positionAfterNode;\n\n        this._setAffectedBoundaries(this.position);\n      }\n    }\n    /**\n     * Returns range to be selected after insertion.\n     * Returns `null` if there is no valid range to select after insertion.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getSelectionRange\",\n    value: function getSelectionRange() {\n      if (this.nodeToSelect) {\n        return Range._createOn(this.nodeToSelect);\n      }\n\n      return this.model.schema.getNearestSelectionRange(this.position);\n    }\n    /**\n     * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n     * before the insertion. Returns `null` if no changes were done.\n     *\n     * @returns {module:engine/model/range~Range|null}\n     */\n\n  }, {\n    key: \"getAffectedRange\",\n    value: function getAffectedRange() {\n      if (!this._affectedStart) {\n        return null;\n      }\n\n      return new Range(this._affectedStart, this._affectedEnd);\n    }\n    /**\n     * Destroys `Insertion` instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._affectedStart) {\n        this._affectedStart.detach();\n      }\n\n      if (this._affectedEnd) {\n        this._affectedEnd.detach();\n      }\n    }\n    /**\n     * Handles insertion of a single node.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node\n     */\n\n  }, {\n    key: \"_handleNode\",\n    value: function _handleNode(node) {\n      // Let's handle object in a special way.\n      // * They should never be merged with other elements.\n      // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n      if (this.schema.isObject(node)) {\n        this._handleObject(node);\n\n        return;\n      } // Try to find a place for the given node.\n      // Check if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n      // Inserts the auto paragraph if it would allow for insertion.\n\n\n      var isAllowed = this._checkAndAutoParagraphToAllowedPosition(node);\n\n      if (!isAllowed) {\n        // Split the position.parent's branch up to a point where the node can be inserted.\n        // If it isn't allowed in the whole branch, then of course don't split anything.\n        isAllowed = this._checkAndSplitToAllowedPosition(node);\n\n        if (!isAllowed) {\n          this._handleDisallowedNode(node);\n\n          return;\n        }\n      } // Add node to the current temporary DocumentFragment.\n\n\n      this._appendToFragment(node); // Store the first and last nodes for easy access for merging with sibling nodes.\n\n\n      if (!this._firstNode) {\n        this._firstNode = node;\n      }\n\n      this._lastNode = node;\n    }\n    /**\n     * Inserts the temporary DocumentFragment into the model.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_insertPartialFragment\",\n    value: function _insertPartialFragment() {\n      if (this._documentFragment.isEmpty) {\n        return;\n      }\n\n      var livePosition = LivePosition.fromPosition(this.position, 'toNext');\n\n      this._setAffectedBoundaries(this.position); // If the very first node of the whole insertion process is inserted, insert it separately for OT reasons (undo).\n      // Note: there can be multiple calls to `_insertPartialFragment()` during one insertion process.\n      // Note: only the very first node can be merged so we have to do separate operation only for it.\n\n\n      if (this._documentFragment.getChild(0) == this._firstNode) {\n        this.writer.insert(this._firstNode, this.position); // We must merge the first node just after inserting it to avoid problems with OT.\n        // (See: https://github.com/ckeditor/ckeditor5/pull/8773#issuecomment-760945652).\n\n        this._mergeOnLeft();\n\n        this.position = livePosition.toPosition();\n      } // Insert the remaining nodes from document fragment.\n\n\n      if (!this._documentFragment.isEmpty) {\n        this.writer.insert(this._documentFragment, this.position);\n      }\n\n      this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);\n      this.position = livePosition.toPosition();\n      livePosition.detach();\n    }\n    /**\n     * @private\n     * @param {module:engine/model/element~Element} node The object element.\n     */\n\n  }, {\n    key: \"_handleObject\",\n    value: function _handleObject(node) {\n      // Try finding it a place in the tree.\n      if (this._checkAndSplitToAllowedPosition(node)) {\n        this._appendToFragment(node);\n      } // Try autoparagraphing.\n      else {\n        this._tryAutoparagraphing(node);\n      }\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n     */\n\n  }, {\n    key: \"_handleDisallowedNode\",\n    value: function _handleDisallowedNode(node) {\n      // If the node is an element, try inserting its children (strip the parent).\n      if (node.is('element')) {\n        this.handleNodes(node.getChildren());\n      } // If text is not allowed, try autoparagraphing it.\n      else {\n        this._tryAutoparagraphing(node);\n      }\n    }\n    /**\n     * Append a node to the temporary DocumentFragment.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node to insert.\n     */\n\n  }, {\n    key: \"_appendToFragment\",\n    value: function _appendToFragment(node) {\n      /* istanbul ignore if */\n      if (!this.schema.checkChild(this.position, node)) {\n        // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n        // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n        /**\n         * Given node cannot be inserted on the given position.\n         *\n         * @error insertcontent-wrong-position\n         * @param {module:engine/model/node~Node} node Node to insert.\n         * @param {module:engine/model/position~Position} position Position to insert the node at.\n         */\n        throw new CKEditorError('insertcontent-wrong-position', this, {\n          node: node,\n          position: this.position\n        });\n      }\n\n      this.writer.insert(node, this._documentFragmentPosition);\n      this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize); // The last inserted object should be selected because we can't put a collapsed selection after it.\n\n      if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n        this.nodeToSelect = node;\n      } else {\n        this.nodeToSelect = null;\n      }\n\n      this._filterAttributesOf.push(node);\n    }\n    /**\n     * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n     * mark the affected range.\n     *\n     * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n     * during merging, but the logic there is more complicated so it is left out of this function.\n     *\n     * @private\n     * @param {module:engine/model/position~Position} position\n     */\n\n  }, {\n    key: \"_setAffectedBoundaries\",\n    value: function _setAffectedBoundaries(position) {\n      // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n      // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n      // This is why it cannot be a range but two separate positions.\n      if (!this._affectedStart) {\n        this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n      } // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n      // inserted into the parent but the next node is moved-out of that parent:\n      // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n      // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\n\n      if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n        if (this._affectedEnd) {\n          this._affectedEnd.detach();\n        }\n\n        this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n      }\n    }\n    /**\n     * Merges the previous sibling of the first node if it should be merged.\n     *\n     * After the content was inserted we may try to merge it with its siblings.\n     * This should happen only if the selection was in those elements initially.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_mergeOnLeft\",\n    value: function _mergeOnLeft() {\n      var node = this._firstNode;\n\n      if (!(node instanceof Element)) {\n        return;\n      }\n\n      if (!this._canMergeLeft(node)) {\n        return;\n      }\n\n      var mergePosLeft = LivePosition._createBefore(node);\n\n      mergePosLeft.stickiness = 'toNext';\n      var livePosition = LivePosition.fromPosition(this.position, 'toNext'); // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n      // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n      // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n      // shown as `][`).\n      //\n      // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n      //\n      // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n      //\n      // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\n      if (this._affectedStart.isEqual(mergePosLeft)) {\n        this._affectedStart.detach();\n\n        this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n      } // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n      // because the reference would point to the removed node.\n      //\n      // <p>A^A</p> + <p>X</p>\n      //\n      // <p>A</p>^<p>A</p>\n      // <p>A</p><p>X</p><p>A</p>\n      // <p>AX</p><p>A</p>\n      // <p>AXA</p>\n\n\n      if (this._firstNode === this._lastNode) {\n        this._firstNode = mergePosLeft.nodeBefore;\n        this._lastNode = mergePosLeft.nodeBefore;\n      }\n\n      this.writer.merge(mergePosLeft); // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n      //\n      // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n      //\n      // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\n      if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {\n        this._affectedEnd.detach();\n\n        this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n      }\n\n      this.position = livePosition.toPosition();\n      livePosition.detach(); // After merge elements that were marked by _insert() to be filtered might be gone so\n      // we need to mark the new container.\n\n      this._filterAttributesOf.push(this.position.parent);\n\n      mergePosLeft.detach();\n    }\n    /**\n     * Merges the next sibling of the last node if it should be merged.\n     *\n     * After the content was inserted we may try to merge it with its siblings.\n     * This should happen only if the selection was in those elements initially.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_mergeOnRight\",\n    value: function _mergeOnRight() {\n      var node = this._lastNode;\n\n      if (!(node instanceof Element)) {\n        return;\n      }\n\n      if (!this._canMergeRight(node)) {\n        return;\n      }\n\n      var mergePosRight = LivePosition._createAfter(node);\n\n      mergePosRight.stickiness = 'toNext';\n      /* istanbul ignore if */\n\n      if (!this.position.isEqual(mergePosRight)) {\n        // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n        // At this point the insertion position should be after the node we'll merge. If it isn't,\n        // it should need to be secured as in the left merge case.\n\n        /**\n         * An internal error occurred when merging inserted content with its siblings.\n         * The insertion position should equal the merge position.\n         *\n         * If you encountered this error, report it back to the CKEditor 5 team\n         * with as many details as possible regarding the content being inserted and the insertion position.\n         *\n         * @error insertcontent-invalid-insertion-position\n         */\n        throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n      } // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n      // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\n\n      this.position = Position._createAt(mergePosRight.nodeBefore, 'end'); // Explanation of setting position stickiness to `'toPrevious'`:\n      // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n      // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\n      var livePosition = LivePosition.fromPosition(this.position, 'toPrevious'); // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\n      if (this._affectedEnd.isEqual(mergePosRight)) {\n        this._affectedEnd.detach();\n\n        this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n      } // We need to update the references to the first and last nodes if they will be merged into the previous sibling node\n      // because the reference would point to the removed node.\n      //\n      // <p>A^A</p> + <p>X</p>\n      //\n      // <p>A</p>^<p>A</p>\n      // <p>A</p><p>X</p><p>A</p>\n      // <p>AX</p><p>A</p>\n      // <p>AXA</p>\n\n\n      if (this._firstNode === this._lastNode) {\n        this._firstNode = mergePosRight.nodeBefore;\n        this._lastNode = mergePosRight.nodeBefore;\n      }\n\n      this.writer.merge(mergePosRight); // See comment in `_mergeOnLeft()` on moving `_affectedStart`.\n\n      if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {\n        this._affectedStart.detach();\n\n        this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n      }\n\n      this.position = livePosition.toPosition();\n      livePosition.detach(); // After merge elements that were marked by _insert() to be filtered might be gone so\n      // we need to mark the new container.\n\n      this._filterAttributesOf.push(this.position.parent);\n\n      mergePosRight.detach();\n    }\n    /**\n     * Checks whether specified node can be merged with previous sibling element.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_canMergeLeft\",\n    value: function _canMergeLeft(node) {\n      var previousSibling = node.previousSibling;\n      return previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);\n    }\n    /**\n     * Checks whether specified node can be merged with next sibling element.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_canMergeRight\",\n    value: function _canMergeRight(node) {\n      var nextSibling = node.nextSibling;\n      return nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);\n    }\n    /**\n     * Tries wrapping the node in a new paragraph and inserting it this way.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n     */\n\n  }, {\n    key: \"_tryAutoparagraphing\",\n    value: function _tryAutoparagraphing(node) {\n      var paragraph = this.writer.createElement('paragraph'); // Do not autoparagraph if the paragraph won't be allowed there,\n      // cause that would lead to an infinite loop. The paragraph would be rejected in\n      // the next _handleNode() call and we'd be here again.\n\n      if (this._getAllowedIn(this.position.parent, paragraph) && this.schema.checkChild(paragraph, node)) {\n        paragraph._appendChild(node);\n\n        this._handleNode(paragraph);\n      }\n    }\n    /**\n     * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.\n     * It also handles inserting the paragraph.\n     *\n     * @private\n     * @param {module:engine/model/node~Node} node The node.\n     * @returns {Boolean} Whether an allowed position was found.\n     * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.\n     */\n\n  }, {\n    key: \"_checkAndAutoParagraphToAllowedPosition\",\n    value: function _checkAndAutoParagraphToAllowedPosition(node) {\n      if (this.schema.checkChild(this.position.parent, node)) {\n        return true;\n      } // Do not auto paragraph if the paragraph won't be allowed there,\n      // cause that would lead to an infinite loop. The paragraph would be rejected in\n      // the next _handleNode() call and we'd be here again.\n\n\n      if (!this.schema.checkChild(this.position.parent, 'paragraph') || !this.schema.checkChild('paragraph', node)) {\n        return false;\n      } // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\n\n      this._insertPartialFragment(); // Insert a paragraph and move insertion position to it.\n\n\n      var paragraph = this.writer.createElement('paragraph');\n      this.writer.insert(paragraph, this.position);\n\n      this._setAffectedBoundaries(this.position);\n\n      this._lastAutoParagraph = paragraph;\n      this.position = this.writer.createPositionAt(paragraph, 0);\n      return true;\n    }\n    /**\n     * @private\n     * @param {module:engine/model/node~Node} node\n     * @returns {Boolean} Whether an allowed position was found.\n     * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n     */\n\n  }, {\n    key: \"_checkAndSplitToAllowedPosition\",\n    value: function _checkAndSplitToAllowedPosition(node) {\n      var allowedIn = this._getAllowedIn(this.position.parent, node);\n\n      if (!allowedIn) {\n        return false;\n      } // Insert nodes collected in temporary DocumentFragment if the position parent needs change to process further nodes.\n\n\n      if (allowedIn != this.position.parent) {\n        this._insertPartialFragment();\n      }\n\n      while (allowedIn != this.position.parent) {\n        if (this.position.isAtStart) {\n          // If insertion position is at the beginning of the parent, move it out instead of splitting.\n          // <p>^Foo</p> -> ^<p>Foo</p>\n          var parent = this.position.parent;\n          this.position = this.writer.createPositionBefore(parent); // Special case â€“ parent is empty (<p>^</p>).\n          //\n          // 1. parent.isEmpty\n          // We can remove the element after moving insertion position out of it.\n          //\n          // 2. parent.parent === allowedIn\n          // However parent should remain in place when allowed element is above limit element in document tree.\n          // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n          // content allowed in $root.\n\n          if (parent.isEmpty && parent.parent === allowedIn) {\n            this.writer.remove(parent);\n          }\n        } else if (this.position.isAtEnd) {\n          // If insertion position is at the end of the parent, move it out instead of splitting.\n          // <p>Foo^</p> -> <p>Foo</p>^\n          this.position = this.writer.createPositionAfter(this.position.parent);\n        } else {\n          var tempPos = this.writer.createPositionAfter(this.position.parent);\n\n          this._setAffectedBoundaries(this.position);\n\n          this.writer.split(this.position);\n          this.position = tempPos;\n          this.canMergeWith.add(this.position.nodeAfter);\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} contextElement The element in which context the node should be checked.\n     * @param {module:engine/model/node~Node} childNode The node to check.\n     * @returns {module:engine/model/element~Element|null}\n     */\n\n  }, {\n    key: \"_getAllowedIn\",\n    value: function _getAllowedIn(contextElement, childNode) {\n      if (this.schema.checkChild(contextElement, childNode)) {\n        return contextElement;\n      } // If the child wasn't allowed in the context element and the element is a limit there's no point in\n      // checking any further towards the root. This is it: the limit is unsplittable and there's nothing\n      // we can do about it. Without this check, the algorithm will analyze parent of the limit and may create\n      // an illusion of the child being allowed. There's no way to insert it down there, though. It results in\n      // infinite loops.\n\n\n      if (this.schema.isLimit(contextElement)) {\n        return null;\n      }\n\n      return this._getAllowedIn(contextElement.parent, childNode);\n    }\n  }]);\n\n  return Insertion;\n}();","map":null,"metadata":{},"sourceType":"module"}