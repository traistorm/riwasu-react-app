{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/utils/changebuffer\n */\n\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n *\t\tconst buffer = new ChangeBuffer( model, LIMIT );\n *\n *\t\t// Later on in your feature:\n *\t\tbuffer.batch.insert( pos, insertedCharacters );\n *\t\tbuffer.input( insertedCharacters.length );\n *\n */\nvar ChangeBuffer = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of the change buffer.\n   *\n   * @param {module:engine/model/model~Model} model\n   * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.\n   */\n  function ChangeBuffer(model) {\n    var _this = this;\n\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n\n    _classCallCheck(this, ChangeBuffer);\n\n    /**\n     * The model instance.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n     * the {@link #batch batch} is set to a new one.\n     *\n     * @readonly\n     * @member {Number} #size\n     */\n\n    this.size = 0;\n    /**\n     * The maximum number of atomic changes which can be contained in one batch.\n     *\n     * @readonly\n     * @member {Number} #limit\n     */\n\n    this.limit = limit;\n    /**\n     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n     *\n     * @readonly\n     * @member {Boolean} #isLocked\n     */\n\n    this.isLocked = false; // The function to be called in order to notify the buffer about batches which appeared in the document.\n    // The callback will check whether it is a new batch and in that case the buffer will be flushed.\n    //\n    // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n    // should be added to a new batch. For instance, when the user types, then inserts an image, and then types again,\n    // the characters typed after inserting the image should be added to a different batch than the characters typed before.\n\n    this._changeCallback = function (evt, batch) {\n      if (batch.isLocal && batch.isUndoable && batch !== _this._batch) {\n        _this._reset(true);\n      }\n    };\n\n    this._selectionChangeCallback = function () {\n      _this._reset();\n    };\n\n    this.model.document.on('change', this._changeCallback);\n    this.model.document.selection.on('change:range', this._selectionChangeCallback);\n    this.model.document.selection.on('change:attribute', this._selectionChangeCallback);\n    /**\n     * The current batch instance.\n     *\n     * @private\n     * @member #_batch\n     */\n\n    /**\n     * The callback to document the change event which later needs to be removed.\n     *\n     * @private\n     * @member #_changeCallback\n     */\n\n    /**\n     * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.\n     *\n     * @private\n     * @member #_selectionChangeCallback\n     */\n  }\n  /**\n   * The current batch to which a feature should add its operations. Once the {@link #size}\n   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n   *\n   * @type {module:engine/model/batch~Batch}\n   */\n\n\n  _createClass(ChangeBuffer, [{\n    key: \"input\",\n\n    /**\n     * The input number of changes into the buffer. Once the {@link #size} is\n     * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n     *\n     * @param {Number} changeCount The number of atomic changes to input.\n     */\n    value: function input(changeCount) {\n      this.size += changeCount;\n\n      if (this.size >= this.limit) {\n        this._reset(true);\n      }\n    }\n    /**\n     * Locks the buffer.\n     */\n\n  }, {\n    key: \"lock\",\n    value: function lock() {\n      this.isLocked = true;\n    }\n    /**\n     * Unlocks the buffer.\n     */\n\n  }, {\n    key: \"unlock\",\n    value: function unlock() {\n      this.isLocked = false;\n    }\n    /**\n     * Destroys the buffer.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.model.document.off('change', this._changeCallback);\n      this.model.document.selection.off('change:range', this._selectionChangeCallback);\n      this.model.document.selection.off('change:attribute', this._selectionChangeCallback);\n    }\n    /**\n     * Resets the change buffer.\n     *\n     * @private\n     * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset(ignoreLock) {\n      if (!this.isLocked || ignoreLock) {\n        this._batch = null;\n        this.size = 0;\n      }\n    }\n  }, {\n    key: \"batch\",\n    get: function get() {\n      if (!this._batch) {\n        this._batch = this.model.createBatch({\n          isTyping: true\n        });\n      }\n\n      return this._batch;\n    }\n  }]);\n\n  return ChangeBuffer;\n}();\n\nexport { ChangeBuffer as default };","map":null,"metadata":{},"sourceType":"module"}