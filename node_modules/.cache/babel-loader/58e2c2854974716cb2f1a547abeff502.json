{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imageinlineediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { downcastImageAttribute, downcastSrcsetAttribute } from './converters';\nimport ImageEditing from './imageediting';\nimport ImageTypeCommand from './imagetypecommand';\nimport ImageUtils from '../imageutils';\nimport { getImgViewElementMatcher, createInlineImageViewElement, determineImageTypeForInsertionAtSelection } from '../image/utils';\n/**\n * The image inline plugin.\n *\n * It registers:\n *\n * * `<imageInline>` as an inline element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.\n * * {@link module:image/image/imagetypecommand~ImageTypeCommand `'imageTypeInline'`} command that converts block images into\n * inline images.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageInlineEditing = /*#__PURE__*/function (_Plugin) {\n  _inherits(ImageInlineEditing, _Plugin);\n\n  function ImageInlineEditing() {\n    _classCallCheck(this, ImageInlineEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageInlineEditing).apply(this, arguments));\n  }\n\n  _createClass(ImageInlineEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema; // Converters 'alt' and 'srcset' are added in 'ImageEditing' plugin.\n\n      schema.register('imageInline', {\n        inheritAllFrom: '$inlineObject',\n        allowAttributes: ['alt', 'src', 'srcset']\n      }); // Disallow inline images in captions (for now). This is the best spot to do that because\n      // independent packages can introduce captions (ImageCaption, TableCaption, etc.) so better this\n      // be future-proof.\n\n      schema.addChildCheck(function (context, childDefinition) {\n        if (context.endsWith('caption') && childDefinition.name === 'imageInline') {\n          return false;\n        }\n      });\n\n      this._setupConversion();\n\n      if (editor.plugins.has('ImageBlockEditing')) {\n        editor.commands.add('imageTypeInline', new ImageTypeCommand(this.editor, 'imageInline'));\n\n        this._setupClipboardIntegration();\n      }\n    }\n    /**\n     * Configures conversion pipelines to support upcasting and downcasting\n     * inline images (inline image widgets) and their attributes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupConversion\",\n    value: function _setupConversion() {\n      var editor = this.editor;\n      var t = editor.t;\n      var conversion = editor.conversion;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      conversion.for('dataDowncast').elementToElement({\n        model: 'imageInline',\n        view: function view(modelElement, _ref) {\n          var writer = _ref.writer;\n          return writer.createEmptyElement('img');\n        }\n      });\n      conversion.for('editingDowncast').elementToStructure({\n        model: 'imageInline',\n        view: function view(modelElement, _ref2) {\n          var writer = _ref2.writer;\n          return imageUtils.toImageWidget(createInlineImageViewElement(writer), writer, t('image widget'));\n        }\n      });\n      conversion.for('downcast').add(downcastImageAttribute(imageUtils, 'imageInline', 'src')).add(downcastImageAttribute(imageUtils, 'imageInline', 'alt')).add(downcastSrcsetAttribute(imageUtils, 'imageInline')); // More image related upcasts are in 'ImageEditing' plugin.\n\n      conversion.for('upcast').elementToElement({\n        view: getImgViewElementMatcher(editor, 'imageInline'),\n        model: function model(viewImage, _ref3) {\n          var writer = _ref3.writer;\n          return writer.createElement('imageInline', viewImage.hasAttribute('src') ? {\n            src: viewImage.getAttribute('src')\n          } : null);\n        }\n      });\n    }\n    /**\n     * Integrates the plugin with the clipboard pipeline.\n     *\n     * Idea is that the feature should recognize the user's intent when an **block** image is\n     * pasted or dropped. If such an image is pasted/dropped into a non-empty block\n     * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.\n     *\n     * We assume this is the user's intent if they decided to put their image there.\n     *\n     * **Note**: If a block image has a caption, it will not be converted to an inline image\n     * to avoid the confusion. Captions are added on purpose and they should never be lost\n     * in the clipboard pipeline.\n     *\n     * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupClipboardIntegration\",\n    value: function _setupClipboardIntegration() {\n      var editor = this.editor;\n      var model = editor.model;\n      var editingView = editor.editing.view;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      this.listenTo(editor.plugins.get('ClipboardPipeline'), 'inputTransformation', function (evt, data) {\n        var docFragmentChildren = Array.from(data.content.getChildren());\n        var modelRange; // Make sure only <figure class=\"image\"></figure> elements are dropped or pasted. Otherwise, if there some other HTML\n        // mixed up, this should be handled as a regular paste.\n\n        if (!docFragmentChildren.every(imageUtils.isBlockImageView)) {\n          return;\n        } // When drag and dropping, data.targetRanges specifies where to drop because\n        // this is usually a different place than the current model selection (the user\n        // uses a drop marker to specify the drop location).\n\n\n        if (data.targetRanges) {\n          modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);\n        } // Pasting, however, always occurs at the current model selection.\n        else {\n          modelRange = model.document.selection.getFirstRange();\n        }\n\n        var selection = model.createSelection(modelRange); // Convert block images into inline images only when pasting or dropping into non-empty blocks\n        // and when the block is not an object (e.g. pasting to replace another widget).\n\n        if (determineImageTypeForInsertionAtSelection(model.schema, selection) === 'imageInline') {\n          var writer = new UpcastWriter(editingView.document); // Unwrap <figure class=\"image\"><img .../></figure> -> <img ... />\n          // but <figure class=\"image\"><img .../><figcaption>...</figcaption></figure> -> stays the same\n\n          var inlineViewImages = docFragmentChildren.map(function (blockViewImage) {\n            // If there's just one child, it can be either <img /> or <a><img></a>.\n            // If there are other children than <img>, this means that the block image\n            // has a caption or some other features and this kind of image should be\n            // pasted/dropped without modifications.\n            if (blockViewImage.childCount === 1) {\n              // Pass the attributes which are present only in the <figure> to the <img>\n              // (e.g. the style=\"width:10%\" attribute applied by the ImageResize plugin).\n              Array.from(blockViewImage.getAttributes()).forEach(function (attribute) {\n                return writer.setAttribute.apply(writer, _toConsumableArray(attribute).concat([imageUtils.findViewImgElement(blockViewImage)]));\n              });\n              return blockViewImage.getChild(0);\n            } else {\n              return blockViewImage;\n            }\n          });\n          data.content = writer.createDocumentFragment(inlineViewImages);\n        }\n      });\n    }\n  }], [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ImageEditing, ImageUtils, ClipboardPipeline];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageInlineEditing';\n    }\n  }]);\n\n  return ImageInlineEditing;\n}(Plugin);\n\nexport { ImageInlineEditing as default };","map":null,"metadata":{},"sourceType":"module"}