{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/mutationobserver\n */\n\n/* globals window */\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { startsWithFiller, getDataWithoutFiller } from '../filler';\nimport { isEqualWith } from 'lodash-es';\n/**\n * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view\n * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.\n * Because all mutated nodes are marked as \"to be rendered\" and the\n * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the\n * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor\n * will block all changes which are not handled.\n *\n * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and\n * mutations on elements which do not have corresponding view elements. Also\n * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\n\nvar MutationObserver = /*#__PURE__*/function (_Observer) {\n  _inherits(MutationObserver, _Observer);\n\n  function MutationObserver(view) {\n    var _this;\n\n    _classCallCheck(this, MutationObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MutationObserver).call(this, view));\n    /**\n     * Native mutation observer config.\n     *\n     * @private\n     * @member {Object}\n     */\n\n    _this._config = {\n      childList: true,\n      characterData: true,\n      characterDataOldValue: true,\n      subtree: true\n    };\n    /**\n     * Reference to the {@link module:engine/view/view~View#domConverter}.\n     *\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n\n    _this.domConverter = view.domConverter;\n    /**\n     * Reference to the {@link module:engine/view/view~View#_renderer}.\n     *\n     * @member {module:engine/view/renderer~Renderer}\n     */\n\n    _this.renderer = view._renderer;\n    /**\n     * Observed DOM elements.\n     *\n     * @private\n     * @member {Array.<HTMLElement>}\n     */\n\n    _this._domElements = [];\n    /**\n     * Native mutation observer.\n     *\n     * @private\n     * @member {MutationObserver}\n     */\n\n    _this._mutationObserver = new window.MutationObserver(_this._onMutations.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    return _this;\n  }\n  /**\n   * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.\n   * At the same time empties the queue so mutations will not be fired twice.\n   */\n\n\n  _createClass(MutationObserver, [{\n    key: \"flush\",\n    value: function flush() {\n      this._onMutations(this._mutationObserver.takeRecords());\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"observe\",\n    value: function observe(domElement) {\n      this._domElements.push(domElement);\n\n      if (this.isEnabled) {\n        this._mutationObserver.observe(domElement, this._config);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      _get(_getPrototypeOf(MutationObserver.prototype), \"enable\", this).call(this);\n\n      var _iterator = _createForOfIteratorHelper(this._domElements),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var domElement = _step.value;\n\n          this._mutationObserver.observe(domElement, this._config);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      _get(_getPrototypeOf(MutationObserver.prototype), \"disable\", this).call(this);\n\n      this._mutationObserver.disconnect();\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(MutationObserver.prototype), \"destroy\", this).call(this);\n\n      this._mutationObserver.disconnect();\n    }\n    /**\n     * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.\n     *\n     * @private\n     * @param {Array.<Object>} domMutations Array of native mutations.\n     */\n\n  }, {\n    key: \"_onMutations\",\n    value: function _onMutations(domMutations) {\n      // As a result of this.flush() we can have an empty collection.\n      if (domMutations.length === 0) {\n        return;\n      }\n\n      var domConverter = this.domConverter; // Use map and set for deduplication.\n\n      var mutatedTexts = new Map();\n      var mutatedElements = new Set(); // Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the\n      // element with changed structure anyway.\n\n      var _iterator2 = _createForOfIteratorHelper(domMutations),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mutation = _step2.value;\n\n          if (mutation.type === 'childList') {\n            var element = domConverter.mapDomToView(mutation.target); // Do not collect mutations from UIElements and RawElements.\n\n            if (element && (element.is('uiElement') || element.is('rawElement'))) {\n              continue;\n            }\n\n            if (element && !this._isBogusBrMutation(mutation)) {\n              mutatedElements.add(element);\n            }\n          }\n        } // Handle `characterData` mutations later, when we have the full list of nodes which changed structure.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(domMutations),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _mutation = _step3.value;\n\n          var _element = domConverter.mapDomToView(_mutation.target); // Do not collect mutations from UIElements and RawElements.\n\n\n          if (_element && (_element.is('uiElement') || _element.is('rawElement'))) {\n            continue;\n          }\n\n          if (_mutation.type === 'characterData') {\n            var text = domConverter.findCorrespondingViewText(_mutation.target);\n\n            if (text && !mutatedElements.has(text.parent)) {\n              // Use text as a key, for deduplication. If there will be another mutation on the same text element\n              // we will have only one in the map.\n              mutatedTexts.set(text, {\n                type: 'text',\n                oldText: text.data,\n                newText: getDataWithoutFiller(_mutation.target),\n                node: text\n              });\n            } // When we added first letter to the text node which had only inline filler, for the DOM it is mutation\n            // on text, but for the view, where filler text node did not existed, new text node was created, so we\n            // need to fire 'children' mutation instead of 'text'.\n            else if (!text && startsWithFiller(_mutation.target)) {\n              mutatedElements.add(domConverter.mapDomToView(_mutation.target.parentNode));\n            }\n          }\n        } // Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the\n        // same node multiple times in case of duplication.\n        // List of mutations we will fire.\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var viewMutations = [];\n\n      var _iterator4 = _createForOfIteratorHelper(mutatedTexts.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var mutatedText = _step4.value;\n          this.renderer.markToSync('text', mutatedText.node);\n          viewMutations.push(mutatedText);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(mutatedElements),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var viewElement = _step5.value;\n          var domElement = domConverter.mapViewToDom(viewElement);\n          var viewChildren = Array.from(viewElement.getChildren());\n          var newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {\n            withChildren: false\n          })); // It may happen that as a result of many changes (sth was inserted and then removed),\n          // both elements haven't really changed. #1031\n\n          if (!isEqualWith(viewChildren, newViewChildren, sameNodes)) {\n            this.renderer.markToSync('children', viewElement);\n            viewMutations.push({\n              type: 'children',\n              oldChildren: viewChildren,\n              newChildren: newViewChildren,\n              node: viewElement\n            });\n          }\n        } // Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.\n        // There should not be simultaneous mutation in multiple documents, so it's fine.\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var domSelection = domMutations[0].target.ownerDocument.getSelection();\n      var viewSelection = null;\n\n      if (domSelection && domSelection.anchorNode) {\n        // If `domSelection` is inside a dom node that is already bound to a view node from view tree, get\n        // corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may\n        // be used by features handling mutations.\n        // Only one range is supported.\n        var viewSelectionAnchor = domConverter.domPositionToView(domSelection.anchorNode, domSelection.anchorOffset);\n        var viewSelectionFocus = domConverter.domPositionToView(domSelection.focusNode, domSelection.focusOffset); // Anchor and focus has to be properly mapped to view.\n\n        if (viewSelectionAnchor && viewSelectionFocus) {\n          viewSelection = new ViewSelection(viewSelectionAnchor);\n          viewSelection.setFocus(viewSelectionFocus);\n        }\n      } // In case only non-relevant mutations were recorded it skips the event and force render (#5600).\n\n\n      if (viewMutations.length) {\n        this.document.fire('mutations', viewMutations, viewSelection); // If nothing changes on `mutations` event, at this point we have \"dirty DOM\" (changed) and de-synched\n        // view (which has not been changed). In order to \"reset DOM\" we render the view again.\n\n        this.view.forceRender();\n      }\n\n      function sameNodes(child1, child2) {\n        // First level of comparison (array of children vs array of children) â€“ use the Lodash's default behavior.\n        if (Array.isArray(child1)) {\n          return;\n        } // Elements.\n\n\n        if (child1 === child2) {\n          return true;\n        } // Texts.\n        else if (child1.is('$text') && child2.is('$text')) {\n          return child1.data === child2.data;\n        } // Not matching types.\n\n\n        return false;\n      }\n    }\n    /**\n     * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.\n     * Such mutations are generated while pressing space or performing native spellchecker correction\n     * on the end of the block element in Firefox browser.\n     *\n     * @private\n     * @param {Object} mutation Native mutation object.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isBogusBrMutation\",\n    value: function _isBogusBrMutation(mutation) {\n      var addedNode = null; // Check if mutation added only one node on the end of its parent.\n\n      if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {\n        addedNode = this.domConverter.domToView(mutation.addedNodes[0], {\n          withChildren: false\n        });\n      }\n\n      return addedNode && addedNode.is('element', 'br');\n    }\n  }]);\n\n  return MutationObserver;\n}(Observer);\n/**\n * Fired when mutation occurred. If tree view is not changed on this event, DOM will be reverted to the state before\n * mutation, so all changes which should be applied, should be handled on this event.\n *\n * Introduced by {@link module:engine/view/observer/mutationobserver~MutationObserver}.\n *\n * Note that because {@link module:engine/view/observer/mutationobserver~MutationObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @event module:engine/view/document~Document#event:mutations\n * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|module:engine/view/observer/mutationobserver~MutatedChildren>}\n * viewMutations Array of mutations.\n * For mutated texts it will be {@link module:engine/view/observer/mutationobserver~MutatedText} and for mutated elements it will be\n * {@link module:engine/view/observer/mutationobserver~MutatedChildren}. You can recognize the type based on the `type` property.\n * @param {module:engine/view/selection~Selection|null} viewSelection View selection that is a result of converting DOM selection to view.\n * Keep in\n * mind that the DOM selection is already \"updated\", meaning that it already acknowledges changes done in mutation.\n */\n\n/**\n * Mutation item for text.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedText\n *\n * @property {String} type For text mutations it is always 'text'.\n * @property {module:engine/view/text~Text} node Mutated text node.\n * @property {String} oldText Old text.\n * @property {String} newText New text.\n */\n\n/**\n * Mutation item for child nodes.\n *\n * @see module:engine/view/document~Document#event:mutations\n * @see module:engine/view/observer/mutationobserver~MutatedText\n *\n * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedChildren\n *\n * @property {String} type For child nodes mutations it is always 'children'.\n * @property {module:engine/view/element~Element} node Parent of the mutated children.\n * @property {Array.<module:engine/view/node~Node>} oldChildren Old child nodes.\n * @property {Array.<module:engine/view/node~Node>} newChildren New child nodes.\n */\n\n\nexport { MutationObserver as default };","map":null,"metadata":{},"sourceType":"module"}