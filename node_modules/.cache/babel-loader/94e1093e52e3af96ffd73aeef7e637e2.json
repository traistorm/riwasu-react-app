{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _objectSpread from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/markercollection\n */\nimport LiveRange from './liverange';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\n\nvar MarkerCollection = /*#__PURE__*/function () {\n  /**\n   * Creates a markers collection.\n   */\n  function MarkerCollection() {\n    _classCallCheck(this, MarkerCollection);\n\n    /**\n     * Stores {@link ~Marker markers} added to the collection.\n     *\n     * @private\n     * @member {Map} #_markers\n     */\n    this._markers = new Map();\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link ~Marker markers} added to the collection.\n   *\n   * @returns {Iterable}\n   */\n\n\n  _createClass(MarkerCollection, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this._markers.values();\n    }\n    /**\n     * Checks if given {@link ~Marker marker} or marker name is in the collection.\n     *\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker or marker instance to check.\n     * @returns {Boolean} `true` if marker is in the collection, `false` otherwise.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(markerOrName) {\n      var markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n      return this._markers.has(markerName);\n    }\n    /**\n     * Returns {@link ~Marker marker} with given `markerName`.\n     *\n     * @param {String} markerName Name of marker to get.\n     * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n     * not added to the collection.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(markerName) {\n      return this._markers.get(markerName) || null;\n    }\n    /**\n     * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n     * {@link module:engine/model/range~Range range}.\n     *\n     * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n     * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n     * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n     * flag has changed.\n     *\n     * @protected\n     * @fires module:engine/model/markercollection~MarkerCollection#event:update\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n     * @param {module:engine/model/range~Range} range Marker range.\n     * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n     * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n     * (is persisted in the editor's data).\n     * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n     */\n\n  }, {\n    key: \"_set\",\n    value: function _set(markerOrName, range) {\n      var managedUsingOperations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var affectsData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n      if (markerName.includes(',')) {\n        /**\n         * Marker name cannot contain the \",\" character.\n         *\n         * @error markercollection-incorrect-marker-name\n         */\n        throw new CKEditorError('markercollection-incorrect-marker-name', this);\n      }\n\n      var oldMarker = this._markers.get(markerName);\n\n      if (oldMarker) {\n        var oldMarkerData = oldMarker.getData();\n        var oldRange = oldMarker.getRange();\n        var hasChanged = false;\n\n        if (!oldRange.isEqual(range)) {\n          oldMarker._attachLiveRange(LiveRange.fromRange(range));\n\n          hasChanged = true;\n        }\n\n        if (managedUsingOperations != oldMarker.managedUsingOperations) {\n          oldMarker._managedUsingOperations = managedUsingOperations;\n          hasChanged = true;\n        }\n\n        if (typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData) {\n          oldMarker._affectsData = affectsData;\n          hasChanged = true;\n        }\n\n        if (hasChanged) {\n          this.fire('update:' + markerName, oldMarker, oldRange, range, oldMarkerData);\n        }\n\n        return oldMarker;\n      }\n\n      var liveRange = LiveRange.fromRange(range);\n      var marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);\n\n      this._markers.set(markerName, marker);\n\n      this.fire('update:' + markerName, marker, null, range, _objectSpread({}, marker.getData(), {\n        range: null\n      }));\n      return marker;\n    }\n    /**\n     * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n     *\n     * @protected\n     * @fires module:engine/model/markercollection~MarkerCollection#event:update\n     * @param {String} markerOrName Marker or name of a marker to remove.\n     * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(markerOrName) {\n      var markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n      var oldMarker = this._markers.get(markerName);\n\n      if (oldMarker) {\n        this._markers.delete(markerName);\n\n        this.fire('update:' + markerName, oldMarker, oldMarker.getRange(), null, oldMarker.getData());\n\n        this._destroyMarker(oldMarker);\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}\n     * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast\n     * conversion} for the marker.\n     *\n     * @protected\n     * @fires module:engine/model/markercollection~MarkerCollection#event:update\n     * @param {String} markerOrName Marker or name of a marker to refresh.\n     */\n\n  }, {\n    key: \"_refresh\",\n    value: function _refresh(markerOrName) {\n      var markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\n      var marker = this._markers.get(markerName);\n\n      if (!marker) {\n        /**\n         * Marker with provided name does not exists.\n         *\n         * @error markercollection-refresh-marker-not-exists\n         */\n        throw new CKEditorError('markercollection-refresh-marker-not-exists', this);\n      }\n\n      var range = marker.getRange();\n      this.fire('update:' + markerName, marker, range, range, marker.getData());\n    }\n    /**\n     * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n     *\n     * @param {module:engine/model/position~Position} position\n     * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n     */\n\n  }, {\n    key: \"getMarkersAtPosition\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getMarkersAtPosition(position) {\n      var _iterator, _step, marker;\n\n      return _regeneratorRuntime.wrap(function getMarkersAtPosition$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper(this);\n              _context.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 10;\n                break;\n              }\n\n              marker = _step.value;\n\n              if (!marker.getRange().containsPosition(position)) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 8;\n              return marker;\n\n            case 8:\n              _context.next = 3;\n              break;\n\n            case 10:\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](1);\n\n              _iterator.e(_context.t0);\n\n            case 15:\n              _context.prev = 15;\n\n              _iterator.f();\n\n              return _context.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, getMarkersAtPosition, this, [[1, 12, 15, 18]]);\n    })\n    /**\n     * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n     *\n     * @param {module:engine/model/range~Range} range\n     * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n     */\n\n  }, {\n    key: \"getMarkersIntersectingRange\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getMarkersIntersectingRange(range) {\n      var _iterator2, _step2, marker;\n\n      return _regeneratorRuntime.wrap(function getMarkersIntersectingRange$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator2 = _createForOfIteratorHelper(this);\n              _context2.prev = 1;\n\n              _iterator2.s();\n\n            case 3:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 10;\n                break;\n              }\n\n              marker = _step2.value;\n\n              if (!(marker.getRange().getIntersection(range) !== null)) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 8;\n              return marker;\n\n            case 8:\n              _context2.next = 3;\n              break;\n\n            case 10:\n              _context2.next = 15;\n              break;\n\n            case 12:\n              _context2.prev = 12;\n              _context2.t0 = _context2[\"catch\"](1);\n\n              _iterator2.e(_context2.t0);\n\n            case 15:\n              _context2.prev = 15;\n\n              _iterator2.f();\n\n              return _context2.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getMarkersIntersectingRange, this, [[1, 12, 15, 18]]);\n    })\n    /**\n     * Destroys marker collection and all markers inside it.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator3 = _createForOfIteratorHelper(this._markers.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var marker = _step3.value;\n\n          this._destroyMarker(marker);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._markers = null;\n      this.stopListening();\n    }\n    /**\n     * Iterates over all markers that starts with given `prefix`.\n     *\n     *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n     *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n     *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n     *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n     *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n     *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n     *\n     * @param prefix\n     * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n     */\n\n  }, {\n    key: \"getMarkersGroup\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getMarkersGroup(prefix) {\n      var _iterator4, _step4, marker;\n\n      return _regeneratorRuntime.wrap(function getMarkersGroup$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _iterator4 = _createForOfIteratorHelper(this._markers.values());\n              _context3.prev = 1;\n\n              _iterator4.s();\n\n            case 3:\n              if ((_step4 = _iterator4.n()).done) {\n                _context3.next = 10;\n                break;\n              }\n\n              marker = _step4.value;\n\n              if (!marker.name.startsWith(prefix + ':')) {\n                _context3.next = 8;\n                break;\n              }\n\n              _context3.next = 8;\n              return marker;\n\n            case 8:\n              _context3.next = 3;\n              break;\n\n            case 10:\n              _context3.next = 15;\n              break;\n\n            case 12:\n              _context3.prev = 12;\n              _context3.t0 = _context3[\"catch\"](1);\n\n              _iterator4.e(_context3.t0);\n\n            case 15:\n              _context3.prev = 15;\n\n              _iterator4.f();\n\n              return _context3.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, getMarkersGroup, this, [[1, 12, 15, 18]]);\n    })\n    /**\n     * Destroys the marker.\n     *\n     * @private\n     * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n     */\n\n  }, {\n    key: \"_destroyMarker\",\n    value: function _destroyMarker(marker) {\n      marker.stopListening();\n\n      marker._detachLiveRange();\n    }\n    /**\n     * Fired whenever marker is added, updated or removed from `MarkerCollection`.\n     *\n     * @event update\n     * @param {module:engine/model/markercollection~Marker} marker Updated Marker.\n     * @param {module:engine/model/range~Range|null} oldRange Marker range before the update. When is not defined it\n     * means that marker is just added.\n     * @param {module:engine/model/range~Range|null} newRange Marker range after update. When is not defined it\n     * means that marker is just removed.\n     * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Data of the marker before the change.\n     */\n\n  }]);\n\n  return MarkerCollection;\n}();\n\nexport { MarkerCollection as default };\nmix(MarkerCollection, EmitterMixin);\n/**\n * @typedef {Object} module:engine/model/markercollection~MarkerData\n *\n * @property {module:engine/model/range~Range|null} range Marker range. `null` if the marker was removed.\n * @property {Boolean} affectsData A property defining if the marker affects data.\n * @property {Boolean} managedUsingOperations A property defining if the marker is managed using operations.\n */\n\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\n\nvar Marker = /*#__PURE__*/function () {\n  /**\n   * Creates a marker instance.\n   *\n   * @param {String} name Marker name.\n   * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n   * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n   * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n   * (is persisted in the editor's data).\n   */\n  function Marker(name, liveRange, managedUsingOperations, affectsData) {\n    _classCallCheck(this, Marker);\n\n    /**\n     * Marker's name.\n     *\n     * @readonly\n     * @type {String}\n     */\n    this.name = name;\n    /**\n     * Range marked by the marker.\n     *\n     * @protected\n     * @member {module:engine/model/liverange~LiveRange}\n     */\n\n    this._liveRange = this._attachLiveRange(liveRange);\n    /**\n     * Flag indicates if the marker is managed using operations or not.\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._managedUsingOperations = managedUsingOperations;\n    /**\n     * Specifies whether the marker affects the data produced by the data pipeline\n     * (is persisted in the editor's data).\n     *\n     * @private\n     * @member {Boolean}\n     */\n\n    this._affectsData = affectsData;\n  }\n  /**\n   * A value indicating if the marker is managed using operations.\n   * See {@link ~Marker marker class description} to learn more about marker types.\n   * See {@link module:engine/model/writer~Writer#addMarker}.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Marker, [{\n    key: \"getData\",\n\n    /**\n     * Returns the marker data (properties defining the marker).\n     *\n     * @returns {module:engine/model/markercollection~MarkerData}\n     */\n    value: function getData() {\n      return {\n        range: this.getRange(),\n        affectsData: this.affectsData,\n        managedUsingOperations: this.managedUsingOperations\n      };\n    }\n    /**\n     * Returns current marker start position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"getStart\",\n    value: function getStart() {\n      if (!this._liveRange) {\n        throw new CKEditorError('marker-destroyed', this);\n      }\n\n      return this._liveRange.start.clone();\n    }\n    /**\n     * Returns current marker end position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"getEnd\",\n    value: function getEnd() {\n      if (!this._liveRange) {\n        throw new CKEditorError('marker-destroyed', this);\n      }\n\n      return this._liveRange.end.clone();\n    }\n    /**\n     * Returns a range that represents the current state of the marker.\n     *\n     * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n     * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n     * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n     * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n     * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n     * that it's data is up-to-date.\n     *\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      if (!this._liveRange) {\n        throw new CKEditorError('marker-destroyed', this);\n      }\n\n      return this._liveRange.toRange();\n    }\n    /**\n     * Checks whether this object is of the given.\n     *\n     *\t\tmarker.is( 'marker' ); // -> true\n     *\t\tmarker.is( 'model:marker' ); // -> true\n     *\n     *\t\tmarker.is( 'view:element' ); // -> false\n     *\t\tmarker.is( 'documentSelection' ); // -> false\n     *\n     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type === 'marker' || type === 'model:marker';\n    }\n    /**\n     * Binds new live range to the marker and detach the old one if is attached.\n     *\n     * @protected\n     * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n     * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n     */\n\n  }, {\n    key: \"_attachLiveRange\",\n    value: function _attachLiveRange(liveRange) {\n      if (this._liveRange) {\n        this._detachLiveRange();\n      } // Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n\n\n      liveRange.delegate('change:range').to(this);\n      liveRange.delegate('change:content').to(this);\n      this._liveRange = liveRange;\n      return liveRange;\n    }\n    /**\n     * Unbinds and destroys currently attached live range.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_detachLiveRange\",\n    value: function _detachLiveRange() {\n      this._liveRange.stopDelegating('change:range', this);\n\n      this._liveRange.stopDelegating('change:content', this);\n\n      this._liveRange.detach();\n\n      this._liveRange = null;\n    }\n    /**\n     * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.\n     * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.\n     *\n     * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n     * all event listeners listening to it should be removed. It is best to do it on\n     * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n     *\n     * @see module:engine/model/liverange~LiveRange#event:change:range\n     * @event change:range\n     * @param {module:engine/model/range~Range} oldRange\n     * @param {Object} data\n     */\n\n    /**\n     * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.\n     * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.\n     *\n     * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n     * all event listeners listening to it should be removed. It is best to do it on\n     * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n     *\n     * @see module:engine/model/liverange~LiveRange#event:change:content\n     * @event change:content\n     * @param {module:engine/model/range~Range} oldRange\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"managedUsingOperations\",\n    get: function get() {\n      if (!this._liveRange) {\n        throw new CKEditorError('marker-destroyed', this);\n      }\n\n      return this._managedUsingOperations;\n    }\n    /**\n     * A value indicating if the marker changes the data.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"affectsData\",\n    get: function get() {\n      if (!this._liveRange) {\n        throw new CKEditorError('marker-destroyed', this);\n      }\n\n      return this._affectsData;\n    }\n  }]);\n\n  return Marker;\n}();\n\nmix(Marker, EmitterMixin);\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */","map":null,"metadata":{},"sourceType":"module"}