{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/texttransformation\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport TextWatcher from './textwatcher';\nimport { escapeRegExp } from 'lodash-es'; // All named transformations.\n\nvar TRANSFORMATIONS = {\n  // Common symbols:\n  copyright: {\n    from: '(c)',\n    to: '©'\n  },\n  registeredTrademark: {\n    from: '(r)',\n    to: '®'\n  },\n  trademark: {\n    from: '(tm)',\n    to: '™'\n  },\n  // Mathematical:\n  oneHalf: {\n    from: /(^|[^/a-z0-9])(1\\/2)([^/a-z0-9])$/i,\n    to: [null, '½', null]\n  },\n  oneThird: {\n    from: /(^|[^/a-z0-9])(1\\/3)([^/a-z0-9])$/i,\n    to: [null, '⅓', null]\n  },\n  twoThirds: {\n    from: /(^|[^/a-z0-9])(2\\/3)([^/a-z0-9])$/i,\n    to: [null, '⅔', null]\n  },\n  oneForth: {\n    from: /(^|[^/a-z0-9])(1\\/4)([^/a-z0-9])$/i,\n    to: [null, '¼', null]\n  },\n  threeQuarters: {\n    from: /(^|[^/a-z0-9])(3\\/4)([^/a-z0-9])$/i,\n    to: [null, '¾', null]\n  },\n  lessThanOrEqual: {\n    from: '<=',\n    to: '≤'\n  },\n  greaterThanOrEqual: {\n    from: '>=',\n    to: '≥'\n  },\n  notEqual: {\n    from: '!=',\n    to: '≠'\n  },\n  arrowLeft: {\n    from: '<-',\n    to: '←'\n  },\n  arrowRight: {\n    from: '->',\n    to: '→'\n  },\n  // Typography:\n  horizontalEllipsis: {\n    from: '...',\n    to: '…'\n  },\n  enDash: {\n    from: /(^| )(--)( )$/,\n    to: [null, '–', null]\n  },\n  emDash: {\n    from: /(^| )(---)( )$/,\n    to: [null, '—', null]\n  },\n  // Quotations:\n  // English, US\n  quotesPrimary: {\n    from: buildQuotesRegExp('\"'),\n    to: [null, '“', null, '”']\n  },\n  quotesSecondary: {\n    from: buildQuotesRegExp('\\''),\n    to: [null, '‘', null, '’']\n  },\n  // English, UK\n  quotesPrimaryEnGb: {\n    from: buildQuotesRegExp('\\''),\n    to: [null, '‘', null, '’']\n  },\n  quotesSecondaryEnGb: {\n    from: buildQuotesRegExp('\"'),\n    to: [null, '“', null, '”']\n  },\n  // Polish\n  quotesPrimaryPl: {\n    from: buildQuotesRegExp('\"'),\n    to: [null, '„', null, '”']\n  },\n  quotesSecondaryPl: {\n    from: buildQuotesRegExp('\\''),\n    to: [null, '‚', null, '’']\n  }\n}; // Transformation groups.\n\nvar TRANSFORMATION_GROUPS = {\n  symbols: ['copyright', 'registeredTrademark', 'trademark'],\n  mathematical: ['oneHalf', 'oneThird', 'twoThirds', 'oneForth', 'threeQuarters', 'lessThanOrEqual', 'greaterThanOrEqual', 'notEqual', 'arrowLeft', 'arrowRight'],\n  typography: ['horizontalEllipsis', 'enDash', 'emDash'],\n  quotes: ['quotesPrimary', 'quotesSecondary']\n}; // A set of default transformations provided by the feature.\n\nvar DEFAULT_TRANSFORMATIONS = ['symbols', 'mathematical', 'typography', 'quotes'];\n/**\n * The text transformation plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar TextTransformation = /*#__PURE__*/function (_Plugin) {\n  _inherits(TextTransformation, _Plugin);\n\n  _createClass(TextTransformation, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return ['Delete', 'Input'];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'TextTransformation';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function TextTransformation(editor) {\n    var _this;\n\n    _classCallCheck(this, TextTransformation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextTransformation).call(this, editor));\n    editor.config.define('typing', {\n      transformations: {\n        include: DEFAULT_TRANSFORMATIONS\n      }\n    });\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(TextTransformation, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var model = this.editor.model;\n      var modelSelection = model.document.selection;\n      modelSelection.on('change:range', function () {\n        // Disable plugin when selection is inside a code block.\n        _this2.isEnabled = !modelSelection.anchor.parent.is('element', 'codeBlock');\n      });\n\n      this._enableTransformationWatchers();\n    }\n    /**\n     * Create new TextWatcher listening to the editor for typing and selection events.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableTransformationWatchers\",\n    value: function _enableTransformationWatchers() {\n      var editor = this.editor;\n      var model = editor.model;\n      var deletePlugin = editor.plugins.get('Delete');\n      var normalizedTransformations = normalizeTransformations(editor.config.get('typing.transformations'));\n\n      var testCallback = function testCallback(text) {\n        var _iterator = _createForOfIteratorHelper(normalizedTransformations),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var normalizedTransformation = _step.value;\n            var from = normalizedTransformation.from;\n            var match = from.test(text);\n\n            if (match) {\n              return {\n                normalizedTransformation: normalizedTransformation\n              };\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      };\n\n      var watcherCallback = function watcherCallback(evt, data) {\n        if (!data.batch.isTyping) {\n          return;\n        }\n\n        var _data$normalizedTrans = data.normalizedTransformation,\n            from = _data$normalizedTrans.from,\n            to = _data$normalizedTrans.to;\n        var matches = from.exec(data.text);\n        var replaces = to(matches.slice(1));\n        var matchedRange = data.range;\n        var changeIndex = matches.index;\n        model.enqueueChange(function (writer) {\n          for (var i = 1; i < matches.length; i++) {\n            var match = matches[i];\n            var replaceWith = replaces[i - 1];\n\n            if (replaceWith == null) {\n              changeIndex += match.length;\n              continue;\n            }\n\n            var replacePosition = matchedRange.start.getShiftedBy(changeIndex);\n            var replaceRange = model.createRange(replacePosition, replacePosition.getShiftedBy(match.length));\n            var attributes = getTextAttributesAfterPosition(replacePosition);\n            model.insertContent(writer.createText(replaceWith, attributes), replaceRange);\n            changeIndex += replaceWith.length;\n          }\n\n          model.enqueueChange(function () {\n            deletePlugin.requestUndoOnBackspace();\n          });\n        });\n      };\n\n      var watcher = new TextWatcher(editor.model, testCallback);\n      watcher.on('matched:data', watcherCallback);\n      watcher.bind('isEnabled').to(this);\n    }\n  }]);\n\n  return TextTransformation;\n}(Plugin); // Normalizes the configuration `from` parameter value.\n// The normalized value for the `from` parameter is a RegExp instance. If the passed `from` is already a RegExp instance,\n// it is returned unchanged.\n//\n// @param {String|RegExp} from\n// @returns {RegExp}\n\n\nexport { TextTransformation as default };\n\nfunction normalizeFrom(from) {\n  if (typeof from == 'string') {\n    return new RegExp(\"(\".concat(escapeRegExp(from), \")$\"));\n  } // `from` is already a regular expression.\n\n\n  return from;\n} // Normalizes the configuration `to` parameter value.\n// The normalized value for the `to` parameter is a function that takes an array and returns an array. See more in the\n// configuration description. If the passed `to` is already a function, it is returned unchanged.\n//\n// @param {String|Array.<null|String>|Function} to\n// @returns {Function}\n\n\nfunction normalizeTo(to) {\n  if (typeof to == 'string') {\n    return function () {\n      return [to];\n    };\n  } else if (to instanceof Array) {\n    return function () {\n      return to;\n    };\n  } // `to` is already a function.\n\n\n  return to;\n} // For given `position` returns attributes for the text that is after that position.\n// The text can be in the same text node as the position (`foo[]bar`) or in the next text node (`foo[]<$text bold=\"true\">bar</$text>`).\n//\n// @param {module:engine/model/position~Position} position\n// @returns {Iterable.<*>}\n\n\nfunction getTextAttributesAfterPosition(position) {\n  var textNode = position.textNode ? position.textNode : position.nodeAfter;\n  return textNode.getAttributes();\n} // Returns a RegExp pattern string that detects a sentence inside a quote.\n//\n// @param {String} quoteCharacter The character to create a pattern for.\n// @returns {String}\n\n\nfunction buildQuotesRegExp(quoteCharacter) {\n  return new RegExp(\"(^|\\\\s)(\".concat(quoteCharacter, \")([^\").concat(quoteCharacter, \"]*)(\").concat(quoteCharacter, \")$\"));\n} // Reads text transformation config and returns normalized array of transformations objects.\n//\n// @param {module:typing/texttransformation~TextTransformationDescription} config\n// @returns {Array.<{from:String,to:Function}>}\n\n\nfunction normalizeTransformations(config) {\n  var extra = config.extra || [];\n  var remove = config.remove || [];\n\n  var isNotRemoved = function isNotRemoved(transformation) {\n    return !remove.includes(transformation);\n  };\n\n  var configured = config.include.concat(extra).filter(isNotRemoved);\n  return expandGroupsAndRemoveDuplicates(configured).filter(isNotRemoved) // Filter out 'remove' transformations as they might be set in group.\n  .map(function (transformation) {\n    return TRANSFORMATIONS[transformation] || transformation;\n  }).filter(function (transformation) {\n    return typeof transformation === 'object';\n  }) // Filter out transformations set as string that has not been found.\n  .map(function (transformation) {\n    return {\n      from: normalizeFrom(transformation.from),\n      to: normalizeTo(transformation.to)\n    };\n  });\n} // Reads definitions and expands named groups if needed to transformation names.\n// This method also removes duplicated named transformations if any.\n//\n// @param {Array.<String|Object>} definitions\n// @returns {Array.<String|Object>}\n\n\nfunction expandGroupsAndRemoveDuplicates(definitions) {\n  // Set is using to make sure that transformation names are not duplicated.\n  var definedTransformations = new Set();\n\n  var _iterator2 = _createForOfIteratorHelper(definitions),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var transformationOrGroup = _step2.value;\n\n      if (TRANSFORMATION_GROUPS[transformationOrGroup]) {\n        var _iterator3 = _createForOfIteratorHelper(TRANSFORMATION_GROUPS[transformationOrGroup]),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var transformation = _step3.value;\n            definedTransformations.add(transformation);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } else {\n        definedTransformations.add(transformationOrGroup);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Array.from(definedTransformations);\n}\n/**\n * The text transformation definition object. It describes what should be replaced with what.\n *\n * The input value (`from`) can be passed either as a string or as a regular expression.\n *\n * * If a string is passed, it will be simply checked if the end of the input matches it.\n * * If a regular expression is passed, its entire length must be covered with capturing groups (e.g. `/(foo)(bar)$/`).\n * Also, since it is compared against the end of the input, it has to end with  `$` to be correctly matched.\n * See examples below.\n *\n * The output value (`to`) can be passed as a string, as an array or as a function.\n *\n * * If a string is passed, it will be used as a replacement value as-is. Note that a string output value can be used only if\n * the input value is a string, too.\n * * If an array is passed, it has to have the same number of elements as there are capturing groups in the input value regular expression.\n * Each capture group will be replaced with a corresponding string from the passed array. If a given capturing group should not be replaced,\n * use `null` instead of passing a string.\n * * If a function is used, it should return an array as described above. The function is passed one parameter &mdash; an array with matches\n * by the regular expression. See the examples below.\n *\n * A simple string-to-string replacement:\n *\n *\t\t{ from: '(c)', to: '©' }\n *\n * Change quote styles using a regular expression. Note how all the parts are in separate capturing groups and the space at the beginning\n * and the text inside quotes are not replaced (`null` passed as the first and the third value in the `to` parameter):\n *\n *\t\t{\n *\t\t\tfrom: /(^|\\s)(\")([^\"]*)(\")$/,\n *\t\t\tto: [ null, '“', null, '”' ]\n *\t\t}\n *\n * Automatic uppercase after a dot using a callback:\n *\n *\t\t{\n *\t\t\tfrom: /(\\. )([a-z])$/,\n *\t\t\tto: matches => [ null, matches[ 1 ].toUpperCase() ]\n *\t\t}\n *\n * @typedef {Object} module:typing/texttransformation~TextTransformationDescription\n * @property {String|RegExp} from The string or regular expression to transform.\n * @property {String} to The text to transform compatible with `String.replace()`.\n */\n\n/**\n * The configuration of the {@link module:typing/texttransformation~TextTransformation} feature.\n *\n * Read more in {@link module:typing/texttransformation~TextTransformationConfig}.\n *\n * @member {module:typing/texttransformation~TextTransformationConfig} module:typing/typing~TypingConfig#transformations\n */\n\n/**\n * The configuration of the text transformation feature.\n *\n *\t\tClassicEditor\n *\t\t\t.create( editorElement, {\n *\t\t\t\ttyping: {\n *\t\t\t\t\ttransformations: ... // Text transformation feature options.\n *\t\t\t\t}\n *\t\t\t} )\n *\t\t\t.then( ... )\n *\t\t\t.catch( ... );\n *\n * By default, the feature comes pre-configured\n * (via {@link module:typing/texttransformation~TextTransformationConfig#include `config.typing.transformations.include`}) with the\n * following groups of transformations:\n *\n * * Typography (group name: `typography`)\n *   - `ellipsis`: transforms `...` to `…`\n *   - `enDash`: transforms ` -- ` to ` – `\n *   - `emDash`: transforms ` --- ` to ` — `\n * * Quotations (group name: `quotes`)\n *   - `quotesPrimary`: transforms `\"Foo bar\"` to `“Foo bar”`\n *   - `quotesSecondary`: transforms `'Foo bar'` to `‘Foo bar’`\n * * Symbols (group name: `symbols`)\n *   - `trademark`: transforms `(tm)` to `™`\n *   - `registeredTrademark`: transforms `(r)` to `®`\n *   - `copyright`: transforms `(c)` to `©`\n * * Mathematical (group name: `mathematical`)\n *   - `oneHalf`: transforms `1/2` to: `½`\n *   - `oneThird`: transforms `1/3` to: `⅓`\n *   - `twoThirds`: transforms `2/3` to: `⅔`\n *   - `oneForth`: transforms `1/4` to: `¼`\n *   - `threeQuarters`: transforms `3/4` to: `¾`\n *   - `lessThanOrEqual`: transforms `<=` to: `≤`\n *   - `greaterThanOrEqual`: transforms `>=` to: `≥`\n *   - `notEqual`: transforms `!=` to: `≠`\n *   - `arrowLeft`: transforms `<-` to: `←`\n *   - `arrowRight`: transforms `->` to: `→`\n * * Misc:\n *   - `quotesPrimaryEnGb`: transforms `'Foo bar'` to `‘Foo bar’`\n *   - `quotesSecondaryEnGb`: transforms `\"Foo bar\"` to `“Foo bar”`\n *   - `quotesPrimaryPl`: transforms `\"Foo bar\"` to `„Foo bar”`\n *   - `quotesSecondaryPl`:  transforms `'Foo bar'` to `‚Foo bar’`\n *\n * In order to load additional transformations, use the\n * {@link module:typing/texttransformation~TextTransformationConfig#extra `transformations.extra` option}.\n *\n * In order to narrow down the list of transformations, use the\n * {@link module:typing/texttransformation~TextTransformationConfig#remove `transformations.remove` option}.\n *\n * In order to completely override the supported transformations, use the\n * {@link module:typing/texttransformation~TextTransformationConfig#include `transformations.include` option}.\n *\n * Examples:\n *\n *\t\tconst transformationsConfig = {\n *\t\t\tinclude: [\n *\t\t\t\t// Use only the 'quotes' and 'typography' groups.\n *\t\t\t\t'quotes',\n *\t\t\t\t'typography',\n *\n *\t\t\t\t// Plus, some custom transformation.\n *\t\t\t\t{ from: 'CKE', to: 'CKEditor' }\n *\t\t\t]\n *\t\t};\n *\n *\t\tconst transformationsConfig = {\n *\t\t\t// Remove the 'ellipsis' transformation loaded by the 'typography' group.\n *\t\t\tremove: [ 'ellipsis' ]\n *\t\t}\n *\n * @interface TextTransformationConfig\n */\n\n/* eslint-disable max-len */\n\n/**\n * The standard list of text transformations supported by the editor. By default it comes pre-configured with a couple dozen of them\n * (see {@link module:typing/texttransformation~TextTransformationConfig} for the full list). You can override this list completely\n * by setting this option or use the other two options\n * ({@link module:typing/texttransformation~TextTransformationConfig#extra `transformations.extra`},\n * {@link module:typing/texttransformation~TextTransformationConfig#remove `transformations.remove`}) to fine-tune the default list.\n *\n * @member {Array.<module:typing/texttransformation~TextTransformationDescription>} module:typing/texttransformation~TextTransformationConfig#include\n */\n\n/**\n * Additional text transformations that are added to the transformations defined in\n * {@link module:typing/texttransformation~TextTransformationConfig#include `transformations.include`}.\n *\n *\t\tconst transformationsConfig = {\n *\t\t\textra: [\n *\t\t\t\t{ from: 'CKE', to: 'CKEditor' }\n *\t\t\t]\n *\t\t};\n *\n * @member {Array.<module:typing/texttransformation~TextTransformationDescription>} module:typing/texttransformation~TextTransformationConfig#extra\n */\n\n/**\n * The text transformation names that are removed from transformations defined in\n * {@link module:typing/texttransformation~TextTransformationConfig#include `transformations.include`} or\n * {@link module:typing/texttransformation~TextTransformationConfig#extra `transformations.extra`}.\n *\n *\t\tconst transformationsConfig = {\n *\t\t\tremove: [\n *\t\t\t\t'ellipsis',    // Remove only 'ellipsis' from the 'typography' group.\n *\t\t\t\t'mathematical' // Remove all transformations from the 'mathematical' group.\n *\t\t\t]\n *\t\t}\n *\n * @member {Array.<module:typing/texttransformation~TextTransformationDescription>} module:typing/texttransformation~TextTransformationConfig#remove\n */\n\n/* eslint-enable max-len */","map":null,"metadata":{},"sourceType":"module"}