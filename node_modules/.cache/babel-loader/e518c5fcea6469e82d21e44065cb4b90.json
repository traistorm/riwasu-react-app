{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es'; // @if CK_DEBUG_POSITION // import { RectDrawer } from '@ckeditor/ckeditor5-minimap/src/utils';\n\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options The input data and configuration of the helper.\n * @returns {module:utils/dom/position~Position}\n */\n\nexport function getOptimalPosition(_ref) {\n  var element = _ref.element,\n      target = _ref.target,\n      positions = _ref.positions,\n      limiter = _ref.limiter,\n      fitInViewport = _ref.fitInViewport,\n      viewportOffsetConfig = _ref.viewportOffsetConfig;\n\n  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-utils/issues/157\n  if (isFunction(target)) {\n    target = target();\n  } // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-ui/issues/260\n\n\n  if (isFunction(limiter)) {\n    limiter = limiter();\n  }\n\n  var positionedElementAncestor = getPositionedAncestor(element);\n  var elementRect = new Rect(element);\n  var targetRect = new Rect(target);\n  var bestPosition; // @if CK_DEBUG_POSITION // RectDrawer.clear();\n  // @if CK_DEBUG_POSITION // RectDrawer.draw( targetRect, { outlineWidth: '5px' }, 'Target' );\n\n  var positionOptions = {\n    targetRect: targetRect,\n    elementRect: elementRect,\n    positionedElementAncestor: positionedElementAncestor\n  }; // If there are no limits, just grab the very first position and be done with that drama.\n\n  if (!limiter && !fitInViewport) {\n    bestPosition = new Position(positions[0], positionOptions);\n  } else {\n    var limiterRect = limiter && new Rect(limiter).getVisible();\n    var viewportRect = fitInViewport && getConstrainedViewportRect(viewportOffsetConfig); // @if CK_DEBUG_POSITION // if ( viewportRect ) {\n    // @if CK_DEBUG_POSITION //\t\tRectDrawer.draw( viewportRect, { outlineWidth: '5px' }, 'Viewport' );\n    // @if CK_DEBUG_POSITION // }\n    // @if CK_DEBUG_POSITION // if ( limiter ) {\n    // @if CK_DEBUG_POSITION // \tRectDrawer.draw( limiterRect, { outlineWidth: '5px', outlineColor: 'green' }, 'Visible limiter' );\n    // @if CK_DEBUG_POSITION // }\n\n    Object.assign(positionOptions, {\n      limiterRect: limiterRect,\n      viewportRect: viewportRect\n    }); // If there's no best position found, i.e. when all intersections have no area because\n    // rects have no width or height, then just use the first available position.\n\n    bestPosition = getBestPosition(positions, positionOptions) || new Position(positions[0], positionOptions);\n  }\n\n  return bestPosition;\n} // Returns a viewport `Rect` shrunk by the viewport offset config from all sides.\n//\n// @private\n// @param {Object} An object containing viewportOffset config.\n// @returns {utils/dom/rect~Rect} A shrunken rect of the viewport.\n\nfunction getConstrainedViewportRect(viewportOffsetConfig) {\n  viewportOffsetConfig = Object.assign({\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  }, viewportOffsetConfig);\n  var viewportRect = new Rect(global.window);\n  viewportRect.top += viewportOffsetConfig.top;\n  viewportRect.height -= viewportOffsetConfig.top;\n  viewportRect.bottom -= viewportOffsetConfig.bottom;\n  viewportRect.height -= viewportOffsetConfig.bottom;\n  return viewportRect;\n} // For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {Object} options\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position}to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned\n// {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the {@link module:utils/dom/position~Options#viewport}.\n//\n// @returns {Array} An array containing the name of the position and it's rect.\n\n\nfunction getBestPosition(positions, options) {\n  var elementRect = options.elementRect; // This is when element is fully visible.\n\n  var elementRectArea = elementRect.getArea();\n  var positionInstances = positions.map(function (positioningFunction) {\n    return new Position(positioningFunction, options);\n  }) // Some positioning functions may return `null` if they don't want to participate.\n  .filter(function (position) {\n    return !!position.name;\n  });\n  var maxFitFactor = 0;\n  var bestPosition = null;\n\n  var _iterator = _createForOfIteratorHelper(positionInstances),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var position = _step.value;\n      var _limiterIntersectionArea = position._limiterIntersectionArea,\n          _viewportIntersectionArea = position._viewportIntersectionArea; // If a such position is found that element is fully contained by the limiter then, obviously,\n      // there will be no better one, so finishing.\n\n      if (_limiterIntersectionArea === elementRectArea) {\n        return position;\n      } // To maximize both viewport and limiter intersection areas we use distance on _viewportIntersectionArea\n      // and _limiterIntersectionArea plane (without sqrt because we are looking for max value).\n\n\n      var fitFactor = Math.pow(_viewportIntersectionArea, 2) + Math.pow(_limiterIntersectionArea, 2);\n\n      if (fitFactor > maxFitFactor) {\n        maxFitFactor = fitFactor;\n        bestPosition = position;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return bestPosition;\n} // For a given absolute Rect coordinates object and a positioned element ancestor, it returns an object with\n// new Rect coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in real–life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {utils/dom/rect~Rect} rect A rect with absolute rect coordinates.\n// @param {Number} rect.top\n// @param {Number} rect.left\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\n//\n// @returns {utils/dom/rect~Rect} A rect corresponding to `absoluteRect` input but with values shifted\n// to make up for the positioned element ancestor.\n\n\nfunction shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {\n  var ancestorPosition = getRectForAbsolutePositioning(new Rect(positionedElementAncestor));\n  var ancestorBorderWidths = getBorderWidths(positionedElementAncestor);\n  var moveX = 0;\n  var moveY = 0; // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n  // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n  // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n  // with respect to that positioned ancestor.\n\n  moveX -= ancestorPosition.left;\n  moveY -= ancestorPosition.top; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, not only its position must be taken into\n  // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n  // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n  // must compensate that scrolling.\n\n  moveX += positionedElementAncestor.scrollLeft;\n  moveY += positionedElementAncestor.scrollTop; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n  // while `position: absolute` positioning does not consider it.\n  // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n  // not upper-left corner of its border.\n\n  moveX -= ancestorBorderWidths.left;\n  moveY -= ancestorBorderWidths.top;\n  rect.moveBy(moveX, moveY);\n} // DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\n\n\nfunction getRectForAbsolutePositioning(rect) {\n  var _global$window = global.window,\n      scrollX = _global$window.scrollX,\n      scrollY = _global$window.scrollY;\n  return rect.clone().moveBy(scrollX, scrollY);\n}\n/**\n * A position class which instances are created and used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n *\n * {@link module:utils/dom/position~Position#top} and {@link module:utils/dom/position~Position#left} properties of the position instance\n * translate directly to the `top` and `left` properties in CSS \"`position: absolute` coordinate system\". If set on the positioned element\n * in DOM, they will make it display it in the right place in the viewport.\n */\n\n\nexport var Position = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the {@link module:utils/dom/position~Position} class.\n   *\n   * @param {module:utils/dom/position~positioningFunction} [positioningFunction] function The function that defines the expected\n   * coordinates the positioned element should move to.\n   * @param {Object} [options] options object.\n   * @param {module:utils/dom/rect~Rect} options.elementRect The positioned element rect.\n   * @param {module:utils/dom/rect~Rect} options.targetRect The target element rect.\n   * @param {module:utils/dom/rect~Rect} options.viewportRect The viewport rect.\n   * @param {HTMLElement|null} [options.positionedElementAncestor] Nearest element ancestor element which CSS position is not \"static\".\n   */\n  function Position(positioningFunction, options) {\n    _classCallCheck(this, Position);\n\n    var positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect); // Nameless position for a function that didn't participate.\n\n    if (!positioningFunctionOutput) {\n      return;\n    }\n\n    var left = positioningFunctionOutput.left,\n        top = positioningFunctionOutput.top,\n        name = positioningFunctionOutput.name,\n        config = positioningFunctionOutput.config;\n    Object.assign(this, {\n      name: name,\n      config: config\n    });\n    this._positioningFunctionCorrdinates = {\n      left: left,\n      top: top\n    };\n    this._options = options;\n    /**\n     * Position name.\n     *\n     * @readonly\n     * @member {String} #name\n     */\n\n    /**\n     * Additional position configuration, as passed from the {@link module:utils/dom/position~positioningFunction positioning function}.\n     *\n     * This object can be use, for instance, to pass through presentation options used by the consumer of the\n     * {@link module:utils/dom/position~getOptimalPosition} helper.\n     *\n     * @readonly\n     * @member {Object} #config\n     */\n  }\n  /**\n   * The left value in pixels in the CSS `position: absolute` coordinate system.\n   * Set it on the positioned element in DOM to move it to the position.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  _createClass(Position, [{\n    key: \"left\",\n    get: function get() {\n      return this._absoluteRect.left;\n    }\n    /**\n     * The top value in pixels in the CSS `position: absolute` coordinate system.\n     * Set it on the positioned element in DOM to move it to the position.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._absoluteRect.top;\n    }\n    /**\n     * An intersection area between positioned element and limiter within viewport constraints.\n     *\n     * @readonly\n     * @private\n     * @type {Number}\n     */\n\n  }, {\n    key: \"_limiterIntersectionArea\",\n    get: function get() {\n      var limiterRect = this._options.limiterRect;\n\n      if (limiterRect) {\n        var viewportRect = this._options.viewportRect;\n\n        if (viewportRect) {\n          // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n          var limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n\n          if (limiterViewportIntersectRect) {\n            // If the limiter is within the viewport, then check the intersection between that part of the\n            // limiter and actual position.\n            return limiterViewportIntersectRect.getIntersectionArea(this._rect);\n          }\n        } else {\n          return limiterRect.getIntersectionArea(this._rect);\n        }\n      }\n\n      return 0;\n    }\n    /**\n     * An intersection area between positioned element and viewport.\n     *\n     * @readonly\n     * @private\n     * @type {Number}\n     */\n\n  }, {\n    key: \"_viewportIntersectionArea\",\n    get: function get() {\n      var viewportRect = this._options.viewportRect;\n\n      if (viewportRect) {\n        return viewportRect.getIntersectionArea(this._rect);\n      }\n\n      return 0;\n    }\n    /**\n     * An already positioned element rect. A clone of the element rect passed to the constructor\n     * but placed in the viewport according to the positioning function.\n     *\n     * @private\n     * @type {module:utils/dom/rect~Rect}\n     */\n\n  }, {\n    key: \"_rect\",\n    get: function get() {\n      if (this._cachedRect) {\n        return this._cachedRect;\n      }\n\n      this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top);\n      return this._cachedRect;\n    }\n    /**\n     * An already absolutely positioned element rect. See ({@link #_rect}).\n     *\n     * @private\n     * @type {module:utils/dom/rect~Rect}\n     */\n\n  }, {\n    key: \"_absoluteRect\",\n    get: function get() {\n      if (this._cachedAbsoluteRect) {\n        return this._cachedAbsoluteRect;\n      }\n\n      this._cachedAbsoluteRect = getRectForAbsolutePositioning(this._rect);\n\n      if (this._options.positionedElementAncestor) {\n        shiftRectToCompensatePositionedAncestor(this._cachedAbsoluteRect, this._options.positionedElementAncestor);\n      }\n\n      return this._cachedAbsoluteRect;\n    }\n  }]);\n\n  return Position;\n}();\n/**\n * The `getOptimalPosition()` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #target\n */\n\n/**\n * An array of positioning functions.\n *\n * **Note**: Positioning functions are processed in the order of preference. The first function that works\n * in the current environment (e.g. offers the complete fit in the viewport geometry) will be picked by\n * `getOptimalPosition()`.\n *\n * **Note**: Any positioning function returning `null` is ignored.\n *\n * @member {Array.<module:utils/dom/position~positioningFunction>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * Viewport offset config object. It restricts the visible viewport available to the `getOptimalPosition()` from each side.\n *\n *\t\t{\n *\t\t\ttop: 50,\n *\t\t\tright: 50,\n *\t\t\tbottom: 50,\n *\t\t\tleft: 50\n *\t\t}\n *\n * @member {Object} #viewportOffsetConfig\n */\n\n/**\n * A positioning function which, based on positioned element and target {@link module:utils/dom/rect~Rect Rects}, returns rect coordinates\n * representing the geometrical relation between them. Used by the {@link module:utils/dom/position~getOptimalPosition} helper.\n *\n *\t\t// This simple position will place the element directly under the target, in the middle:\n *\t\t//\n *\t\t//\t    [ Target ]\n *\t\t//\t+-----------------+\n *\t\t//\t|     Element     |\n *\t\t//\t+-----------------+\n *\t\t//\n *\t\tconst position = ( targetRect, elementRect, [ viewportRect ] ) => ( {\n *\t\t\ttop: targetRect.bottom,\n *\t\t\tleft: targetRect.left + targetRect.width / 2 - elementRect.width / 2,\n *\t\t\tname: 'bottomMiddle',\n *\n *\t\t\t// Note: The config is optional.\n *\t\t\tconfig: {\n *\t\t\t\tzIndex: '999'\n *\t\t\t}\n *\t\t} );\n *\n * @callback module:utils/dom/position~positioningFunction\n * @param {module:utils/dom/rect~Rect} elementRect The rect of the element to be positioned.\n * @param {module:utils/dom/rect~Rect} targetRect The rect of the target the element (its rect) is relatively positioned to.\n * @param {module:utils/dom/rect~Rect} viewportRect The rect of the visual browser viewport.\n * @returns {Object|null} return When the function returns `null`, it will not be considered by\n * {@link module:utils/dom/position~getOptimalPosition}.\n * @returns {Number} return.top The `top` value of the element rect that would represent the position.\n * @returns {Number} return.left The `left` value of the element rect that would represent the position.\n * @returns {Number} return.name The name of the position. It helps the user of the {@link module:utils/dom/position~getOptimalPosition}\n * helper to recognize different positioning function results. It will pass through to the {@link module:utils/dom/position~Position}\n * returned by the helper.\n * @returns {Number} [return.config] An optional configuration that will pass-through the\n * {@link module:utils/dom/position~getOptimalPosition} helper to the {@link module:utils/dom/position~Position} returned by this helper.\n * This configuration may, for instance, let the user of {@link module:utils/dom/position~getOptimalPosition} know that this particular\n * position comes with a certain presentation.\n */","map":null,"metadata":{},"sourceType":"module"}