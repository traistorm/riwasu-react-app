{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/model/documentfragment\n */\nimport NodeList from './nodelist';\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable'; // @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n\n/**\n * DocumentFragment represents a part of model which does not have a common root but its top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\n\nvar DocumentFragment = /*#__PURE__*/function () {\n  /**\n   * Creates an empty `DocumentFragment`.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n   *\n   * @protected\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * Nodes to be contained inside the `DocumentFragment`.\n   */\n  function DocumentFragment(children) {\n    _classCallCheck(this, DocumentFragment);\n\n    /**\n     * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n     * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n     * when DocumentFragment will be inserted to the document.\n     *\n     * @readonly\n     * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n     */\n    this.markers = new Map();\n    /**\n     * List of nodes contained inside the document fragment.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n     */\n\n    this._children = new NodeList();\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Returns an iterator that iterates over all nodes contained inside this document fragment.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n\n\n  _createClass(DocumentFragment, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this.getChildren();\n    }\n    /**\n     * Number of this document fragment's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"is\",\n\n    /**\n     * Checks whether this object is of the given type.\n     *\n     *\t\tdocFrag.is( 'documentFragment' ); // -> true\n     *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n     *\n     *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n     *\t\tdocFrag.is( 'element' ); // -> false\n     *\t\tdocFrag.is( 'node' ); // -> false\n     *\n     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n    value: function is(type) {\n      return type === 'documentFragment' || type === 'model:documentFragment';\n    }\n    /**\n     * Gets the child at the given index. Returns `null` if incorrect index was passed.\n     *\n     * @param {Number} index Index of child.\n     * @returns {module:engine/model/node~Node|null} Child node.\n     */\n\n  }, {\n    key: \"getChild\",\n    value: function getChild(index) {\n      return this._children.getNode(index);\n    }\n    /**\n     * Returns an iterator that iterates over all of this document fragment's children.\n     *\n     * @returns {Iterable.<module:engine/model/node~Node>}\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this._children[Symbol.iterator]();\n    }\n    /**\n     * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's index.\n     */\n\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(node) {\n      return this._children.getNodeIndex(node);\n    }\n    /**\n     * Returns the starting offset of given child. Starting offset is equal to the sum of\n     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n     * given node is not a child of this document fragment.\n     *\n     * @param {module:engine/model/node~Node} node Child node to look for.\n     * @returns {Number|null} Child node's starting offset.\n     */\n\n  }, {\n    key: \"getChildStartOffset\",\n    value: function getChildStartOffset(node) {\n      return this._children.getNodeStartOffset(node);\n    }\n    /**\n     * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      return [];\n    }\n    /**\n     * Returns a descendant node by its path relative to this element.\n     *\n     *\t\t// <this>a<b>c</b></this>\n     *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n     *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n     *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n     *\n     * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n     * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"getNodeByPath\",\n    value: function getNodeByPath(relativePath) {\n      var node = this; // eslint-disable-line consistent-this\n\n      var _iterator = _createForOfIteratorHelper(relativePath),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n          node = node.getChild(node.offsetToIndex(index));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return node;\n    }\n    /**\n     * Converts offset \"position\" to index \"position\".\n     *\n     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n     * too high, returns index after last child}.\n     *\n     *\t\tconst textNode = new Text( 'foo' );\n     *\t\tconst pElement = new Element( 'p' );\n     *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n     *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n     *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n     *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n     *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n     *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n     *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n     *\n     * @param {Number} offset Offset to look for.\n     * @returns {Number} Index of a node that occupies given offset.\n     */\n\n  }, {\n    key: \"offsetToIndex\",\n    value: function offsetToIndex(offset) {\n      return this._children.offsetToIndex(offset);\n    }\n    /**\n     * Converts `DocumentFragment` instance to plain object and returns it.\n     * Takes care of converting all of this document fragment's children.\n     *\n     * @returns {Object} `DocumentFragment` instance converted to plain object.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = [];\n\n      var _iterator2 = _createForOfIteratorHelper(this._children),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var node = _step2.value;\n          json.push(node.toJSON());\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return json;\n    }\n    /**\n     * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n     * Converts `DocumentFragment` children to proper nodes.\n     *\n     * @param {Object} json Plain object to be converted to `DocumentFragment`.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n     */\n\n  }, {\n    key: \"_appendChild\",\n\n    /**\n     * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n     *\n     * @protected\n     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n     */\n    value: function _appendChild(items) {\n      this._insertChild(this.childCount, items);\n    }\n    /**\n     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n     * to this document fragment.\n     *\n     * @protected\n     * @param {Number} index Index at which nodes should be inserted.\n     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n     */\n\n  }, {\n    key: \"_insertChild\",\n    value: function _insertChild(index, items) {\n      var nodes = normalize(items);\n\n      var _iterator3 = _createForOfIteratorHelper(nodes),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var node = _step3.value;\n\n          // If node that is being added to this element is already inside another element, first remove it from the old parent.\n          if (node.parent !== null) {\n            node._remove();\n          }\n\n          node.parent = this;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._children._insertNodes(index, nodes);\n    }\n    /**\n     * Removes one or more nodes starting at the given index\n     * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n     *\n     * @protected\n     * @param {Number} index Index of the first node to remove.\n     * @param {Number} [howMany=1] Number of nodes to remove.\n     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n     */\n\n  }, {\n    key: \"_removeChildren\",\n    value: function _removeChildren(index) {\n      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var nodes = this._children._removeNodes(index, howMany);\n\n      var _iterator4 = _createForOfIteratorHelper(nodes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var node = _step4.value;\n          node.parent = null;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return nodes;\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \treturn 'documentFragment';\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // log() {\n    // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelDocumentFragment: ' + this );\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // printTree() {\n    // @if CK_DEBUG_ENGINE //\tlet string = 'ModelDocumentFragment: [';\n    // @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n    // @if CK_DEBUG_ENGINE //\t\tstring += '\\n';\n    // @if CK_DEBUG_ENGINE //\t\tif ( child.is( '$text' ) ) {\n    // @if CK_DEBUG_ENGINE //\t\t\tconst textAttrs = stringifyMap( child._attrs );\n    // @if CK_DEBUG_ENGINE //\t\t\tstring += '\\t'.repeat( 1 );\n    // @if CK_DEBUG_ENGINE //\t\t\tif ( textAttrs !== '' ) {\n    // @if CK_DEBUG_ENGINE //\t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n    // @if CK_DEBUG_ENGINE //\t\t\t} else {\n    // @if CK_DEBUG_ENGINE //\t\t\t\tstring += child.data;\n    // @if CK_DEBUG_ENGINE //\t\t\t}\n    // @if CK_DEBUG_ENGINE //\t\t} else {\n    // @if CK_DEBUG_ENGINE //\t\t\tstring += child.printTree( 1 );\n    // @if CK_DEBUG_ENGINE //\t\t}\n    // @if CK_DEBUG_ENGINE //\t}\n    // @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n    // @if CK_DEBUG_ENGINE //\treturn string;\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // logTree() {\n    // @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n    // @if CK_DEBUG_ENGINE // }\n\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this._children.length;\n    }\n    /**\n     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"maxOffset\",\n    get: function get() {\n      return this._children.maxOffset;\n    }\n    /**\n     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.childCount === 0;\n    }\n    /**\n     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this;\n    }\n    /**\n     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n     *\n     * @readonly\n     * @type {null}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return null;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var children = [];\n\n      var _iterator5 = _createForOfIteratorHelper(json),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n\n          if (child.name) {\n            // If child has name property, it is an Element.\n            children.push(Element.fromJSON(child));\n          } else {\n            // Otherwise, it is a Text node.\n            children.push(Text.fromJSON(child));\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return new DocumentFragment(children);\n    }\n  }]);\n\n  return DocumentFragment;\n}(); // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\n\n\nexport { DocumentFragment as default };\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(function (node) {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n\n    return node;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}