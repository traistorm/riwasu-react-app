{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\n\nvar Position = /*#__PURE__*/function () {\n  /**\n   * Creates a position.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   */\n  function Position(root, path) {\n    var stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n\n    _classCallCheck(this, Position);\n\n    if (!root.is('element') && !root.is('documentFragment')) {\n      /**\n       * Position root is invalid.\n       *\n       * Positions can only be anchored in elements or document fragments.\n       *\n       * @error model-position-root-invalid\n       */\n      throw new CKEditorError('model-position-root-invalid', root);\n    }\n\n    if (!(path instanceof Array) || path.length === 0) {\n      /**\n       * Position path must be an array with at least one item.\n       *\n       * @error model-position-path-incorrect-format\n       * @param path\n       */\n      throw new CKEditorError('model-position-path-incorrect-format', root, {\n        path: path\n      });\n    } // Normalize the root and path when element (not root) is passed.\n\n\n    if (root.is('rootElement')) {\n      path = path.slice();\n    } else {\n      path = [].concat(_toConsumableArray(root.getPath()), _toConsumableArray(path));\n      root = root.root;\n    }\n    /**\n     * Root of the position path.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/position~Position#root\n     */\n\n\n    this.root = root;\n    /**\n     * Position of the node in the tree. **Path contains offsets, not indexes.**\n     *\n     * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n     * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n     * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n     * down to the position offset in it's parent.\n     *\n     *\t\t ROOT\n     *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n     *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n     *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n     *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n     *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n     *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n     *\n     * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n     * greater than `1` you can place position offset between their start and end:\n     *\n     *\t\t ROOT\n     *\t\t  |- P\n     *\t\t  |- UL\n     *\t\t     |- LI\n     *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n     *\t\t     |- LI\n     *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n     *\n     * @readonly\n     * @member {Array.<Number>} module:engine/model/position~Position#path\n     */\n\n    this.path = path;\n    /**\n     * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n     *\n     * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n     */\n\n    this.stickiness = stickiness;\n  }\n  /**\n   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n   * to the last item in position {@link module:engine/model/position~Position#path path}.\n   *\n   * @type {Number}\n   */\n\n\n  _createClass(Position, [{\n    key: \"compareWith\",\n\n    /**\n     * Checks whether this position is before or after given position.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {module:engine/model/position~PositionRelation}\n     */\n    value: function compareWith(otherPosition) {\n      if (this.root != otherPosition.root) {\n        return 'different';\n      }\n\n      var result = compareArrays(this.path, otherPosition.path);\n\n      switch (result) {\n        case 'same':\n          return 'same';\n\n        case 'prefix':\n          return 'before';\n\n        case 'extension':\n          return 'after';\n\n        default:\n          return this.path[result] < otherPosition.path[result] ? 'before' : 'after';\n      }\n    }\n    /**\n     * Gets the farthest position which matches the callback using\n     * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n     *\n     * For example:\n     *\n     * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n     * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n     *\n     * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n     * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n     *\n     * \t\tgetLastMatchingPosition( value => false );\n     * \t\t// Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     *\n     * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n     */\n\n  }, {\n    key: \"getLastMatchingPosition\",\n    value: function getLastMatchingPosition(skip) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options.startPosition = this;\n      var treeWalker = new TreeWalker(options);\n      treeWalker.skip(skip);\n      return treeWalker.position;\n    }\n    /**\n     * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n     * but without the last item.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @returns {Array.<Number>} Path to the parent.\n     */\n\n  }, {\n    key: \"getParentPath\",\n    value: function getParentPath() {\n      return this.path.slice(0, -1);\n    }\n    /**\n     * Returns ancestors array of this position, that is this position's parent and its ancestors.\n     *\n     * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n     */\n\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors() {\n      var parent = this.parent;\n\n      if (parent.is('documentFragment')) {\n        return [parent];\n      } else {\n        return parent.getAncestors({\n          includeSelf: true\n        });\n      }\n    }\n    /**\n     * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.\n     *\n     * @param {String} parentName The name of the parent element to find.\n     * @returns {module:engine/model/element~Element|null}\n     */\n\n  }, {\n    key: \"findAncestor\",\n    value: function findAncestor(parentName) {\n      var parent = this.parent;\n\n      if (parent.is('element')) {\n        return parent.findAncestor(parentName, {\n          includeSelf: true\n        });\n      }\n\n      return null;\n    }\n    /**\n     * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n     * of these two paths must be identical.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} position The second position.\n     * @returns {Array.<Number>} The common path.\n     */\n\n  }, {\n    key: \"getCommonPath\",\n    value: function getCommonPath(position) {\n      if (this.root != position.root) {\n        return [];\n      } // We find on which tree-level start and end have the lowest common ancestor\n\n\n      var cmp = compareArrays(this.path, position.path); // If comparison returned string it means that arrays are same.\n\n      var diffAt = typeof cmp == 'string' ? Math.min(this.path.length, position.path.length) : cmp;\n      return this.path.slice(0, diffAt);\n    }\n    /**\n     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n     * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n     *\n     * @param {module:engine/model/position~Position} position The second position.\n     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor(position) {\n      var ancestorsA = this.getAncestors();\n      var ancestorsB = position.getAncestors();\n      var i = 0;\n\n      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n        i++;\n      }\n\n      return i === 0 ? null : ancestorsA[i - 1];\n    }\n    /**\n     * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n     * is shifted by `shift` value (can be a negative value).\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {Number} shift Offset shift. Can be a negative value.\n     * @returns {module:engine/model/position~Position} Shifted position.\n     */\n\n  }, {\n    key: \"getShiftedBy\",\n    value: function getShiftedBy(shift) {\n      var shifted = this.clone();\n      var offset = shifted.offset + shift;\n      shifted.offset = offset < 0 ? 0 : offset;\n      return shifted;\n    }\n    /**\n     * Checks whether this position is after given position.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @see module:engine/model/position~Position#isBefore\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if this position is after given position.\n     */\n\n  }, {\n    key: \"isAfter\",\n    value: function isAfter(otherPosition) {\n      return this.compareWith(otherPosition) == 'after';\n    }\n    /**\n     * Checks whether this position is before given position.\n     *\n     * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n     * be `true` if positions are in different roots and you might not expect this. You should probably use\n     * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n     * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n     *\n     *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n     *\t\t\t// do A.\n     *\t\t} else {\n     *\t\t\t// do B.\n     *\t\t}\n     *\n     * or, if you have only one if-branch:\n     *\n     *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n     *\t\t\t// do B.\n     *\t\t}\n     *\n     * rather than:\n     *\n     *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n     *\t\t\t// do B.\n     *\t\t} else {\n     *\t\t\t// do A.\n     *\t\t}\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if this position is before given position.\n     */\n\n  }, {\n    key: \"isBefore\",\n    value: function isBefore(otherPosition) {\n      return this.compareWith(otherPosition) == 'before';\n    }\n    /**\n     * Checks whether this position is equal to given position.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if positions are same.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(otherPosition) {\n      return this.compareWith(otherPosition) == 'same';\n    }\n    /**\n     * Checks whether this position is touching given position. Positions touch when there are no text nodes\n     * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n     * they are very similar or even indistinguishable.\n     *\n     * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n     * @returns {Boolean} True if positions touch.\n     */\n\n  }, {\n    key: \"isTouching\",\n    value: function isTouching(otherPosition) {\n      var left = null;\n      var right = null;\n      var compare = this.compareWith(otherPosition);\n\n      switch (compare) {\n        case 'same':\n          return true;\n\n        case 'before':\n          left = Position._createAt(this);\n          right = Position._createAt(otherPosition);\n          break;\n\n        case 'after':\n          left = Position._createAt(otherPosition);\n          right = Position._createAt(this);\n          break;\n\n        default:\n          return false;\n      } // Cached for optimization purposes.\n\n\n      var leftParent = left.parent;\n\n      while (left.path.length + right.path.length) {\n        if (left.isEqual(right)) {\n          return true;\n        }\n\n        if (left.path.length > right.path.length) {\n          if (left.offset !== leftParent.maxOffset) {\n            return false;\n          }\n\n          left.path = left.path.slice(0, -1);\n          leftParent = leftParent.parent;\n          left.offset++;\n        } else {\n          if (right.offset !== 0) {\n            return false;\n          }\n\n          right.path = right.path.slice(0, -1);\n        }\n      }\n    }\n    /**\n     * Checks whether this object is of the given.\n     *\n     *\t\tposition.is( 'position' ); // -> true\n     *\t\tposition.is( 'model:position' ); // -> true\n     *\n     *\t\tposition.is( 'view:position' ); // -> false\n     *\t\tposition.is( 'documentSelection' ); // -> false\n     *\n     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type === 'position' || type === 'model:position';\n    }\n    /**\n     * Checks if two positions are in the same parent.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/position~Position} position Position to compare with.\n     * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n     */\n\n  }, {\n    key: \"hasSameParentAs\",\n    value: function hasSameParentAs(position) {\n      if (this.root !== position.root) {\n        return false;\n      }\n\n      var thisParentPath = this.getParentPath();\n      var posParentPath = position.getParentPath();\n      return compareArrays(thisParentPath, posParentPath) == 'same';\n    }\n    /**\n     * Returns a copy of this position that is transformed by given `operation`.\n     *\n     * The new position's parameters are updated accordingly to the effect of the `operation`.\n     *\n     * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n     * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n     *\n     * This method is safe to use it on non-existing positions (for example during operational transformation).\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n     * @returns {module:engine/model/position~Position} Transformed position.\n     */\n\n  }, {\n    key: \"getTransformedByOperation\",\n    value: function getTransformedByOperation(operation) {\n      var result;\n\n      switch (operation.type) {\n        case 'insert':\n          result = this._getTransformedByInsertOperation(operation);\n          break;\n\n        case 'move':\n        case 'remove':\n        case 'reinsert':\n          result = this._getTransformedByMoveOperation(operation);\n          break;\n\n        case 'split':\n          result = this._getTransformedBySplitOperation(operation);\n          break;\n\n        case 'merge':\n          result = this._getTransformedByMergeOperation(operation);\n          break;\n\n        default:\n          result = Position._createAt(this);\n          break;\n      }\n\n      return result;\n    }\n    /**\n     * Returns a copy of this position transformed by an insert operation.\n     *\n     * @protected\n     * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"_getTransformedByInsertOperation\",\n    value: function _getTransformedByInsertOperation(operation) {\n      return this._getTransformedByInsertion(operation.position, operation.howMany);\n    }\n    /**\n     * Returns a copy of this position transformed by a move operation.\n     *\n     * @protected\n     * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"_getTransformedByMoveOperation\",\n    value: function _getTransformedByMoveOperation(operation) {\n      return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);\n    }\n    /**\n     * Returns a copy of this position transformed by a split operation.\n     *\n     * @protected\n     * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"_getTransformedBySplitOperation\",\n    value: function _getTransformedBySplitOperation(operation) {\n      var movedRange = operation.movedRange;\n      var isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == 'toNext';\n\n      if (isContained) {\n        return this._getCombined(operation.splitPosition, operation.moveTargetPosition);\n      } else {\n        if (operation.graveyardPosition) {\n          return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);\n        } else {\n          return this._getTransformedByInsertion(operation.insertionPosition, 1);\n        }\n      }\n    }\n    /**\n     * Returns a copy of this position transformed by merge operation.\n     *\n     * @protected\n     * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"_getTransformedByMergeOperation\",\n    value: function _getTransformedByMergeOperation(operation) {\n      var movedRange = operation.movedRange;\n      var isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);\n      var pos;\n\n      if (isContained) {\n        pos = this._getCombined(operation.sourcePosition, operation.targetPosition);\n\n        if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n          // Above happens during OT when the merged element is moved before the merged-to element.\n          pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);\n        }\n      } else if (this.isEqual(operation.deletionPosition)) {\n        pos = Position._createAt(operation.deletionPosition);\n      } else {\n        pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);\n      }\n\n      return pos;\n    }\n    /**\n     * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n     * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n     * @param {Number} howMany How many nodes are removed.\n     * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n     */\n\n  }, {\n    key: \"_getTransformedByDeletion\",\n    value: function _getTransformedByDeletion(deletePosition, howMany) {\n      var transformed = Position._createAt(this); // This position can't be affected if deletion was in a different root.\n\n\n      if (this.root != deletePosition.root) {\n        return transformed;\n      }\n\n      if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {\n        // If nodes are removed from the node that is pointed by this position...\n        if (deletePosition.offset < this.offset) {\n          // And are removed from before an offset of that position...\n          if (deletePosition.offset + howMany > this.offset) {\n            // Position is in removed range, it's no longer in the tree.\n            return null;\n          } else {\n            // Decrement the offset accordingly.\n            transformed.offset -= howMany;\n          }\n        }\n      } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {\n        // If nodes are removed from a node that is on a path to this position...\n        var i = deletePosition.path.length - 1;\n\n        if (deletePosition.offset <= this.path[i]) {\n          // And are removed from before next node of that path...\n          if (deletePosition.offset + howMany > this.path[i]) {\n            // If the next node of that path is removed return null\n            // because the node containing this position got removed.\n            return null;\n          } else {\n            // Otherwise, decrement index on that path.\n            transformed.path[i] -= howMany;\n          }\n        }\n      }\n\n      return transformed;\n    }\n    /**\n     * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n     * @param {Number} howMany How many nodes are inserted.\n     * @returns {module:engine/model/position~Position} Transformed position.\n     */\n\n  }, {\n    key: \"_getTransformedByInsertion\",\n    value: function _getTransformedByInsertion(insertPosition, howMany) {\n      var transformed = Position._createAt(this); // This position can't be affected if insertion was in a different root.\n\n\n      if (this.root != insertPosition.root) {\n        return transformed;\n      }\n\n      if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {\n        // If nodes are inserted in the node that is pointed by this position...\n        if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != 'toPrevious') {\n          // And are inserted before an offset of that position...\n          // \"Push\" this positions offset.\n          transformed.offset += howMany;\n        }\n      } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {\n        // If nodes are inserted in a node that is on a path to this position...\n        var i = insertPosition.path.length - 1;\n\n        if (insertPosition.offset <= this.path[i]) {\n          // And are inserted before next node of that path...\n          // \"Push\" the index on that path.\n          transformed.path[i] += howMany;\n        }\n      }\n\n      return transformed;\n    }\n    /**\n     * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n     * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n     * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n     * @returns {module:engine/model/position~Position} Transformed position.\n     */\n\n  }, {\n    key: \"_getTransformedByMove\",\n    value: function _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n      // Update target position, as it could be affected by nodes removal.\n      targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n\n      if (sourcePosition.isEqual(targetPosition)) {\n        // If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n        return Position._createAt(this);\n      } // Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\n\n      var transformed = this._getTransformedByDeletion(sourcePosition, howMany);\n\n      var isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == 'toNext' || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == 'toPrevious';\n\n      if (isMoved) {\n        // This position is inside moved range (or sticks to it).\n        // In this case, we calculate a combination of this position, move source position and target position.\n        return this._getCombined(sourcePosition, targetPosition);\n      } else {\n        // This position is not inside a removed range.\n        //\n        // In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n        return transformed._getTransformedByInsertion(targetPosition, howMany);\n      }\n    }\n    /**\n     * Returns a new position that is a combination of this position and given positions.\n     *\n     * The combined position is a copy of this position transformed by moving a range starting at `source` position\n     * to the `target` position. It is expected that this position is inside the moved range.\n     *\n     * Example:\n     *\n     *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n     *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n     *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n     *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n     *\n     * Explanation:\n     *\n     * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n     * was inside moved nodes and now should point to the new place. The moved nodes will be after\n     * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n     * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n     * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n     * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} source Beginning of the moved range.\n     * @param {module:engine/model/position~Position} target Position where the range is moved.\n     * @returns {module:engine/model/position~Position} Combined position.\n     */\n\n  }, {\n    key: \"_getCombined\",\n    value: function _getCombined(source, target) {\n      var i = source.path.length - 1; // The first part of a path to combined position is a path to the place where nodes were moved.\n\n      var combined = Position._createAt(target);\n\n      combined.stickiness = this.stickiness; // Then we have to update the rest of the path.\n      // Fix the offset because this position might be after `from` position and we have to reflect that.\n\n      combined.offset = combined.offset + this.path[i] - source.offset; // Then, add the rest of the path.\n      // If this position is at the same level as `from` position nothing will get added.\n\n      combined.path = [].concat(_toConsumableArray(combined.path), _toConsumableArray(this.path.slice(i + 1)));\n      return combined;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        root: this.root.toJSON(),\n        path: Array.from(this.path),\n        stickiness: this.stickiness\n      };\n    }\n    /**\n     * Returns a new position that is equal to current position.\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.root, this.path, this.stickiness);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/model/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n     *\n     * This method is a shortcut to other factory methods such as:\n     *\n     * * {@link module:engine/model/position~Position._createBefore},\n     * * {@link module:engine/model/position~Position._createAfter}.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n     * first parameter is a {@link module:engine/model/item~Item model item}.\n     * @protected\n     */\n\n  }, {\n    key: \"offset\",\n    get: function get() {\n      return this.path[this.path.length - 1];\n    },\n    set: function set(newOffset) {\n      this.path[this.path.length - 1] = newOffset;\n    }\n    /**\n     * Parent element of this position.\n     *\n     * Keep in mind that `parent` value is calculated when the property is accessed.\n     * If {@link module:engine/model/position~Position#path position path}\n     * leads to a non-existing element, `parent` property will throw error.\n     *\n     * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n     *\n     * @readonly\n     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      var parent = this.root;\n\n      for (var i = 0; i < this.path.length - 1; i++) {\n        parent = parent.getChild(parent.offsetToIndex(this.path[i]));\n\n        if (!parent) {\n          /**\n           * The position's path is incorrect. This means that a position does not point to\n           * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n           *\n           * **Note**: Unlike DOM and view positions, in the model, the\n           * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n           * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element\n           * where this position points.\n           *\n           * Read more about model positions and offsets in\n           * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n           *\n           * @error model-position-path-incorrect\n           * @param {module:engine/model/position~Position} position The incorrect position.\n           */\n          throw new CKEditorError('model-position-path-incorrect', this, {\n            position: this\n          });\n        }\n      }\n\n      if (parent.is('$text')) {\n        throw new CKEditorError('model-position-path-incorrect', this, {\n          position: this\n        });\n      }\n\n      return parent;\n    }\n    /**\n     * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n     * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n     * in text node, position index is equal to the index of that text node.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.parent.offsetToIndex(this.offset);\n    }\n    /**\n     * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n     * position is not in a text node.\n     *\n     * @readonly\n     * @type {module:engine/model/text~Text|null}\n     */\n\n  }, {\n    key: \"textNode\",\n    get: function get() {\n      return getTextNodeAtPosition(this, this.parent);\n    }\n    /**\n     * Node directly after this position or `null` if this position is in text node.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|null}\n     */\n\n  }, {\n    key: \"nodeAfter\",\n    get: function get() {\n      // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n      var parent = this.parent;\n      return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));\n    }\n    /**\n     * Node directly before this position or `null` if this position is in text node.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|null}\n     */\n\n  }, {\n    key: \"nodeBefore\",\n    get: function get() {\n      // Cache the parent and reuse for performance reasons. See #6579 and #6582.\n      var parent = this.parent;\n      return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));\n    }\n    /**\n     * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isAtStart\",\n    get: function get() {\n      return this.offset === 0;\n    }\n    /**\n     * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n     *\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isAtEnd\",\n    get: function get() {\n      return this.offset == this.parent.maxOffset;\n    }\n  }], [{\n    key: \"_createAt\",\n    value: function _createAt(itemOrPosition, offset) {\n      var stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';\n\n      if (itemOrPosition instanceof Position) {\n        return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);\n      } else {\n        var node = itemOrPosition;\n\n        if (offset == 'end') {\n          offset = node.maxOffset;\n        } else if (offset == 'before') {\n          return this._createBefore(node, stickiness);\n        } else if (offset == 'after') {\n          return this._createAfter(node, stickiness);\n        } else if (offset !== 0 && !offset) {\n          /**\n           * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n           * requires the offset to be specified when the first parameter is a model item.\n           *\n           * @error model-createpositionat-offset-required\n           */\n          throw new CKEditorError('model-createpositionat-offset-required', [this, itemOrPosition]);\n        }\n\n        if (!node.is('element') && !node.is('documentFragment')) {\n          /**\n           * Position parent have to be a model element or model document fragment.\n           *\n           * @error model-position-parent-incorrect\n           */\n          throw new CKEditorError('model-position-parent-incorrect', [this, itemOrPosition]);\n        }\n\n        var path = node.getPath();\n        path.push(offset);\n        return new this(node.root, path, stickiness);\n      }\n    }\n    /**\n     * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n     *\n     * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * @returns {module:engine/model/position~Position}\n     * @protected\n     */\n\n  }, {\n    key: \"_createAfter\",\n    value: function _createAfter(item, stickiness) {\n      if (!item.parent) {\n        /**\n         * You can not make a position after a root element.\n         *\n         * @error model-position-after-root\n         * @param {module:engine/model/item~Item} root\n         */\n        throw new CKEditorError('model-position-after-root', [this, item], {\n          root: item\n        });\n      }\n\n      return this._createAt(item.parent, item.endOffset, stickiness);\n    }\n    /**\n     * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n     *\n     * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n     * @returns {module:engine/model/position~Position}\n     * @protected\n     */\n\n  }, {\n    key: \"_createBefore\",\n    value: function _createBefore(item, stickiness) {\n      if (!item.parent) {\n        /**\n         * You can not make a position before a root element.\n         *\n         * @error model-position-before-root\n         * @param {module:engine/model/item~Item} root\n         */\n        throw new CKEditorError('model-position-before-root', item, {\n          root: item\n        });\n      }\n\n      return this._createAt(item.parent, item.startOffset, stickiness);\n    }\n    /**\n     * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n     *\n     * @param {Object} json Plain object to be converted to `Position`.\n     * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n     * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json, doc) {\n      if (json.root === '$graveyard') {\n        var pos = new Position(doc.graveyard, json.path);\n        pos.stickiness = json.stickiness;\n        return pos;\n      }\n\n      if (!doc.getRoot(json.root)) {\n        /**\n         * Cannot create position for document. Root with specified name does not exist.\n         *\n         * @error model-position-fromjson-no-root\n         * @param {String} rootName\n         */\n        throw new CKEditorError('model-position-fromjson-no-root', doc, {\n          rootName: json.root\n        });\n      }\n\n      return new Position(doc.getRoot(json.root), json.path, json.stickiness);\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.path.join( ', ' ) } ]`;\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // log() {\n    // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n    // @if CK_DEBUG_ENGINE // }\n\n  }]);\n\n  return Position;\n}();\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n\n/**\n * Returns a text node at the given position.\n *\n * This is a helper function optimized to reuse the position parent instance for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}\n * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getNodeAfterPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @returns {module:engine/model/text~Text|null}\n */\n\n\nexport { Position as default };\nexport function getTextNodeAtPosition(position, positionParent) {\n  var node = positionParent.getChild(positionParent.offsetToIndex(position.offset));\n\n  if (node && node.is('$text') && node.startOffset < position.offset) {\n    return node;\n  }\n\n  return null;\n}\n/**\n * Returns the node after the given position.\n *\n * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the\n * specific position for performance reasons.\n *\n * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.\n * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or\n * {@link module:engine/model/position~Position#textNode `Position#textNode`}\n * check if your algorithm does not access those properties multiple times\n * (which can happen directly or indirectly via other position properties).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeBeforePosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\n\nexport function getNodeAfterPosition(position, positionParent, textNode) {\n  if (textNode !== null) {\n    return null;\n  }\n\n  return positionParent.getChild(positionParent.offsetToIndex(position.offset));\n}\n/**\n * Returns the node before the given position.\n *\n * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.\n *\n * See also:\n *\n * * {@link module:engine/model/position~getTextNodeAtPosition}\n * * {@link module:engine/model/position~getNodeAfterPosition}\n *\n * @param {module:engine/model/position~Position} position\n * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the\n * given position.\n * @param {module:engine/model/text~Text|null} textNode Text node at the given position.\n * @returns {module:engine/model/node~Node|null}\n */\n\nexport function getNodeBeforePosition(position, positionParent, textNode) {\n  if (textNode !== null) {\n    return null;\n  }\n\n  return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);\n}","map":null,"metadata":{},"sourceType":"module"}