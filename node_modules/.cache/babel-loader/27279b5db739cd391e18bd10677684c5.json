{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport RawElement from './rawelement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\n\nvar DowncastWriter = /*#__PURE__*/function () {\n  /**\n   * @param {module:engine/view/document~Document} document The view document instance.\n   */\n  function DowncastWriter(document) {\n    _classCallCheck(this, DowncastWriter);\n\n    /**\n     * The view document instance in which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n     *\n     * @private\n     * @type {Map.<String,Set>}\n     */\n\n    this._cloneGroups = new Map();\n    /**\n     * The slot factory used by the `elementToStructure` downcast helper.\n     *\n     * @private\n     * @type {Function|null}\n     */\n\n    this._slotFactory = null;\n  }\n  /**\n   * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n   * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n   *\n   * Usage:\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets backward selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\twriter.setSelection( otherSelection );\n   *\n   * \t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\twriter.setSelection( position );\n   *\n   * \t\t// Sets collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\twriter.setSelection( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n  \t * that element and ends after the last child of that element.\n   *\n   * \t\twriter.setSelection( paragraph, 'in' );\n   *\n   * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\twriter.setSelection( paragraph, 'on' );\n   *\n   * \t\t// Removes all ranges.\n   *\t\twriter.setSelection( null );\n   *\n   * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\twriter.setSelection( range, { backward: true } );\n   *\n   *\t\t// Sets selection as fake.\n   *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * \t\t// represented in other way, for example by applying proper CSS class.\n   *\t\twriter.setSelection( range, { fake: true } );\n   *\n   * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * \t\t// (and be  properly handled by screen readers).\n   *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n\n\n  _createClass(DowncastWriter, [{\n    key: \"setSelection\",\n    value: function setSelection(selectable, placeOrOffset, options) {\n      this.document.selection._setTo(selectable, placeOrOffset, options);\n    }\n    /**\n     * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n     *\n     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n     * parameters.\n     *\n     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     */\n\n  }, {\n    key: \"setSelectionFocus\",\n    value: function setSelectionFocus(itemOrPosition, offset) {\n      this.document.selection._setFocus(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.\n     *\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]\n     * A list of nodes to be inserted into the created document fragment.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.\n     */\n\n  }, {\n    key: \"createDocumentFragment\",\n    value: function createDocumentFragment(children) {\n      return new DocumentFragment(this.document, children);\n    }\n    /**\n     * Creates a new {@link module:engine/view/text~Text text node}.\n     *\n     *\t\twriter.createText( 'foo' );\n     *\n     * @param {String} data The text's data.\n     * @returns {module:engine/view/text~Text} The created text node.\n     */\n\n  }, {\n    key: \"createText\",\n    value: function createText(data) {\n      return new Text(this.document, data);\n    }\n    /**\n     * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.\n     *\n     *\t\twriter.createAttributeElement( 'strong' );\n     *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n     *\n     *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n     *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n     *\n     *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n     *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Element's attributes.\n     * @param {Object} [options] Element's options.\n     * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n     * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n     */\n\n  }, {\n    key: \"createAttributeElement\",\n    value: function createAttributeElement(name, attributes) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var attributeElement = new AttributeElement(this.document, name, attributes);\n\n      if (typeof options.priority === 'number') {\n        attributeElement._priority = options.priority;\n      }\n\n      if (options.id) {\n        attributeElement._id = options.id;\n      }\n\n      if (options.renderUnsafeAttributes) {\n        var _attributeElement$_un;\n\n        (_attributeElement$_un = attributeElement._unsafeAttributesToRender).push.apply(_attributeElement$_un, _toConsumableArray(options.renderUnsafeAttributes));\n      }\n\n      return attributeElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/containerelement~ContainerElement}.\n     *\n     *\t\twriter.createContainerElement( 'p' );\n     *\n     *\t\t// Create element with custom attributes.\n     *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n     *\n     *\t\t// Create element with custom styles.\n     *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n     *\n     *\t\t// Create element with custom classes.\n     *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n     *\n     *\t\t// Create element with children.\n     *\t\twriter.createContainerElement( 'figure', { class: 'image' }, [\n     *\t\t\twriter.createEmptyElement( 'img' ),\n     *\t\t\twriter.createContainerElement( 'figcaption' )\n     *\t\t] );\n     *\n     *\t\t// Create element with specific options.\n     *\t\twriter.createContainerElement( 'span', { class: 'placeholder' }, { renderUnsafeAttributes: [ 'foo' ] } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>|Object} [childrenOrOptions]\n     * A node or a list of nodes to be inserted into the created element. If no children were specified, element's `options`\n     * can be passed in this argument.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n     */\n\n  }, {\n    key: \"createContainerElement\",\n    value: function createContainerElement(name, attributes) {\n      var childrenOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var children = null;\n\n      if (isPlainObject(childrenOrOptions)) {\n        options = childrenOrOptions;\n      } else {\n        children = childrenOrOptions;\n      }\n\n      var containerElement = new ContainerElement(this.document, name, attributes, children);\n\n      if (options.renderUnsafeAttributes) {\n        var _containerElement$_un;\n\n        (_containerElement$_un = containerElement._unsafeAttributesToRender).push.apply(_containerElement$_un, _toConsumableArray(options.renderUnsafeAttributes));\n      }\n\n      return containerElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/editableelement~EditableElement}.\n     *\n     *\t\twriter.createEditableElement( 'div' );\n     *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n     *\n     * Note: The editable element is to be used in the editing pipeline. Usually, together with\n     * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/editableelement~EditableElement} Created element.\n     */\n\n  }, {\n    key: \"createEditableElement\",\n    value: function createEditableElement(name, attributes) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var editableElement = new EditableElement(this.document, name, attributes);\n      editableElement._document = this.document;\n\n      if (options.renderUnsafeAttributes) {\n        var _editableElement$_uns;\n\n        (_editableElement$_uns = editableElement._unsafeAttributesToRender).push.apply(_editableElement$_uns, _toConsumableArray(options.renderUnsafeAttributes));\n      }\n\n      return editableElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.\n     *\n     *\t\twriter.createEmptyElement( 'img' );\n     *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n     *\n     * @param {String} name Name of the element.\n     * @param {Object} [attributes] Elements attributes.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n     */\n\n  }, {\n    key: \"createEmptyElement\",\n    value: function createEmptyElement(name, attributes) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var emptyElement = new EmptyElement(this.document, name, attributes);\n\n      if (options.renderUnsafeAttributes) {\n        var _emptyElement$_unsafe;\n\n        (_emptyElement$_unsafe = emptyElement._unsafeAttributesToRender).push.apply(_emptyElement$_unsafe, _toConsumableArray(options.renderUnsafeAttributes));\n      }\n\n      return emptyElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/uielement~UIElement}.\n     *\n     *\t\twriter.createUIElement( 'span' );\n     *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n     *\n     * A custom render function can be provided as the third parameter:\n     *\n     *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n     *\t\t\tconst domElement = this.toDomElement( domDocument );\n     *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n     *\n     *\t\t\treturn domElement;\n     *\t\t} );\n     *\n     * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,\n     * they are ignored by the editor selection system.\n     *\n     * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.\n     *\n     * @param {String} name The name of the element.\n     * @param {Object} [attributes] Element attributes.\n     * @param {Function} [renderFunction] A custom render function.\n     * @returns {module:engine/view/uielement~UIElement} The created element.\n     */\n\n  }, {\n    key: \"createUIElement\",\n    value: function createUIElement(name, attributes, renderFunction) {\n      var uiElement = new UIElement(this.document, name, attributes);\n\n      if (renderFunction) {\n        uiElement.render = renderFunction;\n      }\n\n      return uiElement;\n    }\n    /**\n     * Creates a new {@link module:engine/view/rawelement~RawElement}.\n     *\n     *\t\twriter.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {\n     *\t\t\tdomElement.innerHTML = '<b>This is the raw content of the raw element.</b>';\n     *\t\t} );\n     *\n     * Raw elements work as data containers (\"wrappers\", \"sandboxes\") but their children are not managed or\n     * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures\n     * in the editor content without, for instance, worrying about compatibility with other editor features.\n     * Raw elements are a perfect tool for integration with external frameworks and data sources.\n     *\n     * Unlike {@link #createUIElement UI elements}, raw elements act like \"real\" editor content (similar to\n     * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),\n     * and they are considered by the editor selection.\n     *\n     * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}\n     * instead.\n     *\n     * @param {String} name The name of the element.\n     * @param {Object} [attributes] Element attributes.\n     * @param {Function} [renderFunction] A custom render function.\n     * @param {Object} [options] Element's options.\n     * @param {Array.<String>} [options.renderUnsafeAttributes] A list of attribute names that should be rendered in the editing\n     * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.\n     * @returns {module:engine/view/rawelement~RawElement} The created element.\n     */\n\n  }, {\n    key: \"createRawElement\",\n    value: function createRawElement(name, attributes, renderFunction) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var rawElement = new RawElement(this.document, name, attributes);\n\n      rawElement.render = renderFunction || function () {};\n\n      if (options.renderUnsafeAttributes) {\n        var _rawElement$_unsafeAt;\n\n        (_rawElement$_unsafeAt = rawElement._unsafeAttributesToRender).push.apply(_rawElement$_unsafeAt, _toConsumableArray(options.renderUnsafeAttributes));\n      }\n\n      return rawElement;\n    }\n    /**\n     * Adds or overwrites the element's attribute with a specified key and value.\n     *\n     *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n     *\n     * @param {String} key The attribute key.\n     * @param {String} value The attribute value.\n     * @param {module:engine/view/element~Element} element\n     */\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(key, value, element) {\n      element._setAttribute(key, value);\n    }\n    /**\n     * Removes attribute from the element.\n     *\n     *\t\twriter.removeAttribute( 'href', linkElement );\n     *\n     * @param {String} key Attribute key.\n     * @param {module:engine/view/element~Element} element\n     */\n\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(key, element) {\n      element._removeAttribute(key);\n    }\n    /**\n     * Adds specified class to the element.\n     *\n     *\t\twriter.addClass( 'foo', linkElement );\n     *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n     *\n     * @param {Array.<String>|String} className\n     * @param {module:engine/view/element~Element} element\n     */\n\n  }, {\n    key: \"addClass\",\n    value: function addClass(className, element) {\n      element._addClass(className);\n    }\n    /**\n     * Removes specified class from the element.\n     *\n     *\t\twriter.removeClass( 'foo', linkElement );\n     *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n     *\n     * @param {Array.<String>|String} className\n     * @param {module:engine/view/element~Element} element\n     */\n\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(className, element) {\n      element._removeClass(className);\n    }\n    /**\n     * Adds style to the element.\n     *\n     *\t\twriter.setStyle( 'color', 'red', element );\n     *\t\twriter.setStyle( {\n     *\t\t\tcolor: 'red',\n     *\t\t\tposition: 'fixed'\n     *\t\t}, element );\n     *\n     * **Note**: The passed style can be normalized if\n     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n     * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n     *\n     * @param {String|Object} property Property name or object with key - value pairs.\n     * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n     * @param {module:engine/view/element~Element} element Element to set styles on.\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(property, value, element) {\n      if (isPlainObject(property) && element === undefined) {\n        element = value;\n      }\n\n      element._setStyle(property, value);\n    }\n    /**\n     * Removes specified style from the element.\n     *\n     *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n     *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n     *\n     * **Note**: This method can work with normalized style names if\n     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n     *\n     * @param {Array.<String>|String} property\n     * @param {module:engine/view/element~Element} element\n     */\n\n  }, {\n    key: \"removeStyle\",\n    value: function removeStyle(property, element) {\n      element._removeStyle(property);\n    }\n    /**\n     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n     * so they can be used to add special data to elements.\n     *\n     * @param {String|Symbol} key\n     * @param {*} value\n     * @param {module:engine/view/element~Element} element\n     */\n\n  }, {\n    key: \"setCustomProperty\",\n    value: function setCustomProperty(key, value, element) {\n      element._setCustomProperty(key, value);\n    }\n    /**\n     * Removes a custom property stored under the given key.\n     *\n     * @param {String|Symbol} key\n     * @param {module:engine/view/element~Element} element\n     * @returns {Boolean} Returns true if property was removed.\n     */\n\n  }, {\n    key: \"removeCustomProperty\",\n    value: function removeCustomProperty(key, element) {\n      return element._removeCustomProperty(key);\n    }\n    /**\n     * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements\n     * up to their first ancestor that is a container element.\n     *\n     * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:\n     *\n     *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n     *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n     *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n     *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n     *\n     * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n     *\n     * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n     * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.\n     *\n     * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * when the {@link module:engine/view/range~Range#start start}\n     * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n     *\n     * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n     *\n     * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}\n     * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n     * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange The position where\n     * to break attribute elements.\n     * @returns {module:engine/view/position~Position|module:engine/view/range~Range} The new position or range, after breaking the\n     * attribute elements.\n     */\n\n  }, {\n    key: \"breakAttributes\",\n    value: function breakAttributes(positionOrRange) {\n      if (positionOrRange instanceof Position) {\n        return this._breakAttributes(positionOrRange);\n      } else {\n        return this._breakAttributesRange(positionOrRange);\n      }\n    }\n    /**\n     * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.\n     * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element\n     * if the position is at the beginning or at the end of its parent element.\n     *\n     *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n     *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n     *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n     *\t\t<p>foobar^</p> -> <p>foobar</p>^\n     *\n     * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,\n     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n     * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n     * @param {module:engine/view/position~Position} position The position where to break the element.\n     * @returns {module:engine/view/position~Position} The position between broken elements. If an element has not been broken,\n     * the returned position is placed either before or after it.\n     */\n\n  }, {\n    key: \"breakContainer\",\n    value: function breakContainer(position) {\n      var element = position.parent;\n\n      if (!element.is('containerElement')) {\n        /**\n         * Trying to break an element which is not a container element.\n         *\n         * @error view-writer-break-non-container-element\n         */\n        throw new CKEditorError('view-writer-break-non-container-element', this.document);\n      }\n\n      if (!element.parent) {\n        /**\n         * Trying to break root element.\n         *\n         * @error view-writer-break-root\n         */\n        throw new CKEditorError('view-writer-break-root', this.document);\n      }\n\n      if (position.isAtStart) {\n        return Position._createBefore(element);\n      } else if (!position.isAtEnd) {\n        var newElement = element._clone(false);\n\n        this.insert(Position._createAfter(element), newElement);\n        var sourceRange = new Range(position, Position._createAt(element, 'end'));\n        var targetPosition = new Position(newElement, 0);\n        this.move(sourceRange, targetPosition);\n      }\n\n      return Position._createAfter(element);\n    }\n    /**\n     * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n     * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n     *\n     * In following examples `<p>` is a container and `<b>` is an attribute element:\n     *\n     *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n     *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n     *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n     *\n     * It will also take care about empty attributes when merging:\n     *\n     *\t\t<p><b>[]</b></p> -> <p>[]</p>\n     *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n     *\n     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n     * @param {module:engine/view/position~Position} position Merge position.\n     * @returns {module:engine/view/position~Position} Position after merge.\n     */\n\n  }, {\n    key: \"mergeAttributes\",\n    value: function mergeAttributes(position) {\n      var positionOffset = position.offset;\n      var positionParent = position.parent; // When inside text node - nothing to merge.\n\n      if (positionParent.is('$text')) {\n        return position;\n      } // When inside empty attribute - remove it.\n\n\n      if (positionParent.is('attributeElement') && positionParent.childCount === 0) {\n        var parent = positionParent.parent;\n        var offset = positionParent.index;\n\n        positionParent._remove();\n\n        this._removeFromClonedElementsGroup(positionParent);\n\n        return this.mergeAttributes(new Position(parent, offset));\n      }\n\n      var nodeBefore = positionParent.getChild(positionOffset - 1);\n      var nodeAfter = positionParent.getChild(positionOffset); // Position should be placed between two nodes.\n\n      if (!nodeBefore || !nodeAfter) {\n        return position;\n      } // When position is between two text nodes.\n\n\n      if (nodeBefore.is('$text') && nodeAfter.is('$text')) {\n        return mergeTextNodes(nodeBefore, nodeAfter);\n      } // When position is between two same attribute elements.\n      else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {\n        // Move all children nodes from node placed after selection and remove that node.\n        var count = nodeBefore.childCount;\n\n        nodeBefore._appendChild(nodeAfter.getChildren());\n\n        nodeAfter._remove();\n\n        this._removeFromClonedElementsGroup(nodeAfter); // New position is located inside the first node, before new nodes.\n        // Call this method recursively to merge again if needed.\n\n\n        return this.mergeAttributes(new Position(nodeBefore, count));\n      }\n\n      return position;\n    }\n    /**\n     * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n     * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n     *\n     *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n     *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n     *\n     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n     *\n     * @see module:engine/view/attributeelement~AttributeElement\n     * @see module:engine/view/containerelement~ContainerElement\n     * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n     * @param {module:engine/view/position~Position} position Merge position.\n     * @returns {module:engine/view/position~Position} Position after merge.\n     */\n\n  }, {\n    key: \"mergeContainers\",\n    value: function mergeContainers(position) {\n      var prev = position.nodeBefore;\n      var next = position.nodeAfter;\n\n      if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {\n        /**\n         * Element before and after given position cannot be merged.\n         *\n         * @error view-writer-merge-containers-invalid-position\n         */\n        throw new CKEditorError('view-writer-merge-containers-invalid-position', this.document);\n      }\n\n      var lastChild = prev.getChild(prev.childCount - 1);\n      var newPosition = lastChild instanceof Text ? Position._createAt(lastChild, 'end') : Position._createAt(prev, 'end');\n      this.move(Range._createIn(next), Position._createAt(prev, 'end'));\n      this.remove(Range._createOn(next));\n      return newPosition;\n    }\n    /**\n     * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion\n     * and merging them afterwards.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n     * contains instances that are not {@link module:engine/view/text~Text Texts},\n     * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n     * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n     * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n     * {@link module:engine/view/rawelement~RawElement RawElements} or\n     * {@link module:engine/view/uielement~UIElement UIElements}.\n     *\n     * @param {module:engine/view/position~Position} position Insertion position.\n     * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n     * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n     * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n     * Iterable.<module:engine/view/text~Text|\n     * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n     * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n     * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n     * @returns {module:engine/view/range~Range} Range around inserted nodes.\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(position, nodes) {\n      nodes = isIterable(nodes) ? _toConsumableArray(nodes) : [nodes]; // Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\n      validateNodesToInsert(nodes, this.document); // Group nodes in batches of nodes that require or do not require breaking an AttributeElements.\n\n      var nodeGroups = nodes.reduce(function (groups, node) {\n        var lastGroup = groups[groups.length - 1]; // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n        // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\n        var breakAttributes = !node.is('uiElement');\n\n        if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {\n          groups.push({\n            breakAttributes: breakAttributes,\n            nodes: [node]\n          });\n        } else {\n          lastGroup.nodes.push(node);\n        }\n\n        return groups;\n      }, []); // Insert nodes in batches.\n\n      var start = null;\n      var end = position;\n\n      var _iterator = _createForOfIteratorHelper(nodeGroups),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _step.value,\n              _nodes = _step$value.nodes,\n              breakAttributes = _step$value.breakAttributes;\n\n          var range = this._insertNodes(end, _nodes, breakAttributes);\n\n          if (!start) {\n            start = range.start;\n          }\n\n          end = range.end;\n        } // When no nodes were inserted - return collapsed range.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!start) {\n        return new Range(position);\n      }\n\n      return new Range(start, end);\n    }\n    /**\n     * Removes provided range from the container.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n     * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n     * to a collapsed range showing the new position.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(rangeOrItem) {\n      var range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn(rangeOrItem);\n      validateRangeContainer(range, this.document); // If range is collapsed - nothing to remove.\n\n      if (range.isCollapsed) {\n        return new DocumentFragment(this.document);\n      } // Break attributes at range start and end.\n\n\n      var _this$_breakAttribute = this._breakAttributesRange(range, true),\n          breakStart = _this$_breakAttribute.start,\n          breakEnd = _this$_breakAttribute.end;\n\n      var parentContainer = breakStart.parent;\n      var count = breakEnd.offset - breakStart.offset; // Remove nodes in range.\n\n      var removed = parentContainer._removeChildren(breakStart.offset, count);\n\n      var _iterator2 = _createForOfIteratorHelper(removed),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var node = _step2.value;\n\n          this._removeFromClonedElementsGroup(node);\n        } // Merge after removing.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var mergePosition = this.mergeAttributes(breakStart);\n      range.start = mergePosition;\n      range.end = mergePosition.clone(); // Return removed nodes.\n\n      return new DocumentFragment(this.document, removed);\n    }\n    /**\n     * Removes matching elements from given range.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range} range Range to clear.\n     * @param {module:engine/view/element~Element} element Element to remove.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(range, element) {\n      validateRangeContainer(range, this.document); // Create walker on given range.\n      // We walk backward because when we remove element during walk it modifies range end position.\n\n      var walker = range.getWalker({\n        direction: 'backward',\n        ignoreElementEnd: true\n      }); // Let's walk.\n\n      var _iterator3 = _createForOfIteratorHelper(walker),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var current = _step3.value;\n          var item = current.item;\n          var rangeToRemove = void 0; // When current item matches to the given element.\n\n          if (item.is('element') && element.isSimilar(item)) {\n            // Create range on this element.\n            rangeToRemove = Range._createOn(item); // When range starts inside Text or TextProxy element.\n          } else if (!current.nextPosition.isAfter(range.start) && item.is('$textProxy')) {\n            // We need to check if parent of this text matches to given element.\n            var parentElement = item.getAncestors().find(function (ancestor) {\n              return ancestor.is('element') && element.isSimilar(ancestor);\n            }); // If it is then create range inside this element.\n\n            if (parentElement) {\n              rangeToRemove = Range._createIn(parentElement);\n            }\n          } // If we have found element to remove.\n\n\n          if (rangeToRemove) {\n            // We need to check if element range stick out of the given range and truncate if it is.\n            if (rangeToRemove.end.isAfter(range.end)) {\n              rangeToRemove.end = range.end;\n            }\n\n            if (rangeToRemove.start.isBefore(range.start)) {\n              rangeToRemove.start = range.start;\n            } // At the end we remove range with found element.\n\n\n            this.remove(rangeToRemove);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Moves nodes from provided range to target position.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n     * @param {module:engine/view/position~Position} targetPosition Position to insert.\n     * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(sourceRange, targetPosition) {\n      var nodes;\n\n      if (targetPosition.isAfter(sourceRange.end)) {\n        targetPosition = this._breakAttributes(targetPosition, true);\n        var parent = targetPosition.parent;\n        var countBefore = parent.childCount;\n        sourceRange = this._breakAttributesRange(sourceRange, true);\n        nodes = this.remove(sourceRange);\n        targetPosition.offset += parent.childCount - countBefore;\n      } else {\n        nodes = this.remove(sourceRange);\n      }\n\n      return this.insert(targetPosition, nodes);\n    }\n    /**\n     * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n     *\n     * If a collapsed range was passed and is same as selection, the selection\n     * will be moved to the inside of the wrapped attribute element.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n     * when {@link module:engine/view/range~Range#start}\n     * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n     * is collapsed and different than view selection.\n     *\n     * @param {module:engine/view/range~Range} range Range to wrap.\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n     * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n     */\n\n  }, {\n    key: \"wrap\",\n    value: function wrap(range, attribute) {\n      if (!(attribute instanceof AttributeElement)) {\n        throw new CKEditorError('view-writer-wrap-invalid-attribute', this.document);\n      }\n\n      validateRangeContainer(range, this.document);\n\n      if (!range.isCollapsed) {\n        // Non-collapsed range. Wrap it with the attribute element.\n        return this._wrapRange(range, attribute);\n      } else {\n        // Collapsed range. Wrap position.\n        var position = range.start;\n\n        if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {\n          position = position.getLastMatchingPosition(function (value) {\n            return value.item.is('uiElement');\n          });\n        }\n\n        position = this._wrapPosition(position, attribute);\n        var viewSelection = this.document.selection; // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\n        if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {\n          this.setSelection(position);\n        }\n\n        return new Range(position);\n      }\n    }\n    /**\n     * Unwraps nodes within provided range from attribute element.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n     * same parent container.\n     *\n     * @param {module:engine/view/range~Range} range\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute\n     */\n\n  }, {\n    key: \"unwrap\",\n    value: function unwrap(range, attribute) {\n      if (!(attribute instanceof AttributeElement)) {\n        /**\n         * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#unwrap `DowncastWriter#unwrap()`}\n         * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n         *\n         * @error view-writer-unwrap-invalid-attribute\n         */\n        throw new CKEditorError('view-writer-unwrap-invalid-attribute', this.document);\n      }\n\n      validateRangeContainer(range, this.document); // If range is collapsed - nothing to unwrap.\n\n      if (range.isCollapsed) {\n        return range;\n      } // Break attributes at range start and end.\n\n\n      var _this$_breakAttribute2 = this._breakAttributesRange(range, true),\n          breakStart = _this$_breakAttribute2.start,\n          breakEnd = _this$_breakAttribute2.end;\n\n      var parentContainer = breakStart.parent; // Unwrap children located between break points.\n\n      var newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.\n\n\n      var start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.\n\n      if (!start.isEqual(newRange.start)) {\n        newRange.end.offset--;\n      }\n\n      var end = this.mergeAttributes(newRange.end);\n      return new Range(start, end);\n    }\n    /**\n     * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n     * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n     * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n     *\n     * New element has to be created because `Element#tagName` property in DOM is readonly.\n     *\n     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n     *\n     * @param {String} newName New name for element.\n     * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n     * @returns {module:engine/view/containerelement~ContainerElement} Element created due to rename.\n     */\n\n  }, {\n    key: \"rename\",\n    value: function rename(newName, viewElement) {\n      var newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());\n      this.insert(Position._createAfter(viewElement), newElement);\n      this.move(Range._createIn(viewElement), Position._createAt(newElement, 0));\n      this.remove(Range._createOn(viewElement));\n      return newElement;\n    }\n    /**\n     * Cleans up memory by removing obsolete cloned elements group from the writer.\n     *\n     * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n     * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n     * the group will no longer be needed.\n     *\n     * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n     * were removed from the view.\n     *\n     * Keep in mind that group names are equal to the `id` property of the attribute element.\n     *\n     * @param {String} groupName Name of the group to clear.\n     */\n\n  }, {\n    key: \"clearClonedElementsGroup\",\n    value: function clearClonedElementsGroup(groupName) {\n      this._cloneGroups.delete(groupName);\n    }\n    /**\n     * Creates position at the given location. The location can be specified as:\n     *\n     * * a {@link module:engine/view/position~Position position},\n     * * parent element and offset (offset defaults to `0`),\n     * * parent element and `'end'` (sets position at the end of that element),\n     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n     *\n     * This method is a shortcut to other constructors such as:\n     *\n     * * {@link #createPositionBefore},\n     * * {@link #createPositionAfter},\n     *\n     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n     * first parameter is a {@link module:engine/view/item~Item view item}.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAt\",\n    value: function createPositionAt(itemOrPosition, offset) {\n      return Position._createAt(itemOrPosition, offset);\n    }\n    /**\n     * Creates a new position after given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item after which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionAfter\",\n    value: function createPositionAfter(item) {\n      return Position._createAfter(item);\n    }\n    /**\n     * Creates a new position before given view item.\n     *\n     * @param {module:engine/view/item~Item} item View item before which the position should be located.\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"createPositionBefore\",\n    value: function createPositionBefore(item) {\n      return Position._createBefore(item);\n    }\n    /**\n     * Creates a range spanning from `start` position to `end` position.\n     *\n     * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n     *\n     * @param {module:engine/view/position~Position} start Start position.\n     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRange\",\n    value: function createRange(start, end) {\n      return new Range(start, end);\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n     *\n     * @param {module:engine/view/item~Item} item\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRangeOn\",\n    value: function createRangeOn(item) {\n      return Range._createOn(item);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"createRangeIn\",\n    value: function createRangeIn(element) {\n      return Range._createIn(element);\n    }\n    /**\n     * Creates new {@link module:engine/view/selection~Selection} instance.\n     *\n     * \t\t// Creates empty selection without ranges.\n     *\t\tconst selection = writer.createSelection();\n     *\n     *\t\t// Creates selection at the given range.\n     *\t\tconst range = writer.createRange( start, end );\n     *\t\tconst selection = writer.createSelection( range );\n     *\n     *\t\t// Creates selection at the given ranges\n     * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n     *\t\tconst selection = writer.createSelection( ranges );\n     *\n     *\t\t// Creates selection from the other selection.\n     *\t\tconst otherSelection = writer.createSelection();\n     *\t\tconst selection = writer.createSelection( otherSelection );\n     *\n     *\t\t// Creates selection from the document selection.\n     *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n     *\n     * \t\t// Creates selection at the given position.\n     *\t\tconst position = writer.createPositionFromPath( root, path );\n     *\t\tconst selection = writer.createSelection( position );\n     *\n     *\t\t// Creates collapsed selection at the position of given item and offset.\n     *\t\tconst paragraph = writer.createContainerElement( 'p' );\n     *\t\tconst selection = writer.createSelection( paragraph, offset );\n     *\n     *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n     *\t\t// first child of that element and ends after the last child of that element.\n     *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n     *\n     *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n     *\t\t// just after the item.\n     *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n     *\n     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n     *\n     *\t\t// Creates backward selection.\n     *\t\tconst selection = writer.createSelection( range, { backward: true } );\n     *\n     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n     * represented in other way, for example by applying proper CSS class.\n     *\n     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n     * (and be  properly handled by screen readers).\n     *\n     *\t\t// Creates fake selection with label.\n     *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n     *\n     * @param {module:engine/view/selection~Selectable} [selectable=null]\n     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n     * @param {Object} [options]\n     * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n     * @param {String} [options.label] Label for the fake selection.\n     * @returns {module:engine/view/selection~Selection}\n     */\n\n  }, {\n    key: \"createSelection\",\n    value: function createSelection(selectable, placeOrOffset, options) {\n      return new Selection(selectable, placeOrOffset, options);\n    }\n    /**\n     * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n     * `elementToStructure()`} conversion helper.\n     *\n     *\t\tconst viewSlot = conversionApi.writer.createSlot();\n     *\t\tconst viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );\n     *\n     *\t\tconversionApi.writer.insert( viewPosition, viewSlot );\n     *\n     * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):\n     *\n     *\t\tconst viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );\n     *\t\tconst viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );\n     *\n     *\t\tconversionApi.writer.insert( viewPosition, viewSlot );\n     *\n     * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into\n     * multiple slots.\n     *\n     * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.\n     *\n     * @param {'children'|module:engine/conversion/downcasthelpers~SlotFilter} [modeOrFilter='children'] The filter for child nodes.\n     * @returns {module:engine/view/element~Element} The slot element to be placed in to the view structure while processing\n     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.\n     */\n\n  }, {\n    key: \"createSlot\",\n    value: function createSlot(modeOrFilter) {\n      if (!this._slotFactory) {\n        /**\n         * The `createSlot()` method is only allowed inside the `elementToStructure` downcast helper callback.\n         *\n         * @error view-writer-invalid-create-slot-context\n         */\n        throw new CKEditorError('view-writer-invalid-create-slot-context', this.document);\n      }\n\n      return this._slotFactory(this, modeOrFilter);\n    }\n    /**\n     * Registers a slot factory.\n     *\n     * @protected\n     * @param {Function} slotFactory The slot factory.\n     */\n\n  }, {\n    key: \"_registerSlotFactory\",\n    value: function _registerSlotFactory(slotFactory) {\n      this._slotFactory = slotFactory;\n    }\n    /**\n     * Clears the registered slot factory.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_clearSlotFactory\",\n    value: function _clearSlotFactory() {\n      this._slotFactory = null;\n    }\n    /**\n     * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion\n     * and merging them afterwards if requested by the breakAttributes param.\n     *\n     * @private\n     * @param {module:engine/view/position~Position} position Insertion position.\n     * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n     * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n     * module:engine/view/rawelement~RawElement|module:engine/view/uielement~UIElement|\n     * Iterable.<module:engine/view/text~Text|\n     * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n     * module:engine/view/emptyelement~EmptyElement|module:engine/view/rawelement~RawElement|\n     * module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n     * @param {Boolean} breakAttributes Whether attributes should be broken.\n     * @returns {module:engine/view/range~Range} Range around inserted nodes.\n     */\n\n  }, {\n    key: \"_insertNodes\",\n    value: function _insertNodes(position, nodes, breakAttributes) {\n      var parentElement; // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements\n      // can't have an attribute in model and won't get wrapped with an AttributeElement while down-casted.\n\n      if (breakAttributes) {\n        parentElement = getParentContainer(position);\n      } else {\n        parentElement = position.parent.is('$text') ? position.parent.parent : position.parent;\n      }\n\n      if (!parentElement) {\n        /**\n         * Position's parent container cannot be found.\n         *\n         * @error view-writer-invalid-position-container\n         */\n        throw new CKEditorError('view-writer-invalid-position-container', this.document);\n      }\n\n      var insertionPosition;\n\n      if (breakAttributes) {\n        insertionPosition = this._breakAttributes(position, true);\n      } else {\n        insertionPosition = position.parent.is('$text') ? breakTextNode(position) : position;\n      }\n\n      var length = parentElement._insertChild(insertionPosition.offset, nodes);\n\n      var _iterator4 = _createForOfIteratorHelper(nodes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var node = _step4.value;\n\n          this._addToClonedElementsGroup(node);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var endPosition = insertionPosition.getShiftedBy(length);\n      var start = this.mergeAttributes(insertionPosition); // If start position was merged - move end position.\n\n      if (!start.isEqual(insertionPosition)) {\n        endPosition.offset--;\n      }\n\n      var end = this.mergeAttributes(endPosition);\n      return new Range(start, end);\n    }\n    /**\n     * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n     * `startOffset` and `endOffset` will be wrapped.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} parent\n     * @param {Number} startOffset\n     * @param {Number} endOffset\n     * @param {module:engine/view/element~Element} wrapElement\n     */\n\n  }, {\n    key: \"_wrapChildren\",\n    value: function _wrapChildren(parent, startOffset, endOffset, wrapElement) {\n      var i = startOffset;\n      var wrapPositions = [];\n\n      while (i < endOffset) {\n        var child = parent.getChild(i);\n        var isText = child.is('$text');\n        var isAttribute = child.is('attributeElement'); //\n        // (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n        //\n        // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n        // If possible, join elements.\n        //\n        // <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n        //\n\n        if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {\n          wrapPositions.push(new Position(parent, i));\n        } //\n        // Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n        // `wrapElement` (due to priority).\n        //\n        // <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n        // <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n        else if (isText || !isAttribute || shouldABeOutsideB(wrapElement, child)) {\n          // Clone attribute.\n          var newAttribute = wrapElement._clone(); // Wrap current node with new attribute.\n\n\n          child._remove();\n\n          newAttribute._appendChild(child);\n\n          parent._insertChild(i, newAttribute);\n\n          this._addToClonedElementsGroup(newAttribute);\n\n          wrapPositions.push(new Position(parent, i));\n        } //\n        // If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n        //\n        // <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n        //\n        else\n          /* if ( isAttribute ) */\n          {\n            this._wrapChildren(child, 0, child.childCount, wrapElement);\n          }\n\n        i++;\n      } // Merge at each wrap.\n\n\n      var offsetChange = 0;\n\n      for (var _i = 0, _wrapPositions = wrapPositions; _i < _wrapPositions.length; _i++) {\n        var position = _wrapPositions[_i];\n        position.offset -= offsetChange; // Do not merge with elements outside selected children.\n\n        if (position.offset == startOffset) {\n          continue;\n        }\n\n        var newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.\n\n        if (!newPosition.isEqual(position)) {\n          offsetChange++;\n          endOffset--;\n        }\n      }\n\n      return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n    }\n    /**\n     * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n     * `startOffset` and `endOffset` will be unwrapped.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} parent\n     * @param {Number} startOffset\n     * @param {Number} endOffset\n     * @param {module:engine/view/element~Element} unwrapElement\n     */\n\n  }, {\n    key: \"_unwrapChildren\",\n    value: function _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {\n      var i = startOffset;\n      var unwrapPositions = []; // Iterate over each element between provided offsets inside parent.\n      // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n      // so it could get messy. It is safer to it manually in this case.\n\n      while (i < endOffset) {\n        var child = parent.getChild(i); // Skip all text nodes. There should be no container element's here either.\n\n        if (!child.is('attributeElement')) {\n          i++;\n          continue;\n        } //\n        // (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n        //\n        // If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n        //\n        // <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n        //\n\n\n        if (child.isSimilar(unwrapElement)) {\n          var unwrapped = child.getChildren();\n          var count = child.childCount; // Replace wrapper element with its children\n\n          child._remove();\n\n          parent._insertChild(i, unwrapped);\n\n          this._removeFromClonedElementsGroup(child); // Save start and end position of moved items.\n\n\n          unwrapPositions.push(new Position(parent, i), new Position(parent, i + count)); // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\n          i += count;\n          endOffset += count - 1;\n          continue;\n        } //\n        // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n        // Partial unwrapping will happen only if the elements have the same name.\n        //\n        // <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n        // <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n        //\n\n\n        if (this._unwrapAttributeElement(unwrapElement, child)) {\n          unwrapPositions.push(new Position(parent, i), new Position(parent, i + 1));\n          i++;\n          continue;\n        } //\n        // If other nested attribute is found, look through it's children for elements to unwrap.\n        //\n        // <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n        //\n\n\n        this._unwrapChildren(child, 0, child.childCount, unwrapElement);\n\n        i++;\n      } // Merge at each unwrap.\n\n\n      var offsetChange = 0;\n\n      for (var _i2 = 0, _unwrapPositions = unwrapPositions; _i2 < _unwrapPositions.length; _i2++) {\n        var position = _unwrapPositions[_i2];\n        position.offset -= offsetChange; // Do not merge with elements outside selected children.\n\n        if (position.offset == startOffset || position.offset == endOffset) {\n          continue;\n        }\n\n        var newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.\n\n        if (!newPosition.isEqual(position)) {\n          offsetChange++;\n          endOffset--;\n        }\n      }\n\n      return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n    }\n    /**\n     * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n     * This method will also merge newly added attribute element with its siblings whenever possible.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * @private\n     * @param {module:engine/view/range~Range} range\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute\n     * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n     */\n\n  }, {\n    key: \"_wrapRange\",\n    value: function _wrapRange(range, attribute) {\n      // Break attributes at range start and end.\n      var _this$_breakAttribute3 = this._breakAttributesRange(range, true),\n          breakStart = _this$_breakAttribute3.start,\n          breakEnd = _this$_breakAttribute3.end;\n\n      var parentContainer = breakStart.parent; // Wrap all children with attribute.\n\n      var newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.\n\n\n      var start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.\n\n      if (!start.isEqual(newRange.start)) {\n        newRange.end.offset--;\n      }\n\n      var end = this.mergeAttributes(newRange.end);\n      return new Range(start, end);\n    }\n    /**\n     * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n     * This method will also merge newly added attribute element with its siblings whenever possible.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n     *\n     * @private\n     * @param {module:engine/view/position~Position} position\n     * @param {module:engine/view/attributeelement~AttributeElement} attribute\n     * @returns {module:engine/view/position~Position} New position after wrapping.\n     */\n\n  }, {\n    key: \"_wrapPosition\",\n    value: function _wrapPosition(position, attribute) {\n      // Return same position when trying to wrap with attribute similar to position parent.\n      if (attribute.isSimilar(position.parent)) {\n        return movePositionToTextNode(position.clone());\n      } // When position is inside text node - break it and place new position between two text nodes.\n\n\n      if (position.parent.is('$text')) {\n        position = breakTextNode(position);\n      } // Create fake element that will represent position, and will not be merged with other attributes.\n\n\n      var fakePosition = this.createAttributeElement();\n      fakePosition._priority = Number.POSITIVE_INFINITY;\n\n      fakePosition.isSimilar = function () {\n        return false;\n      }; // Insert fake element in position location.\n\n\n      position.parent._insertChild(position.offset, fakePosition); // Range around inserted fake attribute element.\n\n\n      var wrapRange = new Range(position, position.getShiftedBy(1)); // Wrap fake element with attribute (it will also merge if possible).\n\n      this.wrap(wrapRange, attribute); // Remove fake element and place new position there.\n\n      var newPosition = new Position(fakePosition.parent, fakePosition.index);\n\n      fakePosition._remove(); // If position is placed between text nodes - merge them and return position inside.\n\n\n      var nodeBefore = newPosition.nodeBefore;\n      var nodeAfter = newPosition.nodeAfter;\n\n      if (nodeBefore instanceof Text && nodeAfter instanceof Text) {\n        return mergeTextNodes(nodeBefore, nodeAfter);\n      } // If position is next to text node - move position inside.\n\n\n      return movePositionToTextNode(newPosition);\n    }\n    /**\n     * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n     * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n     * \telement to element being wrapped.\n     *\n     * \t@private\n     * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n     * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n     * \t@returns {Boolean} Returns `true` if elements are merged.\n     */\n\n  }, {\n    key: \"_wrapAttributeElement\",\n    value: function _wrapAttributeElement(wrapper, toWrap) {\n      if (!canBeJoined(wrapper, toWrap)) {\n        return false;\n      } // Can't merge if name or priority differs.\n\n\n      if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {\n        return false;\n      } // Check if attributes can be merged.\n\n\n      var _iterator5 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var key = _step5.value;\n\n          // Classes and styles should be checked separately.\n          if (key === 'class' || key === 'style') {\n            continue;\n          } // If some attributes are different we cannot wrap.\n\n\n          if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n            return false;\n          }\n        } // Check if styles can be merged.\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(wrapper.getStyleNames()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _key = _step6.value;\n\n          if (toWrap.hasStyle(_key) && toWrap.getStyle(_key) !== wrapper.getStyle(_key)) {\n            return false;\n          }\n        } // Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _key2 = _step7.value;\n\n          // Classes and styles should be checked separately.\n          if (_key2 === 'class' || _key2 === 'style') {\n            continue;\n          } // Move only these attributes that are not present - other are similar.\n\n\n          if (!toWrap.hasAttribute(_key2)) {\n            this.setAttribute(_key2, wrapper.getAttribute(_key2), toWrap);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(wrapper.getStyleNames()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _key3 = _step8.value;\n\n          if (!toWrap.hasStyle(_key3)) {\n            this.setStyle(_key3, wrapper.getStyle(_key3), toWrap);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      var _iterator9 = _createForOfIteratorHelper(wrapper.getClassNames()),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _key4 = _step9.value;\n\n          if (!toWrap.hasClass(_key4)) {\n            this.addClass(_key4, toWrap);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return true;\n    }\n    /**\n     * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n     * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n     * inside element being unwrapped.\n     *\n     * @private\n     * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n     * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n     * @returns {Boolean} Returns `true` if elements are unwrapped.\n     **/\n\n  }, {\n    key: \"_unwrapAttributeElement\",\n    value: function _unwrapAttributeElement(wrapper, toUnwrap) {\n      if (!canBeJoined(wrapper, toUnwrap)) {\n        return false;\n      } // Can't unwrap if name or priority differs.\n\n\n      if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {\n        return false;\n      } // Check if AttributeElement has all wrapper attributes.\n\n\n      var _iterator10 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var key = _step10.value;\n\n          // Classes and styles should be checked separately.\n          if (key === 'class' || key === 'style') {\n            continue;\n          } // If some attributes are missing or different we cannot unwrap.\n\n\n          if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n            return false;\n          }\n        } // Check if AttributeElement has all wrapper classes.\n\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      if (!toUnwrap.hasClass.apply(toUnwrap, _toConsumableArray(wrapper.getClassNames()))) {\n        return false;\n      } // Check if AttributeElement has all wrapper styles.\n\n\n      var _iterator11 = _createForOfIteratorHelper(wrapper.getStyleNames()),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _key5 = _step11.value;\n\n          // If some styles are missing or different we cannot unwrap.\n          if (!toUnwrap.hasStyle(_key5) || toUnwrap.getStyle(_key5) !== wrapper.getStyle(_key5)) {\n            return false;\n          }\n        } // Remove all wrapper's attributes from unwrapped element.\n\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _key6 = _step12.value;\n\n          // Classes and styles should be checked separately.\n          if (_key6 === 'class' || _key6 === 'style') {\n            continue;\n          }\n\n          this.removeAttribute(_key6, toUnwrap);\n        } // Remove all wrapper's classes from unwrapped element.\n\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap); // Remove all wrapper's styles from unwrapped element.\n\n      this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);\n      return true;\n    }\n    /**\n     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n     *\n     * @private\n     * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n     * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n     * @returns {module:engine/view/range~Range} New range with located at break positions.\n     */\n\n  }, {\n    key: \"_breakAttributesRange\",\n    value: function _breakAttributesRange(range) {\n      var forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var rangeStart = range.start;\n      var rangeEnd = range.end;\n      validateRangeContainer(range, this.document); // Break at the collapsed position. Return new collapsed range.\n\n      if (range.isCollapsed) {\n        var position = this._breakAttributes(range.start, forceSplitText);\n\n        return new Range(position, position);\n      }\n\n      var breakEnd = this._breakAttributes(rangeEnd, forceSplitText);\n\n      var count = breakEnd.parent.childCount;\n\n      var breakStart = this._breakAttributes(rangeStart, forceSplitText); // Calculate new break end offset.\n\n\n      breakEnd.offset += breakEnd.parent.childCount - count;\n      return new Range(breakStart, breakEnd);\n    }\n    /**\n     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n     * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n     *\n     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n     * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n     *\n     * @private\n     * @param {module:engine/view/position~Position} position Position where to break attributes.\n     * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n     * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n     */\n\n  }, {\n    key: \"_breakAttributes\",\n    value: function _breakAttributes(position) {\n      var forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var positionOffset = position.offset;\n      var positionParent = position.parent; // If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\n      if (position.parent.is('emptyElement')) {\n        /**\n         * Cannot break an `EmptyElement` instance.\n         *\n         * This error is thrown if\n         * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n         * was executed in an incorrect position.\n         *\n         * @error view-writer-cannot-break-empty-element\n         */\n        throw new CKEditorError('view-writer-cannot-break-empty-element', this.document);\n      } // If position is placed inside UIElement - throw an exception as we cannot break inside.\n\n\n      if (position.parent.is('uiElement')) {\n        /**\n         * Cannot break a `UIElement` instance.\n         *\n         * This error is thrown if\n         * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n         * was executed in an incorrect position.\n         *\n         * @error view-writer-cannot-break-ui-element\n         */\n        throw new CKEditorError('view-writer-cannot-break-ui-element', this.document);\n      } // If position is placed inside RawElement - throw an exception as we cannot break inside.\n\n\n      if (position.parent.is('rawElement')) {\n        /**\n         * Cannot break a `RawElement` instance.\n         *\n         * This error is thrown if\n         * {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes `DowncastWriter#breakAttributes()`}\n         * was executed in an incorrect position.\n         *\n         * @error view-writer-cannot-break-raw-element\n         */\n        throw new CKEditorError('view-writer-cannot-break-raw-element', this.document);\n      } // There are no attributes to break and text nodes breaking is not forced.\n\n\n      if (!forceSplitText && positionParent.is('$text') && isContainerOrFragment(positionParent.parent)) {\n        return position.clone();\n      } // Position's parent is container, so no attributes to break.\n\n\n      if (isContainerOrFragment(positionParent)) {\n        return position.clone();\n      } // Break text and start again in new position.\n\n\n      if (positionParent.is('$text')) {\n        return this._breakAttributes(breakTextNode(position), forceSplitText);\n      }\n\n      var length = positionParent.childCount; // <p>foo<b><u>bar{}</u></b></p>\n      // <p>foo<b><u>bar</u>[]</b></p>\n      // <p>foo<b><u>bar</u></b>[]</p>\n\n      if (positionOffset == length) {\n        var newPosition = new Position(positionParent.parent, positionParent.index + 1);\n        return this._breakAttributes(newPosition, forceSplitText);\n      } else {\n        // <p>foo<b><u>{}bar</u></b></p>\n        // <p>foo<b>[]<u>bar</u></b></p>\n        // <p>foo{}<b><u>bar</u></b></p>\n        if (positionOffset === 0) {\n          var _newPosition = new Position(positionParent.parent, positionParent.index);\n\n          return this._breakAttributes(_newPosition, forceSplitText);\n        } // <p>foo<b><u>b{}ar</u></b></p>\n        // <p>foo<b><u>b[]ar</u></b></p>\n        // <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n        // <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n        else {\n          var offsetAfter = positionParent.index + 1; // Break element.\n\n          var clonedNode = positionParent._clone(); // Insert cloned node to position's parent node.\n\n\n          positionParent.parent._insertChild(offsetAfter, clonedNode);\n\n          this._addToClonedElementsGroup(clonedNode); // Get nodes to move.\n\n\n          var count = positionParent.childCount - positionOffset;\n\n          var nodesToMove = positionParent._removeChildren(positionOffset, count); // Move nodes to cloned node.\n\n\n          clonedNode._appendChild(nodesToMove); // Create new position to work on.\n\n\n          var _newPosition2 = new Position(positionParent.parent, offsetAfter);\n\n          return this._breakAttributes(_newPosition2, forceSplitText);\n        }\n      }\n    }\n    /**\n     * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n     * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n     * from the group now keep a reference to the given attribute element.\n     *\n     * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n     *\n     * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     *\n     * @private\n     * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n     */\n\n  }, {\n    key: \"_addToClonedElementsGroup\",\n    value: function _addToClonedElementsGroup(element) {\n      // Add only if the element is in document tree.\n      if (!element.root.is('rootElement')) {\n        return;\n      } // Traverse the element's children recursively to find other attribute elements that also might got inserted.\n      // The loop is at the beginning so we can make fast returns later in the code.\n\n\n      if (element.is('element')) {\n        var _iterator13 = _createForOfIteratorHelper(element.getChildren()),\n            _step13;\n\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var child = _step13.value;\n\n            this._addToClonedElementsGroup(child);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n\n      var id = element.id;\n\n      if (!id) {\n        return;\n      }\n\n      var group = this._cloneGroups.get(id);\n\n      if (!group) {\n        group = new Set();\n\n        this._cloneGroups.set(id, group);\n      }\n\n      group.add(element);\n      element._clonesGroup = group;\n    }\n    /**\n     * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n     * from its clones group.\n     *\n     * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n     * This allows to reference the whole group even if the element was already removed from the tree.\n     *\n     * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     *\n     * @private\n     * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n     */\n\n  }, {\n    key: \"_removeFromClonedElementsGroup\",\n    value: function _removeFromClonedElementsGroup(element) {\n      // Traverse the element's children recursively to find other attribute elements that also got removed.\n      // The loop is at the beginning so we can make fast returns later in the code.\n      if (element.is('element')) {\n        var _iterator14 = _createForOfIteratorHelper(element.getChildren()),\n            _step14;\n\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var child = _step14.value;\n\n            this._removeFromClonedElementsGroup(child);\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      }\n\n      var id = element.id;\n\n      if (!id) {\n        return;\n      }\n\n      var group = this._cloneGroups.get(id);\n\n      if (!group) {\n        return;\n      }\n\n      group.delete(element); // Not removing group from element on purpose!\n      // If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n    }\n  }]);\n\n  return DowncastWriter;\n}(); // Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\n\n\nexport { DowncastWriter as default };\n\nfunction _hasNonUiChildren(parent) {\n  return Array.from(parent.getChildren()).some(function (child) {\n    return !child.is('uiElement');\n  });\n}\n/**\n * The `attribute` passed to {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`}\n * must be an instance of {@link module:engine/view/attributeelement~AttributeElement `AttributeElement`}.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\n\n\nfunction getParentContainer(position) {\n  var parent = position.parent;\n\n  while (!isContainerOrFragment(parent)) {\n    if (!parent) {\n      return undefined;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n} // Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped outside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\n\n\nfunction shouldABeOutsideB(a, b) {\n  if (a.priority < b.priority) {\n    return true;\n  } else if (a.priority > b.priority) {\n    return false;\n  } // When priorities are equal and names are different - use identities.\n\n\n  return a.getIdentity() < b.getIdentity();\n} // Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\n\n\nfunction movePositionToTextNode(position) {\n  var nodeBefore = position.nodeBefore;\n\n  if (nodeBefore && nodeBefore.is('$text')) {\n    return new Position(nodeBefore, nodeBefore.data.length);\n  }\n\n  var nodeAfter = position.nodeAfter;\n\n  if (nodeAfter && nodeAfter.is('$text')) {\n    return new Position(nodeAfter, 0);\n  }\n\n  return position;\n} // Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\n\n\nfunction breakTextNode(position) {\n  if (position.offset == position.parent.data.length) {\n    return new Position(position.parent.parent, position.parent.index + 1);\n  }\n\n  if (position.offset === 0) {\n    return new Position(position.parent.parent, position.parent.index);\n  } // Get part of the text that need to be moved.\n\n\n  var textToMove = position.parent.data.slice(position.offset); // Leave rest of the text in position's parent.\n\n  position.parent._data = position.parent.data.slice(0, position.offset); // Insert new text node after position's parent text node.\n\n  position.parent.parent._insertChild(position.parent.index + 1, new Text(position.root.document, textToMove)); // Return new position between two newly created text nodes.\n\n\n  return new Position(position.parent.parent, position.parent.index + 1);\n} // Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\n\n\nfunction mergeTextNodes(t1, t2) {\n  // Merge text data into first text node and remove second one.\n  var nodeBeforeLength = t1.data.length;\n  t1._data += t2.data;\n\n  t2._remove();\n\n  return new Position(t1, nodeBeforeLength);\n} // Checks if provided nodes are valid to insert.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not supported ones (see error description for valid ones.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/element~Element> nodes\n// @param {Object} errorContext\n\n\nfunction validateNodesToInsert(nodes, errorContext) {\n  var _iterator15 = _createForOfIteratorHelper(nodes),\n      _step15;\n\n  try {\n    var _loop = function _loop() {\n      var node = _step15.value;\n\n      if (!validNodesToInsert.some(function (validNode) {\n        return node instanceof validNode;\n      })) {\n        // eslint-disable-line no-use-before-define\n\n        /**\n         * One of the nodes to be inserted is of an invalid type.\n         *\n         * Nodes to be inserted with {@link module:engine/view/downcastwriter~DowncastWriter#insert `DowncastWriter#insert()`} should be\n         * of the following types:\n         *\n         * * {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n         * * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n         * * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n         * * {@link module:engine/view/uielement~UIElement UIElement},\n         * * {@link module:engine/view/rawelement~RawElement RawElement},\n         * * {@link module:engine/view/text~Text Text}.\n         *\n         * @error view-writer-insert-invalid-node-type\n         */\n        throw new CKEditorError('view-writer-insert-invalid-node-type', errorContext);\n      }\n\n      if (!node.is('$text')) {\n        validateNodesToInsert(node.getChildren(), errorContext);\n      }\n    };\n\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n}\n\nvar validNodesToInsert = [Text, AttributeElement, ContainerElement, EmptyElement, RawElement, UIElement]; // Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\n\nfunction isContainerOrFragment(node) {\n  return node && (node.is('containerElement') || node.is('documentFragment'));\n} // Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\n\n\nfunction validateRangeContainer(range, errorContext) {\n  var startContainer = getParentContainer(range.start);\n  var endContainer = getParentContainer(range.end);\n\n  if (!startContainer || !endContainer || startContainer !== endContainer) {\n    /**\n     * The container of the given range is invalid.\n     *\n     * This may happen if {@link module:engine/view/range~Range#start range start} and\n     * {@link module:engine/view/range~Range#end range end} positions are not placed inside the same container element or\n     * a parent container for these positions cannot be found.\n     *\n     * Methods like {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#remove()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#clean()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#wrap()`},\n     * {@link module:engine/view/downcastwriter~DowncastWriter#wrap `DowncastWriter#unwrap()`} need to be called\n     * on a range that has its start and end positions located in the same container element. Both positions can be\n     * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.\n     *\n     * @error view-writer-invalid-range-container\n     */\n    throw new CKEditorError('view-writer-invalid-range-container', errorContext);\n  }\n} // Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\n\n\nfunction canBeJoined(a, b) {\n  return a.id === null && b.id === null;\n}","map":null,"metadata":{},"sourceType":"module"}