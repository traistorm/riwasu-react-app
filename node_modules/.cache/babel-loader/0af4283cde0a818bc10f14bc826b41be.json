{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/balloon/contextualballoon\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport BalloonPanelView from './balloonpanelview';\nimport View from '../../view';\nimport ButtonView from '../../button/buttonview';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\nimport prevIcon from '../../../theme/icons/previous-arrow.svg';\nimport nextIcon from '../../../theme/icons/next-arrow.svg';\nimport '../../../theme/components/panel/balloonrotator.css';\nimport '../../../theme/components/panel/fakepanel.css';\nvar toPx = toUnit('px');\n/**\n * Provides the common contextual balloon for the editor.\n *\n * The role of this plugin is to unify the contextual balloons logic, simplify views management and help\n * avoid the unnecessary complexity of handling multiple {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView}\n * instances in the editor.\n *\n * This plugin allows for creating single or multiple panel stacks.\n *\n * Each stack may have multiple views, with the one on the top being visible. When the visible view is removed from the stack,\n * the previous view becomes visible.\n *\n * It might be useful to implement nested navigation in a balloon. For instance, a toolbar view may contain a link button.\n * When you click it, a link view (which lets you set the URL) is created and put on top of the toolbar view, so the link panel\n * is displayed. When you finish editing the link and close (remove) the link view, the toolbar view is visible again.\n *\n * However, there are cases when there are multiple independent balloons to be displayed, for instance, if the selection\n * is inside two inline comments at the same time. For such cases, you can create two independent panel stacks.\n * The contextual balloon plugin will create a navigation bar to let the users switch between these panel stacks using the \"Next\"\n * and \"Previous\" buttons.\n *\n * If there are no views in the current stack, the balloon panel will try to switch to the next stack. If there are no\n * panels in any stack, the balloon panel will be hidden.\n *\n * **Note**: To force the balloon panel to show only one view, even if there are other stacks, use the `singleViewMode=true` option\n * when {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon#add adding} a view to a panel.\n *\n * From the implementation point of view, the contextual ballon plugin is reusing a single\n * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView} instance to display multiple contextual balloon\n * panels in the editor. It also creates a special {@link module:ui/panel/balloon/contextualballoon~RotatorView rotator view},\n * used to manage multiple panel stacks. Rotator view is a child of the balloon panel view and the parent of the specific\n * view you want to display. If there is more than one panel stack to be displayed, the rotator view will add a\n * navigation bar. If there is only one stack, the rotator view is transparent (it does not add any UI elements).\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ContextualBalloon = /*#__PURE__*/function (_Plugin) {\n  _inherits(ContextualBalloon, _Plugin);\n\n  _createClass(ContextualBalloon, null, [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'ContextualBalloon';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function ContextualBalloon(editor) {\n    var _this;\n\n    _classCallCheck(this, ContextualBalloon);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextualBalloon).call(this, editor));\n    /**\n     * The {@link module:utils/dom/position~Options#limiter position limiter}\n     * for the {@link #view balloon}, used when no `limiter` has been passed into {@link #add}\n     * or {@link #updatePosition}.\n     *\n     * By default, a function that obtains the farthest DOM\n     * {@link module:engine/view/rooteditableelement~RootEditableElement}\n     * of the {@link module:engine/view/document~Document#selection}.\n     *\n     * @member {module:utils/dom/position~Options#limiter} #positionLimiter\n     */\n\n    _this.positionLimiter = function () {\n      var view = _this.editor.editing.view;\n      var viewDocument = view.document;\n      var editableElement = viewDocument.selection.editableElement;\n\n      if (editableElement) {\n        return view.domConverter.mapViewToDom(editableElement.root);\n      }\n\n      return null;\n    };\n    /**\n     * The currently visible view or `null` when there are no views in any stack.\n     *\n     * @readonly\n     * @observable\n     * @member {module:ui/view~View|null} #visibleView\n     */\n\n\n    _this.set('visibleView', null);\n    /**\n     * The common balloon panel view.\n     *\n     * @readonly\n     * @member {module:ui/panel/balloon/balloonpanelview~BalloonPanelView} #view\n     */\n\n\n    _this.view = new BalloonPanelView(editor.locale);\n    editor.ui.view.body.add(_this.view);\n    editor.ui.focusTracker.add(_this.view.element);\n    /**\n     * The map of views and their stacks.\n     *\n     * @private\n     * @type {Map.<module:ui/view~View,Set>}\n     */\n\n    _this._viewToStack = new Map();\n    /**\n     * The map of IDs and stacks.\n     *\n     * @private\n     * @type {Map.<String,Set>}\n     */\n\n    _this._idToStack = new Map();\n    /**\n     * A total number of all stacks in the balloon.\n     *\n     * @private\n     * @readonly\n     * @observable\n     * @member {Number} #_numberOfStacks\n     */\n\n    _this.set('_numberOfStacks', 0);\n    /**\n     * A flag that controls the single view mode.\n     *\n     * @private\n     * @readonly\n     * @observable\n     * @member {Boolean} #_singleViewMode\n     */\n\n\n    _this.set('_singleViewMode', false);\n    /**\n     * Rotator view embedded in the contextual balloon.\n     * Displays the currently visible view in the balloon and provides navigation for switching stacks.\n     *\n     * @private\n     * @type {module:ui/panel/balloon/contextualballoon~RotatorView}\n     */\n\n\n    _this._rotatorView = _this._createRotatorView();\n    /**\n     * Displays fake panels under the balloon panel view when multiple stacks are added to the balloon.\n     *\n     * @private\n     * @type {module:ui/view~View}\n     */\n\n    _this._fakePanelsView = _this._createFakePanelsView();\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ContextualBalloon, [{\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(ContextualBalloon.prototype), \"destroy\", this).call(this);\n\n      this.view.destroy();\n\n      this._rotatorView.destroy();\n\n      this._fakePanelsView.destroy();\n    }\n    /**\n     * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.\n     *\n     * @param {module:ui/view~View} view\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasView\",\n    value: function hasView(view) {\n      return Array.from(this._viewToStack.keys()).includes(view);\n    }\n    /**\n     * Adds a new view to the stack and makes it visible if the current stack is visible\n     * or it is the first view in the balloon.\n     *\n     * @param {Object} data The configuration of the view.\n     * @param {String} [data.stackId='main'] The ID of the stack that the view is added to.\n     * @param {module:ui/view~View} [data.view] The content of the balloon.\n     * @param {module:utils/dom/position~Options} [data.position] Positioning options.\n     * @param {String} [data.balloonClassName] An additional CSS class added to the {@link #view balloon} when visible.\n     * @param {Boolean} [data.withArrow=true] Whether the {@link #view balloon} should be rendered with an arrow.\n     * @param {Boolean} [data.singleViewMode=false] Whether the view should be the only visible view even if other stacks were added.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      if (this.hasView(data.view)) {\n        /**\n         * Trying to add configuration of the same view more than once.\n         *\n         * @error contextualballoon-add-view-exist\n         */\n        throw new CKEditorError('contextualballoon-add-view-exist', [this, data]);\n      }\n\n      var stackId = data.stackId || 'main'; // If new stack is added, creates it and show view from this stack.\n\n      if (!this._idToStack.has(stackId)) {\n        this._idToStack.set(stackId, new Map([[data.view, data]]));\n\n        this._viewToStack.set(data.view, this._idToStack.get(stackId));\n\n        this._numberOfStacks = this._idToStack.size;\n\n        if (!this._visibleStack || data.singleViewMode) {\n          this.showStack(stackId);\n        }\n\n        return;\n      }\n\n      var stack = this._idToStack.get(stackId);\n\n      if (data.singleViewMode) {\n        this.showStack(stackId);\n      } // Add new view to the stack.\n\n\n      stack.set(data.view, data);\n\n      this._viewToStack.set(data.view, stack); // And display it if is added to the currently visible stack.\n\n\n      if (stack === this._visibleStack) {\n        this._showView(data);\n      }\n    }\n    /**\n     * Removes the given view from the stack. If the removed view was visible,\n     * the view preceding it in the stack will become visible instead.\n     * When there is no view in the stack, the next stack will be displayed.\n     * When there are no more stacks, the balloon will hide.\n     *\n     * @param {module:ui/view~View} view A view to be removed from the balloon.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(view) {\n      if (!this.hasView(view)) {\n        /**\n         * Trying to remove the configuration of the view not defined in the stack.\n         *\n         * @error contextualballoon-remove-view-not-exist\n         */\n        throw new CKEditorError('contextualballoon-remove-view-not-exist', [this, view]);\n      }\n\n      var stack = this._viewToStack.get(view);\n\n      if (this._singleViewMode && this.visibleView === view) {\n        this._singleViewMode = false;\n      } // When visible view will be removed we need to show a preceding view or next stack\n      // if a view is the only view in the stack.\n\n\n      if (this.visibleView === view) {\n        if (stack.size === 1) {\n          if (this._idToStack.size > 1) {\n            this._showNextStack();\n          } else {\n            this.view.hide();\n            this.visibleView = null;\n\n            this._rotatorView.hideView();\n          }\n        } else {\n          this._showView(Array.from(stack.values())[stack.size - 2]);\n        }\n      }\n\n      if (stack.size === 1) {\n        this._idToStack.delete(this._getStackId(stack));\n\n        this._numberOfStacks = this._idToStack.size;\n      } else {\n        stack.delete(view);\n      }\n\n      this._viewToStack.delete(view);\n    }\n    /**\n     * Updates the position of the balloon using the position data of the first visible view in the stack.\n     * When new position data is given, the position data of the currently visible view will be updated.\n     *\n     * @param {module:utils/dom/position~Options} [position] position options.\n     */\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(position) {\n      if (position) {\n        this._visibleStack.get(this.visibleView).position = position;\n      }\n\n      this.view.pin(this._getBalloonPosition());\n\n      this._fakePanelsView.updatePosition();\n    }\n    /**\n     * Shows the last view from the stack of a given ID.\n     *\n     * @param {String} id\n     */\n\n  }, {\n    key: \"showStack\",\n    value: function showStack(id) {\n      this.visibleStack = id;\n\n      var stack = this._idToStack.get(id);\n\n      if (!stack) {\n        /**\n         * Trying to show a stack that does not exist.\n         *\n         * @error contextualballoon-showstack-stack-not-exist\n         */\n        throw new CKEditorError('contextualballoon-showstack-stack-not-exist', this);\n      }\n\n      if (this._visibleStack === stack) {\n        return;\n      }\n\n      this._showView(Array.from(stack.values()).pop());\n    }\n    /**\n     * Returns the stack of the currently visible view.\n     *\n     * @private\n     * @type {Set}\n     */\n\n  }, {\n    key: \"_getStackId\",\n\n    /**\n     * Returns the ID of the given stack.\n     *\n     * @private\n     * @param {Set} stack\n     * @returns {String}\n     */\n    value: function _getStackId(stack) {\n      var entry = Array.from(this._idToStack.entries()).find(function (entry) {\n        return entry[1] === stack;\n      });\n      return entry[0];\n    }\n    /**\n     * Shows the last view from the next stack.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_showNextStack\",\n    value: function _showNextStack() {\n      var stacks = Array.from(this._idToStack.values());\n      var nextIndex = stacks.indexOf(this._visibleStack) + 1;\n\n      if (!stacks[nextIndex]) {\n        nextIndex = 0;\n      }\n\n      this.showStack(this._getStackId(stacks[nextIndex]));\n    }\n    /**\n     * Shows the last view from the previous stack.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_showPrevStack\",\n    value: function _showPrevStack() {\n      var stacks = Array.from(this._idToStack.values());\n      var nextIndex = stacks.indexOf(this._visibleStack) - 1;\n\n      if (!stacks[nextIndex]) {\n        nextIndex = stacks.length - 1;\n      }\n\n      this.showStack(this._getStackId(stacks[nextIndex]));\n    }\n    /**\n     * Creates a rotator view.\n     *\n     * @private\n     * @returns {module:ui/panel/balloon/contextualballoon~RotatorView}\n     */\n\n  }, {\n    key: \"_createRotatorView\",\n    value: function _createRotatorView() {\n      var _this2 = this;\n\n      var view = new RotatorView(this.editor.locale);\n      var t = this.editor.locale.t;\n      this.view.content.add(view); // Hide navigation when there is only a one stack & not in single view mode.\n\n      view.bind('isNavigationVisible').to(this, '_numberOfStacks', this, '_singleViewMode', function (value, isSingleViewMode) {\n        return !isSingleViewMode && value > 1;\n      }); // Update balloon position after toggling navigation.\n\n      view.on('change:isNavigationVisible', function () {\n        return _this2.updatePosition();\n      }, {\n        priority: 'low'\n      }); // Update stacks counter value.\n\n      view.bind('counter').to(this, 'visibleView', this, '_numberOfStacks', function (visibleView, numberOfStacks) {\n        if (numberOfStacks < 2) {\n          return '';\n        }\n\n        var current = Array.from(_this2._idToStack.values()).indexOf(_this2._visibleStack) + 1;\n        return t('%0 of %1', [current, numberOfStacks]);\n      });\n      view.buttonNextView.on('execute', function () {\n        // When current view has a focus then move focus to the editable before removing it,\n        // otherwise editor will lost focus.\n        if (view.focusTracker.isFocused) {\n          _this2.editor.editing.view.focus();\n        }\n\n        _this2._showNextStack();\n      });\n      view.buttonPrevView.on('execute', function () {\n        // When current view has a focus then move focus to the editable before removing it,\n        // otherwise editor will lost focus.\n        if (view.focusTracker.isFocused) {\n          _this2.editor.editing.view.focus();\n        }\n\n        _this2._showPrevStack();\n      });\n      return view;\n    }\n    /**\n     * @private\n     * @returns {module:ui/view~View}\n     */\n\n  }, {\n    key: \"_createFakePanelsView\",\n    value: function _createFakePanelsView() {\n      var view = new FakePanelsView(this.editor.locale, this.view);\n      view.bind('numberOfPanels').to(this, '_numberOfStacks', this, '_singleViewMode', function (number, isSingleViewMode) {\n        var showPanels = !isSingleViewMode && number >= 2;\n        return showPanels ? Math.min(number - 1, 2) : 0;\n      });\n      view.listenTo(this.view, 'change:top', function () {\n        return view.updatePosition();\n      });\n      view.listenTo(this.view, 'change:left', function () {\n        return view.updatePosition();\n      });\n      this.editor.ui.view.body.add(view);\n      return view;\n    }\n    /**\n     * Sets the view as the content of the balloon and attaches the balloon using position\n     * options of the first view.\n     *\n     * @private\n     * @param {Object} data Configuration.\n     * @param {module:ui/view~View} [data.view] The view to show in the balloon.\n     * @param {String} [data.balloonClassName=''] Additional class name which will be added to the {@link #view balloon}.\n     * @param {Boolean} [data.withArrow=true] Whether the {@link #view balloon} should be rendered with an arrow.\n     */\n\n  }, {\n    key: \"_showView\",\n    value: function _showView(_ref) {\n      var view = _ref.view,\n          _ref$balloonClassName = _ref.balloonClassName,\n          balloonClassName = _ref$balloonClassName === void 0 ? '' : _ref$balloonClassName,\n          _ref$withArrow = _ref.withArrow,\n          withArrow = _ref$withArrow === void 0 ? true : _ref$withArrow,\n          _ref$singleViewMode = _ref.singleViewMode,\n          singleViewMode = _ref$singleViewMode === void 0 ? false : _ref$singleViewMode;\n      this.view.class = balloonClassName;\n      this.view.withArrow = withArrow;\n\n      this._rotatorView.showView(view);\n\n      this.visibleView = view;\n      this.view.pin(this._getBalloonPosition());\n\n      this._fakePanelsView.updatePosition();\n\n      if (singleViewMode) {\n        this._singleViewMode = true;\n      }\n    }\n    /**\n     * Returns position options of the last view in the stack.\n     * This keeps the balloon in the same position when the view is changed.\n     *\n     * @private\n     * @returns {module:utils/dom/position~Options}\n     */\n\n  }, {\n    key: \"_getBalloonPosition\",\n    value: function _getBalloonPosition() {\n      var position = Array.from(this._visibleStack.values()).pop().position;\n\n      if (position) {\n        // Use the default limiter if none has been specified.\n        if (!position.limiter) {\n          // Don't modify the original options object.\n          position = Object.assign({}, position, {\n            limiter: this.positionLimiter\n          });\n        } // Don't modify the original options object.\n\n\n        position = Object.assign({}, position, {\n          viewportOffsetConfig: this.editor.ui.viewportOffset\n        });\n      }\n\n      return position;\n    }\n  }, {\n    key: \"_visibleStack\",\n    get: function get() {\n      return this._viewToStack.get(this.visibleView);\n    }\n  }]);\n\n  return ContextualBalloon;\n}(Plugin);\n/**\n * Rotator view is a helper class for the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon ContextualBalloon}.\n * It is used for displaying the last view from the current stack and providing navigation buttons for switching stacks.\n * See the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon ContextualBalloon} documentation to learn more.\n *\n * @extends module:ui/view~View\n */\n\n\nexport { ContextualBalloon as default };\n\nvar RotatorView = /*#__PURE__*/function (_View) {\n  _inherits(RotatorView, _View);\n\n  /**\n   * @inheritDoc\n   */\n  function RotatorView(locale) {\n    var _this3;\n\n    _classCallCheck(this, RotatorView);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(RotatorView).call(this, locale));\n    var t = locale.t;\n    var bind = _this3.bindTemplate;\n    /**\n     * Defines whether navigation is visible or not.\n     *\n     * @member {Boolean} #isNavigationVisible\n     */\n\n    _this3.set('isNavigationVisible', true);\n    /**\n     * Used for checking if a view is focused or not.\n     *\n     * @type {module:utils/focustracker~FocusTracker}\n     */\n\n\n    _this3.focusTracker = new FocusTracker();\n    /**\n     * Navigation button for switching the stack to the previous one.\n     *\n     * @type {module:ui/button/buttonview~ButtonView}\n     */\n\n    _this3.buttonPrevView = _this3._createButtonView(t('Previous'), prevIcon);\n    /**\n     * Navigation button for switching the stack to the next one.\n     *\n     * @type {module:ui/button/buttonview~ButtonView}\n     */\n\n    _this3.buttonNextView = _this3._createButtonView(t('Next'), nextIcon);\n    /**\n     * A collection of the child views that creates the rotator content.\n     *\n     * @readonly\n     * @type {module:ui/viewcollection~ViewCollection}\n     */\n\n    _this3.content = _this3.createCollection();\n\n    _this3.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-balloon-rotator'],\n        'z-index': '-1'\n      },\n      children: [{\n        tag: 'div',\n        attributes: {\n          class: ['ck-balloon-rotator__navigation', bind.to('isNavigationVisible', function (value) {\n            return value ? '' : 'ck-hidden';\n          })]\n        },\n        children: [_this3.buttonPrevView, {\n          tag: 'span',\n          attributes: {\n            class: ['ck-balloon-rotator__counter']\n          },\n          children: [{\n            text: bind.to('counter')\n          }]\n        }, _this3.buttonNextView]\n      }, {\n        tag: 'div',\n        attributes: {\n          class: 'ck-balloon-rotator__content'\n        },\n        children: _this3.content\n      }]\n    });\n\n    return _this3;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(RotatorView, [{\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(RotatorView.prototype), \"render\", this).call(this);\n\n      this.focusTracker.add(this.element);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(RotatorView.prototype), \"destroy\", this).call(this);\n\n      this.focusTracker.destroy();\n    }\n    /**\n     * Shows a given view.\n     *\n     * @param {module:ui/view~View} view The view to show.\n     */\n\n  }, {\n    key: \"showView\",\n    value: function showView(view) {\n      this.hideView();\n      this.content.add(view);\n    }\n    /**\n     * Hides the currently displayed view.\n     */\n\n  }, {\n    key: \"hideView\",\n    value: function hideView() {\n      this.content.clear();\n    }\n    /**\n     * Creates a navigation button view.\n     *\n     * @private\n     * @param {String} label The button label.\n     * @param {String} icon The button icon.\n     * @returns {module:ui/button/buttonview~ButtonView}\n     */\n\n  }, {\n    key: \"_createButtonView\",\n    value: function _createButtonView(label, icon) {\n      var view = new ButtonView(this.locale);\n      view.set({\n        label: label,\n        icon: icon,\n        tooltip: true\n      });\n      return view;\n    }\n  }]);\n\n  return RotatorView;\n}(View); // Displays additional layers under the balloon when multiple stacks are added to the balloon.\n//\n// @private\n// @extends module:ui/view~View\n\n\nvar FakePanelsView = /*#__PURE__*/function (_View2) {\n  _inherits(FakePanelsView, _View2);\n\n  // @inheritDoc\n  function FakePanelsView(locale, balloonPanelView) {\n    var _this4;\n\n    _classCallCheck(this, FakePanelsView);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(FakePanelsView).call(this, locale));\n    var bind = _this4.bindTemplate; // Fake panels top offset.\n    //\n    // @observable\n    // @member {Number} #top\n\n    _this4.set('top', 0); // Fake panels left offset.\n    //\n    // @observable\n    // @member {Number} #left\n\n\n    _this4.set('left', 0); // Fake panels height.\n    //\n    // @observable\n    // @member {Number} #height\n\n\n    _this4.set('height', 0); // Fake panels width.\n    //\n    // @observable\n    // @member {Number} #width\n\n\n    _this4.set('width', 0); // Number of rendered fake panels.\n    //\n    // @observable\n    // @member {Number} #numberOfPanels\n\n\n    _this4.set('numberOfPanels', 0); // Collection of the child views which creates fake panel content.\n    //\n    // @readonly\n    // @type {module:ui/viewcollection~ViewCollection}\n\n\n    _this4.content = _this4.createCollection(); // Context.\n    //\n    // @private\n    // @type {module:ui/panel/balloon/balloonpanelview~BalloonPanelView}\n\n    _this4._balloonPanelView = balloonPanelView;\n\n    _this4.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck-fake-panel', bind.to('numberOfPanels', function (number) {\n          return number ? '' : 'ck-hidden';\n        })],\n        style: {\n          top: bind.to('top', toPx),\n          left: bind.to('left', toPx),\n          width: bind.to('width', toPx),\n          height: bind.to('height', toPx)\n        }\n      },\n      children: _this4.content\n    });\n\n    _this4.on('change:numberOfPanels', function (evt, name, next, prev) {\n      if (next > prev) {\n        _this4._addPanels(next - prev);\n      } else {\n        _this4._removePanels(prev - next);\n      }\n\n      _this4.updatePosition();\n    });\n\n    return _this4;\n  } // @private\n  // @param {Number} number\n\n\n  _createClass(FakePanelsView, [{\n    key: \"_addPanels\",\n    value: function _addPanels(number) {\n      while (number--) {\n        var view = new View();\n        view.setTemplate({\n          tag: 'div'\n        });\n        this.content.add(view);\n        this.registerChild(view);\n      }\n    } // @private\n    // @param {Number} number\n\n  }, {\n    key: \"_removePanels\",\n    value: function _removePanels(number) {\n      while (number--) {\n        var view = this.content.last;\n        this.content.remove(view);\n        this.deregisterChild(view);\n        view.destroy();\n      }\n    } // Updates coordinates of fake panels.\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition() {\n      if (this.numberOfPanels) {\n        var _this$_balloonPanelVi = this._balloonPanelView,\n            top = _this$_balloonPanelVi.top,\n            left = _this$_balloonPanelVi.left;\n\n        var _Rect = new Rect(this._balloonPanelView.element),\n            width = _Rect.width,\n            height = _Rect.height;\n\n        Object.assign(this, {\n          top: top,\n          left: left,\n          width: width,\n          height: height\n        });\n      }\n    }\n  }]);\n\n  return FakePanelsView;\n}(View);","map":null,"metadata":{},"sourceType":"module"}