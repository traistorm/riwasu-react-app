{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/focuscycler\n */\nimport isVisible from '@ckeditor/ckeditor5-utils/src/dom/isvisible';\n/**\n * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a\n * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the\n * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard\n * navigation in HTML forms, toolbars, lists and the like.\n *\n * To work properly it requires:\n * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,\n * * an associated focus tracker to determine which view is focused.\n *\n * A simple cycler setup can look like this:\n *\n *\t\tconst focusables = new ViewCollection();\n *\t\tconst focusTracker = new FocusTracker();\n *\n *\t\t// Add focusable views to the focus tracker.\n *\t\tfocusTracker.add( ... );\n *\n * Then, the cycler can be used manually:\n *\n *\t\tconst cycler = new FocusCycler( { focusables, focusTracker } );\n *\n *\t\t// Will focus the first focusable view in #focusables.\n *\t\tcycler.focusFirst();\n *\n *\t\t// Will log the next focusable item in #focusables.\n *\t\tconsole.log( cycler.next );\n *\n * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:\n *\n *\t\tconst keystrokeHandler = new KeystrokeHandler();\n *\n *\t\t// Activate the keystroke handler.\n *\t\tkeystrokeHandler.listenTo( sourceOfEvents );\n *\n *\t\tconst cycler = new FocusCycler( {\n *\t\t\tfocusables, focusTracker, keystrokeHandler,\n *\t\t\tactions: {\n *\t\t\t\t// When arrowup of arrowleft is detected by the #keystrokeHandler,\n *\t\t\t\t// focusPrevious() will be called on the cycler.\n *\t\t\t\tfocusPrevious: [ 'arrowup', 'arrowleft' ],\n *\t\t\t}\n *\t\t} );\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n */\n\nvar FocusCycler = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the focus cycler utility.\n   *\n   * @param {Object} options Configuration options.\n   * @param {module:utils/collection~Collection|Object} options.focusables\n   * @param {module:utils/focustracker~FocusTracker} options.focusTracker\n   * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]\n   * @param {Object} [options.actions]\n   */\n  function FocusCycler(options) {\n    var _this = this;\n\n    _classCallCheck(this, FocusCycler);\n\n    Object.assign(this, options);\n    /**\n     * A {@link module:ui/view~View view} collection that the cycler operates on.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} #focusables\n     */\n\n    /**\n     * A focus tracker instance that the cycler uses to determine the current focus\n     * state in {@link #focusables}.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker} #focusTracker\n     */\n\n    /**\n     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n     * which can respond to certain keystrokes and cycle the focus.\n     *\n     * @readonly\n     * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler\n     */\n\n    /**\n     * Actions that the cycler can take when a keystroke is pressed. Requires\n     * `options.keystrokeHandler` to be passed and working. When an action is\n     * performed, `preventDefault` and `stopPropagation` will be called on the event\n     * the keystroke fired in the DOM.\n     *\n     *\t\tactions: {\n     *\t\t\t// Will call #focusPrevious() when arrowleft or arrowup is pressed.\n     *\t\t\tfocusPrevious: [ 'arrowleft', 'arrowup' ],\n     *\n     *\t\t\t// Will call #focusNext() when arrowdown is pressed.\n     *\t\t\tfocusNext: 'arrowdown'\n     *\t\t}\n     *\n     * @readonly\n     * @member {Object} #actions\n     */\n\n    if (options.actions && options.keystrokeHandler) {\n      var _loop = function _loop(methodName) {\n        var actions = options.actions[methodName];\n\n        if (typeof actions == 'string') {\n          actions = [actions];\n        }\n\n        var _iterator = _createForOfIteratorHelper(actions),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var keystroke = _step.value;\n            options.keystrokeHandler.set(keystroke, function (data, cancel) {\n              _this[methodName]();\n\n              cancel();\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      };\n\n      for (var methodName in options.actions) {\n        _loop(methodName);\n      }\n    }\n  }\n  /**\n   * Returns the first focusable view in {@link #focusables}.\n   * Returns `null` if there is none.\n   *\n   * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n   *\n   * @readonly\n   * @member {module:ui/view~View|null} #first\n   */\n\n\n  _createClass(FocusCycler, [{\n    key: \"focusFirst\",\n\n    /**\n     * Focuses the {@link #first} item in {@link #focusables}.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     */\n    value: function focusFirst() {\n      this._focus(this.first);\n    }\n    /**\n     * Focuses the {@link #last} item in {@link #focusables}.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     */\n\n  }, {\n    key: \"focusLast\",\n    value: function focusLast() {\n      this._focus(this.last);\n    }\n    /**\n     * Focuses the {@link #next} item in {@link #focusables}.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     */\n\n  }, {\n    key: \"focusNext\",\n    value: function focusNext() {\n      this._focus(this.next);\n    }\n    /**\n     * Focuses the {@link #previous} item in {@link #focusables}.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     */\n\n  }, {\n    key: \"focusPrevious\",\n    value: function focusPrevious() {\n      this._focus(this.previous);\n    }\n    /**\n     * Focuses the given view if it exists.\n     *\n     * @protected\n     * @param {module:ui/view~View} view\n     */\n\n  }, {\n    key: \"_focus\",\n    value: function _focus(view) {\n      if (view) {\n        view.focus();\n      }\n    }\n    /**\n     * Returns the next or previous focusable view in {@link #focusables} with respect\n     * to {@link #current}.\n     *\n     * @protected\n     * @param {Number} step Either `1` for checking forward from {@link #current} or\n     * `-1` for checking backwards.\n     * @returns {module:ui/view~View|null}\n     */\n\n  }, {\n    key: \"_getFocusableItem\",\n    value: function _getFocusableItem(step) {\n      // Cache for speed.\n      var current = this.current;\n      var collectionLength = this.focusables.length;\n\n      if (!collectionLength) {\n        return null;\n      } // Start from the beginning if no view is focused.\n      // https://github.com/ckeditor/ckeditor5-ui/issues/206\n\n\n      if (current === null) {\n        return this[step === 1 ? 'first' : 'last'];\n      } // Cycle in both directions.\n\n\n      var index = (current + collectionLength + step) % collectionLength;\n\n      do {\n        var view = this.focusables.get(index);\n\n        if (isFocusable(view)) {\n          return view;\n        } // Cycle in both directions.\n\n\n        index = (index + collectionLength + step) % collectionLength;\n      } while (index !== current);\n\n      return null;\n    }\n  }, {\n    key: \"first\",\n    get: function get() {\n      return this.focusables.find(isFocusable) || null;\n    }\n    /**\n     * Returns the last focusable view in {@link #focusables}.\n     * Returns `null` if there is none.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     *\n     * @readonly\n     * @member {module:ui/view~View|null} #last\n     */\n\n  }, {\n    key: \"last\",\n    get: function get() {\n      return this.focusables.filter(isFocusable).slice(-1)[0] || null;\n    }\n    /**\n     * Returns the next focusable view in {@link #focusables} based on {@link #current}.\n     * Returns `null` if there is none.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     *\n     * @readonly\n     * @member {module:ui/view~View|null} #next\n     */\n\n  }, {\n    key: \"next\",\n    get: function get() {\n      return this._getFocusableItem(1);\n    }\n    /**\n     * Returns the previous focusable view in {@link #focusables} based on {@link #current}.\n     * Returns `null` if there is none.\n     *\n     * **Note**: Hidden views (e.g. with `display: none`) are ignored.\n     *\n     * @readonly\n     * @member {module:ui/view~View|null} #previous\n     */\n\n  }, {\n    key: \"previous\",\n    get: function get() {\n      return this._getFocusableItem(-1);\n    }\n    /**\n     * An index of the view in the {@link #focusables} which is focused according\n     * to {@link #focusTracker}. Returns `null` when there is no such view.\n     *\n     * @readonly\n     * @member {Number|null} #current\n     */\n\n  }, {\n    key: \"current\",\n    get: function get() {\n      var _this2 = this;\n\n      var index = null; // There's no focused view in the focusables.\n\n      if (this.focusTracker.focusedElement === null) {\n        return null;\n      }\n\n      this.focusables.find(function (view, viewIndex) {\n        var focused = view.element === _this2.focusTracker.focusedElement;\n\n        if (focused) {\n          index = viewIndex;\n        }\n\n        return focused;\n      });\n      return index;\n    }\n  }]);\n\n  return FocusCycler;\n}(); // Checks whether a view is focusable.\n//\n// @private\n// @param {module:ui/view~View} view A view to be checked.\n// @returns {Boolean}\n\n\nexport { FocusCycler as default };\n\nfunction isFocusable(view) {\n  return !!(view.focus && isVisible(view.element));\n}","map":null,"metadata":{},"sourceType":"module"}