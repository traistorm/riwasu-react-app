{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport { findOptimalInsertionRange as engineFindOptimalInsertionRange } from '@ckeditor/ckeditor5-engine/src/model/utils/findoptimalinsertionrange';\nimport HighlightStack from './highlightstack';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils';\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\n\nexport var WIDGET_CLASS_NAME = 'ck-widget';\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\n\nexport var WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\n\nexport function isWidget(node) {\n  if (!node.is('element')) {\n    return false;\n  }\n\n  return !!node.getCustomProperty('widget');\n}\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandle=false] If `true`, the widget will have a selection handle added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\n\nexport function toWidget(element, writer) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!element.is('containerElement')) {\n    /**\n     * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n     * instance.\n     *\n     * @error widget-to-widget-wrong-element-type\n     * @param {String} element The view element passed to `toWidget()`.\n     */\n    throw new CKEditorError('widget-to-widget-wrong-element-type', null, {\n      element: element\n    });\n  }\n\n  writer.setAttribute('contenteditable', 'false', element);\n  writer.addClass(WIDGET_CLASS_NAME, element);\n  writer.setCustomProperty('widget', true, element);\n  element.getFillerOffset = getFillerOffset;\n\n  if (options.label) {\n    setLabel(element, options.label, writer);\n  }\n\n  if (options.hasSelectionHandle) {\n    addSelectionHandle(element, writer);\n  }\n\n  setHighlightHandling(element, writer);\n  return element;\n} // Default handler for adding a highlight on a widget.\n// It adds CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\nfunction addHighlight(element, descriptor, writer) {\n  if (descriptor.classes) {\n    writer.addClass(toArray(descriptor.classes), element);\n  }\n\n  if (descriptor.attributes) {\n    for (var key in descriptor.attributes) {\n      writer.setAttribute(key, descriptor.attributes[key], element);\n    }\n  }\n} // Default handler for removing a highlight from a widget.\n// It removes CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\n\nfunction removeHighlight(element, descriptor, writer) {\n  if (descriptor.classes) {\n    writer.removeClass(toArray(descriptor.classes), element);\n  }\n\n  if (descriptor.attributes) {\n    for (var key in descriptor.attributes) {\n      writer.removeAttribute(key, element);\n    }\n  }\n}\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} [add]\n * @param {Function} [remove]\n */\n\n\nexport function setHighlightHandling(element, writer) {\n  var add = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : addHighlight;\n  var remove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : removeHighlight;\n  var stack = new HighlightStack();\n  stack.on('change:top', function (evt, data) {\n    if (data.oldDescriptor) {\n      remove(element, data.oldDescriptor, data.writer);\n    }\n\n    if (data.newDescriptor) {\n      add(element, data.newDescriptor, data.writer);\n    }\n  });\n  writer.setCustomProperty('addHighlight', function (element, descriptor, writer) {\n    return stack.add(descriptor, writer);\n  }, element);\n  writer.setCustomProperty('removeHighlight', function (element, id, writer) {\n    return stack.remove(id, writer);\n  }, element);\n}\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\n\nexport function setLabel(element, labelOrCreator, writer) {\n  writer.setCustomProperty('widgetLabel', labelOrCreator, element);\n}\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\n\nexport function getLabel(element) {\n  var labelCreator = element.getCustomProperty('widgetLabel');\n\n  if (!labelCreator) {\n    return '';\n  }\n\n  return typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n * * implements the {@link ~setHighlightHandling view highlight on widget's editable}.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\n\nexport function toWidgetEditable(editable, writer) {\n  writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable); // Set initial contenteditable value.\n\n  writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable); // Bind the contenteditable property to element#isReadOnly.\n\n  editable.on('change:isReadOnly', function (evt, property, is) {\n    writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n  });\n  editable.on('change:isFocused', function (evt, property, is) {\n    if (is) {\n      writer.addClass('ck-editor__nested-editable_focused', editable);\n    } else {\n      writer.removeClass('ck-editor__nested-editable_focused', editable);\n    }\n  });\n  setHighlightHandling(editable, writer);\n  return editable;\n}\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/range~Range} The optimal range.\n */\n\nexport function findOptimalInsertionRange(selection, model) {\n  var selectedElement = selection.getSelectedElement();\n\n  if (selectedElement) {\n    var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection); // If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n    // to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n\n    if (typeAroundFakeCaretPosition) {\n      return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));\n    }\n  }\n\n  return engineFindOptimalInsertionRange(selection, model);\n}\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\n\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n  return function (evt, data) {\n    var mapper = data.mapper,\n        viewPosition = data.viewPosition;\n    var viewParent = mapper.findMappedViewAncestor(viewPosition);\n\n    if (!viewElementMatcher(viewParent)) {\n      return;\n    }\n\n    var modelParent = mapper.toModelElement(viewParent);\n    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n  };\n} // Default filler offset function applied to all widget elements.\n//\n// @returns {null}\n\nfunction getFillerOffset() {\n  return null;\n} // Adds a drag handle to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\n\nfunction addSelectionHandle(widgetElement, writer) {\n  var selectionHandle = writer.createUIElement('div', {\n    class: 'ck ck-widget__selection-handle'\n  }, function (domDocument) {\n    var domElement = this.toDomElement(domDocument); // Use the IconView from the ui library.\n\n    var icon = new IconView();\n    icon.set('content', dragHandleIcon); // Render the icon view right away to append its #element to the selectionHandle DOM element.\n\n    icon.render();\n    domElement.appendChild(icon.element);\n    return domElement;\n  }); // Append the selection handle into the widget wrapper.\n\n  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);\n  writer.addClass(['ck-widget_with-selection-handle'], widgetElement);\n}","map":null,"metadata":{},"sourceType":"module"}