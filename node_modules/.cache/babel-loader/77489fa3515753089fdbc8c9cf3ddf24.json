{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/rect\n */\nimport isRange from './isrange';\nimport isWindow from './iswindow';\nimport getBorderWidths from './getborderwidths';\nimport isText from './istext';\nimport { isElement } from 'lodash-es';\nvar rectProperties = ['top', 'right', 'bottom', 'left', 'width', 'height'];\n/**\n * A helper class representing a `ClientRect` object, e.g. value returned by\n * the native `object.getBoundingClientRect()` method. Provides a set of methods\n * to manipulate the rect and compare it against other rect instances.\n */\n\nvar Rect = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of rect.\n   *\n   *\t\t// Rect of an HTMLElement.\n   *\t\tconst rectA = new Rect( document.body );\n   *\n   *\t\t// Rect of a DOM Range.\n   *\t\tconst rectB = new Rect( document.getSelection().getRangeAt( 0 ) );\n   *\n   *\t\t// Rect of a window (web browser viewport).\n   *\t\tconst rectC = new Rect( window );\n   *\n   *\t\t// Rect out of an object.\n   *\t\tconst rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );\n   *\n   *\t\t// Rect out of another Rect instance.\n   *\t\tconst rectE = new Rect( rectD );\n   *\n   *\t\t// Rect out of a ClientRect.\n   *\t\tconst rectF = new Rect( document.body.getClientRects().item( 0 ) );\n   *\n   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)\n   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}\n   * to get the inner part of the rect.\n   *\n   * @param {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.\n   */\n  function Rect(source) {\n    _classCallCheck(this, Rect);\n\n    var isSourceRange = isRange(source);\n    /**\n     * The object this rect is for.\n     *\n     * @protected\n     * @readonly\n     * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object} #_source\n     */\n\n    Object.defineProperty(this, '_source', {\n      // If the source is a Rect instance, copy it's #_source.\n      value: source._source || source,\n      writable: true,\n      enumerable: false\n    });\n\n    if (isElement(source) || isSourceRange) {\n      // The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods. If the source\n      // of a rect in an HTML element or a DOM range but it does not belong to any rendered DOM tree, these methods\n      // will fail to obtain the geometry and the rect instance makes little sense to the features using it.\n      // To get rid of this warning make sure the source passed to the constructor is a descendant of `window.document.body`.\n      // @if CK_DEBUG // const sourceNode = isSourceRange ? source.startContainer : source;\n      // @if CK_DEBUG // if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {\n      // @if CK_DEBUG // \tconsole.warn(\n      // @if CK_DEBUG // \t\t'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',\n      // @if CK_DEBUG // \t\t{ source } );\n      // @if CK_DEBUG // }\n      if (isSourceRange) {\n        var rangeRects = Rect.getDomRangeRects(source);\n        copyRectProperties(this, Rect.getBoundingRect(rangeRects));\n      } else {\n        copyRectProperties(this, source.getBoundingClientRect());\n      }\n    } else if (isWindow(source)) {\n      var innerWidth = source.innerWidth,\n          innerHeight = source.innerHeight;\n      copyRectProperties(this, {\n        top: 0,\n        right: innerWidth,\n        bottom: innerHeight,\n        left: 0,\n        width: innerWidth,\n        height: innerHeight\n      });\n    } else {\n      copyRectProperties(this, source);\n    }\n    /**\n     * The \"top\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #top\n     */\n\n    /**\n     * The \"right\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #right\n     */\n\n    /**\n     * The \"bottom\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #bottom\n     */\n\n    /**\n     * The \"left\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #left\n     */\n\n    /**\n     * The \"width\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #width\n     */\n\n    /**\n     * The \"height\" value of the rect.\n     *\n     * @readonly\n     * @member {Number} #height\n     */\n\n  }\n  /**\n   * Returns a clone of the rect.\n   *\n   * @returns {module:utils/dom/rect~Rect} A cloned rect.\n   */\n\n\n  _createClass(Rect, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Rect(this);\n    }\n    /**\n     * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.\n     *\n     * @param {Number} x Desired horizontal location.\n     * @param {Number} y Desired vertical location.\n     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n     */\n\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      this.top = y;\n      this.right = x + this.width;\n      this.bottom = y + this.height;\n      this.left = x;\n      return this;\n    }\n    /**\n     * Moves the rect in–place by a dedicated offset.\n     *\n     * @param {Number} x A horizontal offset.\n     * @param {Number} y A vertical offset\n     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.\n     */\n\n  }, {\n    key: \"moveBy\",\n    value: function moveBy(x, y) {\n      this.top += y;\n      this.right += x;\n      this.left += x;\n      this.bottom += y;\n      return this;\n    }\n    /**\n     * Returns a new rect a a result of intersection with another rect.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {module:utils/dom/rect~Rect}\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(anotherRect) {\n      var rect = {\n        top: Math.max(this.top, anotherRect.top),\n        right: Math.min(this.right, anotherRect.right),\n        bottom: Math.min(this.bottom, anotherRect.bottom),\n        left: Math.max(this.left, anotherRect.left)\n      };\n      rect.width = rect.right - rect.left;\n      rect.height = rect.bottom - rect.top;\n\n      if (rect.width < 0 || rect.height < 0) {\n        return null;\n      } else {\n        return new Rect(rect);\n      }\n    }\n    /**\n     * Returns the area of intersection with another rect.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect [description]\n     * @returns {Number} Area of intersection.\n     */\n\n  }, {\n    key: \"getIntersectionArea\",\n    value: function getIntersectionArea(anotherRect) {\n      var rect = this.getIntersection(anotherRect);\n\n      if (rect) {\n        return rect.getArea();\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Returns the area of the rect.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getArea\",\n    value: function getArea() {\n      return this.width * this.height;\n    }\n    /**\n     * Returns a new rect, a part of the original rect, which is actually visible to the user,\n     * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS\n     * other than `\"visible\"`.\n     *\n     * If there's no such visible rect, which is when the rect is limited by one or many of\n     * the ancestors, `null` is returned.\n     *\n     * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.\n     */\n\n  }, {\n    key: \"getVisible\",\n    value: function getVisible() {\n      var source = this._source;\n      var visibleRect = this.clone(); // There's no ancestor to crop <body> with the overflow.\n\n      if (!isBody(source)) {\n        var parent = source.parentNode || source.commonAncestorContainer; // Check the ancestors all the way up to the <body>.\n\n        while (parent && !isBody(parent)) {\n          var parentRect = new Rect(parent);\n          var intersectionRect = visibleRect.getIntersection(parentRect);\n\n          if (intersectionRect) {\n            if (intersectionRect.getArea() < visibleRect.getArea()) {\n              // Reduce the visible rect to the intersection.\n              visibleRect = intersectionRect;\n            }\n          } else {\n            // There's no intersection, the rect is completely invisible.\n            return null;\n          }\n\n          parent = parent.parentNode;\n        }\n      }\n\n      return visibleRect;\n    }\n    /**\n     * Checks if all property values ({@link #top}, {@link #left}, {@link #right},\n     * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect\n     * instances.\n     *\n     * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.\n     * @returns {Boolean} `true` when Rects are equal. `false` otherwise.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(anotherRect) {\n      var _iterator = _createForOfIteratorHelper(rectProperties),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prop = _step.value;\n\n          if (this[prop] !== anotherRect[prop]) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether a rect fully contains another rect instance.\n     *\n     * @param {module:utils/dom/rect~Rect} anotherRect\n     * @returns {Boolean} `true` if contains, `false` otherwise.\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(anotherRect) {\n      var intersectRect = this.getIntersection(anotherRect);\n      return !!(intersectRect && intersectRect.isEqual(anotherRect));\n    }\n    /**\n     * Excludes scrollbars and CSS borders from the rect.\n     *\n     * * Borders are removed when {@link #_source} is an HTML element.\n     * * Scrollbars are excluded from HTML elements and the `window`.\n     *\n     * @returns {module:utils/dom/rect~Rect} A rect which has been updated.\n     */\n\n  }, {\n    key: \"excludeScrollbarsAndBorders\",\n    value: function excludeScrollbarsAndBorders() {\n      var source = this._source;\n      var scrollBarWidth, scrollBarHeight, direction;\n\n      if (isWindow(source)) {\n        scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;\n        scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;\n        direction = source.getComputedStyle(source.document.documentElement).direction;\n      } else {\n        var borderWidths = getBorderWidths(this._source);\n        scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;\n        scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;\n        direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;\n        this.left += borderWidths.left;\n        this.top += borderWidths.top;\n        this.right -= borderWidths.right;\n        this.bottom -= borderWidths.bottom;\n        this.width = this.right - this.left;\n        this.height = this.bottom - this.top;\n      }\n\n      this.width -= scrollBarWidth;\n\n      if (direction === 'ltr') {\n        this.right -= scrollBarWidth;\n      } else {\n        this.left += scrollBarWidth;\n      }\n\n      this.height -= scrollBarHeight;\n      this.bottom -= scrollBarHeight;\n      return this;\n    }\n    /**\n     * Returns an array of rects of the given native DOM Range.\n     *\n     * @param {Range} range A native DOM range.\n     * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.\n     */\n\n  }], [{\n    key: \"getDomRangeRects\",\n    value: function getDomRangeRects(range) {\n      var rects = []; // Safari does not iterate over ClientRectList using for...of loop.\n\n      var clientRects = Array.from(range.getClientRects());\n\n      if (clientRects.length) {\n        var _iterator2 = _createForOfIteratorHelper(clientRects),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var rect = _step2.value;\n            rects.push(new Rect(rect));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } // If there's no client rects for the Range, use parent container's bounding rect\n      // instead and adjust rect's width to simulate the actual geometry of such range.\n      // https://github.com/ckeditor/ckeditor5-utils/issues/153\n      // https://github.com/ckeditor/ckeditor5-ui/issues/317\n      else {\n        var startContainer = range.startContainer;\n\n        if (isText(startContainer)) {\n          startContainer = startContainer.parentNode;\n        }\n\n        var _rect = new Rect(startContainer.getBoundingClientRect());\n\n        _rect.right = _rect.left;\n        _rect.width = 0;\n        rects.push(_rect);\n      }\n\n      return rects;\n    }\n    /**\n     * Returns a bounding rectangle that contains all the given `rects`.\n     *\n     * @param {Iterable.<module:utils/dom/rect~Rect>} rects A list of rectangles that should be contained in the result rectangle.\n     * @returns {module:utils/dom/rect~Rect|null} Bounding rectangle or `null` if no `rects` were given.\n     */\n\n  }, {\n    key: \"getBoundingRect\",\n    value: function getBoundingRect(rects) {\n      var boundingRectData = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY\n      };\n      var rectangleCount = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(rects),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var rect = _step3.value;\n          rectangleCount++;\n          boundingRectData.left = Math.min(boundingRectData.left, rect.left);\n          boundingRectData.top = Math.min(boundingRectData.top, rect.top);\n          boundingRectData.right = Math.max(boundingRectData.right, rect.right);\n          boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (rectangleCount == 0) {\n        return null;\n      }\n\n      boundingRectData.width = boundingRectData.right - boundingRectData.left;\n      boundingRectData.height = boundingRectData.bottom - boundingRectData.top;\n      return new Rect(boundingRectData);\n    }\n  }]);\n\n  return Rect;\n}(); // Acquires all the rect properties from the passed source.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} rect\n// @param {ClientRect|module:utils/dom/rect~Rect|Object} source\n\n\nexport { Rect as default };\n\nfunction copyRectProperties(rect, source) {\n  var _iterator4 = _createForOfIteratorHelper(rectProperties),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var p = _step4.value;\n      rect[p] = source[p];\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n} // Checks if provided object is a <body> HTML element.\n//\n// @private\n// @param {HTMLElement|Range} elementOrRange\n// @returns {Boolean}\n\n\nfunction isBody(elementOrRange) {\n  if (!isElement(elementOrRange)) {\n    return false;\n  }\n\n  return elementOrRange === elementOrRange.ownerDocument.body;\n}","map":null,"metadata":{},"sourceType":"module"}