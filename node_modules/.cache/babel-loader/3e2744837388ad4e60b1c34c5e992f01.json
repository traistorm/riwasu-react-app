{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/editingcontroller\n */\nimport RootEditableElement from '../view/rooteditableelement';\nimport View from '../view/view';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { clearAttributes, convertCollapsedSelection, convertRangeSelection, insertAttributesAndChildren, insertText, remove } from '../conversion/downcasthelpers';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { convertSelectionChange } from '../conversion/upcasthelpers'; // @if CK_DEBUG_ENGINE // const { dumpTrees, initDocumentDumping } = require( '../dev-utils/utils' );\n\n/**\n * A controller for the editing pipeline. The editing pipeline controls the {@link ~EditingController#model model} rendering,\n * including selection handling. It also creates the {@link ~EditingController#view view} which builds a\n * browser-independent virtualization over the DOM elements. The editing controller also attaches default converters.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar EditingController = /*#__PURE__*/function () {\n  /**\n   * Creates an editing controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Editing model.\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  function EditingController(model, stylesProcessor) {\n    var _this = this;\n\n    _classCallCheck(this, EditingController);\n\n    /**\n     * Editor model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Editing view controller.\n     *\n     * @readonly\n     * @member {module:engine/view/view~View}\n     */\n\n    this.view = new View(stylesProcessor);\n    /**\n     * A mapper that describes the model-view binding.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher that converts changes from the model to the {@link #view editing view}.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #downcastDispatcher\n     */\n\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper,\n      schema: model.schema\n    });\n    var doc = this.model.document;\n    var selection = doc.selection;\n    var markers = this.model.markers; // When plugins listen on model changes (on selection change, post fixers, etc.) and change the view as a result of\n    // the model's change, they might trigger view rendering before the conversion is completed (e.g. before the selection\n    // is converted). We disable rendering for the length of the outermost model change() block to prevent that.\n    //\n    // See https://github.com/ckeditor/ckeditor5-engine/issues/1528\n\n    this.listenTo(this.model, '_beforeChanges', function () {\n      _this.view._disableRendering(true);\n    }, {\n      priority: 'highest'\n    });\n    this.listenTo(this.model, '_afterChanges', function () {\n      _this.view._disableRendering(false);\n    }, {\n      priority: 'lowest'\n    }); // Whenever model document is changed, convert those changes to the view (using model.Document#differ).\n    // Do it on 'low' priority, so changes are converted after other listeners did their job.\n    // Also convert model selection.\n\n    this.listenTo(doc, 'change', function () {\n      _this.view.change(function (writer) {\n        _this.downcastDispatcher.convertChanges(doc.differ, markers, writer);\n\n        _this.downcastDispatcher.convertSelection(selection, markers, writer);\n      });\n    }, {\n      priority: 'low'\n    }); // Convert selection from the view to the model when it changes in the view.\n\n    this.listenTo(this.view.document, 'selectionChange', convertSelectionChange(this.model, this.mapper)); // Attach default model converters.\n\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    this.downcastDispatcher.on('insert', insertAttributesAndChildren(), {\n      priority: 'lowest'\n    });\n    this.downcastDispatcher.on('remove', remove(), {\n      priority: 'low'\n    }); // Attach default model selection converters.\n\n    this.downcastDispatcher.on('selection', clearAttributes(), {\n      priority: 'high'\n    });\n    this.downcastDispatcher.on('selection', convertRangeSelection(), {\n      priority: 'low'\n    });\n    this.downcastDispatcher.on('selection', convertCollapsedSelection(), {\n      priority: 'low'\n    }); // Binds {@link module:engine/view/document~Document#roots view roots collection} to\n    // {@link module:engine/model/document~Document#roots model roots collection} so creating\n    // model root automatically creates corresponding view root.\n\n    this.view.document.roots.bindTo(this.model.document.roots).using(function (root) {\n      // $graveyard is a special root that has no reflection in the view.\n      if (root.rootName == '$graveyard') {\n        return null;\n      }\n\n      var viewRoot = new RootEditableElement(_this.view.document, root.name);\n      viewRoot.rootName = root.rootName;\n\n      _this.mapper.bindElements(root, viewRoot);\n\n      return viewRoot;\n    }); // @if CK_DEBUG_ENGINE // initDocumentDumping( this.model.document );\n    // @if CK_DEBUG_ENGINE // initDocumentDumping( this.view.document );\n    // @if CK_DEBUG_ENGINE // dumpTrees( this.model.document, this.model.document.version );\n    // @if CK_DEBUG_ENGINE // dumpTrees( this.view.document, this.model.document.version );\n    // @if CK_DEBUG_ENGINE // this.model.document.on( 'change', () => {\n    // @if CK_DEBUG_ENGINE //\tdumpTrees( this.view.document, this.model.document.version );\n    // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n  }\n  /**\n   * Removes all event listeners attached to the `EditingController`. Destroys all objects created\n   * by `EditingController` that need to be destroyed.\n   */\n\n\n  _createClass(EditingController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.view.destroy();\n      this.stopListening();\n    }\n    /**\n     * Calling this method will refresh the marker by triggering the downcast conversion for it.\n     *\n     * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}\n     * without changing any marker data. For instance:\n     *\n     *\t\tlet isCommentActive = false;\n     *\n     *\t\tmodel.conversion.markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: data => {\n     *\t\t\t\tconst classes = [ 'comment-marker' ];\n     *\n     *\t\t\t\tif ( isCommentActive ) {\n     *\t\t\t\t\tclasses.push( 'comment-marker--active' );\n     *\t\t\t\t}\n     *\n     *\t\t\t\treturn { classes };\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// ...\n     *\n     *\t\t// Change the property that indicates if marker is displayed as active or not.\n     *\t\tisCommentActive = true;\n     *\n     *\t\t// Reconverting will downcast and synchronize the marker with the new isCommentActive state value.\n     *\t\teditor.editing.reconvertMarker( 'comment' );\n     *\n     * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.\n     *\n     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n     */\n\n  }, {\n    key: \"reconvertMarker\",\n    value: function reconvertMarker(markerOrName) {\n      var _this2 = this;\n\n      var markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n      var currentMarker = this.model.markers.get(markerName);\n\n      if (!currentMarker) {\n        /**\n         * The marker with the provided name does not exist and cannot be reconverted.\n         *\n         * @error editingcontroller-reconvertmarker-marker-not-exist\n         * @param {String} markerName The name of the reconverted marker.\n         */\n        throw new CKEditorError('editingcontroller-reconvertmarker-marker-not-exist', this, {\n          markerName: markerName\n        });\n      }\n\n      this.model.change(function () {\n        _this2.model.markers._refresh(currentMarker);\n      });\n    }\n    /**\n     * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).\n     *\n     * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,\n     * when the view structure depends not only on the associated model data but also on some external state.\n     *\n     * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.\n     *\n     * @param {module:engine/model/item~Item} item Item to refresh.\n     */\n\n  }, {\n    key: \"reconvertItem\",\n    value: function reconvertItem(item) {\n      var _this3 = this;\n\n      this.model.change(function () {\n        _this3.model.document.differ._refreshItem(item);\n      });\n    }\n  }]);\n\n  return EditingController;\n}();\n\nexport { EditingController as default };\nmix(EditingController, ObservableMixin);","map":null,"metadata":{},"sourceType":"module"}