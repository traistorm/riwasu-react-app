{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/toolbar/block/blocktoolbar\n */\n\n/* global window */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport pilcrow from '@ckeditor/ckeditor5-core/theme/icons/pilcrow.svg';\nimport BlockButtonView from './blockbuttonview';\nimport BalloonPanelView from '../../panel/balloon/balloonpanelview';\nimport ToolbarView from '../toolbarview';\nimport clickOutsideHandler from '../../bindings/clickoutsidehandler';\nimport { getOptimalPosition } from '@ckeditor/ckeditor5-utils/src/dom/position';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\nimport normalizeToolbarConfig from '../normalizetoolbarconfig';\nimport ResizeObserver from '@ckeditor/ckeditor5-utils/src/dom/resizeobserver';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nvar toPx = toUnit('px');\n/**\n * The block toolbar plugin.\n *\n * This plugin provides a button positioned next to the block of content where the selection is anchored.\n * Upon clicking the button, a dropdown providing access to editor features shows up, as configured in\n * {@link module:core/editor/editorconfig~EditorConfig#blockToolbar}.\n *\n * By default, the button is displayed next to all elements marked in {@link module:engine/model/schema~Schema}\n * as `$block` for which the toolbar provides at least one option.\n *\n * By default, the button is attached so its right boundary is touching the\n * {@link module:engine/view/editableelement~EditableElement}:\n *\n * \t\t __ |\n * \t\t|  ||  This is a block of content that the\n * \t\t ¯¯ |  button is attached to. This is a\n * \t\t    |  block of content that the button is\n * \t\t    |  attached to.\n *\n * The position of the button can be adjusted using the CSS `transform` property:\n *\n * \t\t.ck-block-toolbar-button {\n * \t\t\ttransform: translateX( -10px );\n * \t\t}\n *\n * \t\t __   |\n * \t\t|  |  |  This is a block of content that the\n * \t\t ¯¯   |  button is attached to. This is a\n * \t\t      |  block of content that the button is\n * \t\t      |  attached to.\n *\n * **Note**: If you plan to run the editor in a right–to–left (RTL) language, keep in mind the button\n * will be attached to the **right** boundary of the editable area. In that case, make sure the\n * CSS position adjustment works properly by adding the following styles:\n *\n * \t\t.ck[dir=\"rtl\"] .ck-block-toolbar-button {\n * \t\t\ttransform: translateX( 10px );\n * \t\t}\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar BlockToolbar = /*#__PURE__*/function (_Plugin) {\n  _inherits(BlockToolbar, _Plugin);\n\n  _createClass(BlockToolbar, null, [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'BlockToolbar';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function BlockToolbar(editor) {\n    var _this;\n\n    _classCallCheck(this, BlockToolbar);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BlockToolbar).call(this, editor));\n    /**\n     * A cached and normalized `config.blockToolbar` object.\n     *\n     * @type {module:core/editor/editorconfig~EditorConfig#blockToolbar}\n     * @private\n     */\n\n    _this._blockToolbarConfig = normalizeToolbarConfig(_this.editor.config.get('blockToolbar'));\n    /**\n     * The toolbar view.\n     *\n     * @type {module:ui/toolbar/toolbarview~ToolbarView}\n     */\n\n    _this.toolbarView = _this._createToolbarView();\n    /**\n     * The balloon panel view, containing the {@link #toolbarView}.\n     *\n     * @type {module:ui/panel/balloon/balloonpanelview~BalloonPanelView}\n     */\n\n    _this.panelView = _this._createPanelView();\n    /**\n     * The button view that opens the {@link #toolbarView}.\n     *\n     * @type {module:ui/toolbar/block/blockbuttonview~BlockButtonView}\n     */\n\n    _this.buttonView = _this._createButtonView();\n    /**\n     * An instance of the resize observer that allows to respond to changes in editable's geometry\n     * so the toolbar can stay within its boundaries (and group toolbar items that do not fit).\n     *\n     * **Note**: Used only when `shouldNotGroupWhenFull` was **not** set in the\n     * {@link module:core/editor/editorconfig~EditorConfig#blockToolbar configuration}.\n     *\n     * **Note:** Created in {@link #afterInit}.\n     *\n     * @protected\n     * @member {module:utils/dom/resizeobserver~ResizeObserver}\n     */\n\n    _this._resizeObserver = null; // Close the #panelView upon clicking outside of the plugin UI.\n\n    clickOutsideHandler({\n      emitter: _this.panelView,\n      contextElements: [_this.panelView.element, _this.buttonView.element],\n      activator: function activator() {\n        return _this.panelView.isVisible;\n      },\n      callback: function callback() {\n        return _this._hidePanel();\n      }\n    });\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(BlockToolbar, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var editor = this.editor; // Hides panel on a direct selection change.\n\n      this.listenTo(editor.model.document.selection, 'change:range', function (evt, data) {\n        if (data.directChange) {\n          _this2._hidePanel();\n        }\n      });\n      this.listenTo(editor.ui, 'update', function () {\n        return _this2._updateButton();\n      }); // `low` priority is used because of https://github.com/ckeditor/ckeditor5-core/issues/133.\n\n      this.listenTo(editor, 'change:isReadOnly', function () {\n        return _this2._updateButton();\n      }, {\n        priority: 'low'\n      });\n      this.listenTo(editor.ui.focusTracker, 'change:isFocused', function () {\n        return _this2._updateButton();\n      }); // Reposition button on resize.\n\n      this.listenTo(this.buttonView, 'change:isVisible', function (evt, name, isVisible) {\n        if (isVisible) {\n          // Keep correct position of button and panel on window#resize.\n          _this2.buttonView.listenTo(window, 'resize', function () {\n            return _this2._updateButton();\n          });\n        } else {\n          // Stop repositioning button when is hidden.\n          _this2.buttonView.stopListening(window, 'resize'); // Hide the panel when the button disappears.\n\n\n          _this2._hidePanel();\n        }\n      });\n    }\n    /**\n     * Fills the toolbar with its items based on the configuration.\n     *\n     * **Note:** This needs to be done after all plugins are ready.\n     *\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"afterInit\",\n    value: function afterInit() {\n      var _this3 = this;\n\n      var factory = this.editor.ui.componentFactory;\n      var config = this._blockToolbarConfig;\n      this.toolbarView.fillFromConfig(config, factory); // Hide panel before executing each button in the panel.\n\n      var _iterator = _createForOfIteratorHelper(this.toolbarView.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          item.on('execute', function () {\n            return _this3._hidePanel(true);\n          }, {\n            priority: 'high'\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!config.shouldNotGroupWhenFull) {\n        this.listenTo(this.editor, 'ready', function () {\n          var editableElement = _this3.editor.ui.view.editable.element; // Set #toolbarView's max-width just after the initialization and update it on the editable resize.\n\n          _this3._resizeObserver = new ResizeObserver(editableElement, function () {\n            _this3.toolbarView.maxWidth = _this3._getToolbarMaxWidth();\n          });\n        });\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(BlockToolbar.prototype), \"destroy\", this).call(this); // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).\n\n\n      this.panelView.destroy();\n      this.buttonView.destroy();\n      this.toolbarView.destroy();\n\n      if (this._resizeObserver) {\n        this._resizeObserver.destroy();\n      }\n    }\n    /**\n     * Creates the {@link #toolbarView}.\n     *\n     * @private\n     * @returns {module:ui/toolbar/toolbarview~ToolbarView}\n     */\n\n  }, {\n    key: \"_createToolbarView\",\n    value: function _createToolbarView() {\n      var _this4 = this;\n\n      var shouldGroupWhenFull = !this._blockToolbarConfig.shouldNotGroupWhenFull;\n      var toolbarView = new ToolbarView(this.editor.locale, {\n        shouldGroupWhenFull: shouldGroupWhenFull,\n        isFloating: true\n      }); // When toolbar lost focus then panel should hide.\n\n      toolbarView.focusTracker.on('change:isFocused', function (evt, name, is) {\n        if (!is) {\n          _this4._hidePanel();\n        }\n      });\n      return toolbarView;\n    }\n    /**\n     * Creates the {@link #panelView}.\n     *\n     * @private\n     * @returns {module:ui/panel/balloon/balloonpanelview~BalloonPanelView}\n     */\n\n  }, {\n    key: \"_createPanelView\",\n    value: function _createPanelView() {\n      var _this5 = this;\n\n      var editor = this.editor;\n      var panelView = new BalloonPanelView(editor.locale);\n      panelView.content.add(this.toolbarView);\n      panelView.class = 'ck-toolbar-container';\n      editor.ui.view.body.add(panelView);\n      editor.ui.focusTracker.add(panelView.element); // Close #panelView on `Esc` press.\n\n      this.toolbarView.keystrokes.set('Esc', function (evt, cancel) {\n        _this5._hidePanel(true);\n\n        cancel();\n      });\n      return panelView;\n    }\n    /**\n     * Creates the {@link #buttonView}.\n     *\n     * @private\n     * @returns {module:ui/toolbar/block/blockbuttonview~BlockButtonView}\n     */\n\n  }, {\n    key: \"_createButtonView\",\n    value: function _createButtonView() {\n      var _this6 = this;\n\n      var editor = this.editor;\n      var t = editor.t;\n      var buttonView = new BlockButtonView(editor.locale);\n      buttonView.set({\n        label: t('Edit block'),\n        icon: pilcrow,\n        withText: false\n      }); // Bind the panelView observable properties to the buttonView.\n\n      buttonView.bind('isOn').to(this.panelView, 'isVisible');\n      buttonView.bind('tooltip').to(this.panelView, 'isVisible', function (isVisible) {\n        return !isVisible;\n      }); // Toggle the panelView upon buttonView#execute.\n\n      this.listenTo(buttonView, 'execute', function () {\n        if (!_this6.panelView.isVisible) {\n          _this6._showPanel();\n        } else {\n          _this6._hidePanel(true);\n        }\n      });\n      editor.ui.view.body.add(buttonView);\n      editor.ui.focusTracker.add(buttonView.element);\n      return buttonView;\n    }\n    /**\n     * Shows or hides the button.\n     * When all the conditions for displaying the button are matched, it shows the button. Hides otherwise.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateButton\",\n    value: function _updateButton() {\n      var editor = this.editor;\n      var model = editor.model;\n      var view = editor.editing.view; // Hides the button when the editor is not focused.\n\n      if (!editor.ui.focusTracker.isFocused) {\n        this._hideButton();\n\n        return;\n      } // Hides the button when the editor switches to the read-only mode.\n\n\n      if (editor.isReadOnly) {\n        this._hideButton();\n\n        return;\n      } // Get the first selected block, button will be attached to this element.\n\n\n      var modelTarget = Array.from(model.document.selection.getSelectedBlocks())[0]; // Hides the button when there is no enabled item in toolbar for the current block element.\n\n      if (!modelTarget || Array.from(this.toolbarView.items).every(function (item) {\n        return !item.isEnabled;\n      })) {\n        this._hideButton();\n\n        return;\n      } // Get DOM target element.\n\n\n      var domTarget = view.domConverter.mapViewToDom(editor.editing.mapper.toViewElement(modelTarget)); // Show block button.\n\n      this.buttonView.isVisible = true; // Attach block button to target DOM element.\n\n      this._attachButtonToElement(domTarget); // When panel is opened then refresh it position to be properly aligned with block button.\n\n\n      if (this.panelView.isVisible) {\n        this._showPanel();\n      }\n    }\n    /**\n     * Hides the button.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_hideButton\",\n    value: function _hideButton() {\n      this.buttonView.isVisible = false;\n    }\n    /**\n     * Shows the {@link #toolbarView} attached to the {@link #buttonView}.\n     * If the toolbar is already visible, then it simply repositions it.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_showPanel\",\n    value: function _showPanel() {\n      var wasVisible = this.panelView.isVisible; // So here's the thing: If there was no initial panelView#show() or these two were in different order, the toolbar\n      // positioning will break in RTL editors. Weird, right? What you show know is that the toolbar\n      // grouping works thanks to:\n      //\n      // * the ResizeObserver, which kicks in as soon as the toolbar shows up in DOM (becomes visible again).\n      // * the observable ToolbarView#maxWidth, which triggers re-grouping when changed.\n      //\n      // Here are the possible scenarios:\n      //\n      // 1. (WRONG ❌) If the #maxWidth is set when the toolbar is invisible, it won't affect item grouping (no DOMRects, no grouping).\n      //    Then, when panelView.pin() is called, the position of the toolbar will be calculated for the old\n      //    items grouping state, and when finally ResizeObserver kicks in (hey, the toolbar is visible now, right?)\n      //    it will group/ungroup some items and the length of the toolbar will change. But since in RTL the toolbar\n      //    is attached on the right side and the positioning uses CSS \"left\", it will result in the toolbar shifting\n      //    to the left and being displayed in the wrong place.\n      // 2. (WRONG ❌) If the panelView.pin() is called first and #maxWidth set next, then basically the story repeats. The balloon\n      //    calculates the position for the old toolbar grouping state, then the toolbar re-groups items and because\n      //    it is positioned using CSS \"left\" it will move.\n      // 3. (RIGHT ✅) We show the panel first (the toolbar does re-grouping but it does not matter), then the #maxWidth\n      //    is set allowing the toolbar to re-group again and finally panelView.pin() does the positioning when the\n      //    items grouping state is stable and final.\n      //\n      // https://github.com/ckeditor/ckeditor5/issues/6449, https://github.com/ckeditor/ckeditor5/issues/6575\n\n      this.panelView.show();\n      this.toolbarView.maxWidth = this._getToolbarMaxWidth();\n      this.panelView.pin({\n        target: this.buttonView.element,\n        limiter: this.editor.ui.getEditableElement()\n      });\n\n      if (!wasVisible) {\n        this.toolbarView.items.get(0).focus();\n      }\n    }\n    /**\n     * Hides the {@link #toolbarView}.\n     *\n     * @private\n     * @param {Boolean} [focusEditable=false] When `true`, the editable will be focused after hiding the panel.\n     */\n\n  }, {\n    key: \"_hidePanel\",\n    value: function _hidePanel(focusEditable) {\n      this.panelView.isVisible = false;\n\n      if (focusEditable) {\n        this.editor.editing.view.focus();\n      }\n    }\n    /**\n     * Attaches the {@link #buttonView} to the target block of content.\n     *\n     * @protected\n     * @param {HTMLElement} targetElement Target element.\n     */\n\n  }, {\n    key: \"_attachButtonToElement\",\n    value: function _attachButtonToElement(targetElement) {\n      var _this7 = this;\n\n      var contentStyles = window.getComputedStyle(targetElement);\n      var editableRect = new Rect(this.editor.ui.getEditableElement());\n      var contentPaddingTop = parseInt(contentStyles.paddingTop, 10); // When line height is not an integer then thread it as \"normal\".\n      // MDN says that 'normal' == ~1.2 on desktop browsers.\n\n      var contentLineHeight = parseInt(contentStyles.lineHeight, 10) || parseInt(contentStyles.fontSize, 10) * 1.2;\n      var position = getOptimalPosition({\n        element: this.buttonView.element,\n        target: targetElement,\n        positions: [function (contentRect, buttonRect) {\n          var left;\n\n          if (_this7.editor.locale.uiLanguageDirection === 'ltr') {\n            left = editableRect.left - buttonRect.width;\n          } else {\n            left = editableRect.right;\n          }\n\n          return {\n            top: contentRect.top + contentPaddingTop + (contentLineHeight - buttonRect.height) / 2,\n            left: left\n          };\n        }]\n      });\n      this.buttonView.top = position.top;\n      this.buttonView.left = position.left;\n    }\n    /**\n     * Gets the {@link #toolbarView} max-width, based on\n     * editable width plus distance between farthest edge of the {@link #buttonView} and the editable.\n     *\n     * @private\n     * @returns {String} maxWidth A maximum width that toolbar can have, in pixels.\n     */\n\n  }, {\n    key: \"_getToolbarMaxWidth\",\n    value: function _getToolbarMaxWidth() {\n      var editableElement = this.editor.ui.view.editable.element;\n      var editableRect = new Rect(editableElement);\n      var buttonRect = new Rect(this.buttonView.element);\n      var isRTL = this.editor.locale.uiLanguageDirection === 'rtl';\n      var offset = isRTL ? buttonRect.left - editableRect.right + buttonRect.width : editableRect.left - buttonRect.left;\n      return toPx(editableRect.width + offset);\n    }\n  }]);\n\n  return BlockToolbar;\n}(Plugin);\n/**\n * The block toolbar configuration. Used by the {@link module:ui/toolbar/block/blocktoolbar~BlockToolbar}\n * feature.\n *\n *\t\tconst config = {\n *\t\t\tblockToolbar: [ 'paragraph', 'heading1', 'heading2', 'bulletedList', 'numberedList' ]\n *\t\t};\n *\n * You can also use `'|'` to create a separator between groups of items:\n *\n *\t\tconst config = {\n *\t\t\tblockToolbar: [ 'paragraph', 'heading1', 'heading2', '|', 'bulletedList', 'numberedList' ]\n *\t\t};\n *\n * ## Configuring items grouping\n *\n * You can prevent automatic items grouping by setting the `shouldNotGroupWhenFull` option:\n *\n *\t\tconst config = {\n *\t\t\tblockToolbar: {\n *\t\t\t\titems: [ 'paragraph', 'heading1', 'heading2', '|', 'bulletedList', 'numberedList' ],\n *\t\t\t\tshouldNotGroupWhenFull: true\n *\t\t\t},\n *\t\t};\n *\n * Read more about configuring the main editor toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.\n *\n * @member {Array.<String>|Object} module:core/editor/editorconfig~EditorConfig#blockToolbar\n */\n\n\nexport { BlockToolbar as default };","map":null,"metadata":{},"sourceType":"module"}