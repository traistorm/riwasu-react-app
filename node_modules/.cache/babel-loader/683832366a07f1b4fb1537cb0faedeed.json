{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global setTimeout, clearTimeout */\n\n/**\n * @module utils/focustracker\n */\nimport DomEmitterMixin from './dom/emittermixin';\nimport ObservableMixin from './observablemixin';\nimport CKEditorError from './ckeditorerror';\nimport mix from './mix';\n/**\n * Allows observing a group of `HTMLElement`s whether at least one of them is focused.\n *\n * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,\n * or were used outside of its UI.\n *\n * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`\n * which contain other `focusable` elements. But note that this wrapper element has to be focusable too\n * (have e.g. `tabindex=\"-1\"`).\n *\n * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking \"Deep dive into focus tracking\" guide} to learn more.\n *\n * @mixes module:utils/dom/emittermixin~EmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar FocusTracker = /*#__PURE__*/function () {\n  function FocusTracker() {\n    _classCallCheck(this, FocusTracker);\n\n    /**\n     * True when one of the registered elements is focused.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isFocused\n     */\n    this.set('isFocused', false);\n    /**\n     * The currently focused element.\n     *\n     * While {@link #isFocused `isFocused`} remains `true`, the focus can\n     * move between different UI elements. This property tracks those\n     * elements and tells which one is currently focused.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement|null} #focusedElement\n     */\n\n    this.set('focusedElement', null);\n    /**\n     * List of registered elements.\n     *\n     * @private\n     * @member {Set.<HTMLElement>}\n     */\n\n    this._elements = new Set();\n    /**\n     * Event loop timeout.\n     *\n     * @private\n     * @member {Number}\n     */\n\n    this._nextEventLoopTimeout = null;\n  }\n  /**\n   * Starts tracking the specified element.\n   *\n   * @param {HTMLElement} element\n   */\n\n\n  _createClass(FocusTracker, [{\n    key: \"add\",\n    value: function add(element) {\n      var _this = this;\n\n      if (this._elements.has(element)) {\n        /**\n         * This element is already tracked by {@link module:utils/focustracker~FocusTracker}.\n         *\n         * @error focustracker-add-element-already-exist\n         */\n        throw new CKEditorError('focustracker-add-element-already-exist', this);\n      }\n\n      this.listenTo(element, 'focus', function () {\n        return _this._focus(element);\n      }, {\n        useCapture: true\n      });\n      this.listenTo(element, 'blur', function () {\n        return _this._blur();\n      }, {\n        useCapture: true\n      });\n\n      this._elements.add(element);\n    }\n    /**\n     * Stops tracking the specified element and stops listening on this element.\n     *\n     * @param {HTMLElement} element\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(element) {\n      if (element === this.focusedElement) {\n        this._blur(element);\n      }\n\n      if (this._elements.has(element)) {\n        this.stopListening(element);\n\n        this._elements.delete(element);\n      }\n    }\n    /**\n     * Destroys the focus tracker by:\n     * - Disabling all event listeners attached to tracked elements.\n     * - Removing all tracked elements that were previously added.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n    }\n    /**\n     * Stores currently focused element and set {#isFocused} as `true`.\n     *\n     * @private\n     * @param {HTMLElement} element Element which has been focused.\n     */\n\n  }, {\n    key: \"_focus\",\n    value: function _focus(element) {\n      clearTimeout(this._nextEventLoopTimeout);\n      this.focusedElement = element;\n      this.isFocused = true;\n    }\n    /**\n     * Clears currently focused element and set {@link #isFocused} as `false`.\n     * This method uses `setTimeout` to change order of fires `blur` and `focus` events.\n     *\n     * @private\n     * @fires blur\n     */\n\n  }, {\n    key: \"_blur\",\n    value: function _blur() {\n      var _this2 = this;\n\n      clearTimeout(this._nextEventLoopTimeout);\n      this._nextEventLoopTimeout = setTimeout(function () {\n        _this2.focusedElement = null;\n        _this2.isFocused = false;\n      }, 0);\n    }\n    /**\n     * @event focus\n     */\n\n    /**\n     * @event blur\n     */\n\n  }]);\n\n  return FocusTracker;\n}();\n\nexport { FocusTracker as default };\nmix(FocusTracker, DomEmitterMixin);\nmix(FocusTracker, ObservableMixin);","map":null,"metadata":{},"sourceType":"module"}