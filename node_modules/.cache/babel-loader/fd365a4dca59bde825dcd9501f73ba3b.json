{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/panel/sticky/stickypanelview\n */\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport View from '../../view';\nimport Template from '../../template';\nimport toUnit from '@ckeditor/ckeditor5-utils/src/dom/tounit';\nimport '../../../theme/components/panel/stickypanel.css';\nvar toPx = toUnit('px');\n/**\n * The sticky panel view class.\n */\n\nvar StickyPanelView = /*#__PURE__*/function (_View) {\n  _inherits(StickyPanelView, _View);\n\n  /**\n   * @inheritDoc\n   */\n  function StickyPanelView(locale) {\n    var _this;\n\n    _classCallCheck(this, StickyPanelView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StickyPanelView).call(this, locale));\n    var bind = _this.bindTemplate;\n    /**\n     * Controls whether the sticky panel should be active.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isActive\n     */\n\n    _this.set('isActive', false);\n    /**\n     * Controls whether the sticky panel is in the \"sticky\" state.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} #isSticky\n     */\n\n\n    _this.set('isSticky', false);\n    /**\n     * The limiter element for the sticky panel instance. Its bounding rect limits\n     * the \"stickyness\" of the panel, i.e. when the panel reaches the bottom\n     * edge of the limiter, it becomes sticky to that edge and does not float\n     * off the limiter. It is mandatory for the panel to work properly and once\n     * set, it cannot be changed.\n     *\n     * @readonly\n     * @observable\n     * @member {HTMLElement} #limiterElement\n     */\n\n\n    _this.set('limiterElement', null);\n    /**\n     * The offset from the bottom edge of {@link #limiterElement}\n     * which stops the panel from stickying any further to prevent limiter's content\n     * from being completely covered.\n     *\n     * @readonly\n     * @observable\n     * @default 50\n     * @member {Number} #limiterBottomOffset\n     */\n\n\n    _this.set('limiterBottomOffset', 50);\n    /**\n     * The offset from the top edge of the web browser's viewport which makes the\n     * panel become sticky. The default value is `0`, which means the panel becomes\n     * sticky when it's upper edge touches the top of the page viewport.\n     *\n     * This attribute is useful when the web page has UI elements positioned to the top\n     * either using `position: fixed` or `position: sticky`, which would cover the\n     * sticky panel or viceâ€“versa (depending on the `z-index` hierarchy).\n     *\n     * Bound to {@link module:core/editor/editorui~EditorUI#viewportOffset `EditorUI#viewportOffset`}.\n     *\n     * If {@link module:core/editor/editorconfig~EditorConfig#ui `EditorConfig#ui.viewportOffset.top`} is defined, then\n     * it will override the default value.\n     *\n     * @observable\n     * @default 0\n     * @member {Number} #viewportTopOffset\n     */\n\n\n    _this.set('viewportTopOffset', 0);\n    /**\n     * Controls the `margin-left` CSS style of the panel.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {String} #_marginLeft\n     */\n\n\n    _this.set('_marginLeft', null);\n    /**\n     * Set `true` if the sticky panel reached the bottom edge of the\n     * {@link #limiterElement}.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_isStickyToTheLimiter\n     */\n\n\n    _this.set('_isStickyToTheLimiter', false);\n    /**\n     * Set `true` if the sticky panel uses the {@link #viewportTopOffset},\n     * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}\n     * is not `0`.\n     *\n     * @protected\n     * @readonly\n     * @observable\n     * @member {Boolean} #_hasViewportTopOffset\n     */\n\n\n    _this.set('_hasViewportTopOffset', false);\n    /**\n     * Collection of the child views which creates balloon panel contents.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n\n    _this.content = _this.createCollection();\n    /**\n     * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.\n     *\n     * @protected\n     * @member {Object} #_panelRect\n     */\n\n    /**\n     * The DOM bounding client rect of the {@link #limiterElement}\n     * of the panel.\n     *\n     * @protected\n     * @member {Object} #_limiterRect\n     */\n\n    /**\n     * A dummy element which visually fills the space as long as the\n     * actual panel is sticky. It prevents flickering of the UI.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n\n    _this._contentPanelPlaceholder = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__placeholder'],\n        style: {\n          display: bind.to('isSticky', function (isSticky) {\n            return isSticky ? 'block' : 'none';\n          }),\n          height: bind.to('isSticky', function (isSticky) {\n            return isSticky ? toPx(_this._panelRect.height) : null;\n          })\n        }\n      }\n    }).render();\n    /**\n     * The panel which accepts children into {@link #content} collection.\n     * Also an element which is positioned when {@link #isSticky}.\n     *\n     * @protected\n     * @property {HTMLElement}\n     */\n\n    _this._contentPanel = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel__content', // Toggle class of the panel when \"sticky\" state changes in the view.\n        bind.if('isSticky', 'ck-sticky-panel__content_sticky'), bind.if('_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit')],\n        style: {\n          width: bind.to('isSticky', function (isSticky) {\n            return isSticky ? toPx(_this._contentPanelPlaceholder.getBoundingClientRect().width) : null;\n          }),\n          top: bind.to('_hasViewportTopOffset', function (_hasViewportTopOffset) {\n            return _hasViewportTopOffset ? toPx(_this.viewportTopOffset) : null;\n          }),\n          bottom: bind.to('_isStickyToTheLimiter', function (_isStickyToTheLimiter) {\n            return _isStickyToTheLimiter ? toPx(_this.limiterBottomOffset) : null;\n          }),\n          marginLeft: bind.to('_marginLeft')\n        }\n      },\n      children: _this.content\n    }).render();\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-sticky-panel']\n      },\n      children: [_this._contentPanelPlaceholder, _this._contentPanel]\n    });\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(StickyPanelView, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(StickyPanelView.prototype), \"render\", this).call(this); // Check if the panel should go into the sticky state immediately.\n\n\n      this._checkIfShouldBeSticky(); // Update sticky state of the panel as the window is being scrolled.\n\n\n      this.listenTo(global.window, 'scroll', function () {\n        _this2._checkIfShouldBeSticky();\n      }); // Synchronize with `model.isActive` because sticking an inactive panel is pointless.\n\n      this.listenTo(this, 'change:isActive', function () {\n        _this2._checkIfShouldBeSticky();\n      });\n    }\n    /**\n     * Analyzes the environment to decide whether the panel should\n     * be sticky or not.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_checkIfShouldBeSticky\",\n    value: function _checkIfShouldBeSticky() {\n      var panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();\n\n      var limiterRect;\n\n      if (!this.limiterElement) {\n        this.isSticky = false;\n      } else {\n        limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect(); // The panel must be active to become sticky.\n\n        this.isSticky = this.isActive && // The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).\n        limiterRect.top < this.viewportTopOffset && // The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.\n        // There's no point in entering the sticky mode if the model#limiterElement is very, very small, because\n        // it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel\n        // would be positioned before the model#limiterElement.\n        this._panelRect.height + this.limiterBottomOffset < limiterRect.height;\n      } // Stick the panel to the top edge of the viewport simulating CSS position:sticky.\n      // TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky\n\n\n      if (this.isSticky) {\n        this._isStickyToTheLimiter = limiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;\n        this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;\n        this._marginLeft = this._isStickyToTheLimiter ? null : toPx(-global.window.scrollX);\n      } // Detach the panel from the top edge of the viewport.\n      else {\n        this._isStickyToTheLimiter = false;\n        this._hasViewportTopOffset = false;\n        this._marginLeft = null;\n      }\n    }\n  }]);\n\n  return StickyPanelView;\n}(View);\n\nexport { StickyPanelView as default };","map":null,"metadata":{},"sourceType":"module"}