{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Maps elements, positions and markers between the {@link module:engine/view/document~Document view} and\n * the {@link module:engine/model/model model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map the complex model to/from view relations, you may provide custom callbacks for the\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by the {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds its own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar Mapper = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the mapper.\n   */\n  function Mapper() {\n    var _this = this;\n\n    _classCallCheck(this, Mapper);\n\n    /**\n     * Model element to view element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n    this._modelToViewMapping = new WeakMap();\n    /**\n     * View element to model element mapping.\n     *\n     * @private\n     * @member {WeakMap}\n     */\n\n    this._viewToModelMapping = new WeakMap();\n    /**\n     * A map containing callbacks between view element names and functions evaluating length of view elements\n     * in model.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._viewToModelLengthCallbacks = new Map();\n    /**\n     * Model marker name to view elements mapping.\n     *\n     * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n     * One marker (name) can be mapped to multiple elements.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._markerNameToElements = new Map();\n    /**\n     * View element to model marker names mapping.\n     *\n     * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._elementToMarkerNames = new Map();\n    /**\n     * The map of removed view elements with their current root (used for deferred unbinding).\n     *\n     * @private\n     * @member {Map.<module:engine/view/element~Element,module:engine/view/documentfragment~DocumentFragment>}\n     */\n\n    this._deferredBindingRemovals = new Map();\n    /**\n     * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n     * has been removed, moved or renamed).\n     *\n     * @private\n     * @member {Set.<module:engine/model/markercollection~Marker>}\n     */\n\n    this._unboundMarkerNames = new Set(); // Default mapper algorithm for mapping model position to view position.\n\n    this.on('modelToViewPosition', function (evt, data) {\n      if (data.viewPosition) {\n        return;\n      }\n\n      var viewContainer = _this._modelToViewMapping.get(data.modelPosition.parent);\n\n      if (!viewContainer) {\n        /**\n         * A model position could not be mapped to the view because the parent of the model position\n         * does not have a mapped view element (might have not been converted yet or it has no converter).\n         *\n         * Make sure that the model element is correctly converted to the view.\n         *\n         * @error mapping-model-position-view-parent-not-found\n         */\n        throw new CKEditorError('mapping-model-position-view-parent-not-found', _this, {\n          modelPosition: data.modelPosition\n        });\n      }\n\n      data.viewPosition = _this.findPositionIn(viewContainer, data.modelPosition.offset);\n    }, {\n      priority: 'low'\n    }); // Default mapper algorithm for mapping view position to model position.\n\n    this.on('viewToModelPosition', function (evt, data) {\n      if (data.modelPosition) {\n        return;\n      }\n\n      var viewBlock = _this.findMappedViewAncestor(data.viewPosition);\n\n      var modelParent = _this._viewToModelMapping.get(viewBlock);\n\n      var modelOffset = _this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);\n\n      data.modelPosition = ModelPosition._createAt(modelParent, modelOffset);\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n   * The information that elements are bound is also used to translate positions.\n   *\n   * @param {module:engine/model/element~Element} modelElement Model element.\n   * @param {module:engine/view/element~Element} viewElement View element.\n   */\n\n\n  _createClass(Mapper, [{\n    key: \"bindElements\",\n    value: function bindElements(modelElement, viewElement) {\n      this._modelToViewMapping.set(modelElement, viewElement);\n\n      this._viewToModelMapping.set(viewElement, modelElement);\n    }\n    /**\n     * Unbinds the given {@link module:engine/view/element~Element view element} from the map.\n     *\n     * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n     * will be removed only if model element is still bound to the passed `viewElement`.\n     *\n     * This behavior allows for re-binding model element to another view element without fear of losing the new binding\n     * when the previously bound view element is unbound.\n     *\n     * @param {module:engine/view/element~Element} viewElement View element to unbind.\n     * @param {Object} [options={}] The options object.\n     * @param {Boolean} [options.defer=false] Controls whether the binding should be removed immediately or deferred until a\n     * {@link #flushDeferredBindings `flushDeferredBindings()`} call.\n     */\n\n  }, {\n    key: \"unbindViewElement\",\n    value: function unbindViewElement(viewElement) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var modelElement = this.toModelElement(viewElement);\n\n      if (this._elementToMarkerNames.has(viewElement)) {\n        var _iterator = _createForOfIteratorHelper(this._elementToMarkerNames.get(viewElement)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var markerName = _step.value;\n\n            this._unboundMarkerNames.add(markerName);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (options.defer) {\n        this._deferredBindingRemovals.set(viewElement, viewElement.root);\n      } else {\n        this._viewToModelMapping.delete(viewElement);\n\n        if (this._modelToViewMapping.get(modelElement) == viewElement) {\n          this._modelToViewMapping.delete(modelElement);\n        }\n      }\n    }\n    /**\n     * Unbinds the given {@link module:engine/model/element~Element model element} from the map.\n     *\n     * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding\n     * will be removed only if the view element is still bound to the passed `modelElement`.\n     *\n     * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n     * when the previously bound model element is unbound.\n     *\n     * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n     */\n\n  }, {\n    key: \"unbindModelElement\",\n    value: function unbindModelElement(modelElement) {\n      var viewElement = this.toViewElement(modelElement);\n\n      this._modelToViewMapping.delete(modelElement);\n\n      if (this._viewToModelMapping.get(viewElement) == modelElement) {\n        this._viewToModelMapping.delete(viewElement);\n      }\n    }\n    /**\n     * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element\n     * will be added to the current set of elements bound with the given marker name.\n     *\n     * @param {module:engine/view/element~Element} element Element to bind.\n     * @param {String} name Marker name.\n     */\n\n  }, {\n    key: \"bindElementToMarker\",\n    value: function bindElementToMarker(element, name) {\n      var elements = this._markerNameToElements.get(name) || new Set();\n      elements.add(element);\n      var names = this._elementToMarkerNames.get(element) || new Set();\n      names.add(name);\n\n      this._markerNameToElements.set(name, elements);\n\n      this._elementToMarkerNames.set(element, names);\n    }\n    /**\n     * Unbinds an element from given marker name.\n     *\n     * @param {module:engine/view/element~Element} element Element to unbind.\n     * @param {String} name Marker name.\n     */\n\n  }, {\n    key: \"unbindElementFromMarkerName\",\n    value: function unbindElementFromMarkerName(element, name) {\n      var nameToElements = this._markerNameToElements.get(name);\n\n      if (nameToElements) {\n        nameToElements.delete(element);\n\n        if (nameToElements.size == 0) {\n          this._markerNameToElements.delete(name);\n        }\n      }\n\n      var elementToNames = this._elementToMarkerNames.get(element);\n\n      if (elementToNames) {\n        elementToNames.delete(name);\n\n        if (elementToNames.size == 0) {\n          this._elementToMarkerNames.delete(element);\n        }\n      }\n    }\n    /**\n     * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element\n     * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n     *\n     * @returns {Array.<String>}\n     */\n\n  }, {\n    key: \"flushUnboundMarkerNames\",\n    value: function flushUnboundMarkerNames() {\n      var markerNames = Array.from(this._unboundMarkerNames);\n\n      this._unboundMarkerNames.clear();\n\n      return markerNames;\n    }\n    /**\n     * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.\n     *\n     * See: {@link #unbindViewElement `unbindViewElement()`}.\n     */\n\n  }, {\n    key: \"flushDeferredBindings\",\n    value: function flushDeferredBindings() {\n      var _iterator2 = _createForOfIteratorHelper(this._deferredBindingRemovals),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              viewElement = _step2$value[0],\n              root = _step2$value[1];\n\n          // Unbind it only if it wasn't re-attached to some root or document fragment.\n          if (viewElement.root == root) {\n            this.unbindViewElement(viewElement);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._deferredBindingRemovals = new Map();\n    }\n    /**\n     * Removes all model to view and view to model bindings.\n     */\n\n  }, {\n    key: \"clearBindings\",\n    value: function clearBindings() {\n      this._modelToViewMapping = new WeakMap();\n      this._viewToModelMapping = new WeakMap();\n      this._markerNameToElements = new Map();\n      this._elementToMarkerNames = new Map();\n      this._unboundMarkerNames = new Set();\n      this._deferredBindingRemovals = new Map();\n    }\n    /**\n     * Gets the corresponding model element.\n     *\n     * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n     *\n     * @param {module:engine/view/element~Element} viewElement View element.\n     * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n     */\n\n  }, {\n    key: \"toModelElement\",\n    value: function toModelElement(viewElement) {\n      return this._viewToModelMapping.get(viewElement);\n    }\n    /**\n     * Gets the corresponding view element.\n     *\n     * @param {module:engine/model/element~Element} modelElement Model element.\n     * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n     */\n\n  }, {\n    key: \"toViewElement\",\n    value: function toViewElement(modelElement) {\n      return this._modelToViewMapping.get(modelElement);\n    }\n    /**\n     * Gets the corresponding model range.\n     *\n     * @param {module:engine/view/range~Range} viewRange View range.\n     * @returns {module:engine/model/range~Range} Corresponding model range.\n     */\n\n  }, {\n    key: \"toModelRange\",\n    value: function toModelRange(viewRange) {\n      return new ModelRange(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));\n    }\n    /**\n     * Gets the corresponding view range.\n     *\n     * @param {module:engine/model/range~Range} modelRange Model range.\n     * @returns {module:engine/view/range~Range} Corresponding view range.\n     */\n\n  }, {\n    key: \"toViewRange\",\n    value: function toViewRange(modelRange) {\n      return new ViewRange(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));\n    }\n    /**\n     * Gets the corresponding model position.\n     *\n     * @fires viewToModelPosition\n     * @param {module:engine/view/position~Position} viewPosition View position.\n     * @returns {module:engine/model/position~Position} Corresponding model position.\n     */\n\n  }, {\n    key: \"toModelPosition\",\n    value: function toModelPosition(viewPosition) {\n      var data = {\n        viewPosition: viewPosition,\n        mapper: this\n      };\n      this.fire('viewToModelPosition', data);\n      return data.modelPosition;\n    }\n    /**\n     * Gets the corresponding view position.\n     *\n     * @fires modelToViewPosition\n     * @param {module:engine/model/position~Position} modelPosition Model position.\n     * @param {Object} [options] Additional options for position mapping process.\n     * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n     * in model tree which no longer exists. For example, it could be an end of a removed model range.\n     * @returns {module:engine/view/position~Position} Corresponding view position.\n     */\n\n  }, {\n    key: \"toViewPosition\",\n    value: function toViewPosition(modelPosition) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        isPhantom: false\n      };\n      var data = {\n        modelPosition: modelPosition,\n        mapper: this,\n        isPhantom: options.isPhantom\n      };\n      this.fire('modelToViewPosition', data);\n      return data.viewPosition;\n    }\n    /**\n     * Gets all view elements bound to the given marker name.\n     *\n     * @param {String} name Marker name.\n     * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with the given marker name or `null`\n     * if no elements are bound to the given marker name.\n     */\n\n  }, {\n    key: \"markerNameToElements\",\n    value: function markerNameToElements(name) {\n      var boundElements = this._markerNameToElements.get(name);\n\n      if (!boundElements) {\n        return null;\n      }\n\n      var elements = new Set();\n\n      var _iterator3 = _createForOfIteratorHelper(boundElements),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var element = _step3.value;\n\n          if (element.is('attributeElement')) {\n            var _iterator4 = _createForOfIteratorHelper(element.getElementsWithSameId()),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var clone = _step4.value;\n                elements.add(clone);\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } else {\n            elements.add(element);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return elements;\n    }\n    /**\n     * Registers a callback that evaluates the length in the model of a view element with the given name.\n     *\n     * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n     * a number representing the length of the view element in the model.\n     *\n     *\t\t// List item in view may contain nested list, which have other list items. In model though,\n     *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n     *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n     *\n     *\t\tfunction getViewListItemLength( element ) {\n     *\t\t\tlet length = 1;\n     *\n     *\t\t\tfor ( let child of element.getChildren() ) {\n     *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n     *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n     *\t\t\t\t\t\tlength += getViewListItemLength( item );\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\n     *\t\t\treturn length;\n     *\t\t}\n     *\n     *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n     *\n     * @param {String} viewElementName Name of view element for which callback is registered.\n     * @param {Function} lengthCallback Function return a length of view element instance in model.\n     */\n\n  }, {\n    key: \"registerViewToModelLength\",\n    value: function registerViewToModelLength(viewElementName, lengthCallback) {\n      this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);\n    }\n    /**\n     * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n     * the model.\n     *\n     * @param {module:engine/view/position~Position} viewPosition Position for which a mapped ancestor should be found.\n     * @returns {module:engine/view/element~Element}\n     */\n\n  }, {\n    key: \"findMappedViewAncestor\",\n    value: function findMappedViewAncestor(viewPosition) {\n      var parent = viewPosition.parent;\n\n      while (!this._viewToModelMapping.has(parent)) {\n        parent = parent.parent;\n      }\n\n      return parent;\n    }\n    /**\n     * Calculates model offset based on the view position and the block element.\n     *\n     * Example:\n     *\n     *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n     *\n     * Is a sum of:\n     *\n     *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n     *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewParent Position parent.\n     * @param {Number} viewOffset Position offset.\n     * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n     * @returns {Number} Offset in the model.\n     */\n\n  }, {\n    key: \"_toModelOffset\",\n    value: function _toModelOffset(viewParent, viewOffset, viewBlock) {\n      if (viewBlock != viewParent) {\n        // See example.\n        var offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);\n\n        var offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);\n\n        return offsetToParentStart + offsetInParent;\n      } // viewBlock == viewParent, so we need to calculate the offset in the parent element.\n      // If the position is a text it is simple (\"ba|r\" -> 2).\n\n\n      if (viewParent.is('$text')) {\n        return viewOffset;\n      } // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\n\n      var modelOffset = 0;\n\n      for (var i = 0; i < viewOffset; i++) {\n        modelOffset += this.getModelLength(viewParent.getChild(i));\n      }\n\n      return modelOffset;\n    }\n    /**\n     * Gets the length of the view element in the model.\n     *\n     * The length is calculated as follows:\n     * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to\n     * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),\n     * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its\n     * {@link module:engine/view/text~Text#data data},\n     * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n     * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n     * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.\n     *\n     * Examples:\n     *\n     *\t\tfoo                          -> 3 // Text length is equal to its data length.\n     *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n     *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n     *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n     *\n     * @param {module:engine/view/element~Element} viewNode View node.\n     * @returns {Number} Length of the node in the tree model.\n     */\n\n  }, {\n    key: \"getModelLength\",\n    value: function getModelLength(viewNode) {\n      if (this._viewToModelLengthCallbacks.get(viewNode.name)) {\n        var callback = this._viewToModelLengthCallbacks.get(viewNode.name);\n\n        return callback(viewNode);\n      } else if (this._viewToModelMapping.has(viewNode)) {\n        return 1;\n      } else if (viewNode.is('$text')) {\n        return viewNode.data.length;\n      } else if (viewNode.is('uiElement')) {\n        return 0;\n      } else {\n        var len = 0;\n\n        var _iterator5 = _createForOfIteratorHelper(viewNode.getChildren()),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var child = _step5.value;\n            len += this.getModelLength(child);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return len;\n      }\n    }\n    /**\n     * Finds the position in the view node (or in its children) with the expected model offset.\n     *\n     * Example:\n     *\n     *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n     *\n     *\t\tfindPositionIn( p, 4 ):\n     *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n     *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n     *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n     *\n     *\t\tfindPositionIn( b, 4 - ( 5 - 3 ) ):\n     *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n     *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n     *\n     *\t\tfindPositionIn( bar, 2 - ( 3 - 3 ) ):\n     *\t\tWe are in the text node so we can simple find the offset.\n     *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n     *\n     * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n     * @param {Number} expectedOffset Expected offset.\n     * @returns {module:engine/view/position~Position} Found position.\n     */\n\n  }, {\n    key: \"findPositionIn\",\n    value: function findPositionIn(viewParent, expectedOffset) {\n      // Last scanned view node.\n      var viewNode; // Length of the last scanned view node.\n\n      var lastLength = 0;\n      var modelOffset = 0;\n      var viewOffset = 0; // In the text node it is simple: the offset in the model equals the offset in the text.\n\n      if (viewParent.is('$text')) {\n        return new ViewPosition(viewParent, expectedOffset);\n      } // In other cases we add lengths of child nodes to find the proper offset.\n      // If it is smaller we add the length.\n\n\n      while (modelOffset < expectedOffset) {\n        viewNode = viewParent.getChild(viewOffset);\n        lastLength = this.getModelLength(viewNode);\n        modelOffset += lastLength;\n        viewOffset++;\n      } // If it equals we found the position.\n\n\n      if (modelOffset == expectedOffset) {\n        return this._moveViewPositionToTextNode(new ViewPosition(viewParent, viewOffset));\n      } // If it is higher we need to enter last child.\n      else {\n        // ( modelOffset - lastLength ) is the offset to the child we enter,\n        // so we subtract it from the expected offset to fine the offset in the child.\n        return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));\n      }\n    }\n    /**\n     * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,\n     * it moves it into the text node instead.\n     *\n     *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n     *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n     *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n     *\n     * @private\n     * @param {module:engine/view/position~Position} viewPosition Position potentially next to the text node.\n     * @returns {module:engine/view/position~Position} Position in the text node if possible.\n     */\n\n  }, {\n    key: \"_moveViewPositionToTextNode\",\n    value: function _moveViewPositionToTextNode(viewPosition) {\n      // If the position is just after a text node, put it at the end of that text node.\n      // If the position is just before a text node, put it at the beginning of that text node.\n      var nodeBefore = viewPosition.nodeBefore;\n      var nodeAfter = viewPosition.nodeAfter;\n\n      if (nodeBefore instanceof ViewText) {\n        return new ViewPosition(nodeBefore, nodeBefore.data.length);\n      } else if (nodeAfter instanceof ViewText) {\n        return new ViewPosition(nodeAfter, 0);\n      } // Otherwise, just return the given position.\n\n\n      return viewPosition;\n    }\n    /**\n     * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n     * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n     * calculate the {@link module:engine/view/position~Position view position}. The calculated view position should be added as\n     * a `viewPosition` value in the `data` object that is passed as one of parameters to the event callback.\n     *\n     * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n     * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n     * \t\t// <span> element.\n     *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n     *\t\t\tconst positionParent = modelPosition.parent;\n     *\n     *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n     *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n     *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n     *\n     *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n     *\n     *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n     *\t\t\t\tevt.stop();\n     *\t\t\t}\n     *\t\t} );\n     *\n     * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. A \"phantom\" model position is\n     * a position that points to a nonexistent place in model. Such a position might still be valid for conversion, though\n     * (it would point to a correct place in the view when converted). One example of such a situation is when a range is\n     * removed from the model, there may be a need to map the range's end (which is no longer a valid model position). To\n     * handle such situations, check the `data.isPhantom` flag:\n     *\n     * \t\t// Assume that there is a \"customElement\" model element and whenever the position is before it,\n     * \t\t// we want to move it to the inside of the view element bound to \"customElement\".\n     *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n     *\t\t\tif ( data.isPhantom ) {\n     *\t\t\t\treturn;\n     *\t\t\t}\n     *\n     *\t\t\t// Below line might crash for phantom position that does not exist in model.\n     *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n     *\n     *\t\t\t// Check if this is the element we are interested in.\n     *\t\t\tif ( !sibling.is( 'element', 'customElement' ) ) {\n     *\t\t\t\treturn;\n     *\t\t\t}\n     *\n     *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n     *\n     *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n     *\n     *\t\t\tevt.stop();\n     *\t\t} );\n     *\n     * **Note:** the default mapping callback is provided with a `low` priority setting and does not cancel the event, so it is possible to\n     * attach a custom callback after a default callback and also use `data.viewPosition` calculated by the default callback\n     * (for example to fix it).\n     *\n     * **Note:** the default mapping callback will not fire if `data.viewPosition` is already set.\n     *\n     * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n     * mapping between the given model and view elements is unsolvable by using just elements mapping and default algorithm.\n     * Also, the condition that checks if a special case scenario happened should be as simple as possible.\n     *\n     * @event modelToViewPosition\n     * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n     * the `viewPosition` value to that object with calculated the {@link module:engine/view/position~Position view position}.\n     * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n     */\n\n    /**\n     * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n     *\n     * \t\t// See example in `modelToViewPosition` event description.\n     * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n     *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n     *\t\t\tconst positionParent = viewPosition.parent;\n     *\n     *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n     *\t\t\t\tconst viewImg = positionParent.previousSibling;\n     *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n     *\n     *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n     *\t\t\t\tevt.stop();\n     *\t\t\t}\n     *\t\t} );\n     *\n     * **Note:** the default mapping callback is provided with a `low` priority setting and does not cancel the event, so it is possible to\n     * attach a custom callback after the default callback and also use `data.modelPosition` calculated by the default callback\n     * (for example to fix it).\n     *\n     * **Note:** the default mapping callback will not fire if `data.modelPosition` is already set.\n     *\n     * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n     * mapping between the given model and view elements is unsolvable by using just elements mapping and default algorithm.\n     * Also, the condition that checks if special case scenario happened should be as simple as possible.\n     *\n     * @event viewToModelPosition\n     * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n     * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n     * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n     */\n\n  }]);\n\n  return Mapper;\n}();\n\nexport { Mapper as default };\nmix(Mapper, EmitterMixin);","map":null,"metadata":{},"sourceType":"module"}