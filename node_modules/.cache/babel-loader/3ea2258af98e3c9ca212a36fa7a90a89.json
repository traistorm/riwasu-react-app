{"ast":null,"code":"import _defineProperty from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Matcher from '../view/matcher';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\nimport { isParagraphable, wrapInParagraph } from '../model/utils/autoparagraphing';\n/**\n * Contains the {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * Learn more about {@glink framework/guides/deep-dive/conversion/upcast upcast helpers}.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nvar UpcastHelpers = /*#__PURE__*/function (_ConversionHelpers) {\n  _inherits(UpcastHelpers, _ConversionHelpers);\n\n  function UpcastHelpers() {\n    _classCallCheck(this, UpcastHelpers);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UpcastHelpers).apply(this, arguments));\n  }\n\n  _createClass(UpcastHelpers, [{\n    key: \"elementToElement\",\n\n    /**\n     * View element to model element conversion helper.\n     *\n     * This conversion results in creating a model element. For example,\n     * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n     *\n     * Keep in mind that the element will be inserted only if it is allowed\n     * by {@link module:engine/model/schema~Schema schema} configuration.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     *\t\t\tview: 'p',\n     *\t\t\tmodel: 'paragraph'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     *\t\t\tview: 'p',\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t},\n     *\t\t\tmodel: 'fancyParagraph'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n     * \t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'heading'\n     * \t\t\t},\n     * \t\t\tmodel: ( viewElement, conversionApi ) => {\n     * \t\t\t\tconst modelWriter = conversionApi.writer;\n     *\n     * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n     * \t\t\t}\n     * \t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToElement\n     * @param {Object} config Conversion configuration.\n     * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n     * set, the converter will fire for every view element.\n     * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element instance or a\n     * function that takes a view element and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}\n     * and returns a model element. The model element will be inserted in the model.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n    value: function elementToElement(config) {\n      return this.add(upcastElementToElement(config));\n    }\n    /**\n     * View element to model attribute conversion helper.\n     *\n     * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n     * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n     *\n     * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n     *\n     *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n     *\n     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n     * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n     *\n     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: 'strong',\n     *\t\t\tmodel: 'bold'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: 'strong',\n     *\t\t\tmodel: 'bold',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: 'bold'\n     *\t\t\t},\n     *\t\t\tmodel: 'bold'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'styled',\n     *\t\t\t\tvalue: 'dark'\n     *\t\t\t}\n     *\t\t} );\n     *\n     * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tstyles: {\n     *\t\t\t\t\t'font-size': /[\\s\\S]+/\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n     *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n     *\n     *\t\t\t\t\tif ( value <= 10 ) {\n     *\t\t\t\t\t\treturn 'small';\n     *\t\t\t\t\t} else if ( value > 12 ) {\n     *\t\t\t\t\t\treturn 'big';\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n     * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n     * the model attribute. `value` property may be set as a function that takes a view element and\n     * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n     * If `String` is given, the model attribute value will be set to `true`.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"elementToAttribute\",\n    value: function elementToAttribute(config) {\n      return this.add(upcastElementToAttribute(config));\n    }\n    /**\n     * View attribute to model attribute conversion helper.\n     *\n     * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n     * `<imageBlock source=\"foo.jpg\"></imageBlock>` in the model.\n     *\n     * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n     * is set only on the corresponding model node:\n     *\n     *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n     *\n     * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n     * all the children in the model:\n     *\n     *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n     *\n     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n     * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n     *\n     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: 'src',\n     *\t\t\tmodel: 'source'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: { key: 'src' },\n     *\t\t\tmodel: 'source'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: { key: 'src' },\n     *\t\t\tmodel: 'source',\n     *\t\t\tconverterPriority: 'normal'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tkey: 'data-style',\n     *\t\t\t\tvalue: /[\\s\\S]+/\n     *\t\t\t},\n     *\t\t\tmodel: 'styled'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'img',\n     *\t\t\t\tkey: 'class',\n     *\t\t\t\tvalue: 'styled-dark'\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'styled',\n     *\t\t\t\tvalue: 'dark'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tkey: 'class',\n     *\t\t\t\tvalue: /styled-[\\S]+/\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'styled'\n     *\t\t\t\tvalue: ( viewElement, conversionApi ) => {\n     *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n     *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n     *\n     *\t\t\t\t\treturn match[ 1 ];\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n     * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n     * callback that returns the desired value.\n     *\n     *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tstyles: {\n     *\t\t\t\t\t'font-weight': 'bold'\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tmodel: 'bold'\n     *\t\t} );\n     *\n     *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n     *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n     *\t\t\tview: {\n     *\t\t\t\tstyles: {\n     *\t\t\t\t\t'line-height': /[\\s\\S]+/\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'lineHeight',\n     *\t\t\t\tvalue: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n     * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n     * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n     * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n     * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n     * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n     * the model attribute. `value` property may be set as a function that takes a view element and\n     * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.\n     * If `String` is given, the model attribute value will be same as view attribute value.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"attributeToAttribute\",\n    value: function attributeToAttribute(config) {\n      return this.add(upcastAttributeToAttribute(config));\n    }\n    /**\n     * View element to model marker conversion helper.\n     *\n     * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n     * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n     * after the conversion is done, the marker will be available in\n     * {@link module:engine/model/model~Model#markers model document markers}.\n     *\n     * **Note**: When this helper is used in the data upcast in combination with\n     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,\n     * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.\n     *\n     * In most of the cases, the {@link #dataToMarker} should be used instead.\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: 'marker-search',\n     *\t\t\tmodel: 'search'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: 'marker-search',\n     *\t\t\tmodel: 'search',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: 'marker-search',\n     *\t\t\tmodel: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tattributes: {\n     *\t\t\t\t\t'data-marker': 'search'\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tmodel: 'search'\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToMarker\n     * @param {Object} config Conversion configuration.\n     * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n     * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n     * a model marker name.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"elementToMarker\",\n    value: function elementToMarker(config) {\n      return this.add(upcastElementToMarker(config));\n    }\n    /**\n     * View-to-model marker conversion helper.\n     *\n     * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}\n     * back to a model marker.\n     *\n     * This converter looks for specific view elements and view attributes that mark marker boundaries. See\n     * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data\n     * is expected by this converter.\n     *\n     * The `config.view` property is equal to the marker group name to convert.\n     *\n     * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).\n     *\n     * The conversion configuration can take a function that will generate a marker name.\n     * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is\n     * expected to return a string with the marker name.\n     *\n     * Basic usage:\n     *\n     *\t\t// Using the default conversion.\n     *\t\t// In this case, all markers from the `comment` group will be converted.\n     *\t\t// The conversion will look for `<comment-start>` and `<comment-end>` tags and\n     *\t\t// `data-comment-start-before`, `data-comment-start-after`,\n     *\t\t// `data-comment-end-before` and `data-comment-end-after` attributes.\n     *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n     *\t\t\tview: 'comment'\n     *\t\t} );\n     *\n     * An example of a model that may be generated by this conversion:\n     *\n     *\t\t// View:\n     *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n     *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n     *\n     *\t\t// Model:\n     *\t\t<paragraph>Foo[bar</paragraph>\n     *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n     *\n     * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.\n     *\n     * Other examples of usage:\n     *\n     *\t\t// Using a custom function which is the same as the default conversion:\n     *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n     *\t\t\tview: 'comment',\n     *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n     *\t\t} );\n     *\n     *\t\t// Using the converter priority:\n     *\t\teditor.conversion.for( 'upcast' ).dataToMarker( {\n     *\t\t\tview: 'comment',\n     *\t\t\tmodel: ( name, conversionApi ) => 'comment:' + name,\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #dataToMarker\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.view The marker group name to convert.\n     * @param {Function} [config.model] A function that takes the `name` part from the view element or attribute and\n     * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"dataToMarker\",\n    value: function dataToMarker(config) {\n      return this.add(upcastDataToMarker(config));\n    }\n  }]);\n\n  return UpcastHelpers;\n}(ConversionHelpers);\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\n\n\nexport { UpcastHelpers as default };\nexport function convertToModelFragment() {\n  return function (evt, data, conversionApi) {\n    // Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {\n      name: true\n    })) {\n      var _conversionApi$conver = conversionApi.convertChildren(data.viewItem, data.modelCursor),\n          modelRange = _conversionApi$conver.modelRange,\n          modelCursor = _conversionApi$conver.modelCursor;\n\n      data.modelRange = modelRange;\n      data.modelCursor = modelCursor;\n    }\n  };\n}\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\n\nexport function convertText() {\n  return function (evt, data, _ref) {\n    var schema = _ref.schema,\n        consumable = _ref.consumable,\n        writer = _ref.writer;\n    var position = data.modelCursor; // When node is already converted then do nothing.\n\n    if (!consumable.test(data.viewItem)) {\n      return;\n    }\n\n    if (!schema.checkChild(position, '$text')) {\n      if (!isParagraphable(position, '$text', schema)) {\n        return;\n      }\n\n      position = wrapInParagraph(position, writer);\n    }\n\n    consumable.consume(data.viewItem);\n    var text = writer.createText(data.viewItem.data);\n    writer.insert(text, position);\n    data.modelRange = writer.createRange(position, position.getShiftedBy(text.offsetSize));\n    data.modelCursor = data.modelRange.end;\n  };\n}\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\n\nexport function convertSelectionChange(model, mapper) {\n  return function (evt, data) {\n    var viewSelection = data.newSelection;\n    var ranges = [];\n\n    var _iterator = _createForOfIteratorHelper(viewSelection.getRanges()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var viewRange = _step.value;\n        ranges.push(mapper.toModelRange(viewRange));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var modelSelection = model.createSelection(ranges, {\n      backward: viewSelection.isBackward\n    });\n\n    if (!modelSelection.isEqual(model.document.selection)) {\n      model.change(function (writer) {\n        writer.setSelection(modelSelection);\n      });\n    }\n  };\n} // View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\nfunction upcastElementToElement(config) {\n  config = cloneDeep(config);\n  var converter = prepareToElementConverter(config);\n  var elementName = getViewElementNameFromConfig(config.view);\n  var eventName = elementName ? 'element:' + elementName : 'element';\n  return function (dispatcher) {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToAttribute(config) {\n  config = cloneDeep(config);\n  normalizeModelAttributeConfig(config);\n  var converter = prepareToAttributeConverter(config, false);\n  var elementName = getViewElementNameFromConfig(config.view);\n  var eventName = elementName ? 'element:' + elementName : 'element';\n  return function (dispatcher) {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  var viewKey = null;\n\n  if (typeof config.view == 'string' || config.view.key) {\n    viewKey = normalizeViewAttributeKeyValueConfig(config);\n  }\n\n  normalizeModelAttributeConfig(config, viewKey);\n  var converter = prepareToAttributeConverter(config, true);\n  return function (dispatcher) {\n    dispatcher.on('element', converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToMarker(config) {\n  config = cloneDeep(config);\n  normalizeElementToMarkerConfig(config);\n  return upcastElementToElement(config);\n} // View data to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#dataToMarker} to learn more.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\n\n\nfunction upcastDataToMarker(config) {\n  config = cloneDeep(config); // Default conversion.\n\n  if (!config.model) {\n    config.model = function (name) {\n      return name ? config.view + ':' + name : config.view;\n    };\n  }\n\n  var converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(config, 'start'));\n  var converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(config, 'end'));\n  return function (dispatcher) {\n    dispatcher.on('element:' + config.view + '-start', converterStart, {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('element:' + config.view + '-end', converterEnd, {\n      priority: config.converterPriority || 'normal'\n    }); // Below is a hack that is needed to properly handle `converterPriority` for both elements and attributes.\n    // Attribute conversion needs to be performed *after* element conversion.\n    // This converter handles both element conversion and attribute conversion, which means that if a single\n    // `config.converterPriority` is used, it will lead to problems. For example, if the `'high'` priority is used,\n    // the attribute conversion will be performed before a lot of element upcast converters.\n    // On the other hand, we want to support `config.converterPriority` and converter overwriting.\n    //\n    // To make it work, we need to do some extra processing for priority for attribute converter.\n    // Priority `'low'` value should be the base value and then we will change it depending on `config.converterPriority` value.\n    //\n    // This hack probably would not be needed if attributes are upcasted separately.\n    //\n\n    var basePriority = priorities.get('low');\n    var maxPriority = priorities.get('highest');\n    var priorityFactor = priorities.get(config.converterPriority) / maxPriority; // Number in range [ -1, 1 ].\n\n    dispatcher.on('element', upcastAttributeToMarker(config), {\n      priority: basePriority + priorityFactor\n    });\n  };\n} // Function factory, returns a callback function which converts view attributes to a model marker.\n//\n// The converter looks for elements with `data-group-start-before`, `data-group-start-after`, `data-group-end-before`\n// and `data-group-end-after` attributes and inserts `$marker` model elements before/after those elements.\n// `group` part is specified in `config.view`.\n//\n// @param {Object} config\n// @param {String} config.view\n// @param {Function} [config.model]\n// @returns {Function} Marker converter.\n\n\nfunction upcastAttributeToMarker(config) {\n  return function (evt, data, conversionApi) {\n    var attrName = \"data-\".concat(config.view); // Check if any attribute for the given view item can be consumed before changing the conversion data\n    // and consuming view items with these attributes.\n\n    if (!conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-end-after'\n    }) && !conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-start-after'\n    }) && !conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-end-before'\n    }) && !conversionApi.consumable.test(data.viewItem, {\n      attributes: attrName + '-start-before'\n    })) {\n      return;\n    } // This converter wants to add a model element, marking a marker, before/after an element (or maybe even group of elements).\n    // To do that, we can use `data.modelRange` which is set on an element (or a group of elements) that has been upcasted.\n    // But, if the processed view element has not been upcasted yet (it does not have been converted), we need to\n    // fire conversion for its children first, then we will have `data.modelRange` available.\n\n\n    if (!data.modelRange) {\n      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-end-after'\n    })) {\n      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + '-end-after').split(','));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-start-after'\n    })) {\n      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + '-start-after').split(','));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-end-before'\n    })) {\n      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + '-end-before').split(','));\n    }\n\n    if (conversionApi.consumable.consume(data.viewItem, {\n      attributes: attrName + '-start-before'\n    })) {\n      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + '-start-before').split(','));\n    }\n\n    function addMarkerElements(position, markerViewNames) {\n      var _iterator2 = _createForOfIteratorHelper(markerViewNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var markerViewName = _step2.value;\n          var markerName = config.model(markerViewName, conversionApi);\n          var element = conversionApi.writer.createElement('$marker', {\n            'data-name': markerName\n          });\n          conversionApi.writer.insert(element, position);\n\n          if (data.modelCursor.isEqual(position)) {\n            data.modelCursor = data.modelCursor.getShiftedBy(1);\n          } else {\n            data.modelCursor = data.modelCursor._getTransformedByInsertion(position, 1);\n          }\n\n          data.modelRange = data.modelRange._getTransformedByInsertion(position, 1)[0];\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n} // Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\n\n\nfunction getViewElementNameFromConfig(viewConfig) {\n  if (typeof viewConfig == 'string') {\n    return viewConfig;\n  }\n\n  if (typeof viewConfig == 'object' && typeof viewConfig.name == 'string') {\n    return viewConfig.name;\n  }\n\n  return null;\n} // Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\n\n\nfunction prepareToElementConverter(config) {\n  var matcher = new Matcher(config.view);\n  return function (evt, data, conversionApi) {\n    var matcherResult = matcher.match(data.viewItem);\n\n    if (!matcherResult) {\n      return;\n    }\n\n    var match = matcherResult.match; // Force consuming element's name.\n\n    match.name = true;\n\n    if (!conversionApi.consumable.test(data.viewItem, match)) {\n      return;\n    }\n\n    var modelElement = getModelElement(config.model, data.viewItem, conversionApi);\n\n    if (!modelElement) {\n      return;\n    }\n\n    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {\n      return;\n    }\n\n    conversionApi.consumable.consume(data.viewItem, match);\n    conversionApi.convertChildren(data.viewItem, modelElement);\n    conversionApi.updateConversionResult(modelElement, data);\n  };\n} // Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi The upcast conversion API.\n\n\nfunction getModelElement(model, input, conversionApi) {\n  if (model instanceof Function) {\n    return model(input, conversionApi);\n  } else {\n    return conversionApi.writer.createElement(model);\n  }\n} // Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\n\n\nfunction normalizeViewAttributeKeyValueConfig(config) {\n  if (typeof config.view == 'string') {\n    config.view = {\n      key: config.view\n    };\n  }\n\n  var key = config.view.key;\n  var normalized;\n\n  if (key == 'class' || key == 'style') {\n    var keyName = key == 'class' ? 'classes' : 'styles';\n    normalized = _defineProperty({}, keyName, config.view.value);\n  } else {\n    var value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n    normalized = {\n      attributes: _defineProperty({}, key, value)\n    };\n  }\n\n  if (config.view.name) {\n    normalized.name = config.view.name;\n  }\n\n  config.view = normalized;\n  return key;\n} // Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\n\n\nfunction normalizeModelAttributeConfig(config) {\n  var viewAttributeKeyToCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var defaultModelValue = viewAttributeKeyToCopy === null ? true : function (viewElement) {\n    return viewElement.getAttribute(viewAttributeKeyToCopy);\n  };\n  var key = typeof config.model != 'object' ? config.model : config.model.key;\n  var value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n  config.model = {\n    key: key,\n    value: value\n  };\n} // Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n\n\nfunction prepareToAttributeConverter(config, shallow) {\n  var matcher = new Matcher(config.view);\n  return function (evt, data, conversionApi) {\n    // Converting an attribute of an element that has not been converted to anything does not make sense\n    // because there will be nowhere to set that attribute on. At this stage, the element should've already\n    // been converted (https://github.com/ckeditor/ckeditor5/issues/11000).\n    if (!data.modelRange && shallow) {\n      return;\n    }\n\n    var match = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.\n\n    if (!match) {\n      return;\n    }\n\n    if (onlyViewNameIsDefined(config.view, data.viewItem)) {\n      match.match.name = true;\n    } else {\n      // Do not test `name` consumable because it could get consumed already while upcasting some other attribute\n      // on the same element (for example <span class=\"big\" style=\"color: red\">foo</span>).\n      delete match.match.name;\n    } // Try to consume appropriate values from consumable values list.\n\n\n    if (!conversionApi.consumable.test(data.viewItem, match.match)) {\n      return;\n    }\n\n    var modelKey = config.model.key;\n    var modelValue = typeof config.model.value == 'function' ? config.model.value(data.viewItem, conversionApi) : config.model.value; // Do not convert if attribute building function returned falsy value.\n\n    if (modelValue === null) {\n      return;\n    } // Since we are converting to attribute we need a range on which we will set the attribute.\n    // If the range is not created yet, let's create it by converting children of the current node first.\n\n\n    if (!data.modelRange) {\n      // Convert children and set conversion result as a current data.\n      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n    } // Set attribute on current `output`. `Schema` is checked inside this helper function.\n\n\n    var attributeWasSet = setAttributeOn(data.modelRange, {\n      key: modelKey,\n      value: modelValue\n    }, shallow, conversionApi); // It may happen that a converter will try to set an attribute that is not allowed in the given context.\n    // In such a situation we cannot consume the attribute. See: https://github.com/ckeditor/ckeditor5/pull/9249#issuecomment-815658459.\n\n    if (attributeWasSet) {\n      // Verify if the element itself wasn't consumed yet. It could be consumed already while upcasting some other attribute\n      // on the same element (for example <span class=\"big\" style=\"color: red\">foo</span>).\n      // We need to consume it so other features (especially GHS) won't try to convert it.\n      // Note that it's not tested by the other element-to-attribute converters whether an element was consumed before\n      // (in case of converters that the element itself is just a context and not the primary information to convert).\n      if (conversionApi.consumable.test(data.viewItem, {\n        name: true\n      })) {\n        match.match.name = true;\n      }\n\n      conversionApi.consumable.consume(data.viewItem, match.match);\n    }\n  };\n} // Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\n\n\nfunction onlyViewNameIsDefined(viewConfig, viewItem) {\n  // https://github.com/ckeditor/ckeditor5-engine/issues/1786\n  var configToTest = typeof viewConfig == 'function' ? viewConfig(viewItem) : viewConfig;\n\n  if (typeof configToTest == 'object' && !getViewElementNameFromConfig(configToTest)) {\n    return false;\n  }\n\n  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n} // Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// If any node on the given range has already defined an attribute with the same name, its value will not be updated.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\n\n\nfunction setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {\n  var result = false; // Set attribute on each item in range according to Schema.\n\n  for (var _i = 0, _Array$from = Array.from(modelRange.getItems({\n    shallow: shallow\n  })); _i < _Array$from.length; _i++) {\n    var node = _Array$from[_i];\n\n    // Skip if not allowed.\n    if (!conversionApi.schema.checkAttribute(node, modelAttribute.key)) {\n      continue;\n    } // Mark the node as consumed even if the attribute will not be updated because it's in a valid context (schema)\n    // and would be converted if the attribute wouldn't be present. See #8921.\n\n\n    result = true; // Do not override the attribute if it's already present.\n\n    if (node.hasAttribute(modelAttribute.key)) {\n      continue;\n    }\n\n    conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);\n  }\n\n  return result;\n} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\n\n\nfunction normalizeElementToMarkerConfig(config) {\n  var oldModel = config.model;\n\n  config.model = function (viewElement, conversionApi) {\n    var markerName = typeof oldModel == 'string' ? oldModel : oldModel(viewElement, conversionApi);\n    return conversionApi.writer.createElement('$marker', {\n      'data-name': markerName\n    });\n  };\n} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastDataToMarker()`\n// function and converts it to a format that is supported by `upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\n\n\nfunction normalizeDataToMarkerConfig(config, type) {\n  var configForElements = {}; // Upcast <markerGroup-start> and <markerGroup-end> elements.\n\n  configForElements.view = config.view + '-' + type;\n\n  configForElements.model = function (viewElement, conversionApi) {\n    var viewName = viewElement.getAttribute('name');\n    var markerName = config.model(viewName, conversionApi);\n    return conversionApi.writer.createElement('$marker', {\n      'data-name': markerName\n    });\n  };\n\n  return configForElements;\n}","map":null,"metadata":{},"sourceType":"module"}