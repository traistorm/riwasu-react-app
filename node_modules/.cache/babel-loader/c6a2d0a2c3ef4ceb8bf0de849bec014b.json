{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<imageBlock src=\"foo.jpg\"></imageBlock>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** If there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<imageBlock src=\"foo.jpg\"></imageBlock>]` -> `<paragraph>[]</paragraph>`.\n */\n\nexport default function deleteContent(model, selection) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (selection.isCollapsed) {\n    return;\n  }\n\n  var selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.\n\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n\n  var schema = model.schema;\n  model.change(function (writer) {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection, schema);\n      return;\n    } // Collect attributes to copy in case of autoparagraphing.\n\n\n    var attributesForAutoparagraph = {};\n\n    if (!options.doNotAutoparagraph) {\n      var selectedElement = selection.getSelectedElement();\n\n      if (selectedElement) {\n        Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, 'copyOnReplace', true));\n      }\n    } // Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\n\n    var _getLivePositionsForS = getLivePositionsForSelectedBlocks(selRange),\n        _getLivePositionsForS2 = _slicedToArray(_getLivePositionsForS, 2),\n        startPosition = _getLivePositionsForS2[0],\n        endPosition = _getLivePositionsForS2[1]; // 2. Remove the content if there is any.\n\n\n    if (!startPosition.isTouching(endPosition)) {\n      writer.remove(writer.createRange(startPosition, endPosition));\n    } // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n\n\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPosition, endPosition); // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\n      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);\n    }\n\n    collapseSelectionAt(writer, selection, startPosition); // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n    // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\n    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {\n      insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);\n    }\n\n    startPosition.detach();\n    endPosition.detach();\n  });\n} // Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\n\nfunction getLivePositionsForSelectedBlocks(range) {\n  var model = range.root.document.model;\n  var startPosition = range.start;\n  var endPosition = range.end; // If the end of selection is at the start position of last block in the selection, then\n  // shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\n  if (model.hasContent(range, {\n    ignoreMarkers: true\n  })) {\n    var endBlock = getParentBlock(endPosition);\n\n    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {\n      // Create forward selection as a probe to find a valid position after excluding last block from the range.\n      var selection = model.createSelection(range); // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n      // This is how modifySelection works and here we are making use of it.\n\n      model.modifySelection(selection, {\n        direction: 'backward'\n      });\n      var newEndPosition = selection.getLastPosition(); // For such a model and selection:\n      //     <paragraph>A[</paragraph><imageBlock></imageBlock><paragraph>]B</paragraph>\n      //\n      // After modifySelection(), we would end up with this:\n      //     <paragraph>A[</paragraph>]<imageBlock></imageBlock><paragraph>B</paragraph>\n      //\n      // So we need to check if there is no content in the skipped range (because we want to include the <imageBlock>).\n\n      var skippedRange = model.createRange(newEndPosition, endPosition);\n\n      if (!model.hasContent(skippedRange, {\n        ignoreMarkers: true\n      })) {\n        endPosition = newEndPosition;\n      }\n    }\n  }\n\n  return [LivePosition.fromPosition(startPosition, 'toPrevious'), LivePosition.fromPosition(endPosition, 'toNext')];\n} // Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\n\n\nfunction getParentBlock(position) {\n  var element = position.parent;\n  var schema = element.root.document.model.schema;\n  var ancestors = element.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n\n  var _iterator = _createForOfIteratorHelper(ancestors),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _element = _step.value;\n\n      if (schema.isLimit(_element)) {\n        return null;\n      }\n\n      if (schema.isBlock(_element)) {\n        return _element;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n} // This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\n\n\nfunction mergeBranches(writer, startPosition, endPosition) {\n  var model = writer.model; // Verify if there is a need and possibility to merge.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n  // then merge those to the right element so that it's properties are preserved (name, attributes).\n  // Because of OT merging is used instead of removing elements.\n  //\n  // Merge left:\n  //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n  //     <paragraph>]bar</paragraph>  ->               --^\n  //\n  // Merge right:\n  //     <heading1>[</heading1>       ->\n  //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n  //\n  // Merge left:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n  //         <paragraph>]bar</paragraph>  ->                   --^\n  //     </blockQuote>                    ->  </blockQuote>\n  //\n  // Merge right:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>[</heading1>       ->\n  //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n  //     </blockQuote>                    ->  </blockQuote>\n  // Merging should not go deeper than common ancestor.\n\n\n  var _getAncestorsJustBelo = getAncestorsJustBelowCommonAncestor(startPosition, endPosition),\n      _getAncestorsJustBelo2 = _slicedToArray(_getAncestorsJustBelo, 2),\n      startAncestor = _getAncestorsJustBelo2[0],\n      endAncestor = _getAncestorsJustBelo2[1]; // Branches can't be merged if one of the positions is directly inside a common ancestor.\n  //\n  // Example:\n  //     <blockQuote>\n  //         <paragraph>[foo</paragraph>]\n  //         <table> ... </table>\n  //     <blockQuote>\n  //\n\n\n  if (!startAncestor || !endAncestor) {\n    return;\n  }\n\n  if (!model.hasContent(startAncestor, {\n    ignoreMarkers: true\n  }) && model.hasContent(endAncestor, {\n    ignoreMarkers: true\n  })) {\n    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);\n  } else {\n    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);\n  }\n} // Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\n\n\nfunction mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {\n  var startElement = startPosition.parent;\n  var endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move endElement just after startElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n    //     </blockQuote>                    ->  </blockQuote>                ^\n    //     <blockBlock>                     ->  <blockBlock>                 |\n    //         <paragraph>]bar</paragraph>  ->      ]                     ---\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(endElement, startPosition);\n  } // Merge two siblings (nodes on sides of startPosition):\n  //\n  //     <blockQuote>                                             ->  <blockQuote>\n  //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                                            ->  </blockQuote>\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         ]                                                    ->      ]\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n  //\n\n\n  writer.merge(startPosition); // Remove empty end ancestors:\n  //\n  //     <blockQuote>                      ->  <blockQuote>\n  //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                     ->  </blockQuote>\n  //     <blockBlock>                      ->\n  //         ]                             ->  ]\n  //     </blockBlock>                     ->\n  //\n\n  while (endPosition.parent.isEmpty) {\n    var parentToRemove = endPosition.parent;\n    endPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Verify if there is a need and possibility to merge next level.\n\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);\n} // Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\n\n\nfunction mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {\n  var startElement = startPosition.parent;\n  var endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move startElement just before endElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      [                   ---\n    //     </blockQuote>                    ->  </blockQuote>              |\n    //     <blockBlock>                     ->  <blockBlock>               v\n    //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(startElement, endPosition);\n  } // Remove empty end ancestors:\n  //\n  //     <blockQuote>                                             ->\n  //         [                                                    ->  [\n  //     </blockQuote>                                            ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n\n\n  while (startPosition.parent.isEmpty) {\n    var parentToRemove = startPosition.parent;\n    startPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Update endPosition after inserting and removing elements.\n\n\n  endPosition = writer.createPositionBefore(endElement); // Merge right two siblings (nodes on sides of endPosition):\n  //                                                              ->\n  //     [                                                        ->  [\n  //                                                              ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n  //\n\n  mergeRight(writer, endPosition); // Verify if there is a need and possibility to merge next level.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);\n} // There is no right merge operation so we need to simulate it.\n\n\nfunction mergeRight(writer, position) {\n  var startElement = position.nodeBefore;\n  var endElement = position.nodeAfter;\n\n  if (startElement.name != endElement.name) {\n    writer.rename(startElement, endElement.name);\n  }\n\n  writer.clearAttributes(startElement);\n  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);\n  writer.merge(position);\n} // Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\n\n\nfunction checkShouldMerge(schema, startPosition, endPosition) {\n  var startElement = startPosition.parent;\n  var endElement = endPosition.parent; // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\n  if (startElement == endElement) {\n    return false;\n  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\n\n  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n    return false;\n  } // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endElement into startElement in this case:\n  // <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\n\n  return isCrossingLimitElement(startPosition, endPosition, schema);\n} // Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\n\n\nfunction getAncestorsJustBelowCommonAncestor(positionA, positionB) {\n  var ancestorsA = positionA.getAncestors();\n  var ancestorsB = positionB.getAncestors();\n  var i = 0;\n\n  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {\n    i++;\n  }\n\n  return [ancestorsA[i], ancestorsB[i]];\n}\n\nfunction shouldAutoparagraph(schema, position) {\n  var isTextAllowed = schema.checkChild(position, '$text');\n  var isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n} // Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\n\n\nfunction isCrossingLimitElement(leftPos, rightPos, schema) {\n  var rangeToCheck = new Range(leftPos, rightPos);\n\n  var _iterator2 = _createForOfIteratorHelper(rangeToCheck.getWalker()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var value = _step2.value;\n\n      if (schema.isLimit(value.item)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return true;\n}\n\nfunction insertParagraph(writer, position, selection) {\n  var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var paragraph = writer.createElement('paragraph');\n  writer.model.schema.setAllowedAttributes(paragraph, attributes, writer);\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\n\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  var limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n} // We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\n\n\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  var limitElement = schema.getLimitElement(selection);\n\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n\n  var range = selection.getFirstRange();\n\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n\n  return schema.checkChild(limitElement, 'paragraph');\n} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\n\n\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}