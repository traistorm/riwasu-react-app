{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widgettoolbarrepository\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';\nimport ToolbarView from '@ckeditor/ckeditor5-ui/src/toolbar/toolbarview';\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport { isWidget } from './utils';\nimport CKEditorError, { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Widget toolbar repository plugin. A central point for registering widget toolbars. This plugin handles the whole\n * toolbar rendering process and exposes a concise API.\n *\n * To add a toolbar for your widget use the {@link ~WidgetToolbarRepository#register `WidgetToolbarRepository#register()`} method.\n *\n * The following example comes from the {@link module:image/imagetoolbar~ImageToolbar} plugin:\n *\n * \t\tclass ImageToolbar extends Plugin {\n *\t\t\tstatic get requires() {\n *\t\t\t\treturn [ WidgetToolbarRepository ];\n *\t\t\t}\n *\n *\t\t\tafterInit() {\n *\t\t\t\tconst editor = this.editor;\n *\t\t\t\tconst widgetToolbarRepository = editor.plugins.get( WidgetToolbarRepository );\n *\n *\t\t\t\twidgetToolbarRepository.register( 'image', {\n *\t\t\t\t\titems: editor.config.get( 'image.toolbar' ),\n *\t\t\t\t\tgetRelatedElement: getClosestSelectedImageWidget\n *\t\t\t\t} );\n *\t\t\t}\n *\t\t}\n */\n\nvar WidgetToolbarRepository = /*#__PURE__*/function (_Plugin) {\n  _inherits(WidgetToolbarRepository, _Plugin);\n\n  function WidgetToolbarRepository() {\n    _classCallCheck(this, WidgetToolbarRepository);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WidgetToolbarRepository).apply(this, arguments));\n  }\n\n  _createClass(WidgetToolbarRepository, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var _this = this;\n\n      var editor = this.editor; // Disables the default balloon toolbar for all widgets.\n\n      if (editor.plugins.has('BalloonToolbar')) {\n        var balloonToolbar = editor.plugins.get('BalloonToolbar');\n        this.listenTo(balloonToolbar, 'show', function (evt) {\n          if (isWidgetSelected(editor.editing.view.document.selection)) {\n            evt.stop();\n          }\n        }, {\n          priority: 'high'\n        });\n      }\n      /**\n       * A map of toolbar definitions.\n       *\n       * @protected\n       * @member {Map.<String,module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition>} #_toolbarDefinitions\n       */\n\n\n      this._toolbarDefinitions = new Map();\n      /**\n       * @private\n       */\n\n      this._balloon = this.editor.plugins.get('ContextualBalloon');\n      this.on('change:isEnabled', function () {\n        _this._updateToolbarsVisibility();\n      });\n      this.listenTo(editor.ui, 'update', function () {\n        _this._updateToolbarsVisibility();\n      }); // UI#update is not fired after focus is back in editor, we need to check if balloon panel should be visible.\n\n      this.listenTo(editor.ui.focusTracker, 'change:isFocused', function () {\n        _this._updateToolbarsVisibility();\n      }, {\n        priority: 'low'\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(WidgetToolbarRepository.prototype), \"destroy\", this).call(this);\n\n      var _iterator = _createForOfIteratorHelper(this._toolbarDefinitions.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var toolbarConfig = _step.value;\n          toolbarConfig.view.destroy();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked\n     * `getRelatedElement` function. Toolbar items are gathered from `items` array.\n     * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.\n     *\n     * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}\n     * callback (or later) to make sure that the given toolbar items were already registered by other plugins.\n     *\n     * @param {String} toolbarId An id for the toolbar. Used to\n     * @param {Object} options\n     * @param {String} [options.ariaLabel] Label used by assistive technologies to describe this toolbar element.\n     * @param {Array.<String>} options.items Array of toolbar items.\n     * @param {Function} options.getRelatedElement Callback which returns an element the toolbar should be attached to.\n     * @param {String} [options.balloonClassName='ck-toolbar-container'] CSS class for the widget balloon.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(toolbarId, _ref) {\n      var ariaLabel = _ref.ariaLabel,\n          items = _ref.items,\n          getRelatedElement = _ref.getRelatedElement,\n          _ref$balloonClassName = _ref.balloonClassName,\n          balloonClassName = _ref$balloonClassName === void 0 ? 'ck-toolbar-container' : _ref$balloonClassName;\n\n      // Trying to register a toolbar without any item.\n      if (!items.length) {\n        /**\n         * When {@link #register registering} a new widget toolbar, you need to provide a non-empty array with\n         * the items that will be inserted into the toolbar.\n         *\n         * If you see this error when integrating the editor, you likely forgot to configure one of the widget toolbars.\n         *\n         * See for instance:\n         *\n         * * {@link module:table/table~TableConfig#contentToolbar `config.table.contentToolbar`}\n         * * {@link module:image/image~ImageConfig#toolbar `config.image.toolbar`}\n         *\n         * @error widget-toolbar-no-items\n         * @param {String} toolbarId The id of the toolbar that has not been configured correctly.\n         */\n        logWarning('widget-toolbar-no-items', {\n          toolbarId: toolbarId\n        });\n        return;\n      }\n\n      var editor = this.editor;\n      var t = editor.t;\n      var toolbarView = new ToolbarView(editor.locale);\n      toolbarView.ariaLabel = ariaLabel || t('Widget toolbar');\n\n      if (this._toolbarDefinitions.has(toolbarId)) {\n        /**\n         * Toolbar with the given id was already added.\n         *\n         * @error widget-toolbar-duplicated\n         * @param toolbarId Toolbar id.\n         */\n        throw new CKEditorError('widget-toolbar-duplicated', this, {\n          toolbarId: toolbarId\n        });\n      }\n\n      toolbarView.fillFromConfig(items, editor.ui.componentFactory);\n\n      this._toolbarDefinitions.set(toolbarId, {\n        view: toolbarView,\n        getRelatedElement: getRelatedElement,\n        balloonClassName: balloonClassName\n      });\n    }\n    /**\n     * Iterates over stored toolbars and makes them visible or hidden.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateToolbarsVisibility\",\n    value: function _updateToolbarsVisibility() {\n      var maxRelatedElementDepth = 0;\n      var deepestRelatedElement = null;\n      var deepestToolbarDefinition = null;\n\n      var _iterator2 = _createForOfIteratorHelper(this._toolbarDefinitions.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var definition = _step2.value;\n          var relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);\n\n          if (!this.isEnabled || !relatedElement) {\n            if (this._isToolbarInBalloon(definition)) {\n              this._hideToolbar(definition);\n            }\n          } else if (!this.editor.ui.focusTracker.isFocused) {\n            if (this._isToolbarVisible(definition)) {\n              this._hideToolbar(definition);\n            }\n          } else {\n            var relatedElementDepth = relatedElement.getAncestors().length; // Many toolbars can express willingness to be displayed but they do not know about\n            // each other. Figure out which toolbar is deepest in the view tree to decide which\n            // should be displayed. For instance, if a selected image is inside a table cell, display\n            // the ImageToolbar rather than the TableToolbar (#60).\n\n            if (relatedElementDepth > maxRelatedElementDepth) {\n              maxRelatedElementDepth = relatedElementDepth;\n              deepestRelatedElement = relatedElement;\n              deepestToolbarDefinition = definition;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (deepestToolbarDefinition) {\n        this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);\n      }\n    }\n    /**\n     * Hides the given toolbar.\n     *\n     * @private\n     * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n     */\n\n  }, {\n    key: \"_hideToolbar\",\n    value: function _hideToolbar(toolbarDefinition) {\n      this._balloon.remove(toolbarDefinition.view);\n\n      this.stopListening(this._balloon, 'change:visibleView');\n    }\n    /**\n     * Shows up the toolbar if the toolbar is not visible.\n     * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.\n     *\n     * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view\n     * should be still visible after the {@link module:core/editor/editorui~EditorUI#event:update}.\n     *\n     * @private\n     * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition\n     * @param {module:engine/view/element~Element} relatedElement\n     */\n\n  }, {\n    key: \"_showToolbar\",\n    value: function _showToolbar(toolbarDefinition, relatedElement) {\n      var _this2 = this;\n\n      if (this._isToolbarVisible(toolbarDefinition)) {\n        repositionContextualBalloon(this.editor, relatedElement);\n      } else if (!this._isToolbarInBalloon(toolbarDefinition)) {\n        this._balloon.add({\n          view: toolbarDefinition.view,\n          position: getBalloonPositionData(this.editor, relatedElement),\n          balloonClassName: toolbarDefinition.balloonClassName\n        }); // Update toolbar position each time stack with toolbar view is switched to visible.\n        // This is in a case target element has changed when toolbar was in invisible stack\n        // e.g. target image was wrapped by a block quote.\n        // See https://github.com/ckeditor/ckeditor5-widget/issues/92.\n\n\n        this.listenTo(this._balloon, 'change:visibleView', function () {\n          var _iterator3 = _createForOfIteratorHelper(_this2._toolbarDefinitions.values()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var definition = _step3.value;\n\n              if (_this2._isToolbarVisible(definition)) {\n                var _relatedElement = definition.getRelatedElement(_this2.editor.editing.view.document.selection);\n\n                repositionContextualBalloon(_this2.editor, _relatedElement);\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        });\n      }\n    }\n    /**\n     * @private\n     * @param {Object} toolbar\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isToolbarVisible\",\n    value: function _isToolbarVisible(toolbar) {\n      return this._balloon.visibleView === toolbar.view;\n    }\n    /**\n     * @private\n     * @param {Object} toolbar\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isToolbarInBalloon\",\n    value: function _isToolbarInBalloon(toolbar) {\n      return this._balloon.hasView(toolbar.view);\n    }\n  }], [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ContextualBalloon];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'WidgetToolbarRepository';\n    }\n  }]);\n\n  return WidgetToolbarRepository;\n}(Plugin);\n\nexport { WidgetToolbarRepository as default };\n\nfunction repositionContextualBalloon(editor, relatedElement) {\n  var balloon = editor.plugins.get('ContextualBalloon');\n  var position = getBalloonPositionData(editor, relatedElement);\n  balloon.updatePosition(position);\n}\n\nfunction getBalloonPositionData(editor, relatedElement) {\n  var editingView = editor.editing.view;\n  var defaultPositions = BalloonPanelView.defaultPositions;\n  return {\n    target: editingView.domConverter.mapViewToDom(relatedElement),\n    positions: [defaultPositions.northArrowSouth, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast, defaultPositions.southArrowNorth, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast, defaultPositions.viewportStickyNorth]\n  };\n}\n\nfunction isWidgetSelected(selection) {\n  var viewElement = selection.getSelectedElement();\n  return !!(viewElement && isWidget(viewElement));\n}\n/**\n * The toolbar definition object used by the toolbar repository to manage toolbars.\n * It contains information necessary to display the toolbar in the\n * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} and\n * update it during its life (display) cycle.\n *\n * @typedef {Object} module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition\n *\n * @property {module:ui/view~View} view The UI view of the toolbar.\n * @property {Function} getRelatedElement A function that returns an engine {@link module:engine/view/view~View}\n * element the toolbar is to be attached to. For instance, an image widget or a table widget (or `null` when\n * there is no such element). The function accepts an instance of {@link module:engine/view/selection~Selection}.\n * @property {String} balloonClassName CSS class for the widget balloon when a toolbar is displayed.\n */","map":null,"metadata":{},"sourceType":"module"}