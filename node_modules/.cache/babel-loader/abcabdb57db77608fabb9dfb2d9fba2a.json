{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller } from './filler';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport '../../theme/renderer.css';\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\n\nvar Renderer = /*#__PURE__*/function () {\n  /**\n   * Creates a renderer instance.\n   *\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n   * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n   */\n  function Renderer(domConverter, selection) {\n    var _this = this;\n\n    _classCallCheck(this, Renderer);\n\n    /**\n     * Set of DOM Documents instances.\n     *\n     * @readonly\n     * @member {Set.<Document>}\n     */\n    this.domDocuments = new Set();\n    /**\n     * Converter instance.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n\n    this.domConverter = domConverter;\n    /**\n     * Set of nodes which attributes changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedAttributes = new Set();\n    /**\n     * Set of elements which child lists changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedChildren = new Set();\n    /**\n     * Set of text nodes which text data changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedTexts = new Set();\n    /**\n     * View selection. Renderer updates DOM selection based on the view selection.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     */\n\n    this.selection = selection;\n    /**\n     * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n     * this is set to `false`.\n     *\n     * @member {Boolean}\n     * @observable\n     */\n\n    this.set('isFocused', false);\n    /**\n     * Indicates whether the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * Note: In some browsers, the renderer will stop rendering the selection and inline fillers while the user is making\n     * a selection to avoid glitches in DOM selection\n     * (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n     *\n     * @member {Boolean}\n     * @observable\n     */\n\n    this.set('isSelecting', false); // Rendering the selection and inline filler manipulation should be postponed in (non-Android) Blink until the user finishes\n    // creating the selection in DOM to avoid accidental selection collapsing\n    // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n    // When the user stops selecting, all pending changes should be rendered ASAP, though.\n\n    if (env.isBlink && !env.isAndroid) {\n      this.on('change:isSelecting', function () {\n        if (!_this.isSelecting) {\n          _this.render();\n        }\n      });\n    }\n    /**\n     * The text node in which the inline filler was rendered.\n     *\n     * @private\n     * @member {Text}\n     */\n\n\n    this._inlineFiller = null;\n    /**\n     * DOM element containing fake selection.\n     *\n     * @private\n     * @type {null|HTMLElement}\n     */\n\n    this._fakeSelectionContainer = null;\n  }\n  /**\n   * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n   *\n   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n   *\n   * @see #markedAttributes\n   * @see #markedChildren\n   * @see #markedTexts\n   *\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~Node} node Node to be marked.\n   */\n\n\n  _createClass(Renderer, [{\n    key: \"markToSync\",\n    value: function markToSync(type, node) {\n      if (type === 'text') {\n        if (this.domConverter.mapViewToDom(node.parent)) {\n          this.markedTexts.add(node);\n        }\n      } else {\n        // If the node has no DOM element it is not rendered yet,\n        // its children/attributes do not need to be marked to be sync.\n        if (!this.domConverter.mapViewToDom(node)) {\n          return;\n        }\n\n        if (type === 'attributes') {\n          this.markedAttributes.add(node);\n        } else if (type === 'children') {\n          this.markedChildren.add(node);\n        } else {\n          /**\n           * Unknown type passed to Renderer.markToSync.\n           *\n           * @error view-renderer-unknown-type\n           */\n          throw new CKEditorError('view-renderer-unknown-type', this);\n        }\n      }\n    }\n    /**\n     * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n     * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n     *\n     * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n     * so it does as little as it is needed to update the DOM.\n     *\n     * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n     * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n     * removed as long as the selection is in the text node which needed it at first.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var inlineFillerPosition;\n      var isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true; // Refresh mappings.\n\n      var _iterator = _createForOfIteratorHelper(this.markedChildren),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var element = _step.value;\n\n          this._updateChildrenMappings(element);\n        } // Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n        // DOM selection collapsing\n        // (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (isInlineFillerRenderingPossible) {\n        // There was inline filler rendered in the DOM but it's not\n        // at the selection position any more, so we can remove it\n        // (cause even if it's needed, it must be placed in another location).\n        if (this._inlineFiller && !this._isSelectionInInlineFiller()) {\n          this._removeInlineFiller();\n        } // If we've got the filler, let's try to guess its position in the view.\n\n\n        if (this._inlineFiller) {\n          inlineFillerPosition = this._getInlineFillerPosition();\n        } // Otherwise, if it's needed, create it at the selection position.\n        else if (this._needsInlineFillerAtSelection()) {\n          inlineFillerPosition = this.selection.getFirstPosition(); // Do not use `markToSync` so it will be added even if the parent is already added.\n\n          this.markedChildren.add(inlineFillerPosition.parent);\n        }\n      } // Paranoid check: we make sure the inline filler has any parent so it can be mapped to view position\n      // by DomConverter.\n      else if (this._inlineFiller && this._inlineFiller.parentNode) {\n        // While the user is making selection, preserve the inline filler at its original position.\n        inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.markedAttributes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _element = _step2.value;\n\n          this._updateAttrs(_element);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.markedChildren),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _element2 = _step3.value;\n\n          this._updateChildren(_element2, {\n            inlineFillerPosition: inlineFillerPosition\n          });\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(this.markedTexts),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var node = _step4.value;\n\n          if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {\n            this._updateText(node, {\n              inlineFillerPosition: inlineFillerPosition\n            });\n          }\n        } // * Check whether the inline filler is required and where it really is in the DOM.\n        //   At this point in most cases it will be in the DOM, but there are exceptions.\n        //   For example, if the inline filler was deep in the created DOM structure, it will not be created.\n        //   Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n        //   it will not be present. Fix those and similar scenarios.\n        // * Don't manipulate inline fillers while the selection is being made in (non-Android) Blink to prevent accidental\n        //   DOM selection collapsing\n        //   (https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723).\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (isInlineFillerRenderingPossible) {\n        if (inlineFillerPosition) {\n          var fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);\n          var domDocument = fillerDomPosition.parent.ownerDocument;\n\n          if (!startsWithFiller(fillerDomPosition.parent)) {\n            // Filler has not been created at filler position. Create it now.\n            this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);\n          } else {\n            // Filler has been found, save it.\n            this._inlineFiller = fillerDomPosition.parent;\n          }\n        } else {\n          // There is no filler needed.\n          this._inlineFiller = null;\n        }\n      } // First focus the new editing host, then update the selection.\n      // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\n\n      this._updateFocus();\n\n      this._updateSelection();\n\n      this.markedTexts.clear();\n      this.markedAttributes.clear();\n      this.markedChildren.clear();\n    }\n    /**\n     * Updates mappings of view element's children.\n     *\n     * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n     * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n     * Thanks to that these elements do not need to be re-rendered completely.\n     *\n     * @private\n     * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n     */\n\n  }, {\n    key: \"_updateChildrenMappings\",\n    value: function _updateChildrenMappings(viewElement) {\n      var domElement = this.domConverter.mapViewToDom(viewElement);\n\n      if (!domElement) {\n        // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n        return;\n      } // Removing nodes from the DOM as we iterate can cause `actualDomChildren`\n      // (which is a live-updating `NodeList`) to get out of sync with the\n      // indices that we compute as we iterate over `actions`.\n      // This would produce incorrect element mappings.\n      //\n      // Converting live list to an array to make the list static.\n\n\n      var actualDomChildren = Array.from(this.domConverter.mapViewToDom(viewElement).childNodes);\n      var expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n        withChildren: false\n      }));\n\n      var diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n      var actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);\n\n      if (actions.indexOf('replace') !== -1) {\n        var counter = {\n          equal: 0,\n          insert: 0,\n          delete: 0\n        };\n\n        var _iterator5 = _createForOfIteratorHelper(actions),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var action = _step5.value;\n\n            if (action === 'replace') {\n              var insertIndex = counter.equal + counter.insert;\n              var deleteIndex = counter.equal + counter.delete;\n              var viewChild = viewElement.getChild(insertIndex); // UIElement and RawElement are special cases. Their children are not stored in a view (#799)\n              // so we cannot use them with replacing flow (since they use view children during rendering\n              // which will always result in rendering empty elements).\n\n              if (viewChild && !(viewChild.is('uiElement') || viewChild.is('rawElement'))) {\n                this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);\n              }\n\n              remove(expectedDomChildren[insertIndex]);\n              counter.equal++;\n            } else {\n              counter[action]++;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n    /**\n     * Updates mappings of a given view element.\n     *\n     * @private\n     * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n     * @param {Node} domElement The DOM element representing the given view element.\n     */\n\n  }, {\n    key: \"_updateElementMappings\",\n    value: function _updateElementMappings(viewElement, domElement) {\n      // Remap 'DomConverter' bindings.\n      this.domConverter.unbindDomElement(domElement);\n      this.domConverter.bindElements(domElement, viewElement); // View element may have children which needs to be updated, but are not marked, mark them to update.\n\n      this.markedChildren.add(viewElement); // Because we replace new view element mapping with the existing one, the corresponding DOM element\n      // will not be rerendered. The new view element may have different attributes than the previous one.\n      // Since its corresponding DOM element will not be rerendered, new attributes will not be added\n      // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n      // detailed case study.\n      // Also there are cases where replaced element is removed from the view structure and then has\n      // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n      // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n      // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\n      this.markedAttributes.add(viewElement);\n    }\n    /**\n     * Gets the position of the inline filler based on the current selection.\n     * Here, we assume that we know that the filler is needed and\n     * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n     * it is somewhere at the selection position.\n     *\n     * Note: The filler position cannot be restored based on the filler's DOM text node, because\n     * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n     * bindings are only dependable after rendering.\n     *\n     * @private\n     * @returns {module:engine/view/position~Position}\n     */\n\n  }, {\n    key: \"_getInlineFillerPosition\",\n    value: function _getInlineFillerPosition() {\n      var firstPos = this.selection.getFirstPosition();\n\n      if (firstPos.parent.is('$text')) {\n        return ViewPosition._createBefore(this.selection.getFirstPosition().parent);\n      } else {\n        return firstPos;\n      }\n    }\n    /**\n     * Returns `true` if the selection has not left the inline filler's text node.\n     * If it is `true`, it means that the filler had been added for a reason and the selection did not\n     * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n     *\n     * @private\n     * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n     */\n\n  }, {\n    key: \"_isSelectionInInlineFiller\",\n    value: function _isSelectionInInlineFiller() {\n      if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n        return false;\n      } // Note, we can't check if selection's position equals position of the\n      // this._inlineFiller node, because of #663. We may not be able to calculate\n      // the filler's position in the view at this stage.\n      // Instead, we check it the other way – whether selection is anchored in\n      // that text node or next to it.\n      // Possible options are:\n      // \"FILLER{}\"\n      // \"FILLERadded-text{}\"\n\n\n      var selectionPosition = this.selection.getFirstPosition();\n      var position = this.domConverter.viewPositionToDom(selectionPosition);\n\n      if (position && isText(position.parent) && startsWithFiller(position.parent)) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Removes the inline filler.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeInlineFiller\",\n    value: function _removeInlineFiller() {\n      var domFillerNode = this._inlineFiller; // Something weird happened and the stored node doesn't contain the filler's text.\n\n      if (!startsWithFiller(domFillerNode)) {\n        /**\n         * The inline filler node was lost. Most likely, something overwrote the filler text node\n         * in the DOM.\n         *\n         * @error view-renderer-filler-was-lost\n         */\n        throw new CKEditorError('view-renderer-filler-was-lost', this);\n      }\n\n      if (isInlineFiller(domFillerNode)) {\n        domFillerNode.remove();\n      } else {\n        domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);\n      }\n\n      this._inlineFiller = null;\n    }\n    /**\n     * Checks if the inline {@link module:engine/view/filler filler} should be added.\n     *\n     * @private\n     * @returns {Boolean} `true` if the inline filler should be added.\n     */\n\n  }, {\n    key: \"_needsInlineFillerAtSelection\",\n    value: function _needsInlineFillerAtSelection() {\n      if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n        return false;\n      }\n\n      var selectionPosition = this.selection.getFirstPosition();\n      var selectionParent = selectionPosition.parent;\n      var selectionOffset = selectionPosition.offset; // If there is no DOM root we do not care about fillers.\n\n      if (!this.domConverter.mapViewToDom(selectionParent.root)) {\n        return false;\n      }\n\n      if (!selectionParent.is('element')) {\n        return false;\n      } // Prevent adding inline filler inside elements with contenteditable=false.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\n\n      if (!isEditable(selectionParent)) {\n        return false;\n      } // We have block filler, we do not need inline one.\n\n\n      if (selectionOffset === selectionParent.getFillerOffset()) {\n        return false;\n      }\n\n      var nodeBefore = selectionPosition.nodeBefore;\n      var nodeAfter = selectionPosition.nodeAfter;\n\n      if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Checks if text needs to be updated and possibly updates it.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} viewText View text to update.\n     * @param {Object} options\n     * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n     * filler should be rendered.\n     */\n\n  }, {\n    key: \"_updateText\",\n    value: function _updateText(viewText, options) {\n      var domText = this.domConverter.findCorrespondingDomText(viewText);\n      var newDomText = this.domConverter.viewToDom(viewText, domText.ownerDocument);\n      var actualText = domText.data;\n      var expectedText = newDomText.data;\n      var filler = options.inlineFillerPosition;\n\n      if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {\n        expectedText = INLINE_FILLER + expectedText;\n      }\n\n      if (actualText != expectedText) {\n        var actions = fastDiff(actualText, expectedText);\n\n        var _iterator6 = _createForOfIteratorHelper(actions),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var action = _step6.value;\n\n            if (action.type === 'insert') {\n              domText.insertData(action.index, action.values.join(''));\n            } else {\n              // 'delete'\n              domText.deleteData(action.index, action.howMany);\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n    }\n    /**\n     * Checks if attribute list needs to be updated and possibly updates it.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewElement The view element to update.\n     */\n\n  }, {\n    key: \"_updateAttrs\",\n    value: function _updateAttrs(viewElement) {\n      var domElement = this.domConverter.mapViewToDom(viewElement);\n\n      if (!domElement) {\n        // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n        // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n        // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n        // in 'this._updateChildrenMappings()' so it will be processed separately.\n        return;\n      }\n\n      var domAttrKeys = Array.from(domElement.attributes).map(function (attr) {\n        return attr.name;\n      });\n      var viewAttrKeys = viewElement.getAttributeKeys(); // Add or overwrite attributes.\n\n      var _iterator7 = _createForOfIteratorHelper(viewAttrKeys),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var key = _step7.value;\n          this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);\n        } // Remove from DOM attributes which do not exists in the view.\n\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(domAttrKeys),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _key = _step8.value;\n\n          // All other attributes not present in the DOM should be removed.\n          if (!viewElement.hasAttribute(_key)) {\n            this.domConverter.removeDomElementAttribute(domElement, _key);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n    /**\n     * Checks if elements child list needs to be updated and possibly updates it.\n     *\n     * @private\n     * @param {module:engine/view/element~Element} viewElement View element to update.\n     * @param {Object} options\n     * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n     * filler should be rendered.\n     */\n\n  }, {\n    key: \"_updateChildren\",\n    value: function _updateChildren(viewElement, options) {\n      var domElement = this.domConverter.mapViewToDom(viewElement);\n\n      if (!domElement) {\n        // If there is no `domElement` it means that it was already removed from DOM.\n        // There is no need to process it. It will be processed when re-inserted.\n        return;\n      }\n\n      var inlineFillerPosition = options.inlineFillerPosition;\n      var actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n      var expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n        bind: true\n      })); // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n      // during diffing so text nodes could be compared correctly and also during rendering to maintain\n      // proper order and indexes while updating the DOM.\n\n      if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {\n        addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);\n      }\n\n      var diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n      var i = 0;\n      var nodesToUnbind = new Set(); // Handle deletions first.\n      // This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different\n      // index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,\n      // and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.\n      //\n      // It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.\n\n      var _iterator9 = _createForOfIteratorHelper(diff),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var action = _step9.value;\n\n          if (action === 'delete') {\n            nodesToUnbind.add(actualDomChildren[i]);\n            remove(actualDomChildren[i]);\n          } else if (action === 'equal') {\n            i++;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      i = 0;\n\n      var _iterator10 = _createForOfIteratorHelper(diff),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _action = _step10.value;\n\n          if (_action === 'insert') {\n            insertAt(domElement, i, expectedDomChildren[i]);\n            i++;\n          } else if (_action === 'equal') {\n            // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n            // Do it here (not in the loop above) because only after insertions the `i` index is correct.\n            this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));\n\n            i++;\n          }\n        } // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n        // comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n        // it was moved to DOM tree out of the removed node.\n\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      var _iterator11 = _createForOfIteratorHelper(nodesToUnbind),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var node = _step11.value;\n\n          if (!node.parentNode) {\n            this.domConverter.unbindDomElement(node);\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n    /**\n     * Shorthand for diffing two arrays or node lists of DOM nodes.\n     *\n     * @private\n     * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n     * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n     * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n     */\n\n  }, {\n    key: \"_diffNodeLists\",\n    value: function _diffNodeLists(actualDomChildren, expectedDomChildren) {\n      actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);\n      return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));\n    }\n    /**\n     * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n     * within one `insert`/`delete` action group, for example:\n     *\n     * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n     * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n     * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n     * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n     *\n     * @private\n     * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n     * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n     * @param {Array.<Node>} expectedDom Expected DOM children.\n     * @returns {Array.<String>} Actions array modified with the `replace` actions.\n     */\n\n  }, {\n    key: \"_findReplaceActions\",\n    value: function _findReplaceActions(actions, actualDom, expectedDom) {\n      // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n      if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {\n        return actions;\n      }\n\n      var newActions = [];\n      var actualSlice = [];\n      var expectedSlice = [];\n      var counter = {\n        equal: 0,\n        insert: 0,\n        delete: 0\n      };\n\n      var _iterator12 = _createForOfIteratorHelper(actions),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var action = _step12.value;\n\n          if (action === 'insert') {\n            expectedSlice.push(expectedDom[counter.equal + counter.insert]);\n          } else if (action === 'delete') {\n            actualSlice.push(actualDom[counter.equal + counter.delete]);\n          } else {\n            // equal\n            newActions = newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(function (x) {\n              return x === 'equal' ? 'replace' : x;\n            }));\n            newActions.push('equal'); // Reset stored elements on 'equal'.\n\n            actualSlice = [];\n            expectedSlice = [];\n          }\n\n          counter[action]++;\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(function (x) {\n        return x === 'equal' ? 'replace' : x;\n      }));\n    }\n    /**\n     * Marks text nodes to be synchronized.\n     *\n     * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n     *\n     * @private\n     * @param {module:engine/view/node~Node} viewNode View node to sync.\n     */\n\n  }, {\n    key: \"_markDescendantTextToSync\",\n    value: function _markDescendantTextToSync(viewNode) {\n      if (!viewNode) {\n        return;\n      }\n\n      if (viewNode.is('$text')) {\n        this.markedTexts.add(viewNode);\n      } else if (viewNode.is('element')) {\n        var _iterator13 = _createForOfIteratorHelper(viewNode.getChildren()),\n            _step13;\n\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var child = _step13.value;\n\n            this._markDescendantTextToSync(child);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n    }\n    /**\n     * Checks if the selection needs to be updated and possibly updates it.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateSelection\",\n    value: function _updateSelection() {\n      // Block updating DOM selection in (non-Android) Blink while the user is selecting to prevent accidental selection collapsing.\n      // Note: Structural changes in DOM must trigger selection rendering, though. Nodes the selection was anchored\n      // to, may disappear in DOM which would break the selection (e.g. in real-time collaboration scenarios).\n      // https://github.com/ckeditor/ckeditor5/issues/10562, https://github.com/ckeditor/ckeditor5/issues/10723\n      if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {\n        return;\n      } // If there is no selection - remove DOM and fake selections.\n\n\n      if (this.selection.rangeCount === 0) {\n        this._removeDomSelection();\n\n        this._removeFakeSelection();\n\n        return;\n      }\n\n      var domRoot = this.domConverter.mapViewToDom(this.selection.editableElement); // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\n      if (!this.isFocused || !domRoot) {\n        return;\n      } // Render selection.\n\n\n      if (this.selection.isFake) {\n        this._updateFakeSelection(domRoot);\n      } else {\n        this._removeFakeSelection();\n\n        this._updateDomSelection(domRoot);\n      }\n    }\n    /**\n     * Updates the fake selection.\n     *\n     * @private\n     * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n     */\n\n  }, {\n    key: \"_updateFakeSelection\",\n    value: function _updateFakeSelection(domRoot) {\n      var domDocument = domRoot.ownerDocument;\n\n      if (!this._fakeSelectionContainer) {\n        this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);\n      }\n\n      var container = this._fakeSelectionContainer; // Bind fake selection container with the current selection *position*.\n\n      this.domConverter.bindFakeSelection(container, this.selection);\n\n      if (!this._fakeSelectionNeedsUpdate(domRoot)) {\n        return;\n      }\n\n      if (!container.parentElement || container.parentElement != domRoot) {\n        domRoot.appendChild(container);\n      }\n\n      container.textContent = this.selection.fakeSelectionLabel || \"\\xA0\";\n      var domSelection = domDocument.getSelection();\n      var domRange = domDocument.createRange();\n      domSelection.removeAllRanges();\n      domRange.selectNodeContents(container);\n      domSelection.addRange(domRange);\n    }\n    /**\n     * Updates the DOM selection.\n     *\n     * @private\n     * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n     */\n\n  }, {\n    key: \"_updateDomSelection\",\n    value: function _updateDomSelection(domRoot) {\n      var domSelection = domRoot.ownerDocument.defaultView.getSelection(); // Let's check whether DOM selection needs updating at all.\n\n      if (!this._domSelectionNeedsUpdate(domSelection)) {\n        return;\n      } // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n      // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n      // and focus of view selection.\n      // Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n      // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\n\n      var anchor = this.domConverter.viewPositionToDom(this.selection.anchor);\n      var focus = this.domConverter.viewPositionToDom(this.selection.focus);\n      domSelection.collapse(anchor.parent, anchor.offset);\n      domSelection.extend(focus.parent, focus.offset); // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\n      if (env.isGecko) {\n        fixGeckoSelectionAfterBr(focus, domSelection);\n      }\n    }\n    /**\n     * Checks whether a given DOM selection needs to be updated.\n     *\n     * @private\n     * @param {Selection} domSelection The DOM selection to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_domSelectionNeedsUpdate\",\n    value: function _domSelectionNeedsUpdate(domSelection) {\n      if (!this.domConverter.isDomSelectionCorrect(domSelection)) {\n        // Current DOM selection is in incorrect position. We need to update it.\n        return true;\n      }\n\n      var oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);\n\n      if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {\n        return false;\n      } // If selection is not collapsed, it does not need to be updated if it is similar.\n\n\n      if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {\n        // Selection did not changed and is correct, do not update.\n        return false;\n      } // Selections are not similar.\n\n\n      return true;\n    }\n    /**\n     * Checks whether the fake selection needs to be updated.\n     *\n     * @private\n     * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_fakeSelectionNeedsUpdate\",\n    value: function _fakeSelectionNeedsUpdate(domRoot) {\n      var container = this._fakeSelectionContainer;\n      var domSelection = domRoot.ownerDocument.getSelection(); // Fake selection needs to be updated if there's no fake selection container, or the container currently sits\n      // in a different root.\n\n      if (!container || container.parentElement !== domRoot) {\n        return true;\n      } // Make sure that the selection actually is within the fake selection.\n\n\n      if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {\n        return true;\n      }\n\n      return container.textContent !== this.selection.fakeSelectionLabel;\n    }\n    /**\n     * Removes the DOM selection.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeDomSelection\",\n    value: function _removeDomSelection() {\n      var _iterator14 = _createForOfIteratorHelper(this.domDocuments),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var doc = _step14.value;\n          var domSelection = doc.getSelection();\n\n          if (domSelection.rangeCount) {\n            var activeDomElement = doc.activeElement;\n            var viewElement = this.domConverter.mapDomToView(activeDomElement);\n\n            if (activeDomElement && viewElement) {\n              doc.getSelection().removeAllRanges();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n    /**\n     * Removes the fake selection.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_removeFakeSelection\",\n    value: function _removeFakeSelection() {\n      var container = this._fakeSelectionContainer;\n\n      if (container) {\n        container.remove();\n      }\n    }\n    /**\n     * Checks if focus needs to be updated and possibly updates it.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateFocus\",\n    value: function _updateFocus() {\n      if (this.isFocused) {\n        var editable = this.selection.editableElement;\n\n        if (editable) {\n          this.domConverter.focus(editable);\n        }\n      }\n    }\n  }]);\n\n  return Renderer;\n}();\n\nexport { Renderer as default };\nmix(Renderer, ObservableMixin); // Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\n\nfunction isEditable(element) {\n  if (element.getAttribute('contenteditable') == 'false') {\n    return false;\n  }\n\n  var parent = element.findAncestor(function (element) {\n    return element.hasAttribute('contenteditable');\n  });\n  return !parent || parent.getAttribute('contenteditable') == 'true';\n} // Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\n\n\nfunction addInlineFiller(domDocument, domParentOrArray, offset) {\n  var childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n  var nodeAfterFiller = childNodes[offset];\n\n  if (isText(nodeAfterFiller)) {\n    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n    return nodeAfterFiller;\n  } else {\n    var fillerNode = domDocument.createTextNode(INLINE_FILLER);\n\n    if (Array.isArray(domParentOrArray)) {\n      childNodes.splice(offset, 0, fillerNode);\n    } else {\n      insertAt(domParentOrArray, offset, fillerNode);\n    }\n\n    return fillerNode;\n  }\n} // Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction areSimilar(node1, node2) {\n  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n} // Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction sameNodes(domConverter, actualDomChild, expectedDomChild) {\n  // Elements.\n  if (actualDomChild === expectedDomChild) {\n    return true;\n  } // Texts.\n  else if (isText(actualDomChild) && isText(expectedDomChild)) {\n    return actualDomChild.data === expectedDomChild.data;\n  } // Block fillers.\n  else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {\n    return true;\n  } // Not matching types.\n\n\n  return false;\n} // The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\n\n\nfunction fixGeckoSelectionAfterBr(focus, domSelection) {\n  var parent = focus.parent; // This fix works only when the focus point is at the very end of an element.\n  // There is no point in running it in cases unrelated to the browser bug.\n\n  if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {\n    return;\n  }\n\n  var childAtOffset = parent.childNodes[focus.offset]; // To stay on the safe side, the fix being as specific as possible, it targets only the\n  // selection which is at the very end of the element and preceded by <br />.\n\n  if (childAtOffset && childAtOffset.tagName == 'BR') {\n    domSelection.addRange(domSelection.getRangeAt(0));\n  }\n}\n\nfunction filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {\n  var childList = Array.from(domChildList);\n\n  if (childList.length == 0 || !fakeSelectionContainer) {\n    return childList;\n  }\n\n  var last = childList[childList.length - 1];\n\n  if (last == fakeSelectionContainer) {\n    childList.pop();\n  }\n\n  return childList;\n} // Creates a fake selection container for a given document.\n//\n// @private\n// @param {Document} domDocument\n// @returns {HTMLElement}\n\n\nfunction createFakeSelectionContainer(domDocument) {\n  var container = domDocument.createElement('div');\n  container.className = 'ck-fake-selection-container';\n  Object.assign(container.style, {\n    position: 'fixed',\n    top: 0,\n    left: '-9999px',\n    // See https://github.com/ckeditor/ckeditor5/issues/752.\n    width: '42px'\n  }); // Fill it with a text node so we can update it later.\n\n  container.textContent = \"\\xA0\";\n  return container;\n}","map":null,"metadata":{},"sourceType":"module"}