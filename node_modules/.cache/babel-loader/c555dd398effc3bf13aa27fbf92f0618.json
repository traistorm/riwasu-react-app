{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport on from 'dom-lib/on';\nimport { useCallback, useRef, useState } from 'react';\nimport AutoScroller from './AutoScroller';\nimport { closestNode, getEdgeOffset, getScrollingParent, isContainInteractiveElement, setInlineStyles, setTransitionDuration, setTranslate3d } from './utils';\nimport { useIsMounted } from '../../utils';\nimport useManager from './useManager';\n\nvar useSortHelper = function useSortHelper(config) {\n  var autoScroll = config.autoScroll,\n      pressDelay = config.pressDelay,\n      transitionDuration = config.transitionDuration,\n      onSort = config.onSort,\n      onSortEnd = config.onSortEnd,\n      onSortMove = config.onSortMove,\n      onSortStart = config.onSortStart;\n\n  var _useState = useState(false),\n      sorting = _useState[0],\n      setSorting = _useState[1];\n\n  var containerRef = useRef(null);\n  var pressTimer = useRef();\n\n  var _useManager = useManager(),\n      listItemRegister = _useManager.listItemRegister,\n      getManagedItem = _useManager.getManagedItem,\n      getOrderedItems = _useManager.getOrderedItems;\n\n  var isMounted = useIsMounted();\n  /**\n   * start dragging\n   * */\n\n  var handlePress = useCallback(function (mouseDownEvent, targetNode, curManagedItem) {\n    var _curManagedItem$info$, _curManagedItem$info$2, _activeNodeHelper;\n\n    if (!isMounted()) return;\n    var listItemBaseClassName = targetNode.classList[0]; // get list item base className\n\n    var helperElementClass = listItemBaseClassName + \"-helper\";\n    var holderElementClass = listItemBaseClassName + \"-holder\"; // data\n\n    var containerElement = containerRef.current;\n    var activeNode = curManagedItem.node;\n    var activeNodeOldIndex = (_curManagedItem$info$ = curManagedItem.info.index) !== null && _curManagedItem$info$ !== void 0 ? _curManagedItem$info$ : 0;\n    var activeNodeNextIndex = (_curManagedItem$info$2 = curManagedItem.info.index) !== null && _curManagedItem$info$2 !== void 0 ? _curManagedItem$info$2 : 0;\n    var activeNodeHolderTranslate = {\n      x: 0,\n      y: 0\n    };\n    var animatedNodesOffset = []; // all list item offset\n    // init scroller\n\n    var scrollContainer = getScrollingParent(containerElement) || containerElement;\n    var initScroll = {\n      x: scrollContainer.scrollLeft,\n      y: scrollContainer.scrollTop\n    };\n    var autoScroller = new AutoScroller(scrollContainer, function (offset) {\n      activeNodeHolderTranslate.x += offset.left;\n      activeNodeHolderTranslate.y += offset.top;\n    });\n    var activeNodeBoundingClientRect = activeNode.getBoundingClientRect();\n    var activeNodeOffsetEdge = getEdgeOffset(activeNode, containerElement);\n    var activeNodeStyle = getComputedStyle(activeNode);\n    var activeNodeHelper = activeNode.cloneNode(true);\n    (_activeNodeHelper = activeNodeHelper) === null || _activeNodeHelper === void 0 ? void 0 : _activeNodeHelper.classList.add(helperElementClass);\n    setInlineStyles(activeNodeHelper, {\n      position: 'fixed',\n      width: activeNodeBoundingClientRect.width + \"px\",\n      height: activeNodeBoundingClientRect.height + \"px\",\n      left: activeNodeBoundingClientRect.left - parseFloat(activeNodeStyle.marginLeft) + \"px\",\n      top: activeNodeBoundingClientRect.top - parseFloat(activeNodeStyle.marginTop) + \"px\"\n    });\n    activeNode.classList.add(holderElementClass);\n    document.body.appendChild(activeNodeHelper);\n\n    var getContainerScrollDelta = function getContainerScrollDelta() {\n      return {\n        left: scrollContainer.scrollLeft - initScroll.x,\n        top: scrollContainer.scrollTop - initScroll.y\n      };\n    };\n\n    var getHolderTranslate = function getHolderTranslate() {\n      return animatedNodesOffset.reduce(function (acc, item) {\n        return {\n          x: acc.x + item.x,\n          y: acc.y + item.y\n        };\n      }, {\n        x: 0,\n        y: 0\n      });\n    };\n\n    var sortMouseMoveListener = on(window, 'mousemove', function (mouseOverEvent) {\n      // Update helper position\n      var offset = {\n        x: (mouseOverEvent === null || mouseOverEvent === void 0 ? void 0 : mouseOverEvent.pageX) || 0,\n        y: (mouseOverEvent === null || mouseOverEvent === void 0 ? void 0 : mouseOverEvent.pageY) || 0\n      };\n      var containerScrollDelta = getContainerScrollDelta();\n      var containerBoundingRect = scrollContainer.getBoundingClientRect();\n      activeNodeHolderTranslate = {\n        x: offset.x - mouseDownEvent.pageX,\n        y: offset.y - mouseDownEvent.pageY\n      };\n\n      if (activeNodeHelper) {\n        setTranslate3d(activeNodeHelper, activeNodeHolderTranslate);\n      } // animate\n\n\n      activeNodeNextIndex = -1;\n      var listItemManagerRefs = getOrderedItems(curManagedItem.info.collection);\n      var aTop = activeNodeOffsetEdge.top || 0;\n      var cTop = containerScrollDelta.top || 0;\n      var sortingOffsetY = aTop + activeNodeHolderTranslate.y + cTop;\n      var activeNodeHeight = parseFloat(activeNodeStyle.height) || 0;\n\n      for (var i = 0, len = listItemManagerRefs.length; i < len; i++) {\n        var _listItemManagerRefs$;\n\n        var currentNode = listItemManagerRefs[i].node;\n        var currentNodeIndex = (_listItemManagerRefs$ = listItemManagerRefs[i].info.index) !== null && _listItemManagerRefs$ !== void 0 ? _listItemManagerRefs$ : 0;\n        var offsetY = activeNodeBoundingClientRect.height > currentNode.offsetHeight ? currentNode.offsetHeight / 2 : activeNodeBoundingClientRect.height / 2;\n        var translate = {\n          x: 0,\n          y: 0\n        }; // If we haven't cached the node's offsetTop / offsetLeft value\n\n        var curEdgeOffset = listItemManagerRefs[i].edgeOffset || getEdgeOffset(currentNode, containerElement);\n        listItemManagerRefs[i].edgeOffset = curEdgeOffset; // Get a reference to the next node\n\n        var prvNode = i > 0 && listItemManagerRefs[i - 1];\n        var nextNode = i < len - 1 && listItemManagerRefs[i + 1]; // Also cache the node's edge offset if needed.\n\n        if (prvNode && !prvNode.edgeOffset) {\n          prvNode.edgeOffset = getEdgeOffset(prvNode.node, containerElement);\n        }\n\n        if (nextNode && !nextNode.edgeOffset) {\n          nextNode.edgeOffset = getEdgeOffset(nextNode.node, containerElement);\n        } // If the node is the one we're currently animating, skip it\n\n\n        if (currentNodeIndex === activeNodeOldIndex) {\n          continue;\n        }\n\n        var curEdgeOffsetTop = curEdgeOffset.top || 0;\n\n        if (prvNode && currentNodeIndex > activeNodeOldIndex && sortingOffsetY + offsetY >= curEdgeOffsetTop) {\n          translate.y = -activeNodeHeight;\n          animatedNodesOffset[currentNodeIndex] = {\n            x: 0,\n            y: currentNode.offsetHeight\n          };\n          activeNodeNextIndex = currentNodeIndex;\n        } else if (nextNode && currentNodeIndex < activeNodeOldIndex && sortingOffsetY <= curEdgeOffsetTop + offsetY) {\n          translate.y = activeNodeHeight;\n          animatedNodesOffset[currentNodeIndex] = {\n            x: 0,\n            y: -currentNode.offsetHeight\n          };\n\n          if (activeNodeNextIndex === -1) {\n            activeNodeNextIndex = currentNodeIndex;\n          }\n        } else {\n          animatedNodesOffset[currentNodeIndex] = {\n            x: 0,\n            y: 0\n          };\n        }\n\n        setTransitionDuration(currentNode, transitionDuration);\n        setTranslate3d(currentNode, translate); // translate holder\n\n        setTranslate3d(activeNode, getHolderTranslate());\n      }\n\n      if (activeNodeNextIndex === -1) {\n        activeNodeNextIndex = activeNodeOldIndex;\n      } // auto scroll\n\n\n      if (autoScroll) {\n        autoScroller.update({\n          width: activeNodeBoundingClientRect.width,\n          height: activeNodeBoundingClientRect.height,\n          translate: activeNodeHolderTranslate,\n          maxTranslate: {\n            x: 0,\n            y: containerBoundingRect.top + containerBoundingRect.height - activeNodeBoundingClientRect.top - activeNodeBoundingClientRect.height / 2\n          },\n          minTranslate: {\n            x: 0,\n            y: containerBoundingRect.top - activeNodeBoundingClientRect.top - activeNodeBoundingClientRect.height / 2\n          }\n        });\n      }\n\n      onSortMove === null || onSortMove === void 0 ? void 0 : onSortMove({\n        collection: curManagedItem.info.collection,\n        node: activeNode,\n        oldIndex: activeNodeOldIndex,\n        newIndex: activeNodeNextIndex\n      }, mouseOverEvent);\n    }, {\n      passive: false\n    });\n    var sortMouseEndListener = on(window, 'mouseup', function (event) {\n      // Remove the event listeners\n      sortMouseMoveListener.off();\n      sortMouseEndListener.off();\n      var holderTranslate = getHolderTranslate();\n      var containerScrollDelta = getContainerScrollDelta();\n\n      if (activeNodeHelper) {\n        setTranslate3d(activeNodeHelper, {\n          x: holderTranslate.x - (containerScrollDelta.left || 0),\n          y: holderTranslate.y - (containerScrollDelta.top || 0)\n        });\n        setTransitionDuration(activeNodeHelper, transitionDuration);\n      } // wait for animation\n\n\n      setTimeout(function () {\n        var _activeNodeHelper2, _activeNodeHelper2$pa;\n\n        if (!isMounted()) return; // Remove the helper from the DOM\n\n        (_activeNodeHelper2 = activeNodeHelper) === null || _activeNodeHelper2 === void 0 ? void 0 : (_activeNodeHelper2$pa = _activeNodeHelper2.parentNode) === null || _activeNodeHelper2$pa === void 0 ? void 0 : _activeNodeHelper2$pa.removeChild(activeNodeHelper);\n        activeNodeHelper = null; // Remove redundant styles\n\n        activeNode.classList.remove(holderElementClass);\n        setTranslate3d(activeNode, null);\n        animatedNodesOffset = [];\n\n        for (var _iterator = _createForOfIteratorHelperLoose(getOrderedItems(curManagedItem.info.collection)), _step; !(_step = _iterator()).done;) {\n          var item = _step.value; // Clear the cached offsetTop / offsetLeft value\n\n          item.edgeOffset = null; // Remove the transforms / transitions\n\n          var el = item.node;\n          setTranslate3d(el, null);\n          setTransitionDuration(el, null);\n        } // Stop autoScroll\n\n\n        autoScroller.clear(); // Update manager state\n\n        setSorting(false); // callbacks\n\n        var callbackPayload = {\n          collection: curManagedItem.info.collection,\n          node: curManagedItem.node,\n          newIndex: activeNodeNextIndex,\n          oldIndex: activeNodeOldIndex\n        };\n        onSortEnd === null || onSortEnd === void 0 ? void 0 : onSortEnd(callbackPayload, event);\n        onSort === null || onSort === void 0 ? void 0 : onSort(callbackPayload, event);\n      }, transitionDuration);\n    }, {\n      passive: false\n    });\n    setSorting(true); // start callback\n\n    onSortStart === null || onSortStart === void 0 ? void 0 : onSortStart({\n      collection: curManagedItem.info.collection,\n      node: activeNode,\n      oldIndex: activeNodeOldIndex,\n      newIndex: activeNodeNextIndex\n    }, mouseDownEvent.nativeEvent);\n  }, [autoScroll, getOrderedItems, isMounted, onSort, onSortEnd, onSortMove, onSortStart, transitionDuration]);\n  /**\n   * Determine whether to start dragging\n   * */\n\n  var handleStart = useCallback(function (mouseDownEvent) {\n    var triggeredNode = mouseDownEvent.target;\n    var targetNode = closestNode(triggeredNode, function (el) {\n      return Boolean(getManagedItem(el));\n    });\n    var curManagedItem = getManagedItem(targetNode);\n\n    if ( // is not secondary button pressed\n    mouseDownEvent.button !== 2 && // is list item\n    Boolean(curManagedItem) && !curManagedItem.info.disabled && // is not sorting\n    !sorting && // is valid node\n    targetNode instanceof HTMLElement && // excludes interactive elements\n    !targetNode.contains(closestNode(triggeredNode, isContainInteractiveElement))) {\n      mouseDownEvent.preventDefault();\n      pressTimer.current = setTimeout(handlePress, pressDelay, mouseDownEvent, targetNode, curManagedItem);\n    }\n  }, [getManagedItem, handlePress, pressDelay, sorting]);\n  /**\n   * Clear timer after drag\n   * */\n\n  var handleEnd = useCallback(function () {\n    return clearTimeout(pressTimer.current);\n  }, []);\n  return {\n    handleStart: handleStart,\n    handleEnd: handleEnd,\n    containerRef: containerRef,\n    sorting: sorting,\n    register: listItemRegister\n  };\n};\n\nexport default useSortHelper;","map":null,"metadata":{},"sourceType":"module"}