{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/editor/editor\n */\nimport Context from '../context';\nimport Config from '@ckeditor/ckeditor5-utils/src/config';\nimport EditingController from '@ckeditor/ckeditor5-engine/src/controller/editingcontroller';\nimport PluginCollection from '../plugincollection';\nimport CommandCollection from '../commandcollection';\nimport DataController from '@ckeditor/ckeditor5-engine/src/controller/datacontroller';\nimport Conversion from '@ckeditor/ckeditor5-engine/src/conversion/conversion';\nimport Model from '@ckeditor/ckeditor5-engine/src/model/model';\nimport EditingKeystrokeHandler from '../editingkeystrokehandler';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { StylesProcessor } from '@ckeditor/ckeditor5-engine/src/view/stylesmap';\n/**\n * The class representing a basic, generic editor.\n *\n * Check out the list of its subclasses to learn about specific editor implementations.\n *\n * All editor implementations (like {@link module:editor-classic/classiceditor~ClassicEditor} or\n * {@link module:editor-inline/inlineeditor~InlineEditor}) should extend this class. They can add their\n * own methods and properties.\n *\n * When you are implementing a plugin, this editor represents the API\n * which your plugin can expect to get when using its {@link module:core/plugin~Plugin#editor} property.\n *\n * This API should be sufficient in order to implement the \"editing\" part of your feature\n * (schema definition, conversion, commands, keystrokes, etc.).\n * It does not define the editor UI, which is available only if\n * the specific editor implements also the {@link module:core/editor/editorwithui~EditorWithUI} interface\n * (as most editor implementations do).\n *\n * @abstract\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Editor = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of the editor class.\n   *\n   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.\n   *\n   * @param {Object} [config={}] The editor configuration.\n   */\n  function Editor() {\n    var _this = this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Editor);\n\n    // Prefer the language passed as the argument to the constructor instead of the constructor's `defaultConfig`, if both are set.\n    var language = config.language || this.constructor.defaultConfig && this.constructor.defaultConfig.language;\n    /**\n     * The editor context.\n     * When it is not provided through the configuration, the editor creates it.\n     *\n     * @protected\n     * @type {module:core/context~Context}\n     */\n\n    this._context = config.context || new Context({\n      language: language\n    });\n\n    this._context._addEditor(this, !config.context); // Clone the plugins to make sure that the plugin array will not be shared\n    // between editors and make the watchdog feature work correctly.\n\n\n    var availablePlugins = Array.from(this.constructor.builtinPlugins || []);\n    /**\n     * Stores all configurations specific to this editor instance.\n     *\n     *\t\teditor.config.get( 'image.toolbar' );\n     *\t\t// -> [ 'imageStyle:block', 'imageStyle:side', '|', 'toggleImageCaption', 'imageTextAlternative' ]\n     *\n     * @readonly\n     * @member {module:utils/config~Config}\n     */\n\n    this.config = new Config(config, this.constructor.defaultConfig);\n    this.config.define('plugins', availablePlugins);\n    this.config.define(this._context._getEditorConfig());\n    /**\n     * The plugins loaded and in use by this editor instance.\n     *\n     *\t\teditor.plugins.get( 'ClipboardPipeline' ); // -> An instance of the clipboard pipeline plugin.\n     *\n     * @readonly\n     * @member {module:core/plugincollection~PluginCollection}\n     */\n\n    this.plugins = new PluginCollection(this, availablePlugins, this._context.plugins);\n    /**\n     * The locale instance.\n     *\n     * @readonly\n     * @type {module:utils/locale~Locale}\n     */\n\n    this.locale = this._context.locale;\n    /**\n     * Shorthand for {@link module:utils/locale~Locale#t}.\n     *\n     * @see module:utils/locale~Locale#t\n     * @method #t\n     */\n\n    this.t = this.locale.t;\n    /**\n     * A set of lock IDs for the {@link #isReadOnly} getter.\n     *\n     * @private\n     * @type {Set.<String|Symbol>}\n     */\n\n    this._readOnlyLocks = new Set();\n    /**\n     * Commands registered to the editor.\n     *\n     * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:\n     *\n     *\t\t// Execute the bold command:\n     *\t\teditor.execute( 'bold' );\n     *\n     *\t\t// Check the state of the bold command:\n     *\t\teditor.commands.get( 'bold' ).value;\n     *\n     * @readonly\n     * @member {module:core/commandcollection~CommandCollection}\n     */\n\n    this.commands = new CommandCollection();\n    /**\n     * Indicates the editor life-cycle state.\n     *\n     * The editor is in one of the following states:\n     *\n     * * `initializing` &ndash; During the editor initialization (before\n     * {@link module:core/editor/editor~Editor.create `Editor.create()`}) finished its job.\n     * * `ready` &ndash; After the promise returned by the {@link module:core/editor/editor~Editor.create `Editor.create()`}\n     * method is resolved.\n     * * `destroyed` &ndash; Once the {@link #destroy `editor.destroy()`} method was called.\n     *\n     * @observable\n     * @member {'initializing'|'ready'|'destroyed'} #state\n     */\n\n    this.set('state', 'initializing');\n    this.once('ready', function () {\n      return _this.state = 'ready';\n    }, {\n      priority: 'high'\n    });\n    this.once('destroy', function () {\n      return _this.state = 'destroyed';\n    }, {\n      priority: 'high'\n    });\n    /**\n     * The editor's model.\n     *\n     * The central point of the editor's abstract data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n\n    this.model = new Model();\n    var stylesProcessor = new StylesProcessor();\n    /**\n     * The {@link module:engine/controller/datacontroller~DataController data controller}.\n     * Used e.g. for setting and retrieving the editor data.\n     *\n     * @readonly\n     * @member {module:engine/controller/datacontroller~DataController}\n     */\n\n    this.data = new DataController(this.model, stylesProcessor);\n    /**\n     * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.\n     * Controls user input and rendering the content for editing.\n     *\n     * @readonly\n     * @member {module:engine/controller/editingcontroller~EditingController}\n     */\n\n    this.editing = new EditingController(this.model, stylesProcessor);\n    this.editing.view.document.bind('isReadOnly').to(this);\n    /**\n     * Conversion manager through which you can register model-to-view and view-to-model converters.\n     *\n     * See the {@link module:engine/conversion/conversion~Conversion} documentation to learn how to add converters.\n     *\n     * @readonly\n     * @member {module:engine/conversion/conversion~Conversion}\n     */\n\n    this.conversion = new Conversion([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);\n    this.conversion.addAlias('dataDowncast', this.data.downcastDispatcher);\n    this.conversion.addAlias('editingDowncast', this.editing.downcastDispatcher);\n    /**\n     * An instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.\n     *\n     * It allows setting simple keystrokes:\n     *\n     *\t\t// Execute the bold command on Ctrl+E:\n     *\t\teditor.keystrokes.set( 'Ctrl+E', 'bold' );\n     *\n     *\t\t// Execute your own callback:\n     *\t\teditor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {\n     *\t\t\tconsole.log( data.keyCode );\n     *\n     *\t\t\t// Prevent the default (native) action and stop the underlying keydown event\n     *\t\t\t// so no other editor feature will interfere.\n     *\t\t\tcancel();\n     *\t\t} );\n     *\n     * Note: Certain typing-oriented keystrokes (like <kbd>Backspace</kbd> or <kbd>Enter</kbd>) are handled\n     * by a low-level mechanism and trying to listen to them via the keystroke handler will not work reliably.\n     * To handle these specific keystrokes, see the events fired by the\n     * {@link module:engine/view/document~Document editing view document} (`editor.editing.view.document`).\n     *\n     * @readonly\n     * @member {module:core/editingkeystrokehandler~EditingKeystrokeHandler}\n     */\n\n    this.keystrokes = new EditingKeystrokeHandler(this);\n    this.keystrokes.listenTo(this.editing.view.document);\n  }\n  /**\n   * Defines whether the editor is in the read-only mode.\n   *\n   * In read-only mode the editor {@link #commands commands} are disabled so it is not possible\n   * to modify the document by using them. Also, the editable element(s) become non-editable.\n   *\n   * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:\n   *\n   *\t\teditor.enableReadOnlyMode( 'feature-id' );\n   *\n      * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:\n   *\n   * \t\teditor.disableReadOnlyMode( 'feature-id' );\n   *\n   * @readonly\n   * @observable\n   * @member {Boolean} #isReadOnly\n   */\n\n\n  _createClass(Editor, [{\n    key: \"enableReadOnlyMode\",\n\n    /**\n     * Turns on the read-only mode in the editor.\n     *\n     * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking\n     * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at\n     * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which\n     * could lead to errors).\n     *\n     * Each read-only mode request is identified by a unique id (also called \"lock\"). If multiple plugins requested to turn on the\n     * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).\n     *\n     * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.\n     *\n     * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:\n     *\n     *\t\teditor.isReadOnly; // `false`.\n     * \t\teditor.enableReadOnlyMode( 'my-feature-id' );\n     * \t\teditor.isReadOnly; // `true`.\n     *\n     * You can turn off the read-only mode (\"clear the lock\") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:\n     *\n     * \t\teditor.enableReadOnlyMode( 'my-feature-id' );\n     * \t\t// ...\n     * \t\teditor.disableReadOnlyMode( 'my-feature-id' );\n     * \t\teditor.isReadOnly; // `false`.\n     *\n     * All \"locks\" need to be removed to enable editing:\n     *\n     * \t\teditor.enableReadOnlyMode( 'my-feature-id' );\n     * \t\teditor.enableReadOnlyMode( 'my-other-feature-id' );\n     * \t\t// ...\n     * \t\teditor.disableReadOnlyMode( 'my-feature-id' );\n     * \t\teditor.isReadOnly; // `true`.\n     * \t\teditor.disableReadOnlyMode( 'my-other-feature-id' );\n     * \t\teditor.isReadOnly; // `false`.\n     *\n     * @param {String|Symbol} lockId A unique ID for setting the editor to the read-only state.\n     */\n    value: function enableReadOnlyMode(lockId) {\n      if (typeof lockId !== 'string' && typeof lockId !== 'symbol') {\n        /**\n         * The lock ID is missing or it is not a string or symbol.\n         *\n         * @error editor-read-only-lock-id-invalid\n         */\n        throw new CKEditorError('editor-read-only-lock-id-invalid', null, {\n          lockId: lockId\n        });\n      }\n\n      if (this._readOnlyLocks.has(lockId)) {\n        return;\n      }\n\n      this._readOnlyLocks.add(lockId);\n\n      if (this._readOnlyLocks.size === 1) {\n        // Manually fire the `change:isReadOnly` event as only getter is provided.\n        this.fire('change:isReadOnly', 'isReadOnly', true, false);\n      }\n    }\n    /**\n     * Removes the read-only lock from the editor with given lock ID.\n     *\n     * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.\n     *\n     * @param {String|Symbol} lockId The lock ID for setting the editor to the read-only state.\n     */\n\n  }, {\n    key: \"disableReadOnlyMode\",\n    value: function disableReadOnlyMode(lockId) {\n      if (typeof lockId !== 'string' && typeof lockId !== 'symbol') {\n        throw new CKEditorError('editor-read-only-lock-id-invalid', null, {\n          lockId: lockId\n        });\n      }\n\n      if (!this._readOnlyLocks.has(lockId)) {\n        return;\n      }\n\n      this._readOnlyLocks.delete(lockId);\n\n      if (this._readOnlyLocks.size === 0) {\n        // Manually fire the `change:isReadOnly` event as only getter is provided.\n        this.fire('change:isReadOnly', 'isReadOnly', false, true);\n      }\n    }\n    /**\n     * Loads and initializes plugins specified in the configuration.\n     *\n     * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which resolves\n     * once the initialization is completed, providing an array of loaded plugins.\n     */\n\n  }, {\n    key: \"initPlugins\",\n    value: function initPlugins() {\n      var config = this.config;\n      var plugins = config.get('plugins');\n      var removePlugins = config.get('removePlugins') || [];\n      var extraPlugins = config.get('extraPlugins') || [];\n      var substitutePlugins = config.get('substitutePlugins') || [];\n      return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins);\n    }\n    /**\n     * Destroys the editor instance, releasing all resources used by it.\n     *\n     * **Note** The editor cannot be destroyed during the initialization phase so if it is called\n     * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.\n     *\n     * @fires destroy\n     * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      var readyPromise = Promise.resolve();\n\n      if (this.state == 'initializing') {\n        readyPromise = new Promise(function (resolve) {\n          return _this2.once('ready', resolve);\n        });\n      }\n\n      return readyPromise.then(function () {\n        _this2.fire('destroy');\n\n        _this2.stopListening();\n\n        _this2.commands.destroy();\n      }).then(function () {\n        return _this2.plugins.destroy();\n      }).then(function () {\n        _this2.model.destroy();\n\n        _this2.data.destroy();\n\n        _this2.editing.destroy();\n\n        _this2.keystrokes.destroy();\n      }) // Remove the editor from the context.\n      // When the context was created by this editor, the context will be destroyed.\n      .then(function () {\n        return _this2._context._removeEditor(_this2);\n      });\n    }\n    /**\n     * Executes the specified command with given parameters.\n     *\n     * Shorthand for:\n     *\n     *\t\teditor.commands.get( commandName ).execute( ... );\n     *\n     * @param {String} commandName The name of the command to execute.\n     * @param {*} [...commandParams] Command parameters.\n     * @returns {*} The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      try {\n        var _this$commands;\n\n        return (_this$commands = this.commands).execute.apply(_this$commands, arguments);\n      } catch (err) {\n        // @if CK_DEBUG // throw err;\n\n        /* istanbul ignore next */\n        CKEditorError.rethrowUnexpectedError(err, this);\n      }\n    }\n    /**\n     * Focuses the editor.\n     *\n     * **Note** To explicitly focus the editing area of the editor, use the\n     * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.\n     *\n     * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section\n     * of the {@glink framework/guides/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.editing.view.focus();\n    }\n    /**\n     * Creates and initializes a new editor instance.\n     *\n     * This is an abstract method. Every editor type needs to implement its own initialization logic.\n     *\n     * See the `create()` methods of the existing editor types to learn how to use them:\n     *\n     * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}\n     * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}\n     * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}\n     * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}\n     *\n     * @abstract\n     * @method module:core/editor/editor~Editor.create\n     */\n\n  }, {\n    key: \"isReadOnly\",\n    get: function get() {\n      return this._readOnlyLocks.size > 0;\n    },\n    set: function set(value) {\n      /**\n       * {@link #isReadOnly Editor#isReadOnly} property is read-only since version `34.0.0` and can be set only using\n       * {@link #enableReadOnlyMode `Editor#enableReadOnlyMode( lockId )`} and\n       * {@link #disableReadOnlyMode `Editor#disableReadOnlyMode( lockId )`}.\n       *\n       * Before version `34.0.0`:\n       *\n       *\t\teditor.isReadOnly = true;\n       * \t\teditor.isReadOnly = false;\n       *\n       * Since version `34.0.0`:\n       *\n       *\t\teditor.enableReadOnlyMode( 'my-feature-id' );\n       * \t\teditor.disableReadOnlyMode( 'my-feature-id' );\n       *\n       * @error editor-isreadonly-has-no-setter\n       */\n      throw new CKEditorError('editor-isreadonly-has-no-setter');\n    }\n  }]);\n\n  return Editor;\n}();\n\nexport { Editor as default };\nmix(Editor, ObservableMixin);\n/**\n * Fired when the {@link module:engine/controller/datacontroller~DataController#event:ready data} and all additional\n * editor components are ready.\n *\n * Note: This event is most useful for plugin developers. When integrating the editor with your website or\n * application, you do not have to listen to `editor#ready` because when the promise returned by the static\n * {@link module:core/editor/editor~Editor.create `Editor.create()`} event is resolved, the editor is already ready.\n * In fact, since the first moment when the editor instance is available to you is inside `then()`'s callback,\n * you cannot even add a listener to the `editor#ready` event.\n *\n * See also the {@link #state `editor.state`} property.\n *\n * @event ready\n */\n\n/**\n * Fired when this editor instance is destroyed. The editor at this point is not usable and this event should be used to\n * perform the clean-up in any plugin.\n *\n *\n * See also the {@link #state `editor.state`} property.\n *\n * @event destroy\n */\n\n/**\n * This error is thrown when trying to pass a `<textarea>` element to a `create()` function of an editor class.\n *\n * The only editor type which can be initialized on `<textarea>` elements is\n * the {@glink installation/advanced/alternative-setups/predefined-builds#classic-editor classic editor}.\n * This editor hides the passed element and inserts its own UI next to it. Other types of editors reuse the passed element as their root\n * editable element and therefore `<textarea>` is not appropriate for them. Use a `<div>` or another text container instead:\n *\n *\t\t<div id=\"editor\">\n *\t\t\t<p>Initial content.</p>\n *\t\t</div>\n *\n * @error editor-wrong-element\n */\n\n/**\n * An array of plugins built into this editor class.\n *\n * It is used in CKEditor 5 builds to provide a list of plugins which are later automatically initialized\n * during the editor initialization.\n *\n * They will be automatically initialized by the editor, unless listed in `config.removePlugins` and\n * unless `config.plugins` is passed.\n *\n *\t\t// Build some plugins into the editor class first.\n *\t\tClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];\n *\n *\t\t// Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was\n *\t\t// defined, now you can call create() without any configuration.\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.\n *\t\t\t\teditor.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.\n *\t\t\t} );\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, {\n *\t\t\t\t// Do not initialize these plugins (note: it is defined by a string):\n *\t\t\t\tremovePlugins: [ 'Foo' ]\n *\t\t\t} )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> Undefined.\n *\t\t\t\teditor.config.get( BarPlugin ); // -> An instance of the Bar plugin.\n *\t\t\t} );\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, {\n *\t\t\t\t// Load only this plugin. It can also be defined by a string if\n *\t\t\t\t// this plugin was built into the editor class.\n *\t\t\t\tplugins: [ FooPlugin ]\n *\t\t\t} )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.\n *\t\t\t\teditor.config.get( BarPlugin ); // -> Undefined.\n *\t\t\t} );\n *\n * See also {@link module:core/editor/editor~Editor.defaultConfig}.\n *\n * @static\n * @member {Array.<Function>} module:core/editor/editor~Editor.builtinPlugins\n */\n\n/**\n * The default configuration which is built into the editor class.\n *\n * It is used in CKEditor 5 builds to provide the default configuration options which are later used during the editor initialization.\n *\n *\t\tClassicEditor.defaultConfig = {\n *\t\t\tfoo: 1,\n *\t\t\tbar: 2\n *\t\t};\n *\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.config.get( 'foo' ); // -> 1\n *\t\t\t\teditor.config.get( 'bar' ); // -> 2\n *\t\t\t} );\n *\n *\t\t// The default options can be overridden by the configuration passed to create().\n *\t\tClassicEditor\n *\t\t\t.create( sourceElement, { bar: 3 } )\n *\t\t\t.then( editor => {\n *\t\t\t\teditor.config.get( 'foo' ); // -> 1\n *\t\t\t\teditor.config.get( 'bar' ); // -> 3\n *\t\t\t} );\n *\n * See also {@link module:core/editor/editor~Editor.builtinPlugins}.\n *\n * @static\n * @member {Object} module:core/editor/editor~Editor.defaultConfig\n */","map":null,"metadata":{},"sourceType":"module"}