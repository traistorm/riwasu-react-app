{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/keystrokehandler\n */\nimport DomEmitterMixin from './dom/emittermixin';\nimport { getCode, parseKeystroke } from './keyboard';\n/**\n * Keystroke handler allows registering callbacks for given keystrokes.\n *\n * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}\n * property. It allows listening to keystrokes executed in the editing view:\n *\n *\t\teditor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {\n *\t\t\tconsole.log( 'Ctrl+A has been pressed' );\n *\t\t\tcancel();\n *\t\t} );\n *\n * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}\n * can use it like this:\n *\n *\t\tclass MyView extends View {\n *\t\t\tconstructor() {\n *\t\t\t\tthis.keystrokes = new KeystrokeHandler();\n *\n * \t\t\t\tthis.keystrokes.set( 'tab', handleTabKey );\n *\t\t\t}\n *\n *\t\t\trender() {\n *\t\t\t\tsuper.render();\n *\n *\t\t\t\tthis.keystrokes.listenTo( this.element );\n *\t\t\t}\n *\t\t}\n *\n * That keystroke handler will listen to `keydown` events fired in this view's main element.\n *\n */\n\nvar KeystrokeHandler = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the keystroke handler.\n   */\n  function KeystrokeHandler() {\n    _classCallCheck(this, KeystrokeHandler);\n\n    /**\n     * Listener used to listen to events for easier keystroke handler destruction.\n     *\n     * @protected\n     * @member {module:utils/dom/emittermixin~Emitter}\n     */\n    this._listener = Object.create(DomEmitterMixin);\n  }\n  /**\n   * Starts listening for `keydown` events from a given emitter.\n   *\n   * @param {module:utils/emittermixin~Emitter} emitter\n   */\n\n\n  _createClass(KeystrokeHandler, [{\n    key: \"listenTo\",\n    value: function listenTo(emitter) {\n      var _this = this;\n\n      // The #_listener works here as a kind of dispatcher. It groups the events coming from the same\n      // keystroke so the listeners can be attached to them with different priorities.\n      //\n      // E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated\n      // as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`\n      // method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts\n      // only with other listeners of this particular event, thus making it possible to prioritize\n      // the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,\n      // the KeystrokeHandler reâ€“uses it to do its job.\n      this._listener.listenTo(emitter, 'keydown', function (evt, keyEvtData) {\n        _this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n      });\n    }\n    /**\n     * Registers a handler for the specified keystroke.\n     *\n     * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by\n     * the {@link module:utils/keyboard~parseKeystroke} function.\n     * @param {Function} callback A function called with the\n     * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and\n     * a helper funcion to call both `preventDefault()` and `stopPropagation()` on the underlying event.\n     * @param {Object} [options={}] Additional options.\n     * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke\n     * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority\n     * are called in the order they were added.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(keystroke, callback) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var keyCode = parseKeystroke(keystroke);\n      var priority = options.priority; // Execute the passed callback on KeystrokeHandler#_keydown.\n      // TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144\n\n      this._listener.listenTo(this._listener, '_keydown:' + keyCode, function (evt, keyEvtData) {\n        callback(keyEvtData, function () {\n          // Stop the event in the DOM: no listener in the web page\n          // will be triggered by this event.\n          keyEvtData.preventDefault();\n          keyEvtData.stopPropagation(); // Stop the event in the KeystrokeHandler: no more callbacks\n          // will be executed for this keystroke.\n\n          evt.stop();\n        }); // Mark this keystroke as handled by the callback. See: #press.\n\n        evt.return = true;\n      }, {\n        priority: priority\n      });\n    }\n    /**\n     * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.\n     *\n     * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.\n     * @returns {Boolean} Whether the keystroke was handled.\n     */\n\n  }, {\n    key: \"press\",\n    value: function press(keyEvtData) {\n      return !!this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);\n    }\n    /**\n     * Destroys the keystroke handler.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._listener.stopListening();\n    }\n  }]);\n\n  return KeystrokeHandler;\n}();\n\nexport { KeystrokeHandler as default };","map":null,"metadata":{},"sourceType":"module"}