{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/toolbar/toolbarview\n */\nimport View from '../view';\nimport FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';\nimport FocusCycler from '../focuscycler';\nimport KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';\nimport ToolbarSeparatorView from './toolbarseparatorview';\nimport ToolbarLineBreakView from './toolbarlinebreakview';\nimport ResizeObserver from '@ckeditor/ckeditor5-utils/src/dom/resizeobserver';\nimport preventDefault from '../bindings/preventdefault.js';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\nimport isVisible from '@ckeditor/ckeditor5-utils/src/dom/isvisible';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport { createDropdown, addToolbarToDropdown } from '../dropdown/utils';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport normalizeToolbarConfig from './normalizetoolbarconfig';\nimport threeVerticalDots from '@ckeditor/ckeditor5-core/theme/icons/three-vertical-dots.svg';\nimport '../../theme/components/toolbar/toolbar.css';\n/**\n * The toolbar view class.\n *\n * @extends module:ui/view~View\n * @implements module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable\n */\n\nvar ToolbarView = /*#__PURE__*/function (_View) {\n  _inherits(ToolbarView, _View);\n\n  /**\n   * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.\n   *\n   * Also see {@link #render}.\n   *\n   * @param {module:utils/locale~Locale} locale The localization services instance.\n   * @param {module:ui/toolbar/toolbarview~ToolbarOptions} [options] Configuration options of the toolbar.\n   */\n  function ToolbarView(locale, options) {\n    var _this;\n\n    _classCallCheck(this, ToolbarView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ToolbarView).call(this, locale));\n    var bind = _this.bindTemplate;\n    var t = _this.t;\n    /**\n     * A reference to the options object passed to the constructor.\n     *\n     * @readonly\n     * @member {module:ui/toolbar/toolbarview~ToolbarOptions}\n     */\n\n    _this.options = options || {};\n    /**\n     * Label used by assistive technologies to describe this toolbar element.\n     *\n     * @default 'Editor toolbar'\n     * @member {String} #ariaLabel\n     */\n\n    _this.set('ariaLabel', t('Editor toolbar'));\n    /**\n     * The maximum width of the toolbar element.\n     *\n     * **Note**: When set to a specific value (e.g. `'200px'`), the value will affect the behavior of the\n     * {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull}\n     * option by changing the number of {@link #items} that will be displayed in the toolbar at a time.\n     *\n     * @observable\n     * @default 'auto'\n     * @member {String} #maxWidth\n     */\n\n\n    _this.set('maxWidth', 'auto');\n    /**\n     * A collection of toolbar items (buttons, dropdowns, etc.).\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n\n    _this.items = _this.createCollection();\n    /**\n     * Tracks information about the DOM focus in the toolbar.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker}\n     */\n\n    _this.focusTracker = new FocusTracker();\n    /**\n     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}\n     * to handle keyboard navigation in the toolbar.\n     *\n     * @readonly\n     * @member {module:utils/keystrokehandler~KeystrokeHandler}\n     */\n\n    _this.keystrokes = new KeystrokeHandler();\n    /**\n     * An additional CSS class added to the {@link #element}.\n     *\n     * @observable\n     * @member {String} #class\n     */\n\n    _this.set('class');\n    /**\n     * When set true, makes the toolbar look compact with {@link #element}.\n     *\n     * @observable\n     * @default false\n     * @member {String} #isCompact\n     */\n\n\n    _this.set('isCompact', false);\n    /**\n     * A (child) view containing {@link #items toolbar items}.\n     *\n     * @readonly\n     * @member {module:ui/toolbar/toolbarview~ItemsView}\n     */\n\n\n    _this.itemsView = new ItemsView(locale);\n    /**\n     * A top–level collection aggregating building blocks of the toolbar.\n     *\n     *\t┌───────────────── ToolbarView ─────────────────┐\n     *\t| ┌──────────────── #children ────────────────┐ |\n     *\t| |   ┌──────────── #itemsView ───────────┐   | |\n     *\t| |   | [ item1 ] [ item2 ] ... [ itemN ] |   | |\n     *\t| |   └──────────────────────────────────-┘   | |\n     *\t| └───────────────────────────────────────────┘ |\n     *\t└───────────────────────────────────────────────┘\n     *\n     * By default, it contains the {@link #itemsView} but it can be extended with additional\n     * UI elements when necessary.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    _this.children = _this.createCollection();\n\n    _this.children.add(_this.itemsView);\n    /**\n     * A collection of {@link #items} that take part in the focus cycling\n     * (i.e. navigation using the keyboard). Usually, it contains a subset of {@link #items} with\n     * some optional UI elements that also belong to the toolbar and should be focusable\n     * by the user.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n\n    _this.focusables = _this.createCollection();\n    /**\n     * Controls the orientation of toolbar items. Only available when\n     * {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull dynamic items grouping}\n     * is **disabled**.\n     *\n     * @observable\n     * @member {Boolean} #isVertical\n     */\n\n    /**\n     * Helps cycling over {@link #focusables focusable items} in the toolbar.\n     *\n     * @readonly\n     * @protected\n     * @member {module:ui/focuscycler~FocusCycler}\n     */\n\n    var isRtl = locale.uiLanguageDirection === 'rtl';\n    _this._focusCycler = new FocusCycler({\n      focusables: _this.focusables,\n      focusTracker: _this.focusTracker,\n      keystrokeHandler: _this.keystrokes,\n      actions: {\n        // Navigate toolbar items backwards using the arrow[left,up] keys.\n        focusPrevious: [isRtl ? 'arrowright' : 'arrowleft', 'arrowup'],\n        // Navigate toolbar items forwards using the arrow[right,down] keys.\n        focusNext: [isRtl ? 'arrowleft' : 'arrowright', 'arrowdown']\n      }\n    });\n    var classes = ['ck', 'ck-toolbar', bind.to('class'), bind.if('isCompact', 'ck-toolbar_compact')];\n\n    if (_this.options.shouldGroupWhenFull && _this.options.isFloating) {\n      classes.push('ck-toolbar_floating');\n    }\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: classes,\n        role: 'toolbar',\n        'aria-label': bind.to('ariaLabel'),\n        style: {\n          maxWidth: bind.to('maxWidth')\n        }\n      },\n      children: _this.children,\n      on: {\n        // https://github.com/ckeditor/ckeditor5-ui/issues/206\n        mousedown: preventDefault(_assertThisInitialized(_assertThisInitialized(_this)))\n      }\n    });\n    /**\n     * An instance of the active toolbar behavior that shapes its look and functionality.\n     *\n     * See {@link module:ui/toolbar/toolbarview~ToolbarBehavior} to learn more.\n     *\n     * @protected\n     * @readonly\n     * @member {module:ui/toolbar/toolbarview~ToolbarBehavior}\n     */\n\n\n    _this._behavior = _this.options.shouldGroupWhenFull ? new DynamicGrouping(_assertThisInitialized(_assertThisInitialized(_this))) : new StaticLayout(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ToolbarView, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ToolbarView.prototype), \"render\", this).call(this); // Children added before rendering should be known to the #focusTracker.\n\n\n      var _iterator = _createForOfIteratorHelper(this.items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          this.focusTracker.add(item.element);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.items.on('add', function (evt, item) {\n        _this2.focusTracker.add(item.element);\n      });\n      this.items.on('remove', function (evt, item) {\n        _this2.focusTracker.remove(item.element);\n      }); // Start listening for the keystrokes coming from #element.\n\n      this.keystrokes.listenTo(this.element);\n\n      this._behavior.render(this);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._behavior.destroy();\n\n      this.focusTracker.destroy();\n      this.keystrokes.destroy();\n      return _get(_getPrototypeOf(ToolbarView.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Focuses the first focusable in {@link #focusables}.\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this._focusCycler.focusFirst();\n    }\n    /**\n     * Focuses the last focusable in {@link #focusables}.\n     */\n\n  }, {\n    key: \"focusLast\",\n    value: function focusLast() {\n      this._focusCycler.focusLast();\n    }\n    /**\n     * A utility that expands the plain toolbar configuration into\n     * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.\n     *\n     * @param {Array.<String>|Object} itemsOrConfig The toolbar items or the entire toolbar configuration object.\n     * @param {module:ui/componentfactory~ComponentFactory} factory A factory producing toolbar items.\n     */\n\n  }, {\n    key: \"fillFromConfig\",\n    value: function fillFromConfig(itemsOrConfig, factory) {\n      var _this3 = this;\n\n      var config = normalizeToolbarConfig(itemsOrConfig);\n      var itemsToClean = config.items.filter(function (name, idx, items) {\n        if (name === '|') {\n          return true;\n        } // Items listed in `config.removeItems` should not be added to the toolbar.\n\n\n        if (config.removeItems.indexOf(name) !== -1) {\n          return false;\n        }\n\n        if (name === '-') {\n          // The toolbar line breaks must not be rendered when toolbar grouping is enabled.\n          // (https://github.com/ckeditor/ckeditor5/issues/8582)\n          if (_this3.options.shouldGroupWhenFull) {\n            /**\n             * The toolbar multiline breaks (`-` items) only work when the automatic button grouping\n             * is disabled in the toolbar configuration.\n             * To do this, set the `shouldNotGroupWhenFull` option to `true` in the editor configuration:\n             *\n             *\t\tconst config = {\n             *\t\t\ttoolbar: {\n             *\t\t\t\titems: [ ... ],\n             *\t\t\t\tshouldNotGroupWhenFull: true\n             *\t\t\t}\n             *\t\t}\n             *\n             * Learn more about {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar configuration}.\n             *\n             * @error toolbarview-line-break-ignored-when-grouping-items\n             */\n            logWarning('toolbarview-line-break-ignored-when-grouping-items', items);\n            return false;\n          }\n\n          return true;\n        } // For the items that cannot be instantiated we are sending warning message. We also filter them out.\n\n\n        if (!factory.has(name)) {\n          /**\n           * There was a problem processing the configuration of the toolbar. The item with the given\n           * name does not exist so it was omitted when rendering the toolbar.\n           *\n           * This warning usually shows up when the {@link module:core/plugin~Plugin} which is supposed\n           * to provide a toolbar item has not been loaded or there is a typo in the configuration.\n           *\n           * Make sure the plugin responsible for this toolbar item is loaded and the toolbar configuration\n           * is correct, e.g. {@link module:basic-styles/bold~Bold} is loaded for the `'bold'` toolbar item.\n           *\n           * You can use the following snippet to retrieve all available toolbar items:\n           *\n           *\t\tArray.from( editor.ui.componentFactory.names() );\n           *\n           * @error toolbarview-item-unavailable\n           * @param {String} name The name of the component.\n           */\n          logWarning('toolbarview-item-unavailable', {\n            name: name\n          });\n          return false;\n        }\n\n        return true;\n      });\n\n      var itemsToAdd = this._cleanSeparators(itemsToClean) // Instantiate toolbar items.\n      .map(function (name) {\n        if (name === '|') {\n          return new ToolbarSeparatorView();\n        } else if (name === '-') {\n          return new ToolbarLineBreakView();\n        }\n\n        return factory.create(name);\n      });\n\n      this.items.addMany(itemsToAdd);\n    }\n    /**\n     * Remove leading, trailing, and duplicated separators (`-` and `|`).\n     *\n     * @private\n     * @param {Array.<String>} items\n     */\n\n  }, {\n    key: \"_cleanSeparators\",\n    value: function _cleanSeparators(items) {\n      var nonSeparatorPredicate = function nonSeparatorPredicate(item) {\n        return item !== '-' && item !== '|';\n      };\n\n      var count = items.length; // Find an index of the first item that is not a separator.\n\n      var firstCommandItem = items.findIndex(nonSeparatorPredicate); // Search from the end of the list, then convert found index back to the original direction.\n\n      var lastCommandItem = count - items.slice().reverse().findIndex(nonSeparatorPredicate);\n      return items // Return items without the leading and trailing separators.\n      .slice(firstCommandItem, lastCommandItem) // Remove duplicated separators.\n      .filter(function (name, idx, items) {\n        // Filter only separators.\n        if (nonSeparatorPredicate(name)) {\n          return true;\n        }\n\n        var isDuplicated = idx > 0 && items[idx - 1] === name;\n        return !isDuplicated;\n      });\n    }\n    /**\n     * Fired when some toolbar {@link #items} were grouped or ungrouped as a result of some change\n     * in the toolbar geometry.\n     *\n     * **Note**: This event is always fired **once** regardless of the number of items that were be\n     * grouped or ungrouped at a time.\n     *\n     * **Note**: This event is fired only if the items grouping functionality was enabled in\n     * the first place (see {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull}).\n     *\n     * @event groupedItemsUpdate\n     */\n\n  }]);\n\n  return ToolbarView;\n}(View);\n/**\n * An inner block of the {@link module:ui/toolbar/toolbarview~ToolbarView} hosting its\n * {@link module:ui/toolbar/toolbarview~ToolbarView#items}.\n *\n * @private\n * @extends module:ui/view~View\n */\n\n\nexport { ToolbarView as default };\n\nvar ItemsView = /*#__PURE__*/function (_View2) {\n  _inherits(ItemsView, _View2);\n\n  /**\n   * @inheritDoc\n   */\n  function ItemsView(locale) {\n    var _this4;\n\n    _classCallCheck(this, ItemsView);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ItemsView).call(this, locale));\n    /**\n     * A collection of items (buttons, dropdowns, etc.).\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    _this4.children = _this4.createCollection();\n\n    _this4.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-toolbar__items']\n      },\n      children: _this4.children\n    });\n\n    return _this4;\n  }\n\n  return ItemsView;\n}(View);\n/**\n * A toolbar behavior that makes it static and unresponsive to the changes of the environment.\n * At the same time, it also makes it possible to display a toolbar with a vertical layout\n * using the {@link module:ui/toolbar/toolbarview~ToolbarView#isVertical} property.\n *\n * @private\n * @implements module:ui/toolbar/toolbarview~ToolbarBehavior\n */\n\n\nvar StaticLayout = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar\n   * behavior.\n   *\n   * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior\n   * is added to.\n   */\n  function StaticLayout(view) {\n    _classCallCheck(this, StaticLayout);\n\n    var bind = view.bindTemplate; // Static toolbar can be vertical when needed.\n\n    view.set('isVertical', false); // 1:1 pass–through binding, all ToolbarView#items are visible.\n\n    view.itemsView.children.bindTo(view.items).using(function (item) {\n      return item;\n    }); // 1:1 pass–through binding, all ToolbarView#items are focusable.\n\n    view.focusables.bindTo(view.items).using(function (item) {\n      return item;\n    });\n    view.extendTemplate({\n      attributes: {\n        class: [// When vertical, the toolbar has an additional CSS class.\n        bind.if('isVertical', 'ck-toolbar_vertical')]\n      }\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(StaticLayout, [{\n    key: \"render\",\n    value: function render() {}\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {}\n  }]);\n\n  return StaticLayout;\n}();\n/**\n * A toolbar behavior that makes the items respond to changes in the geometry.\n *\n * In a nutshell, it groups {@link module:ui/toolbar/toolbarview~ToolbarView#items}\n * that do not fit visually into a single row of the toolbar (due to limited space).\n * Items that do not fit are aggregated in a dropdown displayed at the end of the toolbar.\n *\n *\t┌──────────────────────────────────────── ToolbarView ──────────────────────────────────────────┐\n *\t| ┌─────────────────────────────────────── #children ─────────────────────────────────────────┐ |\n *\t| |   ┌─────── #itemsView ────────┐ ┌──────────────────────┐ ┌── #groupedItemsDropdown ───┐   | |\n *\t| |   |       #ungroupedItems     | | ToolbarSeparatorView | |        #groupedItems       |   | |\n *\t| |   └──────────────────────────-┘ └──────────────────────┘ └────────────────────────────┘   | |\n *\t| |                                  \\---------- only when toolbar items overflow --------/    | |\n *\t| └───────────────────────────────────────────────────────────────────────────────────────────┘ |\n *\t└───────────────────────────────────────────────────────────────────────────────────────────────┘\n *\n * @private\n * @implements module:ui/toolbar/toolbarview~ToolbarBehavior\n */\n\n\nvar DynamicGrouping = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar\n   * behavior.\n   *\n   * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior\n   * is added to.\n   */\n  function DynamicGrouping(view) {\n    var _this5 = this;\n\n    _classCallCheck(this, DynamicGrouping);\n\n    /**\n     * A toolbar view this behavior belongs to.\n     *\n     * @readonly\n     * @member {module:ui/toolbar~ToolbarView}\n     */\n    this.view = view;\n    /**\n     * A collection of toolbar children.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    this.viewChildren = view.children;\n    /**\n     * A collection of focusable toolbar elements.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    this.viewFocusables = view.focusables;\n    /**\n     * A view containing toolbar items.\n     *\n     * @readonly\n     * @member {module:ui/toolbar/toolbarview~ItemsView}\n     */\n\n    this.viewItemsView = view.itemsView;\n    /**\n     * Toolbar focus tracker.\n     *\n     * @readonly\n     * @member {module:utils/focustracker~FocusTracker}\n     */\n\n    this.viewFocusTracker = view.focusTracker;\n    /**\n     * Toolbar locale.\n     *\n     * @readonly\n     * @member {module:utils/locale~Locale}\n     */\n\n    this.viewLocale = view.locale;\n    /**\n     * Toolbar element.\n     *\n     * @readonly\n     * @member {HTMLElement} #viewElement\n     */\n\n    /**\n     * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.\n     * Aggregates items that fit into a single row of the toolbar and were not {@link #groupedItems grouped}\n     * into a {@link #groupedItemsDropdown dropdown}. Items of this collection are displayed in the\n     * {@link module:ui/toolbar/toolbarview~ToolbarView#itemsView}.\n     *\n     * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped, it\n     * matches the {@link module:ui/toolbar/toolbarview~ToolbarView#items} collection in size and order.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    this.ungroupedItems = view.createCollection();\n    /**\n     * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.\n     * A collection of the toolbar items that do not fit into a single row of the toolbar.\n     * Grouped items are displayed in a dedicated {@link #groupedItemsDropdown dropdown}.\n     *\n     * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped,\n     * this collection is empty.\n     *\n     * @readonly\n     * @member {module:ui/viewcollection~ViewCollection}\n     */\n\n    this.groupedItems = view.createCollection();\n    /**\n     * The dropdown that aggregates {@link #groupedItems grouped items} that do not fit into a single\n     * row of the toolbar. It is displayed on demand as the last of\n     * {@link module:ui/toolbar/toolbarview~ToolbarView#children toolbar children} and offers another\n     * (nested) toolbar which displays items that would normally overflow.\n     *\n     * @readonly\n     * @member {module:ui/dropdown/dropdownview~DropdownView}\n     */\n\n    this.groupedItemsDropdown = this._createGroupedItemsDropdown();\n    /**\n     * An instance of the resize observer that helps dynamically determine the geometry of the toolbar\n     * and manage items that do not fit into a single row.\n     *\n     * **Note:** Created in {@link #_enableGroupingOnResize}.\n     *\n     * @readonly\n     * @member {module:utils/dom/resizeobserver~ResizeObserver}\n     */\n\n    this.resizeObserver = null;\n    /**\n     * A cached value of the horizontal padding style used by {@link #_updateGrouping}\n     * to manage the {@link module:ui/toolbar/toolbarview~ToolbarView#items} that do not fit into\n     * a single toolbar line. This value can be reused between updates because it is unlikely that\n     * the padding will change and re–using `Window.getComputedStyle()` is expensive.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.cachedPadding = null;\n    /**\n     * A flag indicating that an items grouping update has been queued (e.g. due to the toolbar being visible)\n     * and should be executed immediately the next time the toolbar shows up.\n     *\n     * @readonly\n     * @member {Boolean}\n     */\n\n    this.shouldUpdateGroupingOnNextResize = false; // Only those items that were not grouped are visible to the user.\n\n    view.itemsView.children.bindTo(this.ungroupedItems).using(function (item) {\n      return item;\n    }); // Make sure all #items visible in the main space of the toolbar are \"focuscycleable\".\n\n    this.ungroupedItems.on('add', this._updateFocusCycleableItems.bind(this));\n    this.ungroupedItems.on('remove', this._updateFocusCycleableItems.bind(this)); // Make sure the #groupedItemsDropdown is also included in cycling when it appears.\n\n    view.children.on('add', this._updateFocusCycleableItems.bind(this));\n    view.children.on('remove', this._updateFocusCycleableItems.bind(this)); // ToolbarView#items is dynamic. When an item is added or removed, it should be automatically\n    // represented in either grouped or ungrouped items at the right index.\n    // In other words #items == concat( #ungroupedItems, #groupedItems )\n    // (in length and order).\n\n    view.items.on('change', function (evt, changeData) {\n      var index = changeData.index; // Removing.\n\n      var _iterator2 = _createForOfIteratorHelper(changeData.removed),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var removedItem = _step2.value;\n\n          if (index >= _this5.ungroupedItems.length) {\n            _this5.groupedItems.remove(removedItem);\n          } else {\n            _this5.ungroupedItems.remove(removedItem);\n          }\n        } // Adding.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      for (var currentIndex = index; currentIndex < index + changeData.added.length; currentIndex++) {\n        var addedItem = changeData.added[currentIndex - index];\n\n        if (currentIndex > _this5.ungroupedItems.length) {\n          _this5.groupedItems.add(addedItem, currentIndex - _this5.ungroupedItems.length);\n        } else {\n          _this5.ungroupedItems.add(addedItem, currentIndex);\n        }\n      } // When new ungrouped items join in and land in #ungroupedItems, there's a chance it causes\n      // the toolbar to overflow.\n      // Consequently if removed from grouped or ungrouped items, there is a chance\n      // some new space is available and we could do some ungrouping.\n\n\n      _this5._updateGrouping();\n    });\n    view.extendTemplate({\n      attributes: {\n        class: [// To group items dynamically, the toolbar needs a dedicated CSS class.\n        'ck-toolbar_grouping']\n      }\n    });\n  }\n  /**\n   * Enables dynamic items grouping based on the dimensions of the toolbar.\n   *\n   * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior\n   * is added to.\n   */\n\n\n  _createClass(DynamicGrouping, [{\n    key: \"render\",\n    value: function render(view) {\n      this.viewElement = view.element;\n\n      this._enableGroupingOnResize();\n\n      this._enableGroupingOnMaxWidthChange(view);\n    }\n    /**\n     * Cleans up the internals used by this behavior.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // The dropdown may not be in ToolbarView#children at the moment of toolbar destruction\n      // so let's make sure it's actually destroyed along with the toolbar.\n      this.groupedItemsDropdown.destroy();\n      this.resizeObserver.destroy();\n    }\n    /**\n     * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,\n     * and it will move them to the {@link #groupedItems} when it happens.\n     *\n     * At the same time, it will also check if there is enough space in the toolbar for the first of the\n     * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row\n     * without the toolbar wrapping.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_updateGrouping\",\n    value: function _updateGrouping() {\n      // Do no grouping–related geometry analysis when the toolbar is detached from visible DOM,\n      // for instance before #render(), or after render but without a parent or a parent detached\n      // from DOM. DOMRects won't work anyway and there will be tons of warning in the console and\n      // nothing else. This happens, for instance, when the toolbar is detached from DOM and\n      // some logic adds or removes its #items.\n      if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {\n        return;\n      } // Do not update grouping when the element is invisible. Such toolbar has DOMRect filled with zeros\n      // and that would cause all items to be grouped. Instead, queue the grouping so it runs next time\n      // the toolbar is visible (the next ResizeObserver callback execution). This is handy because\n      // the grouping could be caused by increasing the #maxWidth when the toolbar was invisible and the next\n      // time it shows up, some items could actually be ungrouped (https://github.com/ckeditor/ckeditor5/issues/6575).\n\n\n      if (!isVisible(this.viewElement)) {\n        this.shouldUpdateGroupingOnNextResize = true;\n        return;\n      } // Remember how many items were initially grouped so at the it is possible to figure out if the number\n      // of grouped items has changed. If the number has changed, geometry of the toolbar has also changed.\n\n\n      var initialGroupedItemsCount = this.groupedItems.length;\n      var wereItemsGrouped; // Group #items as long as some wrap to the next row. This will happen, for instance,\n      // when the toolbar is getting narrow and there is not enough space to display all items in\n      // a single row.\n\n      while (this._areItemsOverflowing) {\n        this._groupLastItem();\n\n        wereItemsGrouped = true;\n      } // If none were grouped now but there were some items already grouped before,\n      // then, what the hell, maybe let's see if some of them can be ungrouped. This happens when,\n      // for instance, the toolbar is stretching and there's more space in it than before.\n\n\n      if (!wereItemsGrouped && this.groupedItems.length) {\n        // Ungroup items as long as none are overflowing or there are none to ungroup left.\n        while (this.groupedItems.length && !this._areItemsOverflowing) {\n          this._ungroupFirstItem();\n        } // If the ungrouping ended up with some item wrapping to the next row,\n        // put it back to the group toolbar (\"undo the last ungroup\"). We don't know whether\n        // an item will wrap or not until we ungroup it (that's a DOM/CSS thing) so this\n        // clean–up is vital for the algorithm.\n\n\n        if (this._areItemsOverflowing) {\n          this._groupLastItem();\n        }\n      }\n\n      if (this.groupedItems.length !== initialGroupedItemsCount) {\n        this.view.fire('groupedItemsUpdate');\n      }\n    }\n    /**\n     * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,\n     * for instance if the toolbar is narrower than its members. Returns `false` otherwise.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"_enableGroupingOnResize\",\n\n    /**\n     * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)\n     * upon resize when there is little space available. Instead, the toolbar items are moved to the\n     * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).\n     *\n     * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and \"group\"\n     * them in the dropdown if necessary. It will also observe the browser window for size changes in\n     * the future and respond to them by grouping more items or reverting already grouped back, depending\n     * on the visual space available.\n     *\n     * @private\n     */\n    value: function _enableGroupingOnResize() {\n      var _this6 = this;\n\n      var previousWidth; // TODO: Consider debounce.\n\n      this.resizeObserver = new ResizeObserver(this.viewElement, function (entry) {\n        if (!previousWidth || previousWidth !== entry.contentRect.width || _this6.shouldUpdateGroupingOnNextResize) {\n          _this6.shouldUpdateGroupingOnNextResize = false;\n\n          _this6._updateGrouping();\n\n          previousWidth = entry.contentRect.width;\n        }\n      });\n\n      this._updateGrouping();\n    }\n    /**\n     * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that\n     * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enableGroupingOnMaxWidthChange\",\n    value: function _enableGroupingOnMaxWidthChange(view) {\n      var _this7 = this;\n\n      view.on('change:maxWidth', function () {\n        _this7._updateGrouping();\n      });\n    }\n    /**\n     * When called, it will remove the last item from {@link #ungroupedItems} and move it back\n     * to the {@link #groupedItems} collection.\n     *\n     * The opposite of {@link #_ungroupFirstItem}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_groupLastItem\",\n    value: function _groupLastItem() {\n      if (!this.groupedItems.length) {\n        this.viewChildren.add(new ToolbarSeparatorView());\n        this.viewChildren.add(this.groupedItemsDropdown);\n        this.viewFocusTracker.add(this.groupedItemsDropdown.element);\n      }\n\n      this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);\n    }\n    /**\n     * Moves the very first item belonging to {@link #groupedItems} back\n     * to the {@link #ungroupedItems} collection.\n     *\n     * The opposite of {@link #_groupLastItem}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_ungroupFirstItem\",\n    value: function _ungroupFirstItem() {\n      this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));\n\n      if (!this.groupedItems.length) {\n        this.viewChildren.remove(this.groupedItemsDropdown);\n        this.viewChildren.remove(this.viewChildren.last);\n        this.viewFocusTracker.remove(this.groupedItemsDropdown.element);\n      }\n    }\n    /**\n     * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}\n     * collection when there is not enough space in the toolbar to display all items in a single row.\n     *\n     * @private\n     * @returns {module:ui/dropdown/dropdownview~DropdownView}\n     */\n\n  }, {\n    key: \"_createGroupedItemsDropdown\",\n    value: function _createGroupedItemsDropdown() {\n      var locale = this.viewLocale;\n      var t = locale.t;\n      var dropdown = createDropdown(locale);\n      dropdown.class = 'ck-toolbar__grouped-dropdown'; // Make sure the dropdown never sticks out to the left/right. It should be under the main toolbar.\n      // (https://github.com/ckeditor/ckeditor5/issues/5608)\n\n      dropdown.panelPosition = locale.uiLanguageDirection === 'ltr' ? 'sw' : 'se';\n      addToolbarToDropdown(dropdown, []);\n      dropdown.buttonView.set({\n        label: t('Show more items'),\n        tooltip: true,\n        tooltipPosition: locale.uiLanguageDirection === 'rtl' ? 'se' : 'sw',\n        icon: threeVerticalDots\n      }); // 1:1 pass–through binding.\n\n      dropdown.toolbarView.items.bindTo(this.groupedItems).using(function (item) {\n        return item;\n      });\n      return dropdown;\n    }\n    /**\n     * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cycleable items}\n     * collection so it represents the up–to–date state of the UI from the perspective of the user.\n     *\n     * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,\n     * it must be subject to focus cycling in the toolbar.\n     *\n     * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation\n     * to learn more about the purpose of this method.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateFocusCycleableItems\",\n    value: function _updateFocusCycleableItems() {\n      var _this8 = this;\n\n      this.viewFocusables.clear();\n      this.ungroupedItems.map(function (item) {\n        _this8.viewFocusables.add(item);\n      });\n\n      if (this.groupedItems.length) {\n        this.viewFocusables.add(this.groupedItemsDropdown);\n      }\n    }\n  }, {\n    key: \"_areItemsOverflowing\",\n    get: function get() {\n      // An empty toolbar cannot overflow.\n      if (!this.ungroupedItems.length) {\n        return false;\n      }\n\n      var element = this.viewElement;\n      var uiLanguageDirection = this.viewLocale.uiLanguageDirection;\n      var lastChildRect = new Rect(element.lastChild);\n      var toolbarRect = new Rect(element);\n\n      if (!this.cachedPadding) {\n        var computedStyle = global.window.getComputedStyle(element);\n        var paddingProperty = uiLanguageDirection === 'ltr' ? 'paddingRight' : 'paddingLeft'; // parseInt() is essential because of quirky floating point numbers logic and DOM.\n        // If the padding turned out too big because of that, the grouped items dropdown would\n        // always look (from the Rect perspective) like it overflows (while it's not).\n\n        this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);\n      }\n\n      if (uiLanguageDirection === 'ltr') {\n        return lastChildRect.right > toolbarRect.right - this.cachedPadding;\n      } else {\n        return lastChildRect.left < toolbarRect.left + this.cachedPadding;\n      }\n    }\n  }]);\n\n  return DynamicGrouping;\n}();\n/**\n * Options passed to the {@link module:ui/toolbar/toolbarview~ToolbarView#constructor} of the toolbar.\n *\n * @interface module:ui/toolbar/toolbarview~ToolbarOptions\n */\n\n/**\n * When set to `true`, the toolbar will automatically group {@link module:ui/toolbar/toolbarview~ToolbarView#items} that\n * would normally wrap to the next line when there is not enough space to display them in a single row, for\n * instance, if the parent container of the toolbar is narrow. For toolbars in absolutely positioned containers\n * without width restrictions also the {@link module:ui/toolbar/toolbarview~ToolbarOptions#isFloating} option is required to be `true`.\n *\n * See also: {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth}.\n *\n * @member {Boolean} module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull\n */\n\n/**\n * This option should be enabled for toolbars in absolutely positioned containers without width restrictions\n * to enable automatic {@link module:ui/toolbar/toolbarview~ToolbarView#items} grouping.\n * When this option is set to `true`, the items will stop wrapping to the next line\n * and together with {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull},\n * this will allow grouping them when there is not enough space in a single row.\n *\n * @member {Boolean} module:ui/toolbar/toolbarview~ToolbarOptions#isFloating\n */\n\n/**\n * A class interface defining the behavior of the {@link module:ui/toolbar/toolbarview~ToolbarView}.\n *\n * Toolbar behaviors extend its look and functionality and have an impact on the\n * {@link module:ui/toolbar/toolbarview~ToolbarView#element} template or\n * {@link module:ui/toolbar/toolbarview~ToolbarView#render rendering}. They can be enabled\n * conditionally, e.g. depending on the configuration of the toolbar.\n *\n * @private\n * @interface module:ui/toolbar/toolbarview~ToolbarBehavior\n */\n\n/**\n * Creates a new toolbar behavior instance.\n *\n * The instance is created in the {@link module:ui/toolbar/toolbarview~ToolbarView#constructor} of the toolbar.\n * This is the right place to extend the {@link module:ui/toolbar/toolbarview~ToolbarView#template} of\n * the toolbar, define extra toolbar properties, etc.\n *\n * @method #constructor\n * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior is added to.\n */\n\n/**\n * A method called after the toolbar has been {@link module:ui/toolbar/toolbarview~ToolbarView#render rendered}.\n * It can be used to, for example, customize the behavior of the toolbar when its {@link module:ui/toolbar/toolbarview~ToolbarView#element}\n * is available.\n *\n * @readonly\n * @member {Function} #render\n * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar being rendered.\n */\n\n/**\n * A method called after the toolbar has been {@link module:ui/toolbar/toolbarview~ToolbarView#destroy destroyed}.\n * It allows cleaning up after the toolbar behavior, for instance, this is the right place to detach\n * event listeners, free up references, etc.\n *\n * @readonly\n * @member {Function} #destroy\n */","map":null,"metadata":{},"sourceType":"module"}