{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/matcher\n */\nimport { isPlainObject } from 'lodash-es';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\n\nvar Matcher = /*#__PURE__*/function () {\n  /**\n   * Creates new instance of Matcher.\n   *\n   * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n   * more information.\n   */\n  function Matcher() {\n    _classCallCheck(this, Matcher);\n\n    /**\n     * @private\n     * @type {Array<String|RegExp|Object>}\n     */\n    this._patterns = [];\n    this.add.apply(this, arguments);\n  }\n  /**\n   * Adds pattern or patterns to matcher instance.\n   *\n   *\t\t// String.\n   *\t\tmatcher.add( 'div' );\n   *\n   *\t\t// Regular expression.\n   *\t\tmatcher.add( /^\\w/ );\n   *\n   *\t\t// Single class.\n   *\t\tmatcher.add( {\n   *\t\t\tclasses: 'foobar'\n   *\t\t} );\n   *\n   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n   *\n   * Multiple patterns can be added in one call:\n   *\n   * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n   *\n   * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n   * is provided it will be used to match element's name. Pattern can be also provided in a form\n   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n   * Function's return value will be stored under `match` key of the object returned from\n   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n   * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n   * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n   * represents attribute name. Value under that key can be either:\n   * * `true` - then attribute is just required (can be empty),\n   * * a string - then attribute has to be equal, or\n   * * a regular expression - then attribute has to match the expression.\n   * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n   * provided in a form of string or regular expression.\n   * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n   * represents style name. Value under that key can be either a string or a regular expression and it will be used\n   * to match style value.\n   */\n\n\n  _createClass(Matcher, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, pattern = new Array(_len), _key = 0; _key < _len; _key++) {\n        pattern[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _pattern = pattern; _i < _pattern.length; _i++) {\n        var item = _pattern[_i];\n\n        // String or RegExp pattern is used as element's name.\n        if (typeof item == 'string' || item instanceof RegExp) {\n          item = {\n            name: item\n          };\n        }\n\n        this._patterns.push(item);\n      }\n    }\n    /**\n     * Matches elements for currently stored patterns. Returns match information about first found\n     * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n     *\n     * Example of returned object:\n     *\n     *\t\t{\n     *\t\t\telement: <instance of found element>,\n     *\t\t\tpattern: <pattern used to match found element>,\n     *\t\t\tmatch: {\n     *\t\t\t\tname: true,\n     *\t\t\t\tattributes: [ 'title', 'href' ],\n     *\t\t\t\tclasses: [ 'foo' ],\n     *\t\t\t\tstyles: [ 'color', 'position' ]\n     *\t\t\t}\n     *\t\t}\n     *\n     * @see module:engine/view/matcher~Matcher#add\n     * @see module:engine/view/matcher~Matcher#matchAll\n     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n     * @returns {Object|null} result\n     * @returns {module:engine/view/element~Element} result.element Matched view element.\n     * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n     * @returns {Object} result.match Object representing matched element parts.\n     * @returns {Boolean} [result.match.name] True if name of the element was matched.\n     * @returns {Array} [result.match.attributes] Array with matched attribute names.\n     * @returns {Array} [result.match.classes] Array with matched class names.\n     * @returns {Array} [result.match.styles] Array with matched style names.\n     */\n\n  }, {\n    key: \"match\",\n    value: function match() {\n      for (var _len2 = arguments.length, element = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        element[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _element = element; _i2 < _element.length; _i2++) {\n        var singleElement = _element[_i2];\n\n        var _iterator = _createForOfIteratorHelper(this._patterns),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var pattern = _step.value;\n            var match = isElementMatching(singleElement, pattern);\n\n            if (match) {\n              return {\n                element: singleElement,\n                pattern: pattern,\n                match: match\n              };\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Matches elements for currently stored patterns. Returns array of match information with all found\n     * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n     *\n     * @see module:engine/view/matcher~Matcher#add\n     * @see module:engine/view/matcher~Matcher#match\n     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n     * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n     * see {@link module:engine/view/matcher~Matcher#match match method} description.\n     */\n\n  }, {\n    key: \"matchAll\",\n    value: function matchAll() {\n      var results = [];\n\n      for (var _len3 = arguments.length, element = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        element[_key3] = arguments[_key3];\n      }\n\n      for (var _i3 = 0, _element2 = element; _i3 < _element2.length; _i3++) {\n        var singleElement = _element2[_i3];\n\n        var _iterator2 = _createForOfIteratorHelper(this._patterns),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var pattern = _step2.value;\n            var match = isElementMatching(singleElement, pattern);\n\n            if (match) {\n              results.push({\n                element: singleElement,\n                pattern: pattern,\n                match: match\n              });\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return results.length > 0 ? results : null;\n    }\n    /**\n     * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n     * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n     *\n     * @returns {String|null} Element name trying to match.\n     */\n\n  }, {\n    key: \"getElementName\",\n    value: function getElementName() {\n      if (this._patterns.length !== 1) {\n        return null;\n      }\n\n      var pattern = this._patterns[0];\n      var name = pattern.name;\n      return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;\n    }\n  }]);\n\n  return Matcher;\n}(); // Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\n\n\nexport { Matcher as default };\n\nfunction isElementMatching(element, pattern) {\n  // If pattern is provided as function - return result of that function;\n  if (typeof pattern == 'function') {\n    return pattern(element);\n  }\n\n  var match = {}; // Check element's name.\n\n  if (pattern.name) {\n    match.name = matchName(pattern.name, element.name);\n\n    if (!match.name) {\n      return null;\n    }\n  } // Check element's attributes.\n\n\n  if (pattern.attributes) {\n    match.attributes = matchAttributes(pattern.attributes, element);\n\n    if (!match.attributes) {\n      return null;\n    }\n  } // Check element's classes.\n\n\n  if (pattern.classes) {\n    match.classes = matchClasses(pattern.classes, element);\n\n    if (!match.classes) {\n      return false;\n    }\n  } // Check element's styles.\n\n\n  if (pattern.styles) {\n    match.styles = matchStyles(pattern.styles, element);\n\n    if (!match.styles) {\n      return false;\n    }\n  }\n\n  return match;\n} // Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\n\n\nfunction matchName(pattern, name) {\n  // If pattern is provided as RegExp - test against this regexp.\n  if (pattern instanceof RegExp) {\n    return !!name.match(pattern);\n  }\n\n  return pattern === name;\n} // Checks if an array of key/value pairs can be matched against provided patterns.\n//\n// Patterns can be provided in a following ways:\n// \t- a boolean value matches any attribute with any value (or no value):\n//\n//\t\t\tpattern: true\n//\n//\t- a RegExp expression or object matches any attribute name:\n//\n//\t\t\tpattern: /h[1-6]/\n//\n//\t- an object matches any attribute that has the same name as the object item's key, where object item's value is:\n//\t\t- equal to `true`, which matches any attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trequired: true\n//\t\t\t}\n//\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: {\n//\t\t\t\trel: 'nofollow'\n//\t\t\t}\n//\n//\t\t- a regular expression that matches attribute value,\n//\n//\t\t\tpattern: {\n//\t\t\t\tsrc: /https.*/\n//\t\t\t}\n//\n//\t- an array with items, where the item is:\n//\t\t- a string that is equal to attribute value:\n//\n//\t\t\tpattern: [ 'data-property-1', 'data-property-2' ],\n//\n//\t\t- an object with `key` and `value` property, where `key` is a regular expression matching attribute name and\n//\t\t  `value` is either regular expression matching attribute value or a string equal to attribute value:\n//\n//\t\t\tpattern: [\n//\t\t\t\t{ key: /data-property-.*/, value: true },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: 'foobar' },\n//\t\t\t\t// or:\n//\t\t\t\t{ key: /data-property-.*/, value: /foo.*/ }\n//\t\t\t]\n//\n// @param {Object} patterns Object with information about attributes to match.\n// @param {Iterable.<String>} keys Attribute, style or class keys.\n// @param {Function} valueGetter A function providing value for a given item key.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\n\n\nfunction matchPatterns(patterns, keys, valueGetter) {\n  var normalizedPatterns = normalizePatterns(patterns);\n  var normalizedItems = Array.from(keys);\n  var match = [];\n  normalizedPatterns.forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        patternKey = _ref2[0],\n        patternValue = _ref2[1];\n\n    normalizedItems.forEach(function (itemKey) {\n      if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {\n        match.push(itemKey);\n      }\n    });\n  }); // Return matches only if there are at least as many of them as there are patterns.\n  // The RegExp pattern can match more than one item.\n\n  if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {\n    return null;\n  }\n\n  return match;\n} // Bring all the possible pattern forms to an array of arrays where first item is a key and second is a value.\n//\n// Examples:\n//\n// Boolean pattern value:\n//\n//\t\ttrue\n//\n// to\n//\n//\t\t[ [ true, true ] ]\n//\n// Textual pattern value:\n//\n//\t\t'attribute-name-or-class-or-style'\n//\n// to\n//\n//\t\t[ [ 'attribute-name-or-class-or-style', true ] ]\n//\n// Regular expression:\n//\n//\t\t/^data-.*$/\n//\n// to\n//\n//\t\t[ [ /^data-.*$/, true ] ]\n//\n// Objects (plain or with `key` and `value` specified explicitly):\n//\n//\t\t{\n//\t\t\tsrc: /^https:.*$/\n//\t\t}\n//\n// or\n//\n//\t\t[ {\n//\t\t\tkey: 'src',\n//\t\t\tvalue: /^https:.*$/\n//\t\t} ]\n//\n// to:\n//\n//\t\t[ [ 'src', /^https:.*$/ ] ]\n//\n// @param {Object|Array} patterns\n// @returns {Array|null} Returns an array of objects or null if provided patterns were not in an expected form.\n\n\nfunction normalizePatterns(patterns) {\n  if (Array.isArray(patterns)) {\n    return patterns.map(function (pattern) {\n      if (isPlainObject(pattern)) {\n        if (pattern.key === undefined || pattern.value === undefined) {\n          // Documented at the end of matcher.js.\n          logWarning('matcher-pattern-missing-key-or-value', pattern);\n        }\n\n        return [pattern.key, pattern.value];\n      } // Assume the pattern is either String or RegExp.\n\n\n      return [pattern, true];\n    });\n  }\n\n  if (isPlainObject(patterns)) {\n    return Object.entries(patterns);\n  } // Other cases (true, string or regexp).\n\n\n  return [[patterns, true]];\n} // @param {String|RegExp} patternKey A pattern representing a key we want to match.\n// @param {String} itemKey An actual item key (e.g. `'src'`, `'background-color'`, `'ck-widget'`) we're testing against pattern.\n// @returns {Boolean}\n\n\nfunction isKeyMatched(patternKey, itemKey) {\n  return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);\n} // @param {String|RegExp} patternValue A pattern representing a value we want to match.\n// @param {String} itemKey An item key, e.g. `background`, `href`, 'rel', etc.\n// @param {Function} valueGetter A function used to provide a value for a given `itemKey`.\n// @returns {Boolean}\n\n\nfunction isValueMatched(patternValue, itemKey, valueGetter) {\n  if (patternValue === true) {\n    return true;\n  }\n\n  var itemValue = valueGetter(itemKey); // For now, the reducers are not returning the full tree of properties.\n  // Casting to string preserves the old behavior until the root cause is fixed.\n  // More can be found in https://github.com/ckeditor/ckeditor5/issues/10399.\n\n  return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);\n} // Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\n\n\nfunction matchAttributes(patterns, element) {\n  var attributeKeys = new Set(element.getAttributeKeys()); // `style` and `class` attribute keys are deprecated. Only allow them in object pattern\n  // for backward compatibility.\n\n  if (isPlainObject(patterns)) {\n    if (patterns.style !== undefined) {\n      // Documented at the end of matcher.js.\n      logWarning('matcher-pattern-deprecated-attributes-style-key', patterns);\n    }\n\n    if (patterns.class !== undefined) {\n      // Documented at the end of matcher.js.\n      logWarning('matcher-pattern-deprecated-attributes-class-key', patterns);\n    }\n  } else {\n    attributeKeys.delete('style');\n    attributeKeys.delete('class');\n  }\n\n  return matchPatterns(patterns, attributeKeys, function (key) {\n    return element.getAttribute(key);\n  });\n} // Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\n\n\nfunction matchClasses(patterns, element) {\n  // We don't need `getter` here because patterns for classes are always normalized to `[ className, true ]`.\n  return matchPatterns(patterns, element.getClassNames());\n} // Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\n\n\nfunction matchStyles(patterns, element) {\n  return matchPatterns(patterns, element.getStyleNames(true), function (key) {\n    return element.getStyle(key);\n  });\n}\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n * If the view element does not meet all of the object's pattern properties, the match will not happen.\n * Available `Object` matching properties:\n *\n * Matching view element:\n *\n *\t\t// Match view element's name using String:\n *\t\tconst pattern = { name: 'p' };\n *\n *\t\t// or by providing RegExp:\n *\t\tconst pattern = { name: /^(ul|ol)$/ };\n *\n *\t\t// The name can also be skipped to match any view element with matching attributes:\n *\t\tconst pattern = {\n *\t\t\tattributes: {\n *\t\t\t\t'title': true\n *\t\t\t}\n *\t\t};\n *\n * Matching view element attributes:\n *\n *\t\t// Match view element with any attribute value.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tattributes: true\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: 'title' // Match title attribute (can be empty).\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: /^data-.*$/ // Match attributes starting with `data-` e.g. `data-foo` with any value (can be empty).\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: {\n *\t\t\t\ttitle: 'foobar',           // Match `title` attribute with 'foobar' value.\n *\t\t\t\talt: true,                 // Match `alt` attribute with any value (can be empty).\n *\t\t\t\t'data-type': /^(jpg|png)$/ // Match `data-type` attribute with `jpg` or `png` value.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tattributes: [\n *\t\t\t\t'title',    // Match `title` attribute (can be empty).\n *\t\t\t\t/^data-*$/ // Match attributes starting with `data-` e.g. `data-foo` with any value (can be empty).\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching attributes (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'input',\n *\t\t\tattributes: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'type',                     // Match `type` as an attribute key.\n *\t\t\t\t\tvalue: /^(text|number|date)$/\t // Match `text`, `number` or `date` values.\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^data-.*$/,                // Match attributes starting with `data-` e.g. `data-foo`.\n *\t\t\t\t\tvalue: true                      // Match any value (can be empty).\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Matching view element styles:\n *\n *\t\t// Match view element with any style.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: true\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: 'color' // Match attributes with `color` style.\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: /^border.*$/ // Match view element with any border style.\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: {\n *\t\t\t\tcolor: /rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)/, // Match `color` in RGB format only.\n *\t\t\t\t'font-weight': 600,                              // Match `font-weight` only if it's `600`.\n *\t\t\t\t'text-decoration': true                          // Match any text decoration.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: [\n *\t\t\t\t'color',      // Match `color` with any value.\n *\t\t\t\t/^border.*$/ // Match all border properties.\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching styles (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tstyles: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'color',                                  \t\t// Match `color` as an property key.\n *\t\t\t\t\tvalue: /rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)/\t\t// Match RGB format only.\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^border.*$/, // Match any border style.\n *\t\t\t\t\tvalue: true        // Match any value.\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Matching view element classes:\n *\n *\t\t// Match view element with any class.\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: true\n *\t\t};\n *\n *\t\t// Match view element which has matching class (String).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: 'highlighted' // Match `highlighted` class.\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (RegExp).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: /^image-side-(left|right)$/ // Match `image-side-left` or `image-side-right` class.\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (Object).\n *\t\tconst pattern = {\n *\t\t\tname: 'p',\n *\t\t\tclasses: {\n *\t\t\t\thighlighted: true, // Match `highlighted` class.\n *\t\t\t\tmarker: true       // Match `marker` class.\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (Array).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: [\n *\t\t\t\t'image',                    // Match `image` class.\n *\t\t\t\t/^image-side-(left|right)$/ // Match `image-side-left` or `image-side-right` class.\n *\t\t\t]\n *\t\t};\n *\n *\t\t// Match view element which has matching classes (key-value pairs).\n *\t\tconst pattern = {\n *\t\t\tname: 'figure',\n *\t\t\tclasses: [\n *\t\t\t\t{\n *\t\t\t\t\tkey: 'image', // Match `image` class.\n *\t\t\t\t\tvalue: true\n *\t\t\t\t},\n *\t\t\t\t{\n *\t\t\t\t\tkey: /^image-side-(left|right)$/, // Match `image-side-left` or `image-side-right` class.\n *\t\t\t\t\tvalue: true\n *\t\t\t\t}\n *\t\t\t]\n *\t\t};\n *\n * Pattern can combine multiple properties allowing for more complex view element matching:\n *\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tattributes: [ 'title' ],\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {Boolean|String|RegExp|Object|Array.<String|RegExp|Object>} [classes] View element's classes to match.\n * @property {Boolean|String|RegExp|Object|Array.<String|RegExp|Object>} [styles] View element's styles to match.\n * @property {Boolean|String|RegExp|Object|Array.<String|RegExp|Object>} [attributes] View element's attributes to match.\n */\n\n/**\n * The key-value matcher pattern is missing key or value. Both must be present.\n * Refer the documentation: {@link module:engine/view/matcher~MatcherPattern}.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-missing-key-or-value\n */\n\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `style` key.\n *\n * Use `styles` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tstyle: /^border.*$/\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tstyles: /^border.*$/\n * \t\t}\n *\n * Refer to the {@glink updating/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-style-key\n */\n\n/**\n * The key-value matcher pattern for `attributes` option is using deprecated `class` key.\n *\n * Use `classes` matcher pattern option instead:\n *\n * \t\t// Instead of:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2',\n * \t\t\t\tclass: 'foobar'\n * \t\t\t}\n * \t\t}\n *\n * \t\t// Use:\n * \t\tconst pattern = {\n * \t\t\tattributes: {\n * \t\t\t\tkey1: 'value1',\n * \t\t\t\tkey2: 'value2'\n * \t\t\t},\n * \t\t\tclasses: 'foobar'\n * \t\t}\n *\n * Refer to the {@glink updating/migration-to-29##migration-to-ckeditor-5-v2910 Migration to v29.1.0} guide\n * and the {@link module:engine/view/matcher~MatcherPattern} documentation.\n *\n * @param {Object} pattern Pattern with missing properties.\n * @error matcher-pattern-deprecated-attributes-class-key\n */","map":null,"metadata":{},"sourceType":"module"}