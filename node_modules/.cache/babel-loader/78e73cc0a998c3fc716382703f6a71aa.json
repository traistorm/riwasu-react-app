{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/emittermixin\n */\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\nimport insertToPriorityArray from './inserttopriorityarray'; // To check if component is loaded more than once.\n\nimport './version';\nimport CKEditorError from './ckeditorerror';\n\nvar _listeningTo = Symbol('listeningTo');\n\nvar _emitterId = Symbol('emitterId');\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * Read more about the concept of emitters in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\n\n\nvar EmitterMixin = {\n  /**\n   * @inheritDoc\n   */\n  on: function on(event, callback) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.listenTo(this, event, callback, options);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  once: function once(event, callback, options) {\n    var wasFired = false;\n\n    var onceCallback = function onceCallback(event) {\n      // Ensure the callback is called only once even if the callback itself leads to re-firing the event\n      // (which would call the callback again).\n      if (!wasFired) {\n        wasFired = true; // Go off() at the first call.\n\n        event.off(); // Go with the original callback.\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        callback.call.apply(callback, [this, event].concat(args));\n      }\n    }; // Make a similar on() call, simply replacing the callback.\n\n\n    this.listenTo(this, event, onceCallback, options);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  off: function off(event, callback) {\n    this.stopListening(this, event, callback);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  listenTo: function listenTo(emitter, event, callback) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var emitterInfo, eventCallbacks; // _listeningTo contains a list of emitters that this object is listening to.\n    // This list has the following format:\n    //\n    // _listeningTo: {\n    //     emitterId: {\n    //         emitter: emitter,\n    //         callbacks: {\n    //             event1: [ callback1, callback2, ... ]\n    //             ....\n    //         }\n    //     },\n    //     ...\n    // }\n\n    if (!this[_listeningTo]) {\n      this[_listeningTo] = {};\n    }\n\n    var emitters = this[_listeningTo];\n\n    if (!_getEmitterId(emitter)) {\n      _setEmitterId(emitter);\n    }\n\n    var emitterId = _getEmitterId(emitter);\n\n    if (!(emitterInfo = emitters[emitterId])) {\n      emitterInfo = emitters[emitterId] = {\n        emitter: emitter,\n        callbacks: {}\n      };\n    }\n\n    if (!(eventCallbacks = emitterInfo.callbacks[event])) {\n      eventCallbacks = emitterInfo.callbacks[event] = [];\n    }\n\n    eventCallbacks.push(callback); // Finally register the callback to the event.\n\n    addEventListener(this, emitter, event, callback, options);\n  },\n\n  /**\n   * @inheritDoc\n   */\n  stopListening: function stopListening(emitter, event, callback) {\n    var emitters = this[_listeningTo];\n\n    var emitterId = emitter && _getEmitterId(emitter);\n\n    var emitterInfo = emitters && emitterId && emitters[emitterId];\n    var eventCallbacks = emitterInfo && event && emitterInfo.callbacks[event]; // Stop if nothing has been listened.\n\n    if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {\n      return;\n    } // All params provided. off() that single callback.\n\n\n    if (callback) {\n      removeEventListener(this, emitter, event, callback); // We must remove callbacks as well in order to prevent memory leaks.\n      // See https://github.com/ckeditor/ckeditor5/pull/8480\n\n      var index = eventCallbacks.indexOf(callback);\n\n      if (index !== -1) {\n        if (eventCallbacks.length === 1) {\n          delete emitterInfo.callbacks[event];\n        } else {\n          removeEventListener(this, emitter, event, callback);\n        }\n      }\n    } // Only `emitter` and `event` provided. off() all callbacks for that event.\n    else if (eventCallbacks) {\n      while (callback = eventCallbacks.pop()) {\n        removeEventListener(this, emitter, event, callback);\n      }\n\n      delete emitterInfo.callbacks[event];\n    } // Only `emitter` provided. off() all events for that emitter.\n    else if (emitterInfo) {\n      for (event in emitterInfo.callbacks) {\n        this.stopListening(emitter, event);\n      }\n\n      delete emitters[emitterId];\n    } // No params provided. off() all emitters.\n    else {\n      for (emitterId in emitters) {\n        this.stopListening(emitters[emitterId].emitter);\n      }\n\n      delete this[_listeningTo];\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  fire: function fire(eventOrInfo) {\n    try {\n      var eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);\n      var event = eventInfo.name;\n      var callbacks = getCallbacksForEvent(this, event); // Record that the event passed this emitter on its path.\n\n      eventInfo.path.push(this); // Handle event listener callbacks first.\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      if (callbacks) {\n        // Arguments passed to each callback.\n        var callbackArgs = [eventInfo].concat(args); // Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n        // are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n        // failed if callbacks were added to the queue before currently processed callback.\n        // If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n        // event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n\n        callbacks = Array.from(callbacks);\n\n        for (var i = 0; i < callbacks.length; i++) {\n          callbacks[i].callback.apply(this, callbackArgs); // Remove the callback from future requests if off() has been called.\n\n          if (eventInfo.off.called) {\n            // Remove the called mark for the next calls.\n            delete eventInfo.off.called;\n\n            this._removeEventListener(event, callbacks[i].callback);\n          } // Do not execute next callbacks if stop() was called.\n\n\n          if (eventInfo.stop.called) {\n            break;\n          }\n        }\n      } // Delegate event to other emitters if needed.\n\n\n      if (this._delegations) {\n        var destinations = this._delegations.get(event);\n\n        var passAllDestinations = this._delegations.get('*');\n\n        if (destinations) {\n          fireDelegatedEvents(destinations, eventInfo, args);\n        }\n\n        if (passAllDestinations) {\n          fireDelegatedEvents(passAllDestinations, eventInfo, args);\n        }\n      }\n\n      return eventInfo.return;\n    } catch (err) {\n      // @if CK_DEBUG // throw err;\n\n      /* istanbul ignore next */\n      CKEditorError.rethrowUnexpectedError(err, this);\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  delegate: function delegate() {\n    var _this = this;\n\n    for (var _len3 = arguments.length, events = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      events[_key3] = arguments[_key3];\n    }\n\n    return {\n      to: function to(emitter, nameOrFunction) {\n        if (!_this._delegations) {\n          _this._delegations = new Map();\n        } // Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow\n        // build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.\n\n\n        events.forEach(function (eventName) {\n          var destinations = _this._delegations.get(eventName);\n\n          if (!destinations) {\n            _this._delegations.set(eventName, new Map([[emitter, nameOrFunction]]));\n          } else {\n            destinations.set(emitter, nameOrFunction);\n          }\n        });\n      }\n    };\n  },\n\n  /**\n   * @inheritDoc\n   */\n  stopDelegating: function stopDelegating(event, emitter) {\n    if (!this._delegations) {\n      return;\n    }\n\n    if (!event) {\n      this._delegations.clear();\n    } else if (!emitter) {\n      this._delegations.delete(event);\n    } else {\n      var destinations = this._delegations.get(event);\n\n      if (destinations) {\n        destinations.delete(emitter);\n      }\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  _addEventListener: function _addEventListener(event, callback, options) {\n    createEventNamespace(this, event);\n    var lists = getCallbacksListsForNamespace(this, event);\n    var priority = priorities.get(options.priority);\n    var callbackDefinition = {\n      callback: callback,\n      priority: priority\n    }; // Add the callback to all callbacks list.\n\n    var _iterator = _createForOfIteratorHelper(lists),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var callbacks = _step.value;\n        // Add the callback to the list in the right priority position.\n        insertToPriorityArray(callbacks, callbackDefinition);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\n   * @inheritDoc\n   */\n  _removeEventListener: function _removeEventListener(event, callback) {\n    var lists = getCallbacksListsForNamespace(this, event);\n\n    var _iterator2 = _createForOfIteratorHelper(lists),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var callbacks = _step2.value;\n\n        for (var i = 0; i < callbacks.length; i++) {\n          if (callbacks[i].callback == callback) {\n            // Remove the callback from the list (fixing the next index).\n            callbacks.splice(i, 1);\n            i--;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n};\nexport default EmitterMixin;\n/**\n * Emitter/listener interface.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/emittermixin~EmitterMixin} mixin.\n *\n * Read more about the usage of this interface in the:\n * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables Event system and observables}\n * section of the {@glink framework/guides/architecture/core-editor-architecture Core editor architecture} guide.\n * * {@glink framework/guides/deep-dive/event-system Event system} deep dive guide.\n *\n * @interface Emitter\n */\n\n/**\n * Registers a callback function to be executed when an event is fired.\n *\n * Shorthand for {@link #listenTo `this.listenTo( this, event, callback, options )`} (it makes the emitter\n * listen on itself).\n *\n * @method #on\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Registers a callback function to be executed on the next time the event is fired only. This is similar to\n * calling {@link #on} followed by {@link #off} in the callback.\n *\n * @method #once\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops executing the callback on the given event.\n * Shorthand for {@link #stopListening `this.stopListening( this, event, callback )`}.\n *\n * @method #off\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Registers a callback function to be executed when an event is fired in a specific (emitter) object.\n *\n * Events can be grouped in namespaces using `:`.\n * When namespaced event is fired, it additionally fires all callbacks for that namespace.\n *\n *\t\t// myEmitter.on( ... ) is a shorthand for myEmitter.listenTo( myEmitter, ... ).\n *\t\tmyEmitter.on( 'myGroup', genericCallback );\n *\t\tmyEmitter.on( 'myGroup:myEvent', specificCallback );\n *\n *\t\t// genericCallback is fired.\n *\t\tmyEmitter.fire( 'myGroup' );\n *\t\t// both genericCallback and specificCallback are fired.\n *\t\tmyEmitter.fire( 'myGroup:myEvent' );\n *\t\t// genericCallback is fired even though there are no callbacks for \"foo\".\n *\t\tmyEmitter.fire( 'myGroup:foo' );\n *\n * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and\n * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.\n *\n * @method #listenTo\n * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops listening for events. It can be used at different levels:\n *\n * * To stop listening to a specific callback.\n * * To stop listening to a specific event.\n * * To stop listening to all events fired by a specific object.\n * * To stop listening to all events fired by all objects.\n *\n * @method #stopListening\n * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n * for all events from `emitter`.\n * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n * `event`.\n */\n\n/**\n * Fires an event, executing all callbacks registered for it.\n *\n * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,\n * followed by the optional `args` provided in the `fire()` method call.\n *\n * @method #fire\n * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.\n * @param {...*} [args] Additional arguments to be passed to the callbacks.\n * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners\n * through modification of the {@link module:utils/eventinfo~EventInfo#return `evt.return`}'s property (the event info\n * is the first param of every callback).\n */\n\n/**\n * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:\n *\n *\t\temitterA.delegate( 'eventX' ).to( emitterB );\n *\t\temitterA.delegate( 'eventX', 'eventY' ).to( emitterC );\n *\n * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventX', data );\n *\n * and `eventY` is delegated (fired by) `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventY', data );\n *\n * @method #delegate\n * @param {...String} events Event names that will be delegated to another emitter.\n * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}\n */\n\n/**\n * Stops delegating events. It can be used at different levels:\n *\n * * To stop delegating all events.\n * * To stop delegating a specific event to all emitters.\n * * To stop delegating a specific event to a specific emitter.\n *\n * @method #stopDelegating\n * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.\n * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.\n * If omitted, stops delegation of `event` to all emitters.\n */\n\n/**\n * Adds callback to emitter for given event.\n *\n * @protected\n * @method #_addEventListener\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Removes callback from emitter for given event.\n *\n * @protected\n * @method #_removeEventListener\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~Emitter|null}\n */\n\nexport function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {\n  if (listeningEmitter[_listeningTo] && listeningEmitter[_listeningTo][listenedToEmitterId]) {\n    return listeningEmitter[_listeningTo][listenedToEmitterId].emitter;\n  }\n\n  return null;\n}\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\n\nexport function _setEmitterId(emitter, id) {\n  if (!emitter[_emitterId]) {\n    emitter[_emitterId] = id || uid();\n  }\n}\n/**\n * Returns emitter's unique id.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.\n */\n\nexport function _getEmitterId(emitter) {\n  return emitter[_emitterId];\n} // Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\n\nfunction getEvents(source) {\n  if (!source._events) {\n    Object.defineProperty(source, '_events', {\n      value: {}\n    });\n  }\n\n  return source._events;\n} // Creates event node for generic-specific events relation architecture.\n\n\nfunction makeEventNode() {\n  return {\n    callbacks: [],\n    childEvents: []\n  };\n} // Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\n\n\nfunction createEventNamespace(source, eventName) {\n  var events = getEvents(source); // First, check if the event we want to add to the structure already exists.\n\n  if (events[eventName]) {\n    // If it exists, we don't have to do anything.\n    return;\n  } // In other case, we have to create the structure for the event.\n  // Note, that we might need to create intermediate events too.\n  // I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n  // we need to also register foo:bar.\n  // Currently processed event name.\n\n\n  var name = eventName; // Name of the event that is a child event for currently processed event.\n\n  var childEventName = null; // Array containing all newly created specific events.\n\n  var newEventNodes = []; // While loop can't check for ':' index because we have to handle generic events too.\n  // In each loop, we truncate event name, going from the most specific name to the generic one.\n  // I.e. foo:bar:abc -> foo:bar -> foo.\n\n  while (name !== '') {\n    if (events[name]) {\n      // If the currently processed event name is already registered, we can be sure\n      // that it already has all the structure created, so we can break the loop here\n      // as no more events need to be registered.\n      break;\n    } // If this event is not yet registered, create a new object for it.\n\n\n    events[name] = makeEventNode(); // Add it to the array with newly created events.\n\n    newEventNodes.push(events[name]); // Add previously processed event name as a child of this event.\n\n    if (childEventName) {\n      events[name].childEvents.push(childEventName);\n    }\n\n    childEventName = name; // If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n\n    name = name.substr(0, name.lastIndexOf(':'));\n  }\n\n  if (name !== '') {\n    // If name is not empty, we found an already registered event that was a parent of the\n    // event we wanted to register.\n    // Copy that event's callbacks to newly registered events.\n    var _iterator3 = _createForOfIteratorHelper(newEventNodes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n        node.callbacks = events[name].callbacks.slice();\n      } // Add last newly created event to the already registered event.\n\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    events[name].childEvents.push(childEventName);\n  }\n} // Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\n\n\nfunction getCallbacksListsForNamespace(source, eventName) {\n  var eventNode = getEvents(source)[eventName];\n\n  if (!eventNode) {\n    return [];\n  }\n\n  var callbacksLists = [eventNode.callbacks];\n\n  for (var i = 0; i < eventNode.childEvents.length; i++) {\n    var childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);\n    callbacksLists = callbacksLists.concat(childCallbacksLists);\n  }\n\n  return callbacksLists;\n} // Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\n\n\nfunction getCallbacksForEvent(source, eventName) {\n  var event;\n\n  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {\n    // There are no callbacks registered for specified eventName.\n    // But this could be a specific-type event that is in a namespace.\n    if (eventName.indexOf(':') > -1) {\n      // If the eventName is specific, try to find callback lists for more generic event.\n      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));\n    } else {\n      // If this is a top-level generic event, return null;\n      return null;\n    }\n  }\n\n  return event.callbacks;\n} // Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing\n// `[ {@link module:utils/emittermixin~Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\n\n\nfunction fireDelegatedEvents(destinations, eventInfo, fireArgs) {\n  var _iterator4 = _createForOfIteratorHelper(destinations),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          emitter = _step4$value[0],\n          name = _step4$value[1];\n\n      if (!name) {\n        name = eventInfo.name;\n      } else if (typeof name == 'function') {\n        name = name(eventInfo.name);\n      }\n\n      var delegatedInfo = new EventInfo(eventInfo.source, name);\n      delegatedInfo.path = _toConsumableArray(eventInfo.path);\n      emitter.fire.apply(emitter, [delegatedInfo].concat(_toConsumableArray(fireArgs)));\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n} // Helper for registering event callback on the emitter.\n\n\nfunction addEventListener(listener, emitter, event, callback, options) {\n  if (emitter._addEventListener) {\n    emitter._addEventListener(event, callback, options);\n  } else {\n    // Allow listening on objects that do not implement Emitter interface.\n    // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n    listener._addEventListener.call(emitter, event, callback, options);\n  }\n} // Helper for removing event callback from the emitter.\n\n\nfunction removeEventListener(listener, emitter, event, callback) {\n  if (emitter._removeEventListener) {\n    emitter._removeEventListener(event, callback);\n  } else {\n    // Allow listening on objects that do not implement Emitter interface.\n    // This is needed in some tests that are using mocks instead of the real objects with EmitterMixin mixed.\n    listener._removeEventListener.call(emitter, event, callback);\n  }\n}\n/**\n * The return value of {@link ~EmitterMixin#delegate}.\n *\n * @interface module:utils/emittermixin~EmitterMixinDelegateChain\n */\n\n/**\n * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n *\n * @method #to\n * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.\n * @param {String|Function} [nameOrFunction] A custom event name or function which converts the original name string.\n */","map":null,"metadata":{},"sourceType":"module"}