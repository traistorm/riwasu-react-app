{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/textwatcher\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport getLastTextLine from './utils/getlasttextline';\n/**\n * The text watcher feature.\n *\n * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},\n * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and\n * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.\n *\n * @private\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar TextWatcher = /*#__PURE__*/function () {\n  /**\n   * Creates a text watcher instance.\n   *\n   * @param {module:engine/model/model~Model} model\n   * @param {Function} testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.\n   */\n  function TextWatcher(model, testCallback) {\n    var _this = this;\n\n    _classCallCheck(this, TextWatcher);\n\n    /**\n     * The editor's model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The function used to match the text.\n     *\n     * The test callback can return 3 values:\n     *\n     * * `false` if there is no match,\n     * * `true` if there is a match,\n     * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.\n     *\n     * @member {Function} #testCallback\n     * @returns {Object} testResult\n     */\n\n    this.testCallback = testCallback;\n    /**\n     * Whether there is a match currently.\n     *\n     * @readonly\n     * @member {Boolean}\n     */\n\n    this.hasMatch = false;\n    /**\n     * Flag indicating whether the `TextWatcher` instance is enabled or disabled.\n     * A disabled TextWatcher will not evaluate text.\n     *\n     * To disable TextWatcher:\n     *\n     *\t\tconst watcher = new TextWatcher( editor.model, testCallback );\n     *\n     *\t\t// After this a testCallback will not be called.\n     *\t\twatcher.isEnabled = false;\n     *\n     * @observable\n     * @member {Boolean} #isEnabled\n     */\n\n    this.set('isEnabled', true); // Toggle text watching on isEnabled state change.\n\n    this.on('change:isEnabled', function () {\n      if (_this.isEnabled) {\n        _this._startListening();\n      } else {\n        _this.stopListening(model.document.selection);\n\n        _this.stopListening(model.document);\n      }\n    });\n\n    this._startListening();\n  }\n  /**\n   * Starts listening to the editor for typing and selection events.\n   *\n   * @private\n   */\n\n\n  _createClass(TextWatcher, [{\n    key: \"_startListening\",\n    value: function _startListening() {\n      var _this2 = this;\n\n      var model = this.model;\n      var document = model.document;\n      this.listenTo(document.selection, 'change:range', function (evt, _ref) {\n        var directChange = _ref.directChange;\n\n        // Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.\n        if (!directChange) {\n          return;\n        } // Act only on collapsed selection.\n\n\n        if (!document.selection.isCollapsed) {\n          if (_this2.hasMatch) {\n            _this2.fire('unmatched');\n\n            _this2.hasMatch = false;\n          }\n\n          return;\n        }\n\n        _this2._evaluateTextBeforeSelection('selection');\n      });\n      this.listenTo(document, 'change:data', function (evt, batch) {\n        if (batch.isUndo || !batch.isLocal) {\n          return;\n        }\n\n        _this2._evaluateTextBeforeSelection('data', {\n          batch: batch\n        });\n      });\n    }\n    /**\n     * Checks the editor content for matched text.\n     *\n     * @fires matched:data\n     * @fires matched:selection\n     * @fires unmatched\n     *\n     * @private\n     * @param {'data'|'selection'} suffix A suffix used for generating the event name.\n     * @param {Object} data Data object for event.\n     */\n\n  }, {\n    key: \"_evaluateTextBeforeSelection\",\n    value: function _evaluateTextBeforeSelection(suffix) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = this.model;\n      var document = model.document;\n      var selection = document.selection;\n      var rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);\n\n      var _getLastTextLine = getLastTextLine(rangeBeforeSelection, model),\n          text = _getLastTextLine.text,\n          range = _getLastTextLine.range;\n\n      var testResult = this.testCallback(text);\n\n      if (!testResult && this.hasMatch) {\n        this.fire('unmatched');\n      }\n\n      this.hasMatch = !!testResult;\n\n      if (testResult) {\n        var eventData = Object.assign(data, {\n          text: text,\n          range: range\n        }); // If the test callback returns an object with additional data, assign the data as well.\n\n        if (typeof testResult == 'object') {\n          Object.assign(eventData, testResult);\n        }\n\n        this.fire(\"matched:\".concat(suffix), eventData);\n      }\n    }\n  }]);\n\n  return TextWatcher;\n}();\n\nexport { TextWatcher as default };\nmix(TextWatcher, ObservableMixin);\n/**\n * Fired whenever the text watcher found a match for data changes.\n *\n * @event matched:data\n * @param {Object} data Event data.\n * @param {String} data.text The full text before selection to which the regexp was applied.\n * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.\n * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.\n */\n\n/**\n * Fired whenever the text watcher found a match for selection changes.\n *\n * @event matched:selection\n * @param {Object} data Event data.\n * @param {String} data.text The full text before selection.\n * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.\n * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.\n */\n\n/**\n * Fired whenever the text does not match anymore. Fired only when the text watcher found a match.\n *\n * @event unmatched\n */","map":null,"metadata":{},"sourceType":"module"}