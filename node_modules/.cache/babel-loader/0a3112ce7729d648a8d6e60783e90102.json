{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\nimport TextProxy from '../model/textproxy';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Manages a list of consumable values for the {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into separate, single properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing the changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and its attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when the given part of a model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), the consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let th {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * the {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.\n *\n * Keep in mind that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, the others should not, because they would duplicate the results. Using `ModelConsumable` helps to avoid\n * this situation, because callbacks should only convert these values that were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `imageBlock` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [imageBlock]\n *\t\t//   └─ [caption]\n *\t\t//       └─ foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//   ├─ <img />\n *\t\t//   └─ <caption>\n *\t\t//       └─ foo\n *\t\tmodelConversionDispatcher.on( 'insert:imageBlock', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `imageBlock` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\t\t\tconst viewWriter = conversionApi.writer;\n *\n *\t\t\t// Check if the `imageBlock` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\n\nvar ModelConsumable = /*#__PURE__*/function () {\n  /**\n   * Creates an empty consumables list.\n   */\n  function ModelConsumable() {\n    _classCallCheck(this, ModelConsumable);\n\n    /**\n     * Contains list of consumable values.\n     *\n     * @private\n     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n     */\n    this._consumable = new Map();\n    /**\n     * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds a parent\n     * of that `TextProxy` and the start and end indices of that `TextProxy`. This allows identification of the `TextProxy`\n     * instances that point to the same part of the model but are different instances. Each distinct `TextProxy`\n     * is given a unique `Symbol` which is then registered as consumable. This process is transparent for the `ModelConsumable`\n     * API user because whenever `TextProxy` is added, tested, consumed or reverted, the internal mechanisms of\n     * `ModelConsumable` translate `TextProxy` to that unique `Symbol`.\n     *\n     * @private\n     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n     */\n\n    this._textProxyRegistry = new Map();\n  }\n  /**\n   * Adds a consumable value to the consumables list and links it with a given model item.\n   *\n   *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n   *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n   *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n   *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n   *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n   * Model item, range or selection that has the consumable.\n   * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n   * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n   */\n\n\n  _createClass(ModelConsumable, [{\n    key: \"add\",\n    value: function add(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      if (!this._consumable.has(item)) {\n        this._consumable.set(item, new Map());\n      }\n\n      this._consumable.get(item).set(type, true);\n    }\n    /**\n     * Removes a given consumable value from a given model item.\n     *\n     *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n     *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n     *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n     *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n     *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n     * Model item, range or selection from which consumable will be consumed.\n     * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n     * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n     * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n     */\n\n  }, {\n    key: \"consume\",\n    value: function consume(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      if (this.test(item, type)) {\n        this._consumable.get(item).set(type, false);\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Tests whether there is a consumable value of a given type connected with a given model item.\n     *\n     *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n     *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n     *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n     *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n     *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n     * Model item, range or selection to be tested.\n     * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n     * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n     * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n     * already consumed or `true` if it was added and not consumed yet.\n     */\n\n  }, {\n    key: \"test\",\n    value: function test(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      var itemConsumables = this._consumable.get(item);\n\n      if (itemConsumables === undefined) {\n        return null;\n      }\n\n      var value = itemConsumables.get(type);\n\n      if (value === undefined) {\n        return null;\n      }\n\n      return value;\n    }\n    /**\n     * Reverts consuming of a consumable value.\n     *\n     *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n     *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n     *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n     *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n     *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n     * Model item, range or selection to be reverted.\n     * @param {String} type Consumable type.\n     * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n     * never been added.\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert(item, type) {\n      type = _normalizeConsumableType(type);\n\n      if (item instanceof TextProxy) {\n        item = this._getSymbolForTextProxy(item);\n      }\n\n      var test = this.test(item, type);\n\n      if (test === false) {\n        this._consumable.get(item).set(type, true);\n\n        return true;\n      } else if (test === true) {\n        return false;\n      }\n\n      return null;\n    }\n    /**\n     * Verifies if all events from the specified group were consumed.\n     *\n     * @param {String} eventGroup The events group to verify.\n     */\n\n  }, {\n    key: \"verifyAllConsumed\",\n    value: function verifyAllConsumed(eventGroup) {\n      var items = [];\n\n      var _iterator = _createForOfIteratorHelper(this._consumable),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              item = _step$value[0],\n              consumables = _step$value[1];\n\n          var _iterator2 = _createForOfIteratorHelper(consumables),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  event = _step2$value[0],\n                  canConsume = _step2$value[1];\n\n              var eventPrefix = event.split(':')[0];\n\n              if (canConsume && eventGroup == eventPrefix) {\n                items.push({\n                  event: event,\n                  item: item.name || item.description\n                });\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (items.length) {\n        /**\n         * Some of the {@link module:engine/model/item~Item model items} were not consumed while downcasting the model to view.\n         *\n         * This might be the effect of:\n         *\n         * * A missing converter for some model elements. Make sure that you registered downcast converters for all model elements.\n         * * A custom converter that does not consume converted items. Make sure that you\n         * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} all model elements that you converted\n         * from the model to the view.\n         * * A custom converter that called `event.stop()`. When providing a custom converter, keep in mind that you should not stop\n         * the event. If you stop it then the default converter at the `lowest` priority will not trigger the conversion of this node's\n         * attributes and child nodes.\n         *\n         * @error conversion-model-consumable-not-consumed\n         * @param {Array.<module:engine/model/item~Item>} items Items that were not consumed.\n         */\n        throw new CKEditorError('conversion-model-consumable-not-consumed', null, {\n          items: items\n        });\n      }\n    }\n    /**\n     * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n     * have same parent, same start index and same end index will get the same symbol.\n     *\n     * Used internally to correctly consume `TextProxy` instances.\n     *\n     * @protected\n     * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n     * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n     */\n\n  }, {\n    key: \"_getSymbolForTextProxy\",\n    value: function _getSymbolForTextProxy(textProxy) {\n      var symbol = null;\n\n      var startMap = this._textProxyRegistry.get(textProxy.startOffset);\n\n      if (startMap) {\n        var endMap = startMap.get(textProxy.endOffset);\n\n        if (endMap) {\n          symbol = endMap.get(textProxy.parent);\n        }\n      }\n\n      if (!symbol) {\n        symbol = this._addSymbolForTextProxy(textProxy);\n      }\n\n      return symbol;\n    }\n    /**\n     * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.\n     *\n     * Used internally to correctly consume `TextProxy` instances.\n     *\n     * @private\n     * @param {module:engine/model/textproxy~TextProxy} textProxy Text proxy instance.\n     * @returns {Symbol} Symbol generated for given `TextProxy`.\n     */\n\n  }, {\n    key: \"_addSymbolForTextProxy\",\n    value: function _addSymbolForTextProxy(textProxy) {\n      var start = textProxy.startOffset;\n      var end = textProxy.endOffset;\n      var parent = textProxy.parent;\n      var symbol = Symbol('$textProxy:' + textProxy.data);\n      var startMap, endMap;\n      startMap = this._textProxyRegistry.get(start);\n\n      if (!startMap) {\n        startMap = new Map();\n\n        this._textProxyRegistry.set(start, startMap);\n      }\n\n      endMap = startMap.get(end);\n\n      if (!endMap) {\n        endMap = new Map();\n        startMap.set(end, endMap);\n      }\n\n      endMap.set(parent, symbol);\n      return symbol;\n    }\n  }]);\n\n  return ModelConsumable;\n}(); // Returns a normalized consumable type name from the given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If a string to normalize has more \"parts\" (more colons),\n// the further parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\n\n\nexport { ModelConsumable as default };\n\nfunction _normalizeConsumableType(type) {\n  var parts = type.split(':'); // For inserts allow passing event name, it's stored in the context of a specified element so the element name is not needed.\n\n  if (parts[0] == 'insert') {\n    return parts[0];\n  } // Markers are identified by the whole name (otherwise we would consume the whole markers group).\n\n\n  if (parts[0] == 'addMarker' || parts[0] == 'removeMarker') {\n    return type;\n  }\n\n  return parts.length > 1 ? parts[0] + ':' + parts[1] : parts[0];\n}","map":null,"metadata":{},"sourceType":"module"}