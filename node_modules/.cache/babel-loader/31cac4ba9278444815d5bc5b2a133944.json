{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/editableelement\n */\nimport ContainerElement from './containerelement';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\n/**\n * Editable element which can be a {@link module:engine/view/rooteditableelement~RootEditableElement root}\n * or nested editable area in the editor.\n *\n * Editable is automatically read-only when its {@link module:engine/view/document~Document Document} is read-only.\n *\n * The constructor of this class shouldn't be used directly. To create new `EditableElement` use the\n * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`} method.\n *\n * @extends module:engine/view/containerelement~ContainerElement\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar EditableElement = /*#__PURE__*/function (_ContainerElement) {\n  _inherits(EditableElement, _ContainerElement);\n\n  /**\n   * Creates an editable element.\n   *\n   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement\n   * @protected\n   */\n  function EditableElement(document, name, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, EditableElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditableElement).call(this, document, name, attrs, children));\n    /**\n     * Whether the editable is in read-write or read-only mode.\n     *\n     * @observable\n     * @member {Boolean} module:engine/view/editableelement~EditableElement#isReadOnly\n     */\n\n    _this.set('isReadOnly', false);\n    /**\n     * Whether the editable is focused.\n     *\n     * This property updates when {@link module:engine/view/document~Document#isFocused document.isFocused} or view\n     * selection is changed.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/editableelement~EditableElement#isFocused\n     */\n\n\n    _this.set('isFocused', false);\n\n    _this.bind('isReadOnly').to(document);\n\n    _this.bind('isFocused').to(document, 'isFocused', function (isFocused) {\n      return isFocused && document.selection.editableElement == _assertThisInitialized(_assertThisInitialized(_this));\n    }); // Update focus state based on selection changes.\n\n\n    _this.listenTo(document.selection, 'change', function () {\n      _this.isFocused = document.isFocused && document.selection.editableElement == _assertThisInitialized(_assertThisInitialized(_this));\n    });\n\n    return _this;\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\teditableElement.is( 'editableElement' ); // -> true\n   *\t\teditableElement.is( 'element' ); // -> true\n   *\t\teditableElement.is( 'node' ); // -> true\n   *\t\teditableElement.is( 'view:editableElement' ); // -> true\n   *\t\teditableElement.is( 'view:element' ); // -> true\n   *\t\teditableElement.is( 'view:node' ); // -> true\n   *\n   *\t\teditableElement.is( 'model:element' ); // -> false\n   *\t\teditableElement.is( 'documentFragment' ); // -> false\n   *\n   * Assuming that the object being checked is an editbale element, you can also check its\n   * {@link module:engine/view/editableelement~EditableElement#name name}:\n   *\n   *\t\teditableElement.is( 'element', 'div' ); // -> true if this is a div element\n   *\t\teditableElement.is( 'editableElement', 'div' ); // -> same as above\n   *\t\ttext.is( 'element', 'div' ); -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type Type to check.\n   * @param {String} [name] Element name.\n   * @returns {Boolean}\n   */\n\n\n  _createClass(EditableElement, [{\n    key: \"is\",\n    value: function is(type) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!name) {\n        return type === 'editableElement' || type === 'view:editableElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n        type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';\n      } else {\n        return name === this.name && (type === 'editableElement' || type === 'view:editableElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n        type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element');\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n    }\n  }]);\n\n  return EditableElement;\n}(ContainerElement);\n\nexport { EditableElement as default };\nmix(EditableElement, ObservableMixin);","map":null,"metadata":{},"sourceType":"module"}