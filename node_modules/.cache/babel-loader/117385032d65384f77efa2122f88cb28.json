{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(_getAllUpcastDefinitions),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(_getUpcastDefinition);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/conversion\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport UpcastHelpers from './upcasthelpers';\nimport DowncastHelpers from './downcasthelpers';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n/**\n * A utility class that helps add converters to upcast and downcast dispatchers.\n *\n * We recommend reading the {@glink framework/guides/deep-dive/conversion/intro editor conversion} guide first to\n * understand the core concepts of the conversion mechanisms.\n *\n * An instance of the conversion manager is available in the\n * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property\n * and by default has the following groups of dispatchers (i.e. directions of conversion):\n *\n * * `downcast` (editing and data downcasts)\n * * `editingDowncast`\n * * `dataDowncast`\n * * `upcast`\n *\n * # One-way converters\n *\n * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}\n * method:\n *\n *\t\t// Add a converter to editing downcast and data downcast.\n *\t\teditor.conversion.for( 'downcast' ).elementToElement( config ) );\n *\n *\t\t// Add a converter to the data pipepline only:\n *\t\teditor.conversion.for( 'dataDowncast' ).elementToElement( dataConversionConfig ) );\n *\n *\t\t// And a slightly different one for the editing pipeline:\n *\t\teditor.conversion.for( 'editingDowncast' ).elementToElement( editingConversionConfig ) );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `for()`} method documentation to learn more about\n * available conversion helpers and how to use your custom ones.\n *\n * # Two-way converters\n *\n * Besides using one-way converters via the `for()` method, you can also use other methods available in this\n * class to add two-way converters (upcast and downcast):\n *\n * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;\n * Model element to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `attributeToAttribute()`} &ndash;\n * Model attribute to view attribute and vice versa.\n */\n\nvar Conversion = /*#__PURE__*/function () {\n  /**\n   * Creates a new conversion instance.\n   *\n   * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n   * Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher>} downcastDispatchers\n   * @param {module:engine/conversion/upcastdispatcher~UpcastDispatcher|\n   * Array.<module:engine/conversion/upcastdispatcher~UpcastDispatcher>} upcastDispatchers\n   */\n  function Conversion(downcastDispatchers, upcastDispatchers) {\n    _classCallCheck(this, Conversion);\n\n    /**\n     * Maps dispatchers group name to ConversionHelpers instances.\n     *\n     * @private\n     * @member {Map.<String,module:engine/conversion/conversionhelpers~ConversionHelpers>}\n     */\n    this._helpers = new Map(); // Define default 'downcast' & 'upcast' dispatchers groups. Those groups are always available as two-way converters needs them.\n\n    this._downcast = toArray(downcastDispatchers);\n\n    this._createConversionHelpers({\n      name: 'downcast',\n      dispatchers: this._downcast,\n      isDowncast: true\n    });\n\n    this._upcast = toArray(upcastDispatchers);\n\n    this._createConversionHelpers({\n      name: 'upcast',\n      dispatchers: this._upcast,\n      isDowncast: false\n    });\n  }\n  /**\n   * Define an alias for registered dispatcher.\n   *\n   *\t\tconst conversion = new Conversion(\n   *\t\t\t[ dataDowncastDispatcher, editingDowncastDispatcher ],\n   *\t\t\tupcastDispatcher\n   *\t\t);\n   *\n   *\t\tconversion.addAlias( 'dataDowncast', dataDowncastDispatcher );\n   *\n   * @param {String} alias An alias of a dispatcher.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n   * module:engine/conversion/upcastdispatcher~UpcastDispatcher} dispatcher Dispatcher which should have an alias.\n   */\n\n\n  _createClass(Conversion, [{\n    key: \"addAlias\",\n    value: function addAlias(alias, dispatcher) {\n      var isDowncast = this._downcast.includes(dispatcher);\n\n      var isUpcast = this._upcast.includes(dispatcher);\n\n      if (!isUpcast && !isDowncast) {\n        /**\n         * Trying to register an alias for a dispatcher that nas not been registered.\n         *\n         * @error conversion-add-alias-dispatcher-not-registered\n         */\n        throw new CKEditorError('conversion-add-alias-dispatcher-not-registered', this);\n      }\n\n      this._createConversionHelpers({\n        name: alias,\n        dispatchers: [dispatcher],\n        isDowncast: isDowncast\n      });\n    }\n    /**\n     * Provides a chainable API to assign converters to a conversion dispatchers group.\n     *\n     * If the given group name has not been registered, the\n     * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.\n     *\n     * You can use conversion helpers available directly in the `for()` chain or your custom ones via\n     * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.\n     *\n     * # Using built-in conversion helpers\n     *\n     * The `for()` chain comes with a set of conversion helpers which you can use like this:\n     *\n     *\t\teditor.conversion.for( 'downcast' )\n     *\t\t\t.elementToElement( config1 )        // Adds an element-to-element downcast converter.\n     *\t\t\t.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.\n     *\n     *\t\teditor.conversion.for( 'upcast' )\n     *\t\t\t.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.\n     *\n     * Refer to the documentation of built-in conversion helpers to learn about their configuration options.\n     *\n     * * downcast (model-to-view) conversion helpers:\n     *\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.\n     *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.\n     *\n     * * upcast (view-to-model) conversion helpers:\n     *\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.\n     *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.\n     *\n     * # Using custom conversion helpers\n     *\n     * If you need to implement an atypical converter, you can do so by calling:\n     *\n     *\t\teditor.conversion.for( direction ).add( customHelper );\n     *\n     * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that\n     * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.\n     *\n     * Example:\n     *\n     *\t\teditor.conversion.for( 'upcast' ).add( dispatcher => {\n     *\t\t\tdispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {\n     *\t\t\t\t// Do something with a view <a> element.\n     *\t\t\t} );\n     *\t\t} );\n     *\n     * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write\n     * custom converters.\n     *\n     * @param {String} groupName The name of dispatchers group to add the converters to.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}\n     */\n\n  }, {\n    key: \"for\",\n    value: function _for(groupName) {\n      if (!this._helpers.has(groupName)) {\n        /**\n         * Trying to add a converter to an unknown dispatchers group.\n         *\n         * @error conversion-for-unknown-group\n         */\n        throw new CKEditorError('conversion-for-unknown-group', this);\n      }\n\n      return this._helpers.get(groupName);\n    }\n    /**\n     * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).\n     * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.\n     *\n     *\t\t// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).\n     *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n     *\n     *\t\t// Override other converters by specifying a converter definition with a higher priority.\n     *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n     *\n     *\t\t// View specified as an object instead of a string.\n     *\t\teditor.conversion.elementToElement( {\n     *\t\t\tmodel: 'fancyParagraph',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.\n     *\t\teditor.conversion.elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'p',\n     *\t\t\tupcastAlso: [\n     *\t\t\t\t'div',\n     *\t\t\t\t{\n     *\t\t\t\t\t// Any element with the `display: block` style.\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\tdisplay: 'block'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t} );\n     *\n     *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n     *\t\teditor.conversion.elementToElement( {\n     *\t\t\tmodel: 'heading',\n     *\t\t\tview: 'h2',\n     *\t\t\t// Convert \"heading-like\" paragraphs to headings.\n     *\t\t\tupcastAlso: viewElement => {\n     *\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\n     *\t\t\t\tif ( !fontSize ) {\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\n     *\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n     *\n     *\t\t\t\tif ( !match ) {\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\n     *\t\t\t\tconst size = Number( match[ 1 ] );\n     *\n     *\t\t\t\tif ( size > 26 ) {\n     *\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n     *\t\t\t\t}\n     *\n     *\t\t\t\treturn null;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * `definition.model` is a `String` with a model element name to convert from or to.\n     * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n     *\n     * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n     */\n\n  }, {\n    key: \"elementToElement\",\n    value: function elementToElement(definition) {\n      // Set up downcast converter.\n      this.for('downcast').elementToElement(definition); // Set up upcast converter.\n\n      var _iterator = _createForOfIteratorHelper(_getAllUpcastDefinitions(definition)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _step.value,\n              model = _step$value.model,\n              view = _step$value.view;\n          this.for('upcast').elementToElement({\n            model: model,\n            view: view,\n            converterPriority: definition.converterPriority\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).\n     * For example, a model text node with `\"Foo\"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.\n     *\n     *\t\t// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).\n     *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );\n     *\n     *\t\t// Override other converters by specifying a converter definition with a higher priority.\n     *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n     *\n     *\t\t// View specified as an object instead of a string.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: 'bold'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.\n     *\t\t// The same attribute on different elements may then be handled by a different converter.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'textDecoration',\n     *\t\t\t\tvalues: [ 'underline', 'lineThrough' ],\n     *\t\t\t\tname: '$text'\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tunderline: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-decoration': 'underline'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tlineThrough: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-decoration': 'line-through'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'strong',\n     *\t\t\tupcastAlso: [\n     *\t\t\t\t'b',\n     *\t\t\t\t{\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tclasses: 'bold'\n     *\t\t\t\t},\n     *\t\t\t\t{\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-weight': 'bold'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tviewElement => {\n     *\t\t\t\t\tconst fontWeight = viewElement.getStyle( 'font-weight' );\n     *\n     *\t\t\t\t\tif ( viewElement.is( 'element', 'span' ) && fontWeight && /\\d+/.test() && Number( fontWeight ) > 500 ) {\n     *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\t\treturn {\n     *\t\t\t\t\t\t\tname: true,\n     *\t\t\t\t\t\t\tstyles: [ 'font-weight' ]\n     *\t\t\t\t\t\t};\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t} );\n     *\n     *\t\t// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).\n     *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n     *\t\teditor.conversion.attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalues: [ 'big', 'small' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tbig: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '1.2em'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tsmall: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '0.8em'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tupcastAlso: {\n     *\t\t\t\tbig: viewElement => {\n     *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\n     *\t\t\t\t\tif ( !fontSize ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n     *\n     *\t\t\t\t\tif ( !match ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst size = Number( match[ 1 ] );\n     *\n     *\t\t\t\t\tif ( viewElement.is( 'element', 'span' ) && size > 10 ) {\n     *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t},\n     *\t\t\t\tsmall: viewElement => {\n     *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n     *\n     *\t\t\t\t\tif ( !fontSize ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n     *\n     *\t\t\t\t\tif ( !match ) {\n     *\t\t\t\t\t\treturn null;\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\tconst size = Number( match[ 1 ] );\n     *\n     *\t\t\t\t\tif ( viewElement.is( 'element', 'span' ) && size < 10 ) {\n     *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n     *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n     *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n     *\n     *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n     *\t\t\t\t\t}\n     *\n     *\t\t\t\t\treturn null;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object\n     * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case\n     * `value` is set to `true`).\n     * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n     *\n     * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n     */\n\n  }, {\n    key: \"attributeToElement\",\n    value: function attributeToElement(definition) {\n      // Set up downcast converter.\n      this.for('downcast').attributeToElement(definition); // Set up upcast converter.\n\n      var _iterator2 = _createForOfIteratorHelper(_getAllUpcastDefinitions(definition)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n              model = _step2$value.model,\n              view = _step2$value.view;\n          this.for('upcast').elementToAttribute({\n            view: view,\n            model: model,\n            converterPriority: definition.converterPriority\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,\n     * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).\n     * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.\n     * To convert the text attributes,\n     * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.\n     *\n     *\t\t// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).\n     *\t\teditor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );\n     *\n     *\t\t// Attribute values are strictly specified.\n     *\t\teditor.conversion.attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'imageInline',\n     *\t\t\t\tkey: 'aside',\n     *\t\t\t\tvalues: [ 'aside' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\taside: {\n     *\t\t\t\t\tname: 'img',\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'aside', 'half-size' ]\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Set the style attribute.\n     *\t\teditor.conversion.attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'imageInline',\n     *\t\t\t\tkey: 'aside',\n     *\t\t\t\tvalues: [ 'aside' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\taside: {\n     *\t\t\t\t\tname: 'img',\n     *\t\t\t\t\tkey: 'style',\n     *\t\t\t\t\tvalue: {\n     *\t\t\t\t\t\tfloat: 'right',\n     *\t\t\t\t\t\twidth: '50%',\n     *\t\t\t\t\t\tmargin: '5px'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\t// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).\n     *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.\n     *\t\teditor.conversion.attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'align',\n     *\t\t\t\tvalues: [ 'right', 'center' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tright: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: 'align-right'\n     *\t\t\t\t},\n     *\t\t\t\tcenter: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: 'align-center'\n     *\t\t\t\t}\n     *\t\t\t},\n     *\t\t\tupcastAlso: {\n     *\t\t\t\tright: {\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-align': 'right'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tcenter: {\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'text-align': 'center'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The `definition.model` parameter specifies which model attribute should be converted from and to.\n     * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.\n     * The `key` property is the model attribute key to convert from and to.\n     * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value\n     * will be the same as the view attribute value.\n     * If `name` is set, the conversion will be set up only for model elements with the given name.\n     *\n     * The `definition.view` parameter specifies which view attribute should be converted from and to.\n     * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.\n     * The `key` property is the view attribute key to convert from and to.\n     * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be\n     * the same as the model attribute value.\n     * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.\n     * If `key` is `'style'`, `value` is an object with key-value pairs.\n     * In other cases, `value` is a `String`.\n     * If `name` is set, the conversion will be set up only for model elements with the given name.\n     * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`\n     * to `{ key, value, [ name ] }` objects.\n     *\n     * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.\n     * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`\n     * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.\n     *\n     * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should\n     * be given in both parameters.\n     *\n     * @param {Object} definition The converter definition.\n     * @param {String|Object} definition.model The model attribute to convert from and to.\n     * @param {String|Object} definition.view The view attribute to convert from and to.\n     * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]\n     * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`\n     * is used only if `config.model.values` is specified.\n     */\n\n  }, {\n    key: \"attributeToAttribute\",\n    value: function attributeToAttribute(definition) {\n      // Set up downcast converter.\n      this.for('downcast').attributeToAttribute(definition); // Set up upcast converter.\n\n      var _iterator3 = _createForOfIteratorHelper(_getAllUpcastDefinitions(definition)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _step3.value,\n              model = _step3$value.model,\n              view = _step3$value.view;\n          this.for('upcast').attributeToAttribute({\n            view: view,\n            model: model\n          });\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Creates and caches conversion helpers for given dispatchers group.\n     *\n     * @private\n     * @param {Object} options\n     * @param {String} options.name Group name.\n     * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n     * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} options.dispatchers\n     * @param {Boolean} options.isDowncast\n     */\n\n  }, {\n    key: \"_createConversionHelpers\",\n    value: function _createConversionHelpers(_ref) {\n      var name = _ref.name,\n          dispatchers = _ref.dispatchers,\n          isDowncast = _ref.isDowncast;\n\n      if (this._helpers.has(name)) {\n        /**\n         * Trying to register a group name that has already been registered.\n         *\n         * @error conversion-group-exists\n         */\n        throw new CKEditorError('conversion-group-exists', this);\n      }\n\n      var helpers = isDowncast ? new DowncastHelpers(dispatchers) : new UpcastHelpers(dispatchers);\n\n      this._helpers.set(name, helpers);\n    }\n  }]);\n\n  return Conversion;\n}();\n/**\n * Defines how the model should be converted from and to the view.\n *\n * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition\n *\n * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs\n * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.\n * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and\n * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions\n * (`view` object values).\n * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]\n * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`\n * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s\n * (`upcastAlso` object values).\n * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.\n */\n// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in\n// `definition.upcastAlso`.\n//\n// @param {module:engine/conversion/conversion~ConverterDefinition} definition\n// @returns {Array} Array containing view definitions.\n\n\nexport { Conversion as default };\n\nfunction _getAllUpcastDefinitions(definition) {\n  var _iterator4, _step4, value, model, view, upcastAlso;\n\n  return _regeneratorRuntime.wrap(function _getAllUpcastDefinitions$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!definition.model.values) {\n            _context.next = 22;\n            break;\n          }\n\n          _iterator4 = _createForOfIteratorHelper(definition.model.values);\n          _context.prev = 2;\n\n          _iterator4.s();\n\n        case 4:\n          if ((_step4 = _iterator4.n()).done) {\n            _context.next = 12;\n            break;\n          }\n\n          value = _step4.value;\n          model = {\n            key: definition.model.key,\n            value: value\n          };\n          view = definition.view[value];\n          upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : undefined;\n          return _context.delegateYield(_getUpcastDefinition(model, view, upcastAlso), \"t0\", 10);\n\n        case 10:\n          _context.next = 4;\n          break;\n\n        case 12:\n          _context.next = 17;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t1 = _context[\"catch\"](2);\n\n          _iterator4.e(_context.t1);\n\n        case 17:\n          _context.prev = 17;\n\n          _iterator4.f();\n\n          return _context.finish(17);\n\n        case 20:\n          _context.next = 23;\n          break;\n\n        case 22:\n          return _context.delegateYield(_getUpcastDefinition(definition.model, definition.view, definition.upcastAlso), \"t2\", 23);\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n\nfunction _getUpcastDefinition(model, view, upcastAlso) {\n  var _iterator5, _step5, upcastAlsoItem;\n\n  return _regeneratorRuntime.wrap(function _getUpcastDefinition$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return {\n            model: model,\n            view: view\n          };\n\n        case 2:\n          if (!upcastAlso) {\n            _context2.next = 20;\n            break;\n          }\n\n          _iterator5 = _createForOfIteratorHelper(toArray(upcastAlso));\n          _context2.prev = 4;\n\n          _iterator5.s();\n\n        case 6:\n          if ((_step5 = _iterator5.n()).done) {\n            _context2.next = 12;\n            break;\n          }\n\n          upcastAlsoItem = _step5.value;\n          _context2.next = 10;\n          return {\n            model: model,\n            view: upcastAlsoItem\n          };\n\n        case 10:\n          _context2.next = 6;\n          break;\n\n        case 12:\n          _context2.next = 17;\n          break;\n\n        case 14:\n          _context2.prev = 14;\n          _context2.t0 = _context2[\"catch\"](4);\n\n          _iterator5.e(_context2.t0);\n\n        case 17:\n          _context2.prev = 17;\n\n          _iterator5.f();\n\n          return _context2.finish(17);\n\n        case 20:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[4, 14, 17, 20]]);\n}","map":null,"metadata":{},"sourceType":"module"}