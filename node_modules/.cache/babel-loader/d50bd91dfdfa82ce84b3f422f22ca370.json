{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar PluginCollection = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the plugin collection class.\n   * Allows loading and initializing plugins and their dependencies.\n   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n   *\n   * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).\n   * Usually, the editor will pass its built-in plugins to the collection so they can later be\n   * used in `config.plugins` or `config.removePlugins` by names.\n   * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n   * `[ PluginConstructor, pluginInstance ]` pair.\n   */\n  function PluginCollection(context) {\n    var availablePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var contextPlugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, PluginCollection);\n\n    /**\n     * @protected\n     * @type {module:core/editor/editor~Editor|module:core/context~Context}\n     */\n    this._context = context;\n    /**\n     * @protected\n     * @type {Map}\n     */\n\n    this._plugins = new Map();\n    /**\n     * A map of plugin constructors that can be retrieved by their names.\n     *\n     * @protected\n     * @type {Map.<String|Function,Function>}\n     */\n\n    this._availablePlugins = new Map();\n\n    var _iterator = _createForOfIteratorHelper(availablePlugins),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var PluginConstructor = _step.value;\n\n        if (PluginConstructor.pluginName) {\n          this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n        }\n      }\n      /**\n       * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n       *\n       * @protected\n       * @type {Map<Function,Function>}\n       */\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._contextPlugins = new Map();\n\n    var _iterator2 = _createForOfIteratorHelper(contextPlugins),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _PluginConstructor = _step2$value[0],\n            pluginInstance = _step2$value[1];\n\n        this._contextPlugins.set(_PluginConstructor, pluginInstance);\n\n        this._contextPlugins.set(pluginInstance, _PluginConstructor); // To make it possible to require a plugin by its name.\n\n\n        if (_PluginConstructor.pluginName) {\n          this._availablePlugins.set(_PluginConstructor.pluginName, _PluginConstructor);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n   *\n   * @returns {Iterable.<Array>}\n   */\n\n\n  _createClass(PluginCollection, [{\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n      var _iterator3, _step3, entry;\n\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper(this._plugins);\n              _context.prev = 1;\n\n              _iterator3.s();\n\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 10;\n                break;\n              }\n\n              entry = _step3.value;\n\n              if (!(typeof entry[0] == 'function')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 8;\n              return entry;\n\n            case 8:\n              _context.next = 3;\n              break;\n\n            case 10:\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](1);\n\n              _iterator3.e(_context.t0);\n\n            case 15:\n              _context.prev = 15;\n\n              _iterator3.f();\n\n              return _context.finish(15);\n\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this, [[1, 12, 15, 18]]);\n    })\n    /**\n     * Gets the plugin instance by its constructor or name.\n     *\n     *\t\t// Check if 'Clipboard' plugin was loaded.\n     *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n     *\t\t\t// Get clipboard plugin instance\n     *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n     *\n     *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n     *\t\t\t\t// Do something on clipboard input.\n     *\t\t\t} );\n     *\t\t}\n     *\n     * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n     * to check if a plugin is available.\n     *\n     * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n     * @returns {module:core/plugin~PluginInterface}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var plugin = this._plugins.get(key);\n\n      if (!plugin) {\n        var pluginName = key;\n\n        if (typeof key == 'function') {\n          pluginName = key.pluginName || key.name;\n        }\n        /**\n         * The plugin is not loaded and could not be obtained.\n         *\n         * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n         * the plugin collection.\n         * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n         * property.\n         *\n         * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n         * to check if a plugin was loaded.\n         *\n         * @error plugincollection-plugin-not-loaded\n         * @param {String} plugin The name of the plugin which is not loaded.\n         */\n\n\n        throw new CKEditorError('plugincollection-plugin-not-loaded', this._context, {\n          plugin: pluginName\n        });\n      }\n\n      return plugin;\n    }\n    /**\n     * Checks if a plugin is loaded.\n     *\n     *\t\t// Check if the 'Clipboard' plugin was loaded.\n     *\t\tif ( editor.plugins.has( 'ClipboardPipeline' ) ) {\n     *\t\t\t// Now use the clipboard plugin instance:\n     *\t\t\tconst clipboard = editor.plugins.get( 'ClipboardPipeline' );\n     *\n     *\t\t\t// ...\n     *\t\t}\n     *\n     * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this._plugins.has(key);\n    }\n    /**\n     * Initializes a set of plugins and adds them to the collection.\n     *\n     * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n     * or {@link module:core/plugin~PluginInterface.pluginName plugin names}.\n     * @param {Array.<String|Function>} [pluginsToRemove] Names of the plugins or plugin constructors\n     * that should not be loaded (despite being specified in the `plugins` array).\n     * @param {Array.<Function>} [pluginsSubstitutions] An array of {@link module:core/plugin~PluginInterface plugin constructors}\n     * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.\n     * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced\n     * must follow these rules:\n     *   * The new plugin must be a class.\n     *   * The new plugin must be named.\n     *   * Both plugins must not depend on other plugins.\n     * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n     * and available in the collection.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(plugins) {\n      var pluginsToRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var pluginsSubstitutions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      // Plugin initialization procedure consists of 2 main steps:\n      // 1) collecting all available plugin constructors,\n      // 2) verification whether all required plugins can be instantiated.\n      //\n      // In the first step, all plugin constructors, available in the provided `plugins` array and inside\n      // plugin's dependencies (from the `Plugin.requires` array), are recursively collected and added to the existing\n      // `this._availablePlugins` map, but without any verification at the given moment. Performing the verification\n      // at this point (during the plugin constructor searching) would cause false errors to occur, that some plugin\n      // is missing but in fact it may be defined further in the array as the dependency of other plugin. After\n      // traversing the entire dependency tree, it will be checked if all required \"top level\" plugins are available.\n      //\n      // In the second step, the list of plugins that have not been explicitly removed is traversed to get all the\n      // plugin constructors to be instantiated in the correct order and to validate against some rules. Finally, if\n      // no plugin is missing and no other error has been found, they all will be instantiated.\n      var that = this;\n      var context = this._context;\n      findAvailablePluginConstructors(plugins);\n      validatePlugins(plugins);\n      var pluginsToLoad = plugins.filter(function (plugin) {\n        return !isPluginRemoved(plugin, pluginsToRemove);\n      });\n\n      var pluginConstructors = _toConsumableArray(getPluginConstructors(pluginsToLoad));\n\n      substitutePlugins(pluginConstructors, pluginsSubstitutions);\n      var pluginInstances = loadPlugins(pluginConstructors);\n      return initPlugins(pluginInstances, 'init').then(function () {\n        return initPlugins(pluginInstances, 'afterInit');\n      }).then(function () {\n        return pluginInstances;\n      });\n\n      function isPluginConstructor(plugin) {\n        return typeof plugin === 'function';\n      }\n\n      function isContextPlugin(plugin) {\n        return isPluginConstructor(plugin) && plugin.isContextPlugin;\n      }\n\n      function isPluginRemoved(plugin, pluginsToRemove) {\n        return pluginsToRemove.some(function (removedPlugin) {\n          if (removedPlugin === plugin) {\n            return true;\n          }\n\n          if (getPluginName(plugin) === removedPlugin) {\n            return true;\n          }\n\n          if (getPluginName(removedPlugin) === plugin) {\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      function getPluginName(plugin) {\n        return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;\n      }\n\n      function findAvailablePluginConstructors(plugins) {\n        var processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n        plugins.forEach(function (plugin) {\n          if (!isPluginConstructor(plugin)) {\n            return;\n          }\n\n          if (processed.has(plugin)) {\n            return;\n          }\n\n          processed.add(plugin);\n\n          if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {\n            that._availablePlugins.set(plugin.pluginName, plugin);\n          }\n\n          if (plugin.requires) {\n            findAvailablePluginConstructors(plugin.requires, processed);\n          }\n        });\n      }\n\n      function getPluginConstructors(plugins) {\n        var processed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n        return plugins.map(function (plugin) {\n          return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);\n        }).reduce(function (result, plugin) {\n          if (processed.has(plugin)) {\n            return result;\n          }\n\n          processed.add(plugin);\n\n          if (plugin.requires) {\n            validatePlugins(plugin.requires, plugin);\n            getPluginConstructors(plugin.requires, processed).forEach(function (plugin) {\n              return result.add(plugin);\n            });\n          }\n\n          return result.add(plugin);\n        }, new Set());\n      }\n\n      function validatePlugins(plugins) {\n        var parentPluginConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        plugins.map(function (plugin) {\n          return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;\n        }).forEach(function (plugin) {\n          checkMissingPlugin(plugin, parentPluginConstructor);\n          checkContextPlugin(plugin, parentPluginConstructor);\n          checkRemovedPlugin(plugin, parentPluginConstructor);\n        });\n      }\n\n      function checkMissingPlugin(plugin, parentPluginConstructor) {\n        if (isPluginConstructor(plugin)) {\n          return;\n        }\n\n        if (parentPluginConstructor) {\n          /**\n           * A required \"soft\" dependency was not found on the plugin list.\n           *\n           * When configuring the editor, either prior to building (via\n           * {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}) or when\n           * creating a new instance of the editor (e.g. via\n           * {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`}), you need to provide\n           * some of the dependencies for other plugins that you used.\n           *\n           * This error is thrown when one of these dependencies was not provided. The name of the missing plugin\n           * can be found in `missingPlugin` and the plugin that required it in `requiredBy`.\n           *\n           * In order to resolve it, you need to import the missing plugin and add it to the\n           * current list of plugins (`Editor.builtinPlugins` or `config.plugins`/`config.extraPlugins`).\n           *\n           * Soft requirements were introduced in version 26.0.0. If you happen to stumble upon this error\n           * when upgrading to version 26.0.0, read also the\n           * {@glink updating/migration-to-26 Migration to 26.0.0} guide.\n           *\n           * @error plugincollection-soft-required\n           * @param {String} missingPlugin The name of the required plugin.\n           * @param {String} requiredBy The name of the plugin that requires the other plugin.\n           */\n          throw new CKEditorError('plugincollection-soft-required', context, {\n            missingPlugin: plugin,\n            requiredBy: getPluginName(parentPluginConstructor)\n          });\n        }\n        /**\n         * A plugin is not available and could not be loaded.\n         *\n         * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n         * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n         * property.\n         *\n         * **If you see this warning when using one of the {@glink installation/advanced/alternative-setups/predefined-builds\n         * CKEditor 5 Builds}**,\n         * it means that you try to enable a plugin which was not included in that build. This may be due to a typo\n         * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n         * read more about {@glink installation/getting-started/quick-start custom builds}.\n         *\n         * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n         * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n         * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n         * provide each plugin through a reference (as a constructor function). Check out the examples in\n         * {@glink installation/advanced/alternative-setups/integrating-from-source \"Building from source\"}.\n         *\n         * @error plugincollection-plugin-not-found\n         * @param {String} plugin The name of the plugin which could not be loaded.\n         */\n\n\n        throw new CKEditorError('plugincollection-plugin-not-found', context, {\n          plugin: plugin\n        });\n      }\n\n      function checkContextPlugin(plugin, parentPluginConstructor) {\n        if (!isContextPlugin(parentPluginConstructor)) {\n          return;\n        }\n\n        if (isContextPlugin(plugin)) {\n          return;\n        }\n        /**\n         * If a plugin is a context plugin, all plugins it requires should also be context plugins\n         * instead of plugins. In other words, if one plugin can be used in the context,\n         * all its requirements should also be ready to be used in the context. Note that the context\n         * provides only a part of the API provided by the editor. If one plugin needs a full\n         * editor API, all plugins which require it are considered as plugins that need a full\n         * editor API.\n         *\n         * @error plugincollection-context-required\n         * @param {String} plugin The name of the required plugin.\n         * @param {String} requiredBy The name of the parent plugin.\n         */\n\n\n        throw new CKEditorError('plugincollection-context-required', context, {\n          plugin: getPluginName(plugin),\n          requiredBy: getPluginName(parentPluginConstructor)\n        });\n      }\n\n      function checkRemovedPlugin(plugin, parentPluginConstructor) {\n        if (!parentPluginConstructor) {\n          return;\n        }\n\n        if (!isPluginRemoved(plugin, pluginsToRemove)) {\n          return;\n        }\n        /**\n         * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n         *\n         * @error plugincollection-required\n         * @param {String} plugin The name of the required plugin.\n         * @param {String} requiredBy The name of the parent plugin.\n         */\n\n\n        throw new CKEditorError('plugincollection-required', context, {\n          plugin: getPluginName(plugin),\n          requiredBy: getPluginName(parentPluginConstructor)\n        });\n      }\n\n      function loadPlugins(pluginConstructors) {\n        return pluginConstructors.map(function (PluginConstructor) {\n          var pluginInstance = that._contextPlugins.get(PluginConstructor) || new PluginConstructor(context);\n\n          that._add(PluginConstructor, pluginInstance);\n\n          return pluginInstance;\n        });\n      }\n\n      function initPlugins(pluginInstances, method) {\n        return pluginInstances.reduce(function (promise, plugin) {\n          if (!plugin[method]) {\n            return promise;\n          }\n\n          if (that._contextPlugins.has(plugin)) {\n            return promise;\n          }\n\n          return promise.then(plugin[method].bind(plugin));\n        }, Promise.resolve());\n      } // Replaces plugin constructors with the specified set of plugins.\n      //\n      // @param {Array.<Function>} pluginConstructors\n      // @param {Array.<Function>} pluginsSubstitutions\n\n\n      function substitutePlugins(pluginConstructors, pluginsSubstitutions) {\n        var _iterator4 = _createForOfIteratorHelper(pluginsSubstitutions),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var pluginItem = _step4.value;\n\n            if (typeof pluginItem != 'function') {\n              /**\n               * The plugin replacing an existing plugin must be a function.\n               *\n               * @error plugincollection-replace-plugin-invalid-type\n               */\n              throw new CKEditorError('plugincollection-replace-plugin-invalid-type', null, {\n                pluginItem: pluginItem\n              });\n            }\n\n            var pluginName = pluginItem.pluginName;\n\n            if (!pluginName) {\n              /**\n               * The plugin replacing an existing plugin must have a name.\n               *\n               * @error plugincollection-replace-plugin-missing-name\n               */\n              throw new CKEditorError('plugincollection-replace-plugin-missing-name', null, {\n                pluginItem: pluginItem\n              });\n            }\n\n            if (pluginItem.requires && pluginItem.requires.length) {\n              /**\n               * The plugin replacing an existing plugin cannot depend on other plugins.\n               *\n               * @error plugincollection-plugin-for-replacing-cannot-have-dependencies\n               */\n              throw new CKEditorError('plugincollection-plugin-for-replacing-cannot-have-dependencies', null, {\n                pluginName: pluginName\n              });\n            }\n\n            var pluginToReplace = that._availablePlugins.get(pluginName);\n\n            if (!pluginToReplace) {\n              /**\n               * The replaced plugin does not exist in the\n               * {@link module:core/plugincollection~PluginCollection available plugins} collection.\n               *\n               * @error plugincollection-plugin-for-replacing-not-exist\n               */\n              throw new CKEditorError('plugincollection-plugin-for-replacing-not-exist', null, {\n                pluginName: pluginName\n              });\n            }\n\n            var indexInPluginConstructors = pluginConstructors.indexOf(pluginToReplace);\n\n            if (indexInPluginConstructors === -1) {\n              // The Context feature can substitute plugins as well.\n              // It may happen that the editor will be created with the given context, where the plugin for substitute\n              // was already replaced. In such a case, we don't want to do it again.\n              if (that._contextPlugins.has(pluginToReplace)) {\n                return;\n              }\n              /**\n               * The replaced plugin will not be loaded so it cannot be replaced.\n               *\n               * @error plugincollection-plugin-for-replacing-not-loaded\n               */\n\n\n              throw new CKEditorError('plugincollection-plugin-for-replacing-not-loaded', null, {\n                pluginName: pluginName\n              });\n            }\n\n            if (pluginToReplace.requires && pluginToReplace.requires.length) {\n              /**\n               * The replaced plugin cannot depend on other plugins.\n               *\n               * @error plugincollection-replaced-plugin-cannot-have-dependencies\n               */\n              throw new CKEditorError('plugincollection-replaced-plugin-cannot-have-dependencies', null, {\n                pluginName: pluginName\n              });\n            }\n\n            pluginConstructors.splice(indexInPluginConstructors, 1, pluginItem);\n\n            that._availablePlugins.set(pluginName, pluginItem);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n    /**\n     * Destroys all loaded plugins.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var promises = [];\n\n      var _iterator5 = _createForOfIteratorHelper(this),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              pluginInstance = _step5$value[1];\n\n          if (typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has(pluginInstance)) {\n            promises.push(pluginInstance.destroy());\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return Promise.all(promises);\n    }\n    /**\n     * Adds the plugin to the collection. Exposed mainly for testing purposes.\n     *\n     * @protected\n     * @param {Function} PluginConstructor The plugin constructor.\n     * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n     */\n\n  }, {\n    key: \"_add\",\n    value: function _add(PluginConstructor, plugin) {\n      this._plugins.set(PluginConstructor, plugin);\n\n      var pluginName = PluginConstructor.pluginName;\n\n      if (!pluginName) {\n        return;\n      }\n\n      if (this._plugins.has(pluginName)) {\n        /**\n         * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n         * This will lead to runtime conflicts between these plugins.\n         *\n         * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n         * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n         * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n         *\n         * Check your import paths and the list of plugins passed to\n         * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n         * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n         *\n         * The second option is that your `node_modules/` directory contains duplicated versions of the same\n         * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n         * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n         * of some packages, their dependencies may need to be installed in more than one version which may lead to this\n         * warning.\n         *\n         * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n         * the dependencies of this plugin are being duplicated.\n         * They are already built into that editor build and now get added for the second time as dependencies\n         * of the plugin you are installing.\n         *\n         * Read more about {@glink installation/getting-started/installing-plugins installing plugins}.\n         *\n         * @error plugincollection-plugin-name-conflict\n         * @param {String} pluginName The duplicated plugin name.\n         * @param {Function} plugin1 The first plugin constructor.\n         * @param {Function} plugin2 The second plugin constructor.\n         */\n        throw new CKEditorError('plugincollection-plugin-name-conflict', null, {\n          pluginName: pluginName,\n          plugin1: this._plugins.get(pluginName).constructor,\n          plugin2: PluginConstructor\n        });\n      }\n\n      this._plugins.set(pluginName, plugin);\n    }\n  }]);\n\n  return PluginCollection;\n}();\n\nexport { PluginCollection as default };\nmix(PluginCollection, EmitterMixin);","map":null,"metadata":{},"sourceType":"module"}