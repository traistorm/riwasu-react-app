{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/context\n */\nimport Config from '@ckeditor/ckeditor5-utils/src/config';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport PluginCollection from './plugincollection';\nimport Locale from '@ckeditor/ckeditor5-utils/src/locale';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Provides a common, higher-level environment for solutions that use multiple {@link module:core/editor/editor~Editor editors}\n * or plugins that work outside the editor. Use it instead of {@link module:core/editor/editor~Editor.create `Editor.create()`}\n * in advanced application integrations.\n *\n * All configuration options passed to a context will be used as default options for editor instances initialized in that context.\n *\n * {@link module:core/contextplugin~ContextPlugin Context plugins} passed to a context instance will be shared among all\n * editor instances initialized in this context. These will be the same plugin instances for all the editors.\n *\n * **Note:** The context can only be initialized with {@link module:core/contextplugin~ContextPlugin context plugins}\n * (e.g. [comments](https://ckeditor.com/collaboration/comments/)). Regular {@link module:core/plugin~Plugin plugins} require an\n * editor instance to work and cannot be added to a context.\n *\n * **Note:** You can add a context plugin to an editor instance, though.\n *\n * If you are using multiple editor instances on one page and use any context plugins, create a context to share the configuration and\n * plugins among these editors. Some plugins will use the information about all existing editors to better integrate between them.\n *\n * If you are using plugins that do not require an editor to work (e.g. [comments](https://ckeditor.com/collaboration/comments/)),\n * enable and configure them using the context.\n *\n * If you are using only a single editor on each page, use {@link module:core/editor/editor~Editor.create `Editor.create()`} instead.\n * In such case, a context instance will be created by the editor instance in a transparent way.\n *\n * See {@link module:core/context~Context.create `Context.create()`} for usage examples.\n */\n\nvar Context = /*#__PURE__*/function () {\n  /**\n   * Creates a context instance with a given configuration.\n   *\n   * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.\n   *\n   * @param {Object} [config={}] The context configuration.\n   */\n  function Context(config) {\n    _classCallCheck(this, Context);\n\n    /**\n     * Stores all the configurations specific to this context instance.\n     *\n     * @readonly\n     * @type {module:utils/config~Config}\n     */\n    this.config = new Config(config, this.constructor.defaultConfig);\n    var availablePlugins = this.constructor.builtinPlugins;\n    this.config.define('plugins', availablePlugins);\n    /**\n     * The plugins loaded and in use by this context instance.\n     *\n     * @readonly\n     * @type {module:core/plugincollection~PluginCollection}\n     */\n\n    this.plugins = new PluginCollection(this, availablePlugins);\n    var languageConfig = this.config.get('language') || {};\n    /**\n     * @readonly\n     * @type {module:utils/locale~Locale}\n     */\n\n    this.locale = new Locale({\n      uiLanguage: typeof languageConfig === 'string' ? languageConfig : languageConfig.ui,\n      contentLanguage: this.config.get('language.content')\n    });\n    /**\n     * Shorthand for {@link module:utils/locale~Locale#t}.\n     *\n     * @see module:utils/locale~Locale#t\n     * @method #t\n     */\n\n    this.t = this.locale.t;\n    /**\n     * A list of editors that this context instance is injected to.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.editors = new Collection();\n    /**\n     * Reference to the editor which created the context.\n     * Null when the context was created outside of the editor.\n     *\n     * It is used to destroy the context when removing the editor that has created the context.\n     *\n     * @private\n     * @type {module:core/editor/editor~Editor|null}\n     */\n\n    this._contextOwner = null;\n  }\n  /**\n   * Loads and initializes plugins specified in the configuration.\n   *\n   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which resolves\n   * once the initialization is completed, providing an array of loaded plugins.\n   */\n\n\n  _createClass(Context, [{\n    key: \"initPlugins\",\n    value: function initPlugins() {\n      var plugins = this.config.get('plugins') || [];\n      var substitutePlugins = this.config.get('substitutePlugins') || []; // Plugins for substitution should be checked as well.\n\n      var _iterator = _createForOfIteratorHelper(plugins.concat(substitutePlugins)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var Plugin = _step.value;\n\n          if (typeof Plugin != 'function') {\n            /**\n             * Only a constructor function is allowed as a {@link module:core/contextplugin~ContextPlugin context plugin}.\n             *\n             * @error context-initplugins-constructor-only\n             */\n            throw new CKEditorError('context-initplugins-constructor-only', null, {\n              Plugin: Plugin\n            });\n          }\n\n          if (Plugin.isContextPlugin !== true) {\n            /**\n             * Only a plugin marked as a {@link module:core/contextplugin~ContextPlugin.isContextPlugin context plugin}\n             * is allowed to be used with a context.\n             *\n             * @error context-initplugins-invalid-plugin\n             */\n            throw new CKEditorError('context-initplugins-invalid-plugin', null, {\n              Plugin: Plugin\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this.plugins.init(plugins, [], substitutePlugins);\n    }\n    /**\n     * Destroys the context instance and all editors used with the context,\n     * releasing all resources used by the context.\n     *\n     * @returns {Promise} A promise that resolves once the context instance is fully destroyed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this = this;\n\n      return Promise.all(Array.from(this.editors, function (editor) {\n        return editor.destroy();\n      })).then(function () {\n        return _this.plugins.destroy();\n      });\n    }\n    /**\n     * Adds a reference to the editor which is used with this context.\n     *\n     * When the given editor has created the context, the reference to this editor will be stored\n     * as a {@link ~Context#_contextOwner}.\n     *\n     * This method should only be used by the editor.\n     *\n     * @protected\n     * @param {module:core/editor/editor~Editor} editor\n     * @param {Boolean} isContextOwner Stores the given editor as a context owner.\n     */\n\n  }, {\n    key: \"_addEditor\",\n    value: function _addEditor(editor, isContextOwner) {\n      if (this._contextOwner) {\n        /**\n         * Cannot add multiple editors to the context which is created by the editor.\n         *\n         * @error context-addeditor-private-context\n         */\n        throw new CKEditorError('context-addeditor-private-context');\n      }\n\n      this.editors.add(editor);\n\n      if (isContextOwner) {\n        this._contextOwner = editor;\n      }\n    }\n    /**\n     * Removes a reference to the editor which was used with this context.\n     * When the context was created by the given editor, the context will be destroyed.\n     *\n     * This method should only be used by the editor.\n     *\n     * @protected\n     * @param {module:core/editor/editor~Editor} editor\n     * @return {Promise} A promise that resolves once the editor is removed from the context or when the context was destroyed.\n     */\n\n  }, {\n    key: \"_removeEditor\",\n    value: function _removeEditor(editor) {\n      if (this.editors.has(editor)) {\n        this.editors.remove(editor);\n      }\n\n      if (this._contextOwner === editor) {\n        return this.destroy();\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Returns the context configuration which will be copied to the editors created using this context.\n     *\n     * The configuration returned by this method has the plugins configuration removed &mdash; plugins are shared with all editors\n     * through another mechanism.\n     *\n     * This method should only be used by the editor.\n     *\n     * @protected\n     * @returns {Object} Configuration as a plain object.\n     */\n\n  }, {\n    key: \"_getEditorConfig\",\n    value: function _getEditorConfig() {\n      var result = {};\n\n      var _iterator2 = _createForOfIteratorHelper(this.config.names()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var name = _step2.value;\n\n          if (!['plugins', 'removePlugins', 'extraPlugins'].includes(name)) {\n            result[name] = this.config.get(name);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result;\n    }\n    /**\n     * Creates and initializes a new context instance.\n     *\n     *\t\tconst commonConfig = { ... }; // Configuration for all the plugins and editors.\n     *\t\tconst editorPlugins = [ ... ]; // Regular plugins here.\n     *\n     *\t\tContext\n     *\t\t\t.create( {\n     *\t\t\t\t// Only context plugins here.\n     *\t\t\t\tplugins: [ ... ],\n     *\n     *\t\t\t\t// Configure the language for all the editors (it cannot be overwritten).\n     *\t\t\t\tlanguage: { ... },\n     *\n     *\t\t\t\t// Configuration for context plugins.\n     *\t\t\t\tcomments: { ... },\n     *\t\t\t\t...\n     *\n     *\t\t\t\t// Default configuration for editor plugins.\n     *\t\t\t\ttoolbar: { ... },\n     *\t\t\t\timage: { ... },\n     *\t\t\t\t...\n     *\t\t\t} )\n     *\t\t\t.then( context => {\n     *\t\t\t\tconst promises = [];\n     *\n     *\t\t\t\tpromises.push( ClassicEditor.create(\n     *\t\t\t\t\tdocument.getElementById( 'editor1' ),\n     *\t\t\t\t\t{\n     *\t\t\t\t\t\teditorPlugins,\n     *\t\t\t\t\t\tcontext\n     *\t\t\t\t\t}\n     *\t\t\t\t) );\n     *\n     *\t\t\t\tpromises.push( ClassicEditor.create(\n     *\t\t\t\t\tdocument.getElementById( 'editor2' ),\n     *\t\t\t\t\t{\n     *\t\t\t\t\t\teditorPlugins,\n     *\t\t\t\t\t\tcontext,\n     *\t\t\t\t\t\ttoolbar: { ... } // You can overwrite the configuration of the context.\n     *\t\t\t\t\t}\n     *\t\t\t\t) );\n     *\n     *\t\t\t\treturn Promise.all( promises );\n     *\t\t\t} );\n     *\n     * @param {Object} [config] The context configuration.\n     * @returns {Promise} A promise resolved once the context is ready. The promise resolves with the created context instance.\n     */\n\n  }], [{\n    key: \"create\",\n    value: function create(config) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        var context = new _this2(config);\n        resolve(context.initPlugins().then(function () {\n          return context;\n        }));\n      });\n    }\n  }]);\n\n  return Context;\n}();\n/**\n * An array of plugins built into the `Context` class.\n *\n * It is used in CKEditor 5 builds featuring `Context` to provide a list of context plugins which are later automatically initialized\n * during the context initialization.\n *\n * They will be automatically initialized by `Context` unless `config.plugins` is passed.\n *\n *\t\t// Build some context plugins into the Context class first.\n *\t\tContext.builtinPlugins = [ FooPlugin, BarPlugin ];\n *\n *\t\t// Normally, you need to define config.plugins, but since Context.builtinPlugins was\n *\t\t// defined, now you can call create() without any configuration.\n *\t\tContext\n *\t\t\t.create()\n *\t\t\t.then( context => {\n *\t\t\t\tcontext.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.\n *\t\t\t\tcontext.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.\n *\t\t\t} );\n *\n * See also {@link module:core/context~Context.defaultConfig `Context.defaultConfig`}\n * and {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n *\n * @static\n * @member {Array.<Function>} module:core/context~Context.builtinPlugins\n */\n\n/**\n * The default configuration which is built into the `Context` class.\n *\n * It is used in CKEditor 5 builds featuring `Context` to provide the default configuration options which are later used during the\n * context initialization.\n *\n *\t\tContext.defaultConfig = {\n *\t\t\tfoo: 1,\n *\t\t\tbar: 2\n *\t\t};\n *\n *\t\tContext\n *\t\t\t.create()\n *\t\t\t.then( context => {\n *\t\t\t\tcontext.config.get( 'foo' ); // -> 1\n *\t\t\t\tcontext.config.get( 'bar' ); // -> 2\n *\t\t\t} );\n *\n *\t\t// The default options can be overridden by the configuration passed to create().\n *\t\tContext\n *\t\t\t.create( { bar: 3 } )\n *\t\t\t.then( context => {\n *\t\t\t\tcontext.config.get( 'foo' ); // -> 1\n *\t\t\t\tcontext.config.get( 'bar' ); // -> 3\n *\t\t\t} );\n *\n * See also {@link module:core/context~Context.builtinPlugins `Context.builtinPlugins`}\n * and {@link module:core/editor/editor~Editor.defaultConfig `Editor.defaultConfig`}.\n *\n * @static\n * @member {Object} module:core/context~Context.defaultConfig\n */\n\n\nexport { Context as default };","map":null,"metadata":{},"sourceType":"module"}