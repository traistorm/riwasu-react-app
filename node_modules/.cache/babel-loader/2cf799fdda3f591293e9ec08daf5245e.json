{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/selection-post-fixer\n */\nimport Range from '../range';\nimport Position from '../position';\n/**\n * Injects selection post-fixer to the model.\n *\n * The role of the selection post-fixer is to ensure that the selection is in a correct place\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct position means that:\n *\n * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}\n * allows a `$text`.\n * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}\n * boundary (a range must be rooted within one limit element).\n * * Only {@link module:engine/model/schema~Schema#isSelectable selectable elements} can be selected from the outside\n * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this\n * selection is correct: `<paragraph>f[oo</paragraph><imageBlock></imageBlock>]`.\n *\n * If the position is not correct, the post-fixer will automatically correct it.\n *\n * ## Fixing a non-collapsed selection\n *\n * See as an example a selection that starts in a P1 element and ends inside the text of a TD element\n * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):\n *\n *\t\troot\n *\t\t |- element P1\n *\t\t |   |- \"foo\"                                      root\n *\t\t |- element TABLE (l)                   P1         TABLE             P2\n *\t\t |   |- element TR (l)                 f o[o     TR      TR         b a r\n *\t\t |   |   |- element TD (l)                       TD      TD\n *\t\t |   |       |- \"aaa\"                          a]a a    b b b\n *\t\t |   |- element TR (l)\n *\t\t |   |   |- element TD (l)                           ||\n *\t\t |   |       |- \"bbb\"                                ||\n *\t\t |- element P2                                       VV\n *\t\t |   |- \"bar\"\n *\t\t                                                   root\n *\t\t                                        P1         TABLE]            P2\n *\t\t                                       f o[o     TR      TR         b a r\n *\t\t                                                 TD      TD\n *\t\t                                               a a a    b b b\n *\n * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within\n * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.\n * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be\n * expanded to select the whole TABLE element.\n *\n * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding\n * them to select `isLimit=true` elements.\n *\n * @param {module:engine/model/model~Model} model\n */\n\nexport function injectSelectionPostFixer(model) {\n  model.document.registerPostFixer(function (writer) {\n    return selectionPostFixer(writer, model);\n  });\n} // The selection post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction selectionPostFixer(writer, model) {\n  var selection = model.document.selection;\n  var schema = model.schema;\n  var ranges = [];\n  var wasFixed = false;\n\n  var _iterator = _createForOfIteratorHelper(selection.getRanges()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var modelRange = _step.value;\n      // Go through all ranges in selection and try fixing each of them.\n      // Those ranges might overlap but will be corrected later.\n      var correctedRange = tryFixingRange(modelRange, schema); // \"Selection fixing\" algorithms sometimes get lost. In consequence, it may happen\n      // that a new range is returned but, in fact, it has the same positions as the original\n      // range anyway. If this range is not discarded, a new selection will be set and that,\n      // for instance, would destroy the selection attributes. Let's make sure that the post-fixer\n      // actually worked first before setting a new selection.\n      //\n      // https://github.com/ckeditor/ckeditor5/issues/6693\n\n      if (correctedRange && !correctedRange.isEqual(modelRange)) {\n        ranges.push(correctedRange);\n        wasFixed = true;\n      } else {\n        ranges.push(modelRange);\n      }\n    } // If any of ranges were corrected update the selection.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (wasFixed) {\n    writer.setSelection(mergeIntersectingRanges(ranges), {\n      backward: selection.isBackward\n    });\n  }\n} // Tries fixing a range if it's incorrect.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingRange(range, schema) {\n  if (range.isCollapsed) {\n    return tryFixingCollapsedRange(range, schema);\n  }\n\n  return tryFixingNonCollapsedRage(range, schema);\n} // Tries to fix collapsed ranges.\n//\n// * Fixes situation when a range is in a place where $text is not allowed\n//\n// @param {module:engine/model/range~Range} range Collapsed range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingCollapsedRange(range, schema) {\n  var originalPosition = range.start;\n  var nearestSelectionRange = schema.getNearestSelectionRange(originalPosition); // This might be null, i.e. when the editor data is empty or the selection is inside a limit element\n  // that doesn't allow text inside.\n  // In the first case, there is no need to fix the selection range.\n  // In the second, let's go up to the outer selectable element\n\n  if (!nearestSelectionRange) {\n    var ancestorObject = originalPosition.getAncestors().reverse().find(function (item) {\n      return schema.isObject(item);\n    });\n\n    if (ancestorObject) {\n      return Range._createOn(ancestorObject);\n    }\n\n    return null;\n  }\n\n  if (!nearestSelectionRange.isCollapsed) {\n    return nearestSelectionRange;\n  }\n\n  var fixedPosition = nearestSelectionRange.start; // Fixed position is the same as original - no need to return corrected range.\n\n  if (originalPosition.isEqual(fixedPosition)) {\n    return null;\n  }\n\n  return new Range(fixedPosition);\n} // Tries to fix an expanded range.\n//\n// @param {module:engine/model/range~Range} range Expanded range to fix.\n// @param {module:engine/model/schema~Schema} schema\n// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.\n\n\nfunction tryFixingNonCollapsedRage(range, schema) {\n  var start = range.start,\n      end = range.end;\n  var isTextAllowedOnStart = schema.checkChild(start, '$text');\n  var isTextAllowedOnEnd = schema.checkChild(end, '$text');\n  var startLimitElement = schema.getLimitElement(start);\n  var endLimitElement = schema.getLimitElement(end); // Ranges which both end are inside the same limit element (or root) might needs only minor fix.\n\n  if (startLimitElement === endLimitElement) {\n    // Range is valid when both position allows to place a text:\n    // - <block>f[oobarba]z</block>\n    // This would be \"fixed\" by a next check but as it will be the same it's better to return null so the selection stays the same.\n    if (isTextAllowedOnStart && isTextAllowedOnEnd) {\n      return null;\n    } // Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:\n    // - [<block>foo</block>]    ->    <block>[foo]</block>\n    // - [<block>foo]</block>    ->    <block>[foo]</block>\n    // - <block>f[oo</block>]    ->    <block>f[oo]</block>\n    // - [<block>foo</block><selectable></selectable>]    ->    <block>[foo</block><selectable></selectable>]\n\n\n    if (checkSelectionOnNonLimitElements(start, end, schema)) {\n      var isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);\n      var fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, 'forward');\n      var isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);\n      var fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, 'backward'); // The schema.getNearestSelectionRange might return null - if that happens use original position.\n\n      var rangeStart = fixedStart ? fixedStart.start : start;\n      var rangeEnd = fixedEnd ? fixedEnd.end : end;\n      return new Range(rangeStart, rangeEnd);\n    }\n  }\n\n  var isStartInLimit = startLimitElement && !startLimitElement.is('rootElement');\n  var isEndInLimit = endLimitElement && !endLimitElement.is('rootElement'); // At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element\n  // then the range crossed limit element boundaries and needs to be fixed.\n\n  if (isStartInLimit || isEndInLimit) {\n    var bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;\n    var expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));\n    var expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema)); // Although we've already found limit element on start/end positions we must find the outer-most limit element.\n    // as limit elements might be nested directly inside (ie table > tableRow > tableCell).\n\n    var _fixedStart = start;\n    var _fixedEnd = end;\n\n    if (expandStart) {\n      _fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));\n    }\n\n    if (expandEnd) {\n      _fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));\n    }\n\n    return new Range(_fixedStart, _fixedEnd);\n  } // Range was not fixed at this point so it is valid - ie it was placed around limit element already.\n\n\n  return null;\n} // Finds the outer-most ancestor.\n//\n// @param {module:engine/model/node~Node} startingNode\n// @param {module:engine/model/schema~Schema} schema\n// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.\n// @returns {module:engine/model/node~Node}\n\n\nfunction findOutermostLimitAncestor(startingNode, schema) {\n  var isLimitNode = startingNode;\n  var parent = isLimitNode; // Find outer most isLimit block as such blocks might be nested (ie. in tables).\n\n  while (schema.isLimit(parent) && parent.parent) {\n    isLimitNode = parent;\n    parent = parent.parent;\n  }\n\n  return isLimitNode;\n} // Checks whether any of range boundaries is placed around non-limit elements.\n//\n// @param {module:engine/model/position~Position} start\n// @param {module:engine/model/position~Position} end\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\n\nfunction checkSelectionOnNonLimitElements(start, end, schema) {\n  var startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, '$text');\n  var endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, '$text'); // We should fix such selection when one of those nodes needs fixing.\n\n  return startIsOnBlock || endIsOnBlock;\n}\n/**\n * Returns a minimal non-intersecting array of ranges without duplicates.\n *\n * @param {Array.<module:engine/model/range~Range>} Ranges to merge.\n * @returns {Array.<module:engine/model/range~Range>} Array of unique and nonIntersecting ranges.\n */\n\n\nexport function mergeIntersectingRanges(ranges) {\n  var rangesToMerge = _toConsumableArray(ranges);\n\n  var rangeIndexesToRemove = new Set();\n  var currentRangeIndex = 1;\n\n  while (currentRangeIndex < rangesToMerge.length) {\n    var currentRange = rangesToMerge[currentRangeIndex];\n    var previousRanges = rangesToMerge.slice(0, currentRangeIndex);\n\n    var _iterator2 = _createForOfIteratorHelper(previousRanges.entries()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            previousRangeIndex = _step2$value[0],\n            previousRange = _step2$value[1];\n\n        if (rangeIndexesToRemove.has(previousRangeIndex)) {\n          continue;\n        }\n\n        if (currentRange.isEqual(previousRange)) {\n          rangeIndexesToRemove.add(previousRangeIndex);\n        } else if (currentRange.isIntersecting(previousRange)) {\n          rangeIndexesToRemove.add(previousRangeIndex);\n          rangeIndexesToRemove.add(currentRangeIndex);\n          var mergedRange = currentRange.getJoined(previousRange);\n          rangesToMerge.push(mergedRange);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    currentRangeIndex++;\n  }\n\n  var nonIntersectingRanges = rangesToMerge.filter(function (_, index) {\n    return !rangeIndexesToRemove.has(index);\n  });\n  return nonIntersectingRanges;\n} // Checks if node exists and if it's a selectable.\n//\n// @param {module:engine/model/node~Node} node\n// @param {module:engine/model/schema~Schema} schema\n// @returns {Boolean}\n\nfunction isSelectable(node, schema) {\n  return node && schema.isSelectable(node);\n}","map":null,"metadata":{},"sourceType":"module"}