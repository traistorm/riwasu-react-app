{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/range\n */\nimport Position from './position';\nimport TreeWalker from './treewalker';\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\n\nvar Range = /*#__PURE__*/function () {\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n   *\n   * @param {module:engine/view/position~Position} start Start position.\n   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n   */\n  function Range(start) {\n    var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Range);\n\n    /**\n     * Start position.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position}\n     */\n    this.start = start.clone();\n    /**\n     * End position.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position}\n     */\n\n    this.end = end ? end.clone() : start.clone();\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n   * them together with additional information like length or {@link module:engine/view/position~Position positions},\n   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n   *\n   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n   * `ignoreElementEnd` option\n   * set to `true`.\n   *\n   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n   */\n\n\n  _createClass(Range, [{\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(new TreeWalker({\n                boundaries: this,\n                ignoreElementEnd: true\n              }), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this);\n    })\n    /**\n     * Returns whether the range is collapsed, that is it start and end positions are equal.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"getEnlarged\",\n\n    /**\n     * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n     * and at the end).\n     *\n     * For example:\n     *\n     *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n     *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n     *\n     * Note that in the sample above:\n     *\n     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n     *\n     * @returns {module:engine/view/range~Range} Enlarged range.\n     */\n    value: function getEnlarged() {\n      var start = this.start.getLastMatchingPosition(enlargeTrimSkip, {\n        direction: 'backward'\n      });\n      var end = this.end.getLastMatchingPosition(enlargeTrimSkip); // Fix positions, in case if they are in Text node.\n\n      if (start.parent.is('$text') && start.isAtStart) {\n        start = Position._createBefore(start.parent);\n      }\n\n      if (end.parent.is('$text') && end.isAtEnd) {\n        end = Position._createAfter(end.parent);\n      }\n\n      return new Range(start, end);\n    }\n    /**\n     * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n     * and at the end).\n     *\n     * For example:\n     *\n     *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n     *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n     *\n     * Note that in the sample above:\n     *\n     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n     *\n     * @returns {module:engine/view/range~Range} Shrink range.\n     */\n\n  }, {\n    key: \"getTrimmed\",\n    value: function getTrimmed() {\n      var start = this.start.getLastMatchingPosition(enlargeTrimSkip);\n\n      if (start.isAfter(this.end) || start.isEqual(this.end)) {\n        return new Range(start, start);\n      }\n\n      var end = this.end.getLastMatchingPosition(enlargeTrimSkip, {\n        direction: 'backward'\n      });\n      var nodeAfterStart = start.nodeAfter;\n      var nodeBeforeEnd = end.nodeBefore; // Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\n      if (nodeAfterStart && nodeAfterStart.is('$text')) {\n        start = new Position(nodeAfterStart, 0);\n      }\n\n      if (nodeBeforeEnd && nodeBeforeEnd.is('$text')) {\n        end = new Position(nodeBeforeEnd, nodeBeforeEnd.data.length);\n      }\n\n      return new Range(start, end);\n    }\n    /**\n     * Two ranges are equal if their start and end positions are equal.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(otherRange) {\n      return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n    }\n    /**\n     * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n     *\n     * @param {module:engine/view/position~Position} position Position to check.\n     * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n     * `false` otherwise.\n     */\n\n  }, {\n    key: \"containsPosition\",\n    value: function containsPosition(position) {\n      return position.isAfter(this.start) && position.isBefore(this.end);\n    }\n    /**\n     * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to check.\n     * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n     * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n     * otherwise.\n     */\n\n  }, {\n    key: \"containsRange\",\n    value: function containsRange(otherRange) {\n      var loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (otherRange.isCollapsed) {\n        loose = false;\n      }\n\n      var containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);\n      var containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);\n      return containsStart && containsEnd;\n    }\n    /**\n     * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n     * {@link module:engine/view/range~Range range}.\n     * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n     *\n     * Examples:\n     *\n     *\t\tlet foo = downcastWriter.createText( 'foo' );\n     *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n     *\t\tlet bar = downcastWriter.createText( 'bar' );\n     *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n     *\n     *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n     *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n     *\t\t\tview.createPositionAt( foo, 1 ),\n     *\t\t\tview.createPositionAt( bar, 2 )\n     *\t\t);\n     *\t\tlet transformed = range.getDifference( otherRange );\n     *\t\t// transformed array has no ranges because `otherRange` contains `range`\n     *\n     *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n     *\n     *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n     * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n     */\n\n  }, {\n    key: \"getDifference\",\n    value: function getDifference(otherRange) {\n      var ranges = [];\n\n      if (this.isIntersecting(otherRange)) {\n        // Ranges intersect.\n        if (this.containsPosition(otherRange.start)) {\n          // Given range start is inside this range. This means that we have to\n          // add shrunken range - from the start to the middle of this range.\n          ranges.push(new Range(this.start, otherRange.start));\n        }\n\n        if (this.containsPosition(otherRange.end)) {\n          // Given range end is inside this range. This means that we have to\n          // add shrunken range - from the middle of this range to the end.\n          ranges.push(new Range(otherRange.end, this.end));\n        }\n      } else {\n        // Ranges do not intersect, return the original range.\n        ranges.push(this.clone());\n      }\n\n      return ranges;\n    }\n    /**\n     * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n     *\n     * Examples:\n     *\n     *\t\tlet foo = downcastWriter.createText( 'foo' );\n     *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n     *\t\tlet bar = downcastWriter.createText( 'bar' );\n     *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n     *\n     *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n     *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n     *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n     *\n     *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n     *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n     * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(otherRange) {\n      if (this.isIntersecting(otherRange)) {\n        // Ranges intersect, so a common range will be returned.\n        // At most, it will be same as this range.\n        var commonRangeStart = this.start;\n        var commonRangeEnd = this.end;\n\n        if (this.containsPosition(otherRange.start)) {\n          // Given range start is inside this range. This means thaNt we have to\n          // shrink common range to the given range start.\n          commonRangeStart = otherRange.start;\n        }\n\n        if (this.containsPosition(otherRange.end)) {\n          // Given range end is inside this range. This means that we have to\n          // shrink common range to the given range end.\n          commonRangeEnd = otherRange.end;\n        }\n\n        return new Range(commonRangeStart, commonRangeEnd);\n      } // Ranges do not intersect, so they do not have common part.\n\n\n      return null;\n    }\n    /**\n     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     * @param {module:engine/view/position~Position} [options.startPosition]\n     * @param {Boolean} [options.singleCharacters=false]\n     * @param {Boolean} [options.shallow=false]\n     * @param {Boolean} [options.ignoreElementEnd=false]\n     * @returns {module:engine/view/treewalker~TreeWalker}\n     */\n\n  }, {\n    key: \"getWalker\",\n    value: function getWalker() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      options.boundaries = this;\n      return new TreeWalker(options);\n    }\n    /**\n     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n     * which is a common ancestor of range's both ends (in which the entire range is contained).\n     *\n     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor() {\n      return this.start.getCommonAncestor(this.end);\n    }\n    /**\n     * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n     * The element will be returned when it is the **only** node within the range and **fully–contained**\n     * at the same time.\n     *\n     * @returns {module:engine/view/element~Element|null}\n     */\n\n  }, {\n    key: \"getContainedElement\",\n    value: function getContainedElement() {\n      if (this.isCollapsed) {\n        return null;\n      }\n\n      var nodeAfterStart = this.start.nodeAfter;\n      var nodeBeforeEnd = this.end.nodeBefore; // Handle the situation when the range position is at the beginning / at the end of a text node.\n      // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n      // over one element.\n      //\n      // <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n      //\n      // These are basically the same range, only the difference is if the range position is at\n      // at the end/at the beginning of a text node or just before/just after the text node.\n      //\n\n      if (this.start.parent.is('$text') && this.start.isAtEnd && this.start.parent.nextSibling) {\n        nodeAfterStart = this.start.parent.nextSibling;\n      }\n\n      if (this.end.parent.is('$text') && this.end.isAtStart && this.end.parent.previousSibling) {\n        nodeBeforeEnd = this.end.parent.previousSibling;\n      }\n\n      if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n        return nodeAfterStart;\n      }\n\n      return null;\n    }\n    /**\n     * Clones this range.\n     *\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Range(this.start, this.end);\n    }\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n     * them.\n     *\n     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n     * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n     * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/view/item~Item>}\n     */\n\n  }, {\n    key: \"getItems\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getItems() {\n      var options,\n          treeWalker,\n          _iterator,\n          _step,\n          _value,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.wrap(function getItems$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n              options.boundaries = this;\n              options.ignoreElementEnd = true;\n              treeWalker = new TreeWalker(options);\n              _iterator = _createForOfIteratorHelper(treeWalker);\n              _context2.prev = 5;\n\n              _iterator.s();\n\n            case 7:\n              if ((_step = _iterator.n()).done) {\n                _context2.next = 13;\n                break;\n              }\n\n              _value = _step.value;\n              _context2.next = 11;\n              return _value.item;\n\n            case 11:\n              _context2.next = 7;\n              break;\n\n            case 13:\n              _context2.next = 18;\n              break;\n\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](5);\n\n              _iterator.e(_context2.t0);\n\n            case 18:\n              _context2.prev = 18;\n\n              _iterator.f();\n\n              return _context2.finish(18);\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getItems, this, [[5, 15, 18, 21]]);\n    })\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n     * contained in this range.\n     *\n     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n     * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/view/position~Position>}\n     */\n\n  }, {\n    key: \"getPositions\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getPositions() {\n      var options,\n          treeWalker,\n          _iterator2,\n          _step2,\n          _value2,\n          _args3 = arguments;\n\n      return _regeneratorRuntime.wrap(function getPositions$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n              options.boundaries = this;\n              treeWalker = new TreeWalker(options);\n              _context3.next = 5;\n              return treeWalker.position;\n\n            case 5:\n              _iterator2 = _createForOfIteratorHelper(treeWalker);\n              _context3.prev = 6;\n\n              _iterator2.s();\n\n            case 8:\n              if ((_step2 = _iterator2.n()).done) {\n                _context3.next = 14;\n                break;\n              }\n\n              _value2 = _step2.value;\n              _context3.next = 12;\n              return _value2.nextPosition;\n\n            case 12:\n              _context3.next = 8;\n              break;\n\n            case 14:\n              _context3.next = 19;\n              break;\n\n            case 16:\n              _context3.prev = 16;\n              _context3.t0 = _context3[\"catch\"](6);\n\n              _iterator2.e(_context3.t0);\n\n            case 19:\n              _context3.prev = 19;\n\n              _iterator2.f();\n\n              return _context3.finish(19);\n\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, getPositions, this, [[6, 16, 19, 22]]);\n    })\n    /**\n     * Checks whether this object is of the given type.\n     *\n     *\t\trange.is( 'range' ); // -> true\n     *\t\trange.is( 'view:range' ); // -> true\n     *\n     *\t\trange.is( 'model:range' ); // -> false\n     *\t\trange.is( 'element' ); // -> false\n     *\t\trange.is( 'selection' ); // -> false\n     *\n     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type === 'range' || type === 'view:range';\n    }\n    /**\n     * Checks and returns whether this range intersects with the given range.\n     *\n     * @param {module:engine/view/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} True if ranges intersect.\n     */\n\n  }, {\n    key: \"isIntersecting\",\n    value: function isIntersecting(otherRange) {\n      return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n    }\n    /**\n     * Creates a range from the given parents and offsets.\n     *\n     * @protected\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n     * parent element.\n     * @param {Number} startOffset Start position offset.\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n     * parent element.\n     * @param {Number} endOffset End position offset.\n     * @returns {module:engine/view/range~Range} Created range.\n     */\n\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      return this.start.isEqual(this.end);\n    }\n    /**\n     * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n     * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isFlat\",\n    get: function get() {\n      return this.start.parent === this.end.parent;\n    }\n    /**\n     * Range root element.\n     *\n     * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this.start.root;\n    }\n  }], [{\n    key: \"_createFromParentsAndOffsets\",\n    value: function _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {\n      return new this(new Position(startElement, startOffset), new Position(endElement, endOffset));\n    }\n    /**\n     * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n     *\n     * @protected\n     * @param {module:engine/view/position~Position} position Beginning of the range.\n     * @param {Number} shift How long the range should be.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"_createFromPositionAndShift\",\n    value: function _createFromPositionAndShift(position, shift) {\n      var start = position;\n      var end = position.getShiftedBy(shift);\n      return shift > 0 ? new this(start, end) : new this(end, start);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @protected\n     * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"_createIn\",\n    value: function _createIn(element) {\n      return this._createFromParentsAndOffsets(element, 0, element, element.childCount);\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n     *\n     * @protected\n     * @param {module:engine/view/item~Item} item\n     * @returns {module:engine/view/range~Range}\n     */\n\n  }, {\n    key: \"_createOn\",\n    value: function _createOn(item) {\n      var size = item.is('$textProxy') ? item.offsetSize : 1;\n      return this._createFromPositionAndShift(Position._createBefore(item), size);\n    }\n  }]);\n\n  return Range;\n}(); // Function used by getEnlarged and getTrimmed methods.\n\n\nexport { Range as default };\n\nfunction enlargeTrimSkip(value) {\n  if (value.item.is('attributeElement') || value.item.is('uiElement')) {\n    return true;\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"module"}