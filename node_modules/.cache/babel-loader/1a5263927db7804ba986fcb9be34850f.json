{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertAttributesAndChildren, insertText } from '../conversion/downcasthelpers';\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\nimport ModelRange from '../model/range';\nimport { autoParagraphEmptyRoots } from '../model/utils/autoparagraphing';\nimport HtmlDataProcessor from '../dataprocessor/htmldataprocessor';\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using the given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar DataController = /*#__PURE__*/function () {\n  /**\n   * Creates a data controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model.\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  function DataController(model, stylesProcessor) {\n    var _this = this;\n\n    _classCallCheck(this, DataController);\n\n    /**\n     * Data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and\n     * ae cleared directly after the data are converted. However, the mapper is defined as a class property, because\n     * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n     */\n\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper,\n      schema: model.schema\n    });\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    this.downcastDispatcher.on('insert', insertAttributesAndChildren(), {\n      priority: 'lowest'\n    });\n    /**\n     * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     */\n\n    this.upcastDispatcher = new UpcastDispatcher({\n      schema: model.schema\n    });\n    /**\n     * The view document used by the data controller.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n\n    this.viewDocument = new ViewDocument(stylesProcessor);\n    /**\n     * Styles processor used during the conversion.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Data processor used specifically for HTML conversion.\n     *\n     * @readonly\n     * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #htmlProcessor\n     */\n\n    this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);\n    /**\n     * Data processor used during the conversion.\n     * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.\n     *\n     * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n     */\n\n    this.processor = this.htmlProcessor;\n    /**\n     * The view downcast writer just for data conversion purposes, i.e. to modify\n     * the {@link #viewDocument}.\n     *\n     * @private\n     * @readonly\n     * @member {module:engine/view/downcastwriter~DowncastWriter}\n     */\n\n    this._viewWriter = new ViewDowncastWriter(this.viewDocument); // Define default converters for text and elements.\n    //\n    // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n    // converted to nothing. We therefore add `convertToModelFragment` as a last converter so it converts children of that\n    // element to the document fragment so `<b>foo</b>` will still be converted to `foo` even if there is no converter for `<b>`.\n\n    this.upcastDispatcher.on('text', convertText(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('element', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('documentFragment', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.decorate('init');\n    this.decorate('set');\n    this.decorate('get'); // Fire the `ready` event when the initialization has completed. Such low-level listener offers the possibility\n    // to plug into the initialization pipeline without interrupting the initialization flow.\n\n    this.on('init', function () {\n      _this.fire('ready');\n    }, {\n      priority: 'lowest'\n    }); // Fix empty roots after DataController is 'ready' (note that the init method could be decorated and stopped).\n    // We need to handle this event because initial data could be empty and the post-fixer would not get triggered.\n\n    this.on('ready', function () {\n      _this.model.enqueueChange({\n        isUndoable: false\n      }, autoParagraphEmptyRoots);\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n   * formatted by the {@link #processor data processor}.\n   *\n   * @fires get\n   * @param {Object} [options] Additional configuration for the retrieved data. `DataController` provides two optional\n   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.\n   * @param {String} [options.rootName='main'] Root name.\n   * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n   * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).\n   * @returns {String} Output data.\n   */\n\n\n  _createClass(DataController, [{\n    key: \"get\",\n    value: function get() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$rootName = options.rootName,\n          rootName = _options$rootName === void 0 ? 'main' : _options$rootName,\n          _options$trim = options.trim,\n          trim = _options$trim === void 0 ? 'empty' : _options$trim;\n\n      if (!this._checkIfRootsExists([rootName])) {\n        /**\n         * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n         * is called with a non-existent root name. For example, if there is an editor instance with only `main` root,\n         * calling {@link #get} like:\n         *\n         *\t\tdata.get( { rootName: 'root2' } );\n         *\n         * will throw this error.\n         *\n         * @error datacontroller-get-non-existent-root\n         */\n        throw new CKEditorError('datacontroller-get-non-existent-root', this);\n      }\n\n      var root = this.model.document.getRoot(rootName);\n\n      if (trim === 'empty' && !this.model.hasContent(root, {\n        ignoreWhitespaces: true\n      })) {\n        return '';\n      }\n\n      return this.stringify(root, options);\n    }\n    /**\n     * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n     * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n     * The element whose content will be stringified.\n     * @param {Object} [options] Additional configuration passed to the conversion process.\n     * @returns {String} Output data.\n     */\n\n  }, {\n    key: \"stringify\",\n    value: function stringify(modelElementOrFragment) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Model -> view.\n      var viewDocumentFragment = this.toView(modelElementOrFragment, options); // View -> data.\n\n      return this.processor.toData(viewDocumentFragment);\n    }\n    /**\n     * Returns the content of the given {@link module:engine/model/element~Element model element} or\n     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n     * converters attached to {@link #downcastDispatcher} into a\n     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n     *\n     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n     * Element or document fragment whose content will be converted.\n     * @param {Object} [options={}] Additional configuration that will be available through the\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.\n     * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n     */\n\n  }, {\n    key: \"toView\",\n    value: function toView(modelElementOrFragment) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var viewDocument = this.viewDocument;\n      var viewWriter = this._viewWriter; // Clear bindings so the call to this method returns correct results.\n\n      this.mapper.clearBindings(); // First, convert elements.\n\n      var modelRange = ModelRange._createIn(modelElementOrFragment);\n\n      var viewDocumentFragment = new ViewDocumentFragment(viewDocument);\n      this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment); // Prepare list of markers.\n      // For document fragment, simply take the markers assigned to this document fragment.\n      // For model root, all markers in that root will be taken.\n      // For model element, we need to check which markers are intersecting with this element and relatively modify the markers' ranges.\n      // Collapsed markers at element boundary, although considered as not intersecting with the element, will also be returned.\n\n      var markers = modelElementOrFragment.is('documentFragment') ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);\n      this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);\n      return viewDocumentFragment;\n    }\n    /**\n     * Sets the initial input data parsed by the {@link #processor data processor} and\n     * converted by the {@link #upcastDispatcher view-to-model converters}.\n     * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.\n     *\n     * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n     * used by e.g. collaborative editing plugin that syncs remote data on init.\n     *\n     * When data is passed as a string, it is initialized on the default `main` root:\n     *\n     *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.\n     *\n     * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n     *\n     *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.\n     *\n     * @fires init\n     * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n     * pairs to initialize data on multiple roots at once.\n     * @returns {Promise} Promise that is resolved after the data is set on the editor.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(data) {\n      var _this2 = this;\n\n      if (this.model.document.version) {\n        /**\n         * Cannot set initial data to a non-empty {@link module:engine/model/document~Document}.\n         * Initial data should be set once, during the {@link module:core/editor/editor~Editor} initialization,\n         * when the {@link module:engine/model/document~Document#version} is equal 0.\n         *\n         * @error datacontroller-init-document-not-empty\n         */\n        throw new CKEditorError('datacontroller-init-document-not-empty', this);\n      }\n\n      var initialData = {};\n\n      if (typeof data === 'string') {\n        initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n      } else {\n        initialData = data;\n      }\n\n      if (!this._checkIfRootsExists(Object.keys(initialData))) {\n        /**\n         * Cannot init data on a non-existent root. This error is thrown when {@link #init DataController#init() method}\n         * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n         * calling {@link #init} like:\n         *\n         * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n         *\n         * will throw this error.\n         *\n         * @error datacontroller-init-non-existent-root\n         */\n        throw new CKEditorError('datacontroller-init-non-existent-root', this);\n      }\n\n      this.model.enqueueChange({\n        isUndoable: false\n      }, function (writer) {\n        for (var _i = 0, _Object$keys = Object.keys(initialData); _i < _Object$keys.length; _i++) {\n          var rootName = _Object$keys[_i];\n\n          var modelRoot = _this2.model.document.getRoot(rootName);\n\n          writer.insert(_this2.parse(initialData[rootName], modelRoot), modelRoot, 0);\n        }\n      });\n      return Promise.resolve();\n    }\n    /**\n     * Sets the input data parsed by the {@link #processor data processor} and\n     * converted by the {@link #upcastDispatcher view-to-model converters}.\n     * This method can be used any time to replace existing editor data with the new one without clearing the\n     * {@link module:engine/model/document~Document#history document history}.\n     *\n     * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n     * the {@link #parse} method.\n     *\n     * When data is passed as a string it is set on the default `main` root:\n     *\n     *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.\n     *\n     * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:\n     *\n     *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.\n     *\n     * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.\n     *\n     *\t\tdataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );\n     *\n     * @fires set\n     * @param {String|Object.<String,String>} data Input data as a string or an object containing the `rootName` - `data`\n     * pairs to set data on multiple roots at once.\n     * @param {Object} [options={}] Options for setting data.\n     * @param {Object} [options.batchType] The batch type that will be used to create a batch for the changes applied by this method.\n     * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be\n     * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,\n     * the undo stack will be preserved instead and not cleared when new data is applied.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(data) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var newData = {};\n\n      if (typeof data === 'string') {\n        newData.main = data; // The default root is 'main'. To set data on a different root, an object should be passed.\n      } else {\n        newData = data;\n      }\n\n      if (!this._checkIfRootsExists(Object.keys(newData))) {\n        /**\n         * Cannot set data on a non-existent root. This error is thrown when the {@link #set DataController#set() method}\n         * is called with non-existent root name. For example, if there is an editor instance with only the default `main` root,\n         * calling {@link #set} like:\n         *\n         * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n         *\n         * will throw this error.\n         *\n         * @error datacontroller-set-non-existent-root\n         */\n        throw new CKEditorError('datacontroller-set-non-existent-root', this);\n      }\n\n      this.model.enqueueChange(options.batchType || {}, function (writer) {\n        writer.setSelection(null);\n        writer.removeSelectionAttribute(_this3.model.document.selection.getAttributeKeys());\n\n        for (var _i2 = 0, _Object$keys2 = Object.keys(newData); _i2 < _Object$keys2.length; _i2++) {\n          var rootName = _Object$keys2[_i2];\n\n          // Save to model.\n          var modelRoot = _this3.model.document.getRoot(rootName);\n\n          writer.remove(writer.createRangeIn(modelRoot));\n          writer.insert(_this3.parse(newData[rootName], modelRoot), modelRoot, 0);\n        }\n      });\n    }\n    /**\n     * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n     * attached to the {@link #upcastDispatcher}.\n     *\n     * @see #set\n     * @param {String} data Data to parse.\n     * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n     * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n      // data -> view\n      var viewDocumentFragment = this.processor.toView(data); // view -> model\n\n      return this.toModel(viewDocumentFragment, context);\n    }\n    /**\n     * Returns the result of the given {@link module:engine/view/element~Element view element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n     * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n     *\n     * When marker elements were converted during the conversion process, it will be set as a document fragment's\n     * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n     * The element or document fragment whose content will be converted.\n     * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n     * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n     * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n     */\n\n  }, {\n    key: \"toModel\",\n    value: function toModel(viewElementOrFragment) {\n      var _this4 = this;\n\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';\n      return this.model.change(function (writer) {\n        return _this4.upcastDispatcher.convert(viewElementOrFragment, writer, context);\n      });\n    }\n    /**\n     * Adds the style processor normalization rules.\n     *\n     * You can implement your own rules as well as use one of the available processor rules:\n     *\n     * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n     * * border: {@link module:engine/view/styles/border~addBorderRules}\n     * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n     * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n     *\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"addStyleProcessorRules\",\n    value: function addStyleProcessorRules(callback) {\n      callback(this.stylesProcessor);\n    }\n    /**\n     * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}\n     * and a {@link #processor processor} for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM to view elements.\n     *\n     * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}\n     * `\"$rawContent\"`.\n     *\n     * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching all view elements whose content should\n     * be treated as a raw data.\n     */\n\n  }, {\n    key: \"registerRawContentMatcher\",\n    value: function registerRawContentMatcher(pattern) {\n      // No need to register the pattern if both the `htmlProcessor` and `processor` are the same instances.\n      if (this.processor && this.processor !== this.htmlProcessor) {\n        this.processor.registerRawContentMatcher(pattern);\n      }\n\n      this.htmlProcessor.registerRawContentMatcher(pattern);\n    }\n    /**\n     * Removes all event listeners set by the DataController.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stopListening();\n    }\n    /**\n     * Checks whether all provided root names are actually existing editor roots.\n     *\n     * @private\n     * @param {Array.<String>} rootNames Root names to check.\n     * @returns {Boolean} Whether all provided root names are existing editor roots.\n     */\n\n  }, {\n    key: \"_checkIfRootsExists\",\n    value: function _checkIfRootsExists(rootNames) {\n      var _iterator = _createForOfIteratorHelper(rootNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rootName = _step.value;\n\n          if (!this.model.document.getRootNames().includes(rootName)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n    /**\n     * Event fired once the data initialization has finished.\n     *\n     * @event ready\n     */\n\n    /**\n     * An event fired after the {@link #init `init()` method} was run. It can be {@link #listenTo listened to} in order to adjust or modify\n     * the initialization flow. However, if the `init` event is stopped or prevented, the {@link #event:ready `ready` event}\n     * should be fired manually.\n     *\n     * The `init` event is fired by the decorated {@link #init} method.\n     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n     *\n     * @event init\n     */\n\n    /**\n     * An event fired after {@link #set set() method} has been run.\n     *\n     * The `set` event is fired by the decorated {@link #set} method.\n     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n     *\n     * @event set\n     */\n\n    /**\n     * Event fired after the {@link #get get() method} has been run.\n     *\n     * The `get` event is fired by the decorated {@link #get} method.\n     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n     *\n     * @event get\n     */\n\n  }]);\n\n  return DataController;\n}();\n\nexport { DataController as default };\nmix(DataController, ObservableMixin); // Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it. If the marker is collapsed\n// at element boundary, it is considered as contained inside the element and marker range is returned. Otherwise, if the marker is\n// intersecting with the element, the intersection is returned.\n\nfunction _getMarkersRelativeToElement(element) {\n  var result = [];\n  var doc = element.root.document;\n\n  if (!doc) {\n    return new Map();\n  }\n\n  var elementRange = ModelRange._createIn(element);\n\n  var _iterator2 = _createForOfIteratorHelper(doc.model.markers),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var marker = _step2.value;\n      var markerRange = marker.getRange();\n      var isMarkerCollapsed = markerRange.isCollapsed;\n      var isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);\n\n      if (isMarkerCollapsed && isMarkerAtElementBoundary) {\n        result.push([marker.name, markerRange]);\n      } else {\n        var updatedMarkerRange = elementRange.getIntersection(markerRange);\n\n        if (updatedMarkerRange) {\n          result.push([marker.name, updatedMarkerRange]);\n        }\n      }\n    } // Sort the markers in a stable fashion to ensure that the order in which they are\n    // added to the model's marker collection does not affect how they are\n    // downcast. One particular use case that we are targeting here, is one where\n    // two markers are adjacent but not overlapping, such as an insertion/deletion\n    // suggestion pair representing the replacement of a range of text. In this\n    // case, putting the markers in DOM order causes the first marker's end to be\n    // serialized right after the second marker's start, while putting the markers\n    // in reverse DOM order causes it to be right before the second marker's\n    // start. So, we sort these in a way that ensures non-intersecting ranges are in\n    // reverse DOM order, and intersecting ranges are in something approximating\n    // reverse DOM order (since reverse DOM order doesn't have a precise meaning\n    // when working with intersecting ranges).\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  result.sort(function (_ref, _ref2) {\n    var _ref3 = _slicedToArray(_ref, 2),\n        n1 = _ref3[0],\n        r1 = _ref3[1];\n\n    var _ref4 = _slicedToArray(_ref2, 2),\n        n2 = _ref4[0],\n        r2 = _ref4[1];\n\n    if (r1.end.compareWith(r2.start) !== 'after') {\n      // m1.end <= m2.start -- m1 is entirely <= m2\n      return 1;\n    } else if (r1.start.compareWith(r2.end) !== 'before') {\n      // m1.start >= m2.end -- m1 is entirely >= m2\n      return -1;\n    } else {\n      // they overlap, so use their start positions as the primary sort key and\n      // end positions as the secondary sort key\n      switch (r1.start.compareWith(r2.start)) {\n        case 'before':\n          return 1;\n\n        case 'after':\n          return -1;\n\n        default:\n          switch (r1.end.compareWith(r2.end)) {\n            case 'before':\n              return 1;\n\n            case 'after':\n              return -1;\n\n            default:\n              return n2.localeCompare(n1);\n          }\n\n      }\n    }\n  });\n  return new Map(result);\n}","map":null,"metadata":{},"sourceType":"module"}