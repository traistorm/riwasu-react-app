{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/mergeoperation\n */\nimport Operation from './operation';\nimport SplitOperation from './splitoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to merge two {@link module:engine/model/element~Element elements}.\n *\n * The merged element is the parent of {@link ~MergeOperation#sourcePosition} and it is merged into the parent of\n * {@link ~MergeOperation#targetPosition}. All nodes from the merged element are moved to {@link ~MergeOperation#targetPosition}.\n *\n * The merged element is moved to the graveyard at {@link ~MergeOperation#graveyardPosition}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\n\nvar MergeOperation = /*#__PURE__*/function (_Operation) {\n  _inherits(MergeOperation, _Operation);\n\n  /**\n   * Creates a merge operation.\n   *\n   * @param {module:engine/model/position~Position} sourcePosition Position inside the merged element. All nodes from that\n   * element after that position will be moved to {@link ~#targetPosition}.\n   * @param {Number} howMany Summary offset size of nodes which will be moved from the merged element to the new parent.\n   * @param {module:engine/model/position~Position} targetPosition Position which the nodes from the merged elements will be moved to.\n   * @param {module:engine/model/position~Position} graveyardPosition Position in graveyard to which the merged element will be moved.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  function MergeOperation(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {\n    var _this;\n\n    _classCallCheck(this, MergeOperation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeOperation).call(this, baseVersion));\n    /**\n     * Position inside the merged element. All nodes from that element after that position will be moved to {@link ~#targetPosition}.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#sourcePosition\n     */\n\n    _this.sourcePosition = sourcePosition.clone(); // This is, and should always remain, the first position in its parent.\n\n    _this.sourcePosition.stickiness = 'toPrevious';\n    /**\n     * Summary offset size of nodes which will be moved from the merged element to the new parent.\n     *\n     * @member {Number} module:engine/model/operation/mergeoperation~MergeOperation#howMany\n     */\n\n    _this.howMany = howMany;\n    /**\n     * Position which the nodes from the merged elements will be moved to.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#targetPosition\n     */\n\n    _this.targetPosition = targetPosition.clone(); // Except of a rare scenario in `MergeOperation` x `MergeOperation` transformation,\n    // this is, and should always remain, the last position in its parent.\n\n    _this.targetPosition.stickiness = 'toNext';\n    /**\n     * Position in graveyard to which the merged element will be moved.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#graveyardPosition\n     */\n\n    _this.graveyardPosition = graveyardPosition.clone();\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(MergeOperation, [{\n    key: \"clone\",\n\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/mergeoperation~MergeOperation} Clone of this operation.\n     */\n    value: function clone() {\n      return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n     */\n\n  }, {\n    key: \"getReversed\",\n    value: function getReversed() {\n      // Positions in this method are transformed by this merge operation because the split operation bases on\n      // the context after this merge operation happened (because split operation reverses it).\n      // So we need to acknowledge that the merge operation happened and those positions changed a little.\n      var targetPosition = this.targetPosition._getTransformedByMergeOperation(this);\n\n      var path = this.sourcePosition.path.slice(0, -1);\n\n      var insertionPosition = new Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);\n\n      return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate() {\n      var sourceElement = this.sourcePosition.parent;\n      var targetElement = this.targetPosition.parent; // Validate whether merge operation has correct parameters.\n\n      if (!sourceElement.parent) {\n        /**\n         * Merge source position is invalid. The element to be merged must have a parent node.\n         *\n         * @error merge-operation-source-position-invalid\n         */\n        throw new CKEditorError('merge-operation-source-position-invalid', this);\n      } else if (!targetElement.parent) {\n        /**\n         * Merge target position is invalid. The element to be merged must have a parent node.\n         *\n         * @error merge-operation-target-position-invalid\n         */\n        throw new CKEditorError('merge-operation-target-position-invalid', this);\n      } else if (this.howMany != sourceElement.maxOffset) {\n        /**\n         * Merge operation specifies wrong number of nodes to move.\n         *\n         * @error merge-operation-how-many-invalid\n         */\n        throw new CKEditorError('merge-operation-how-many-invalid', this);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute() {\n      var mergedElement = this.sourcePosition.parent;\n\n      var sourceRange = Range._createIn(mergedElement);\n\n      _move(sourceRange, this.targetPosition);\n\n      _move(Range._createOn(mergedElement), this.graveyardPosition);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(MergeOperation.prototype), \"toJSON\", this).call(this);\n\n      json.sourcePosition = json.sourcePosition.toJSON();\n      json.targetPosition = json.targetPosition.toJSON();\n      json.graveyardPosition = json.graveyardPosition.toJSON();\n      return json;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'merge';\n    }\n    /**\n     * Position before the merged element (which will be deleted).\n     *\n     * @readonly\n     * @type {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"deletionPosition\",\n    get: function get() {\n      return new Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));\n    }\n    /**\n     * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.\n     * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n     *\n     * @readonly\n     * @type {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"movedRange\",\n    get: function get() {\n      var end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);\n      return new Range(this.sourcePosition, end);\n    }\n  }], [{\n    key: \"fromJSON\",\n\n    /**\n     * Creates `MergeOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n     */\n    value: function fromJSON(json, document) {\n      var sourcePosition = Position.fromJSON(json.sourcePosition, document);\n      var targetPosition = Position.fromJSON(json.targetPosition, document);\n      var graveyardPosition = Position.fromJSON(json.graveyardPosition, document);\n      return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \treturn `MergeOperation( ${ this.baseVersion } ): ` +\n    // @if CK_DEBUG_ENGINE //\t\t`${ this.sourcePosition } -> ${ this.targetPosition }` +\n    // @if CK_DEBUG_ENGINE //\t\t` ( ${ this.howMany } ), ${ this.graveyardPosition }`;\n    // @if CK_DEBUG_ENGINE // }\n\n  }, {\n    key: \"className\",\n    get: function get() {\n      return 'MergeOperation';\n    }\n  }]);\n\n  return MergeOperation;\n}(Operation);\n\nexport { MergeOperation as default };","map":null,"metadata":{},"sourceType":"module"}