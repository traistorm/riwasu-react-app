{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\nimport ModelPosition from '../model/position';\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n/**\n * Downcast conversion helper functions.\n *\n * Learn more about {@glink framework/guides/deep-dive/conversion/downcast downcast helpers}.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nvar DowncastHelpers = /*#__PURE__*/function (_ConversionHelpers) {\n  _inherits(DowncastHelpers, _ConversionHelpers);\n\n  function DowncastHelpers() {\n    _classCallCheck(this, DowncastHelpers);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DowncastHelpers).apply(this, arguments));\n  }\n\n  _createClass(DowncastHelpers, [{\n    key: \"elementToElement\",\n\n    /**\n     * Model element to view element conversion helper.\n     *\n     * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'p'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'paragraph',\n     *\t\t\tview: 'div',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'fancyParagraph',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'p',\n     *\t\t\t\tclasses: 'fancy'\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: 'heading',\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or\n     * the `children` props on a model description. You will find a couple examples below.\n     *\n     * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`\n     * description. For example, this model:\n     *\n     *\t\t<box>\n     *\t\t\t<paragraph>Some text.</paragraph>\n     *\t\t</box>\n     *\n     * will be converted into this structure in the view:\n     *\n     *\t\t<div class=\"box\" data-type=\"single\">\n     *\t\t\t<p>Some text.</p>\n     *\t\t</div>\n     *\n     * But if more items were inserted in the model:\n     *\n     *\t\t<box>\n     *\t\t\t<paragraph>Some text.</paragraph>\n     *\t\t\t<paragraph>Other item.</paragraph>\n     *\t\t</box>\n     *\n     * it will be converted into this structure in the view (note the element `data-type` change):\n     *\n     *\t\t<div class=\"box\" data-type=\"multiple\">\n     *\t\t\t<p>Some text.</p>\n     *\t\t\t<p>Other item.</p>\n     *\t\t</div>\n     *\n     * Such a converter would look like this (note that the `paragraph` elements are converted separately):\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: {\n     *\t \t\t\tname: 'box',\n     *\t \t\t\tchildren: true\n     *\t\t\t},\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createContainerElement( 'div', {\n     *\t\t\t\t\tclass: 'box',\n     *\t\t\t\t\t'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`\n     * description. For example, this model:\n     *\n     *\t\t<heading level=\"2\">Some text.</heading>\n     *\n     * will be converted into this structure in the view:\n     *\n     *\t\t<h2>Some text.</h2>\n     *\n     * But if the `heading` element's `level` attribute has been updated to `3` for example, then\n     * it will be converted into this structure in the view:\n     *\n     *\t\t<h3>Some text.</h3>\n     *\n     * Such a converter would look as follows:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n     *\t\t\tmodel: {\n     *\t \t\t\tname: 'heading',\n     *\t \t\t\tattributes: 'level'\n     *\t\t\t},\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * You can read more about the element-to-element conversion in the\n     * {@glink framework/guides/deep-dive/conversion/downcast downcast conversion} guide.\n     *\n     * @method #elementToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The description or a name of the model element to convert.\n     * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n     * the view element. Note that the view will be reconverted if any of the listed attributes changes.\n    \t * @param {Boolean} [config.model.children] Specifies whether the view element requires reconversion if the list\n     * of the model child nodes changed.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n     * config.view A view element definition or a function that takes the model element and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as parameters and returns a view container element.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n    value: function elementToElement(config) {\n      return this.add(downcastElementToElement(config));\n    }\n    /**\n     * The model element to view structure (several elements) conversion helper.\n     *\n     * This conversion results in creating a view structure with one or more slots defined for the child nodes.\n     * For example, a model `<table>` may become this structure in the view:\n     *\n     *\t\t<figure class=\"table\">\n     *\t\t\t<table>\n     *\t\t\t\t<tbody>${ slot for table rows }</tbody>\n     *\t\t\t</table>\n     *\t\t</figure>\n     *\n     * The children of the model's `<table>` element will be inserted into the `<tbody>` element.\n     * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.\n     *\n     * An example converter that converts the following model structure:\n     *\n     *\t\t<wrappedParagraph>Some text.</wrappedParagraph>\n     *\n     * into this structure in the view:\n     *\n     *\t\t<div class=\"wrapper\">\n     *\t\t\t<p>Some text.</p>\n     *\t\t</div>\n     *\n     * would look like this:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n     *\t\t\tmodel: 'wrappedParagraph',\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\tconst wrapperViewElement = writer.createContainerElement( 'div', { class: 'wrapper' } );\n     *\t\t\t\tconst paragraphViewElement = writer.createContainerElement( 'p' );\n     *\n     *\t\t\t\twriter.insert( writer.createPositionAt( wrapperViewElement, 0 ), paragraphViewElement );\n     *\t\t\t\twriter.insert( writer.createPositionAt( paragraphViewElement, 0 ), writer.createSlot() );\n     *\n     *\t\t\t\treturn wrapperViewElement;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * The `slorFor()` function can also take a callback that allows filtering which children of the model element\n     * should be converted into this slot.\n     *\n     * Imagine a table feature where for this model structure:\n     *\n     *\t\t<table headingRows=\"1\">\n     *\t\t\t<tableRow> ... table cells 1 ... </tableRow>\n     *\t\t\t<tableRow> ... table cells 2 ... </tableRow>\n     *\t\t\t<tableRow> ... table cells 3 ... </tableRow>\n     *\t\t\t<caption>Caption text</caption>\n     *\t\t</table>\n     *\n     * we want to generate this view structure:\n     *\n     *\t\t<figure class=\"table\">\n     *\t\t\t<table>\n     *\t\t\t\t<thead>\n     *\t\t\t\t\t<tr> ... table cells 1 ... </tr>\n     *\t\t\t\t</thead>\n     *\t\t\t\t<tbody>\n     *\t\t\t\t\t<tr> ... table cells 2 ... </tr>\n     *\t\t\t\t\t<tr> ... table cells 3 ... </tr>\n     *\t\t\t\t</tbody>\n     *\t\t\t</table>\n     *\t\t\t<figcaption>Caption text</figcaption>\n     *\t\t</figure>\n     *\n     * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements\n     * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.\n     *\n     * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.\n     * In the example above, this will handle the table caption.\n     *\n     * Such a converter would look like this:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'table',\n     *\t\t\t\tattributes: [ 'headingRows' ]\n     *\t\t\t},\n     *\t\t\tview: ( modelElement, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\tconst figureElement = writer.createContainerElement( 'figure', { class: 'table' } );\n     *\t\t\t\tconst tableElement = writer.createContainerElement( 'table' );\n     *\n     *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 0 ), tableElement );\n     *\n     *\t\t\t\tconst headingRows = modelElement.getAttribute( 'headingRows' ) || 0;\n     *\n     *\t\t\t\tif ( headingRows > 0 ) {\n     *\t\t\t\t\tconst tableHead = writer.createContainerElement( 'thead' );\n     *\n     *\t\t\t\t\tconst headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );\n     *\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableHead, 0 ), headSlot );\n     *\t\t\t\t}\n     *\n     *\t\t\t\tif ( headingRows < tableUtils.getRows( table ) ) {\n     *\t\t\t\t\tconst tableBody = writer.createContainerElement( 'tbody' );\n     *\n     *\t\t\t\t\tconst bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );\n     *\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );\n     *\t\t\t\t\twriter.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );\n     *\t\t\t\t}\n     *\n     *\t\t\t\tconst restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );\n     *\n     *\t\t\t\twriter.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );\n     *\n     *\t\t\t\treturn figureElement;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Note: The children of a model element that's being converted must be allocated in the same order in the view\n     * in which they are placed in the model.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #elementToStructure\n     * @param {Object} config Conversion configuration.\n    \t * @param {String|Object} config.model The description or a name of the model element to convert.\n     * @param {String} [config.model.name] The name of the model element to convert.\n    \t * @param {String|Array.<String>} [config.model.attributes] The list of attribute names that should be consumed while creating\n     * the view structure. Note that the view will be reconverted if any of the listed attributes will change.\n     * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view A function\n     * that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n     * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"elementToStructure\",\n    value: function elementToStructure(config) {\n      return this.add(downcastElementToStructure(config));\n    }\n    /**\n     * Model attribute to view element conversion helper.\n     *\n     * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n     * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'strong'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: 'b',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'invert',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'fontSize',\n     *\t\t\t\tvalues: [ 'big', 'small' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tbig: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '1.2em'\n     *\t\t\t\t\t}\n     *\t\t\t\t},\n     *\t\t\t\tsmall: {\n     *\t\t\t\t\tname: 'span',\n     *\t\t\t\t\tstyles: {\n     *\t\t\t\t\t\t'font-size': '0.8em'\n     *\t\t\t\t\t}\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: 'bold',\n     *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createAttributeElement( 'span', {\n     *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n     *\t\t\tmodel: {\n     *\t\t\t\tkey: 'color',\n     *\t\t\t\tname: '$text'\n     *\t\t\t},\n     *\t\t\tview: ( modelAttributeValue, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createAttributeElement( 'span', {\n     *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n     * of `String`s with possible values if the model attribute is an enumerable.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Object|\n     * module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction} config.view A view element definition or a function\n     * that takes the model attribute value and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n     * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`\n     * to view element definitions or functions.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"attributeToElement\",\n    value: function attributeToElement(config) {\n      return this.add(downcastAttributeToElement(config));\n    }\n    /**\n     * Model attribute to view attribute conversion helper.\n     *\n     * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n     * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'source',\n     *\t\t\tview: 'src'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'source',\n     *\t\t\tview: 'href',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'imageInline',\n     *\t\t\t\tkey: 'source'\n     *\t\t\t},\n     *\t\t\tview: 'src'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: {\n     *\t\t\t\tname: 'styled',\n     *\t\t\t\tvalues: [ 'dark', 'light' ]\n     *\t\t\t},\n     *\t\t\tview: {\n     *\t\t\t\tdark: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n     *\t\t\t\t},\n     *\t\t\t\tlight: {\n     *\t\t\t\t\tkey: 'class',\n     *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'styled',\n     *\t\t\tview: modelAttributeValue => ( {\n     *\t\t\t\tkey: 'class',\n     *\t\t\t\tvalue: 'styled-' + modelAttributeValue\n     *\t\t\t} )\n     *\t\t} );\n     *\n     * **Note**: Downcasting to a style property requires providing `value` as an object:\n     *\n     *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n     *\t\t\tmodel: 'lineHeight',\n     *\t\t\tview: modelAttributeValue => ( {\n     *\t\t\t\tkey: 'style',\n     *\t\t\t\tvalue: {\n     *\t\t\t\t\t'line-height': modelAttributeValue,\n     *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n     *\t\t\t\t}\n     *\t\t\t} )\n     *\t\t} );\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #attributeToAttribute\n     * @param {Object} config Conversion configuration.\n     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n     * the attribute key, possible values and, optionally, an element name to convert from.\n     * @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n     * or a `{ key, value }` object or a function that takes the model attribute value and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an\n     * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n     * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n     * `{ key, value }` objects or a functions.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"attributeToAttribute\",\n    value: function attributeToAttribute(config) {\n      return this.add(downcastAttributeToAttribute(config));\n    }\n    /**\n     * Model marker to view element conversion helper.\n     *\n     * **Note**: This method should be used mainly for editing the downcast and it is recommended\n     * to use the {@link #markerToData `#markerToData()`} helper instead.\n     *\n     * This helper may produce invalid HTML code (e.g. a span between table cells).\n     * It should only be used when you are sure that the produced HTML will be semantically correct.\n     *\n     * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n     * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n     * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: 'marker-search'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: 'search-result',\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: {\n     *\t\t\t\tname: 'span',\n     *\t\t\t\tattributes: {\n     *\t\t\t\t\t'data-marker': 'search'\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'editingDowncast' ).markerToElement( {\n     *\t\t\tmodel: 'search',\n     *\t\t\tview: ( markerData, conversionApi ) => {\n     *\t\t\t\tconst { writer } = conversionApi;\n     *\n     *\t\t\t\treturn writer.createUIElement( 'span', {\n     *\t\t\t\t\t'data-marker': 'search',\n     *\t\t\t\t\t'data-start': markerData.isOpening\n     *\t\t\t\t} );\n     *\t\t\t}\n     *\t\t} );\n     *\n     * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n     * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as a parameters and should return an instance of the\n     * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n     * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n     * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for\n     * the marker end boundary element.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #markerToElement\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or model marker group) to convert.\n     * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function that\n     * takes the model marker data and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as a parameters and returns a view UI element.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"markerToElement\",\n    value: function markerToElement(config) {\n      return this.add(downcastMarkerToElement(config));\n    }\n    /**\n     * Model marker to highlight conversion helper.\n     *\n     * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n     * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n     *\n     * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n     * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n     * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n     *\n     * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n     * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n     * For example, a model marker set like this:\n     * `[<imageInline src=\"foo.jpg\"></imageInline>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>` in the view.\n     *\n     * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n     * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n     * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: { classes: 'comment' },\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n     *\t\t\tmodel: 'comment',\n     *\t\t\tview: ( data, conversionApi ) => {\n     *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType:commentId.\n     *\t\t\t\tconst [ , commentType, commentId ] = data.markerName.split( ':' );\n     *\n     *\t\t\t\treturn {\n     *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ],\n     *\t\t\t\t\tattributes: { 'data-comment-id': commentId }\n     *\t\t\t\t};\n     *\t\t\t}\n     *\t\t} );\n     *\n     * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n     * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n     * as the parameters and should return a\n     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n     * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n     *\n     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n     * to the conversion process.\n     *\n     * @method #markerToHighlight\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or model marker group) to convert.\n     * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n     * that will be used for highlighting or a function that takes the model marker data and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters\n     * and returns a highlight descriptor.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"markerToHighlight\",\n    value: function markerToHighlight(config) {\n      return this.add(downcastMarkerToHighlight(config));\n    }\n    /**\n     * Model marker converter for data downcast.\n     *\n     * This conversion creates a representation for model marker boundaries in the view:\n     *\n     * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.\n     * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.\n     *\n     * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.\n     * The default configuration for this conversion is that the first part is the `group` part and the rest of\n     * the marker name becomes the `name` part.\n     *\n     * Tag and attribute names and values are generated from the marker name:\n     *\n     * * The templates for attributes are `data-[group]-start-before=\"[name]\"`, `data-[group]-start-after=\"[name]\"`,\n     * `data-[group]-end-before=\"[name]\"` and `data-[group]-end-after=\"[name]\"`.\n     * * The templates for view elements are `<[group]-start name=\"[name]\">` and `<[group]-end name=\"[name]\">`.\n     *\n     * Attributes mark whether the given marker's start or end boundary is before or after the given element.\n     * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.\n     * The other two are used when the former two cannot be used.\n     *\n     * The conversion configuration can take a function that will generate different group and name parts.\n     * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two\n     * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.\n     *\n     * Basic usage:\n     *\n     *\t\t// Using the default conversion.\n     *\t\t// In this case, all markers with names starting with 'comment:' will be converted.\n     *\t\t// The `group` parameter will be set to `comment`.\n     *\t\t// The `name` parameter will be the rest of the marker name (without the `:`).\n     *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n     *\t\t\tmodel: 'comment'\n     *\t\t} );\n     *\n     * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked\n     * by `[]`):\n     *\n     *\t\t// Model:\n     *\t\t<paragraph>Foo[bar</paragraph>\n     *\t\t<imageBlock src=\"abc.jpg\"></imageBlock>]\n     *\n     *\t\t// View:\n     *\t\t<p>Foo<comment-start name=\"commentId:uid\"></comment-start>bar</p>\n     *\t\t<figure data-comment-end-after=\"commentId:uid\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n     *\n     * In the example above, the comment starts before \"bar\" and ends after the image.\n     *\n     * If the `name` part is empty, the following view may be generated:\n     *\n     *\t\t<p>Foo <myMarker-start></myMarker-start>bar</p>\n     *\t\t<figure data-myMarker-end-after=\"\" class=\"image\"><img src=\"abc.jpg\" /></figure>\n     *\n     * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.\n     *\n     * Examples where `data-group-start-after` and `data-group-end-before` are used:\n     *\n     *\t\t// Model:\n     *\t\t<blockQuote>[]<paragraph>Foo</paragraph></blockQuote>\n     *\n     *\t\t// View:\n     *\t\t<blockquote><p data-group-end-before=\"name\" data-group-start-before=\"name\">Foo</p></blockquote>\n     *\n     * Similarly, when a marker is collapsed after the last element:\n     *\n     *\t\t// Model:\n     *\t\t<blockQuote><paragraph>Foo</paragraph>[]</blockQuote>\n     *\n     *\t\t// View:\n     *\t\t<blockquote><p data-group-end-after=\"name\" data-group-start-after=\"name\">Foo</p></blockquote>\n     *\n     * When there are multiple markers from the same group stored in the same attribute of the same element, their\n     * name parts are put together in the attribute value, for example: `data-group-start-before=\"name1,name2,name3\"`.\n     *\n     * Other examples of usage:\n     *\n     *\t\t// Using a custom function which is the same as the default conversion:\n     *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n     *\t\t\tmodel: 'comment'\n     *\t\t\tview: markerName => ( {\n     *\t\t\t\tgroup: 'comment',\n     *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n     *\t\t\t} )\n     *\t\t} );\n     *\n     *\t\t// Using the converter priority:\n     *\t\teditor.conversion.for( 'dataDowncast' ).markerToData( {\n     *\t\t\tmodel: 'comment'\n     *\t\t\tview: markerName => ( {\n     *\t\t\t\tgroup: 'comment',\n     *\t\t\t\tname: markerName.substr( 8 ) // Removes 'comment:' part.\n     *\t\t\t} ),\n     *\t\t\tconverterPriority: 'high'\n     *\t\t} );\n     *\n     * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n     *\n     * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to\n     * add a converter to the conversion process.\n     *\n     * @method #markerToData\n     * @param {Object} config Conversion configuration.\n     * @param {String} config.model The name of the model marker (or the model marker group) to convert.\n     * @param {Function} [config.view] A function that takes the model marker name and\n     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters\n     * and returns an object with the `group` and `name` properties.\n     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n     */\n\n  }, {\n    key: \"markerToData\",\n    value: function markerToData(config) {\n      return this.add(downcastMarkerToData(config));\n    }\n  }]);\n\n  return DowncastHelpers;\n}(ConversionHelpers);\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\n\n\nexport { DowncastHelpers as default };\nexport function insertText() {\n  return function (evt, data, conversionApi) {\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    var viewText = viewWriter.createText(data.item.data);\n    viewWriter.insert(viewPosition, viewText);\n  };\n}\n/**\n * Function factory that creates a default downcast converter for triggering attributes and children conversion.\n *\n * @returns {Function} The converter.\n */\n\nexport function insertAttributesAndChildren() {\n  return function (evt, data, conversionApi) {\n    conversionApi.convertAttributes(data.item); // Start converting children of the current item.\n    // In case of reconversion children were already re-inserted or converted separately.\n\n    if (!data.reconversion && data.item.is('element') && !data.item.isEmpty) {\n      conversionApi.convertChildren(data.item);\n    }\n  };\n}\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\n\nexport function remove() {\n  return function (evt, data, conversionApi) {\n    // Find the view range start position by mapping the model position at which the remove happened.\n    var viewStart = conversionApi.mapper.toViewPosition(data.position);\n    var modelEnd = data.position.getShiftedBy(data.length);\n    var viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {\n      isPhantom: true\n    });\n    var viewRange = conversionApi.writer.createRange(viewStart, viewEnd); // Trim the range to remove in case some UI elements are on the view range boundaries.\n\n    var removed = conversionApi.writer.remove(viewRange.getTrimmed()); // After the range is removed, unbind all view elements from the model.\n    // Range inside view document fragment is used to unbind deeply.\n\n    var _iterator = _createForOfIteratorHelper(conversionApi.writer.createRangeIn(removed).getItems()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n        conversionApi.mapper.unbindViewElement(child, {\n          defer: true\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  };\n}\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If the priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\n\nexport function createViewElementFromHighlightDescriptor(writer, descriptor) {\n  var viewElement = writer.createAttributeElement('span', descriptor.attributes);\n\n  if (descriptor.classes) {\n    viewElement._addClass(descriptor.classes);\n  }\n\n  if (typeof descriptor.priority === 'number') {\n    viewElement._priority = descriptor.priority;\n  }\n\n  viewElement._id = descriptor.id;\n  return viewElement;\n}\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertRangeSelection() {\n  return function (evt, data, conversionApi) {\n    var selection = data.selection;\n\n    if (selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    var viewRanges = [];\n\n    var _iterator2 = _createForOfIteratorHelper(selection.getRanges()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var range = _step2.value;\n        var viewRange = conversionApi.mapper.toViewRange(range);\n        viewRanges.push(viewRange);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    conversionApi.writer.setSelection(viewRanges, {\n      backward: selection.isBackward\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertCollapsedSelection() {\n  return function (evt, data, conversionApi) {\n    var selection = data.selection;\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var modelPosition = selection.getFirstPosition();\n    var viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n    var brokenPosition = viewWriter.breakAttributes(viewPosition);\n    viewWriter.setSelection(brokenPosition);\n  };\n}\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function clearAttributes() {\n  return function (evt, data, conversionApi) {\n    var viewWriter = conversionApi.writer;\n    var viewSelection = viewWriter.document.selection;\n\n    var _iterator3 = _createForOfIteratorHelper(viewSelection.getRanges()),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var range = _step3.value;\n\n        // Not collapsed selection should not have artifacts.\n        if (range.isCollapsed) {\n          // Position might be in the node removed by the view writer.\n          if (range.end.parent.isAttached()) {\n            conversionApi.writer.mergeAttributes(range.start);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    viewWriter.setSelection(null);\n  };\n}\n/**\n * Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, { writer } ) => {\n *\t\t\treturn writer.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\n\nexport function wrap(elementCreator) {\n  return function (evt, data, conversionApi) {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    } // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n    // or the attribute was removed.\n\n\n    var oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data); // Create node to wrap with.\n\n    var newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);\n\n    if (!oldViewElement && !newViewElement) {\n      return;\n    }\n\n    conversionApi.consumable.consume(data.item, evt.name);\n    var viewWriter = conversionApi.writer;\n    var viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      // Selection attribute conversion.\n      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);\n    } else {\n      // Node attribute conversion.\n      var viewRange = conversionApi.mapper.toViewRange(data.range); // First, unwrap the range from current wrapper.\n\n      if (data.attributeOldValue !== null && oldViewElement) {\n        viewRange = viewWriter.unwrap(viewRange, oldViewElement);\n      }\n\n      if (data.attributeNewValue !== null && newViewElement) {\n        viewWriter.wrap(viewRange, newViewElement);\n      }\n    }\n  };\n}\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, { writer } ) => {\n *\t\t\t\tconst text = writer.createText( 'myText' );\n *\t\t\t\tconst myElem = writer.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} [consumer] Function defining element consumption process.\n * By default this function just consume passed item insertion.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertElement(elementCreator) {\n  var consumer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConsumer;\n  return function (evt, data, conversionApi) {\n    if (!consumer(data.item, conversionApi.consumable, {\n      preflight: true\n    })) {\n      return;\n    }\n\n    var viewElement = elementCreator(data.item, conversionApi, data);\n\n    if (!viewElement) {\n      return;\n    } // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n\n\n    consumer(data.item, conversionApi.consumable);\n    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement); // Convert attributes before converting children.\n\n    conversionApi.convertAttributes(data.item); // Convert children or reinsert previous view elements.\n\n    reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {\n      reconversion: data.reconversion\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a single model node insertion to a view structure.\n *\n * It is expected that the passed element creator function returns an {@link module:engine/view/element~Element} with attached slots\n * created with `writer.createSlot()` to indicate where child nodes should be converted.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n *\n * @protected\n * @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} elementCreator Function returning a view structure,\n * which will be inserted.\n * @param {module:engine/conversion/downcasthelpers~ConsumerFunction} consumer A callback that is expected to consume all the consumables\n * that were used by the element creator.\n * @returns {Function} Insert element event converter.\n*/\n\nexport function insertStructure(elementCreator, consumer) {\n  return function (evt, data, conversionApi) {\n    if (!consumer(data.item, conversionApi.consumable, {\n      preflight: true\n    })) {\n      return;\n    }\n\n    var slotsMap = new Map();\n\n    conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi)); // View creation.\n\n\n    var viewElement = elementCreator(data.item, conversionApi, data);\n\n    conversionApi.writer._clearSlotFactory();\n\n    if (!viewElement) {\n      return;\n    } // Check if all children are covered by slots and there is no child that landed in multiple slots.\n\n\n    validateSlotsChildren(data.item, slotsMap, conversionApi); // Consume an element insertion and all present attributes that are specified as a reconversion triggers.\n\n    consumer(data.item, conversionApi.consumable);\n    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement); // Convert attributes before converting children.\n\n    conversionApi.convertAttributes(data.item); // Fill view slots with previous view elements or create new ones.\n\n    fillSlots(viewElement, slotsMap, conversionApi, {\n      reconversion: data.reconversion\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertUIElement(elementCreator) {\n  return function (evt, data, conversionApi) {\n    // Create two view elements. One will be inserted at the beginning of marker, one at the end.\n    // If marker is collapsed, only \"opening\" element will be inserted.\n    data.isOpening = true;\n    var viewStartElement = elementCreator(data, conversionApi);\n    data.isOpening = false;\n    var viewEndElement = elementCreator(data, conversionApi);\n\n    if (!viewStartElement || !viewEndElement) {\n      return;\n    }\n\n    var markerRange = data.markerRange; // Marker that is collapsed has consumable build differently that non-collapsed one.\n    // For more information see `addMarker` event description.\n    // If marker's range is collapsed - check if it can be consumed.\n\n    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    } // If marker's range is not collapsed - consume all items inside.\n\n\n    var _iterator4 = _createForOfIteratorHelper(markerRange),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var value = _step4.value;\n\n        if (!conversionApi.consumable.consume(value.item, evt.name)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    var mapper = conversionApi.mapper;\n    var viewWriter = conversionApi.writer; // Add \"opening\" element.\n\n    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);\n    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName); // Add \"closing\" element only if range is not collapsed.\n\n    if (!markerRange.isCollapsed) {\n      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);\n      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);\n    }\n\n    evt.stop();\n  };\n} // Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// based on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\n\nfunction removeUIElement() {\n  return function (evt, data, conversionApi) {\n    var elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    var _iterator5 = _createForOfIteratorHelper(elements),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var element = _step5.value;\n        conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Function factory that creates a default converter for model markers.\n//\n// See {@link DowncastHelpers#markerToData} for more information what type of view is generated.\n//\n// This converter binds created UI elements and affected view elements with the marker name\n// using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n//\n// @returns {Function} Add marker converter.\n\n\nfunction insertMarkerData(viewCreator) {\n  return function (evt, data, conversionApi) {\n    var viewMarkerData = viewCreator(data.markerName, conversionApi);\n\n    if (!viewMarkerData) {\n      return;\n    }\n\n    var markerRange = data.markerRange;\n\n    if (!conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    } // Adding closing data first to keep the proper order in the view.\n\n\n    handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);\n    handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);\n    evt.stop();\n  };\n} // Helper function for `insertMarkerData()` that marks a marker boundary at the beginning or end of given `range`.\n\n\nfunction handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {\n  var modelPosition = isStart ? range.start : range.end;\n  var elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is('element') ? modelPosition.nodeAfter : null;\n  var elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is('element') ? modelPosition.nodeBefore : null;\n\n  if (elementAfter || elementBefore) {\n    var modelElement;\n    var isBefore; // If possible, we want to add `data-group-start-before` and `data-group-end-after` attributes.\n\n    if (isStart && elementAfter || !isStart && !elementBefore) {\n      // [<elementAfter>...</elementAfter> -> <elementAfter data-group-start-before=\"...\">...</elementAfter>\n      // <parent>]<elementAfter> -> <parent><elementAfter data-group-end-before=\"...\">\n      modelElement = elementAfter;\n      isBefore = true;\n    } else {\n      // <elementBefore>...</elementBefore>] -> <elementBefore data-group-end-after=\"...\">...</elementBefore>\n      // </elementBefore>[</parent> -> </elementBefore data-group-start-after=\"...\"></parent>\n      modelElement = elementBefore;\n      isBefore = false;\n    }\n\n    var viewElement = conversionApi.mapper.toViewElement(modelElement); // In rare circumstances, the model element may be not mapped to any view element and that would cause an error.\n    // One of those situations is a soft break inside code block.\n\n    if (viewElement) {\n      insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);\n      return;\n    }\n  }\n\n  var viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n  insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);\n} // Helper function for `insertMarkerData()` that marks a marker boundary in the view as an attribute on a view element.\n\n\nfunction insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {\n  var attributeName = \"data-\".concat(viewMarkerData.group, \"-\").concat(isStart ? 'start' : 'end', \"-\").concat(isBefore ? 'before' : 'after');\n  var markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(',') : []; // Adding marker name at the beginning to have the same order in the attribute as there is with marker elements.\n\n  markerNames.unshift(viewMarkerData.name);\n  conversionApi.writer.setAttribute(attributeName, markerNames.join(','), viewElement);\n  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n} // Helper function for `insertMarkerData()` that marks a marker boundary in the view as a separate view ui element.\n\n\nfunction insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {\n  var viewElementName = \"\".concat(viewMarkerData.group, \"-\").concat(isStart ? 'start' : 'end');\n  var attrs = viewMarkerData.name ? {\n    'name': viewMarkerData.name\n  } : null;\n  var viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);\n  conversionApi.writer.insert(position, viewElement);\n  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n} // Function factory that creates a converter for removing a model marker data added by the {@link #insertMarkerData} converter.\n//\n// @returns {Function} Remove marker converter.\n\n\nfunction removeMarkerData(viewCreator) {\n  return function (evt, data, conversionApi) {\n    var viewData = viewCreator(data.markerName, conversionApi);\n\n    if (!viewData) {\n      return;\n    }\n\n    var elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    var _iterator6 = _createForOfIteratorHelper(elements),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var element = _step6.value;\n        conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n\n        if (element.is('containerElement')) {\n          removeMarkerFromAttribute(\"data-\".concat(viewData.group, \"-start-before\"), element);\n          removeMarkerFromAttribute(\"data-\".concat(viewData.group, \"-start-after\"), element);\n          removeMarkerFromAttribute(\"data-\".concat(viewData.group, \"-end-before\"), element);\n          removeMarkerFromAttribute(\"data-\".concat(viewData.group, \"-end-after\"), element);\n        } else {\n          conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n\n    function removeMarkerFromAttribute(attributeName, element) {\n      if (element.hasAttribute(attributeName)) {\n        var markerNames = new Set(element.getAttribute(attributeName).split(','));\n        markerNames.delete(viewData.name);\n\n        if (markerNames.size == 0) {\n          conversionApi.writer.removeAttribute(attributeName, element);\n        } else {\n          conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(','), element);\n        }\n      }\n    }\n  };\n} // Function factory that creates a converter which converts the set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\n\n\nfunction changeAttribute(attributeCreator) {\n  return function (evt, data, conversionApi) {\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n\n    var oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);\n    var newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);\n\n    if (!oldAttribute && !newAttribute) {\n      return;\n    }\n\n    conversionApi.consumable.consume(data.item, evt.name);\n    var viewElement = conversionApi.mapper.toViewElement(data.item);\n    var viewWriter = conversionApi.writer; // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n    // Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\n    if (!viewElement) {\n      /**\n       * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n       * by an {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n       * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n       *\t\t\tmodel: 'attribute-name',\n       *\t\t\tview: 'attribute-name'\n       *\t\t} ) );\n       *\n       * and given attribute is used on text node, for example:\n       *\n       *\t\tmodel.change( writer => {\n       *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n       *\t\t} );\n       *\n       * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n       * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n       * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n       * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n       *\t\t\tmodel: {\n       *\t\t\t\tkey: 'attribute-name',\n       *\t\t\t\tname: '$text'\n       *\t\t\t},\n       *\t\t\tview: ( value, { writer } ) => {\n       *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n       *\t\t\t},\n       *\t\t\tconverterPriority: 'high'\n       *\t\t} ) );\n       *\n       * @error conversion-attribute-to-attribute-on-text\n       */\n      throw new CKEditorError('conversion-attribute-to-attribute-on-text', conversionApi.dispatcher, data);\n    } // First remove the old attribute if there was one.\n\n\n    if (data.attributeOldValue !== null && oldAttribute) {\n      if (oldAttribute.key == 'class') {\n        var classes = toArray(oldAttribute.value);\n\n        var _iterator7 = _createForOfIteratorHelper(classes),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var className = _step7.value;\n            viewWriter.removeClass(className, viewElement);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      } else if (oldAttribute.key == 'style') {\n        var keys = Object.keys(oldAttribute.value);\n\n        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n          var key = _keys[_i];\n          viewWriter.removeStyle(key, viewElement);\n        }\n      } else {\n        viewWriter.removeAttribute(oldAttribute.key, viewElement);\n      }\n    } // Then set the new attribute.\n\n\n    if (data.attributeNewValue !== null && newAttribute) {\n      if (newAttribute.key == 'class') {\n        var _classes = toArray(newAttribute.value);\n\n        var _iterator8 = _createForOfIteratorHelper(_classes),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var _className = _step8.value;\n            viewWriter.addClass(_className, viewElement);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      } else if (newAttribute.key == 'style') {\n        var _keys2 = Object.keys(newAttribute.value);\n\n        for (var _i2 = 0, _keys3 = _keys2; _i2 < _keys3.length; _i2++) {\n          var _key = _keys3[_i2];\n          viewWriter.setStyle(_key, newAttribute.value[_key], viewElement);\n        }\n      } else {\n        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);\n      }\n    }\n  };\n} // Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightText(highlightDescriptor) {\n  return function (evt, data, conversionApi) {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelSelection || data.item instanceof DocumentSelection) && !data.item.is('$textProxy')) {\n      return;\n    }\n\n    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    var viewWriter = conversionApi.writer;\n    var viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);\n    var viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      viewWriter.wrap(viewSelection.getFirstRange(), viewElement, viewSelection);\n    } else {\n      var viewRange = conversionApi.mapper.toViewRange(data.range);\n      var rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);\n\n      var _iterator9 = _createForOfIteratorHelper(rangeAfterWrap.getItems()),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var element = _step9.value;\n\n          if (element.is('attributeElement') && element.isSimilar(viewElement)) {\n            conversionApi.mapper.bindElementToMarker(element, data.markerName); // One attribute element is enough, because all of them are bound together by the view writer.\n            // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  };\n} // Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightElement(highlightDescriptor) {\n  return function (evt, data, conversionApi) {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelElement)) {\n      return;\n    }\n\n    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n\n    var viewElement = conversionApi.mapper.toViewElement(data.item);\n\n    if (viewElement && viewElement.getCustomProperty('addHighlight')) {\n      // Consume element itself.\n      conversionApi.consumable.consume(data.item, evt.name); // Consume all children nodes.\n\n      var _iterator10 = _createForOfIteratorHelper(ModelRange._createIn(data.item)),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var value = _step10.value;\n          conversionApi.consumable.consume(value.item, evt.name);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      viewElement.getCustomProperty('addHighlight')(viewElement, descriptor, conversionApi.writer);\n      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n    }\n  };\n} // Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction removeHighlight(highlightDescriptor) {\n  return function (evt, data, conversionApi) {\n    // This conversion makes sense only for non-collapsed range.\n    if (data.markerRange.isCollapsed) {\n      return;\n    }\n\n    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    } // View element that will be used to unwrap `AttributeElement`s.\n\n\n    var viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor); // Get all elements bound with given marker name.\n\n    var elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    var _iterator11 = _createForOfIteratorHelper(elements),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var element = _step11.value;\n        conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n\n        if (element.is('attributeElement')) {\n          conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);\n        } else {\n          // if element.is( 'containerElement' ).\n          element.getCustomProperty('removeHighlight')(element, descriptor.id, conversionApi.writer);\n        }\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The description or a name of the model element to convert.\n// @param {String|Array.<String>} [config.model.attributes] List of attributes triggering element reconversion.\n// @param {Boolean} [config.model.children] Should reconvert element if the list of model child nodes changed.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~ElementCreatorFunction}\n// config.view\n// @returns {Function} Conversion helper.\n\n\nfunction downcastElementToElement(config) {\n  config = cloneDeep(config);\n  config.model = normalizeModelElementConfig(config.model);\n  config.view = normalizeToElementConfig(config.view, 'container'); // Trigger reconversion on children list change if element is a subject to any reconversion.\n  // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n\n  if (config.model.attributes.length) {\n    config.model.children = true;\n  }\n\n  return function (dispatcher) {\n    dispatcher.on('insert:' + config.model.name, insertElement(config.view, createConsumer(config.model)), {\n      priority: config.converterPriority || 'normal'\n    });\n\n    if (config.model.children || config.model.attributes.length) {\n      dispatcher.on('reduceChanges', createChangeReducer(config.model), {\n        priority: 'low'\n      });\n    }\n  };\n} // Model element to view structure conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToStructure `.elementToStructure()` downcast helper} for examples and config params description.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model\n// @param {String} [config.model.name]\n// @param {Array.<String>} [config.model.attributes]\n// @param {module:engine/conversion/downcasthelpers~StructureCreatorFunction} config.view\n// @returns {Function} Conversion helper.\n\n\nfunction downcastElementToStructure(config) {\n  config = cloneDeep(config);\n  config.model = normalizeModelElementConfig(config.model);\n  config.view = normalizeToElementConfig(config.view, 'container'); // Trigger reconversion on children list change because it always needs to use slots to put children in proper places.\n  // This is required to be able to trigger Differ#refreshItem() on a direct child of the reconverted element.\n\n  config.model.children = true;\n  return function (dispatcher) {\n    if (dispatcher._conversionApi.schema.checkChild(config.model.name, '$text')) {\n      /**\n       * This error occurs when a {@link module:engine/model/element~Element model element} is downcasted\n       * via {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure} helper but the element was\n       * allowed to host `$text` by the {@link module:engine/model/schema~Schema model schema}.\n       *\n       * For instance, this may be the result of `myElement` allowing the content of\n       * {@glink framework/guides/deep-dive/schema#generic-items `$block`} in its schema definition:\n       *\n       *\t\t// Element definition in schema.\n       *\t\tschema.register( 'myElement', {\n       *\t\t\tallowContentOf: '$block',\n       *\n       *\t\t\t// ...\n       *\t\t} );\n       *\n       *\t\t// ...\n       *\n       *\t\t// Conversion of myElement with the use of elementToStructure().\n       *\t\teditor.conversion.for( 'downcast' ).elementToStructure( {\n       *\t\t\tmodel: 'myElement',\n       *\t\t\tview: ( modelElement, { writer } ) => {\n       *\t\t\t\t// ...\n       *\t\t\t}\n       *\t\t} );\n       *\n       * In such case, {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`} helper\n       * can be used instead to get around this problem:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n       *\t\t\tmodel: 'myElement',\n       *\t\t\tview: ( modelElement, { writer } ) => {\n       *\t\t\t\t// ...\n       *\t\t\t}\n       *\t\t} );\n       *\n       * @error conversion-element-to-structure-disallowed-text\n       * @param {String} elementName The name of the element the structure is to be created for.\n       */\n      throw new CKEditorError('conversion-element-to-structure-disallowed-text', dispatcher, {\n        elementName: config.model.name\n      });\n    }\n\n    dispatcher.on('insert:' + config.model.name, insertStructure(config.view, createConsumer(config.model)), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('reduceChanges', createChangeReducer(config.model), {\n      priority: 'low'\n    });\n  };\n} // Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction|\n// Object} config.view A view element definition or a function that takes the model attribute value and\n// {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} as parameters and returns a view attribute element.\n// If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values` to view element\n// definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToElement(config) {\n  config = cloneDeep(config);\n  var modelKey = config.model.key ? config.model.key : config.model;\n  var eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    var _iterator12 = _createForOfIteratorHelper(config.model.values),\n        _step12;\n\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var modelValue = _step12.value;\n        config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  } else {\n    config.view = normalizeToElementConfig(config.view, 'attribute');\n  }\n\n  var elementCreator = getFromAttributeCreator(config);\n  return function (dispatcher) {\n    dispatcher.on(eventName, wrap(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|module:engine/conversion/downcasthelpers~AttributeCreatorFunction} config.view A view attribute key,\n// or a `{ key, value }` object or a function that takes the model attribute value and returns a `{ key, value }` object.\n// If `key` is `'class'`, `value` can be a `String` or an array of `String`s. If `key` is `'style'`, `value` is an object with\n// key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  var modelKey = config.model.key ? config.model.key : config.model;\n  var eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    var _iterator13 = _createForOfIteratorHelper(config.model.values),\n        _step13;\n\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var modelValue = _step13.value;\n        config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n  } else {\n    config.view = normalizeToAttributeConfig(config.view);\n  }\n\n  var elementCreator = getFromAttributeCreator(config);\n  return function (dispatcher) {\n    dispatcher.on(eventName, changeAttribute(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToElement(config) {\n  config = cloneDeep(config);\n  config.view = normalizeToElementConfig(config.view, 'ui');\n  return function (dispatcher) {\n    dispatcher.on('addMarker:' + config.model, insertUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to view data conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToData `markerToData()` downcast helper} to learn more.\n//\n// @param {Object} config\n// @param {String} config.model\n// @param {Function} [config.view]\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal']\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToData(config) {\n  config = cloneDeep(config);\n  var group = config.model; // Default conversion.\n\n  if (!config.view) {\n    config.view = function (markerName) {\n      return {\n        group: group,\n        name: markerName.substr(config.model.length + 1)\n      };\n    };\n  }\n\n  return function (dispatcher) {\n    dispatcher.on('addMarker:' + group, insertMarkerData(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + group, removeMarkerData(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToHighlight(config) {\n  return function (dispatcher) {\n    dispatcher.on('addMarker:' + config.model, highlightText(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('addMarker:' + config.model, highlightElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeHighlight(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Takes `config.model`, and converts it to an object with normalized structure.\n//\n// @param {String|Object} model Model configuration or element name.\n// @param {String} model.name\n// @param {Array.<String>} [model.attributes]\n// @param {Boolean} [model.children]\n// @returns {Object}\n\n\nfunction normalizeModelElementConfig(model) {\n  if (typeof model == 'string') {\n    model = {\n      name: model\n    };\n  } // List of attributes that should trigger reconversion.\n\n\n  if (!model.attributes) {\n    model.attributes = [];\n  } else if (!Array.isArray(model.attributes)) {\n    model.attributes = [model.attributes];\n  } // Whether a children insertion/deletion should trigger reconversion.\n\n\n  model.children = !!model.children;\n  return model;\n} // Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\n\n\nfunction normalizeToElementConfig(view, viewElementType) {\n  if (typeof view == 'function') {\n    // If `view` is already a function, don't do anything.\n    return view;\n  }\n\n  return function (modelData, conversionApi) {\n    return createViewElementFromDefinition(view, conversionApi, viewElementType);\n  };\n} // Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\n\n\nfunction createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {\n  if (typeof viewElementDefinition == 'string') {\n    // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n    viewElementDefinition = {\n      name: viewElementDefinition\n    };\n  }\n\n  var element;\n  var viewWriter = conversionApi.writer;\n  var attributes = Object.assign({}, viewElementDefinition.attributes);\n\n  if (viewElementType == 'container') {\n    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);\n  } else if (viewElementType == 'attribute') {\n    var options = {\n      priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n    };\n    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);\n  } else {\n    // 'ui'.\n    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);\n  }\n\n  if (viewElementDefinition.styles) {\n    var keys = Object.keys(viewElementDefinition.styles);\n\n    for (var _i3 = 0, _keys4 = keys; _i3 < _keys4.length; _i3++) {\n      var key = _keys4[_i3];\n      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);\n    }\n  }\n\n  if (viewElementDefinition.classes) {\n    var classes = viewElementDefinition.classes;\n\n    if (typeof classes == 'string') {\n      viewWriter.addClass(classes, element);\n    } else {\n      var _iterator14 = _createForOfIteratorHelper(classes),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var className = _step14.value;\n          viewWriter.addClass(className, element);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  }\n\n  return element;\n}\n\nfunction getFromAttributeCreator(config) {\n  if (config.model.values) {\n    return function (modelAttributeValue, conversionApi) {\n      var view = config.view[modelAttributeValue];\n\n      if (view) {\n        return view(modelAttributeValue, conversionApi);\n      }\n\n      return null;\n    };\n  } else {\n    return config.view;\n  }\n} // Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\n\n\nfunction normalizeToAttributeConfig(view) {\n  if (typeof view == 'string') {\n    return function (modelAttributeValue) {\n      return {\n        key: view,\n        value: modelAttributeValue\n      };\n    };\n  } else if (typeof view == 'object') {\n    // { key, value, ... }\n    if (view.value) {\n      return function () {\n        return view;\n      };\n    } // { key, ... }\n    else {\n      return function (modelAttributeValue) {\n        return {\n          key: view.key,\n          value: modelAttributeValue\n        };\n      };\n    }\n  } else {\n    // function.\n    return view;\n  }\n} // Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\n\n\nfunction prepareDescriptor(highlightDescriptor, data, conversionApi) {\n  // If passed descriptor is a creator function, call it. If not, just use passed value.\n  var descriptor = typeof highlightDescriptor == 'function' ? highlightDescriptor(data, conversionApi) : highlightDescriptor;\n\n  if (!descriptor) {\n    return null;\n  } // Apply default descriptor priority.\n\n\n  if (!descriptor.priority) {\n    descriptor.priority = 10;\n  } // Default descriptor id is marker name.\n\n\n  if (!descriptor.id) {\n    descriptor.id = data.markerName;\n  }\n\n  return descriptor;\n} // Creates a function that checks a single differ diff item whether it should trigger reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\n\n\nfunction createChangeReducerCallback(model) {\n  return function (node, change) {\n    if (!node.is('element', model.name)) {\n      return false;\n    }\n\n    if (change.type == 'attribute') {\n      if (model.attributes.includes(change.attributeKey)) {\n        return true;\n      }\n    } else {\n      /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. */\n      if (model.children) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n} // Creates a `reduceChanges` event handler for reconversion.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {Function}\n\n\nfunction createChangeReducer(model) {\n  var shouldReplace = createChangeReducerCallback(model);\n  return function (evt, data) {\n    var reducedChanges = [];\n\n    if (!data.reconvertedElements) {\n      data.reconvertedElements = new Set();\n    }\n\n    var _iterator15 = _createForOfIteratorHelper(data.changes),\n        _step15;\n\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var change = _step15.value;\n        // For attribute use node affected by the change.\n        // For insert or remove use parent element because we need to check if it's added/removed child.\n        var node = change.position ? change.position.parent : change.range.start.nodeAfter;\n\n        if (!node || !shouldReplace(node, change)) {\n          reducedChanges.push(change);\n          continue;\n        } // If it's already marked for reconversion, so skip this change, otherwise add the diff items.\n\n\n        if (!data.reconvertedElements.has(node)) {\n          data.reconvertedElements.add(node);\n\n          var position = ModelPosition._createBefore(node);\n\n          reducedChanges.push({\n            type: 'remove',\n            name: node.name,\n            position: position,\n            length: 1\n          }, {\n            type: 'reinsert',\n            name: node.name,\n            position: position,\n            length: 1\n          });\n        }\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n\n    data.changes = reducedChanges;\n  };\n} // Creates a function that checks if an element and its watched attributes can be consumed and consumes them.\n//\n// @param {Object} model A normalized `config.model` converter configuration.\n// @param {String} model.name The name of element.\n// @param {Array.<String>} model.attributes The list of attribute names that should trigger reconversion.\n// @param {Boolean} [model.children] Whether the child list change should trigger reconversion.\n// @returns {module:engine/conversion/downcasthelpers~ConsumerFunction}\n\n\nfunction createConsumer(model) {\n  return function (node, consumable) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var events = ['insert']; // Collect all set attributes that are triggering conversion.\n\n    var _iterator16 = _createForOfIteratorHelper(model.attributes),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var attributeName = _step16.value;\n\n        if (node.hasAttribute(attributeName)) {\n          events.push(\"attribute:\".concat(attributeName));\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n\n    if (!events.every(function (event) {\n      return consumable.test(node, event);\n    })) {\n      return false;\n    }\n\n    if (!options.preflight) {\n      events.forEach(function (event) {\n        return consumable.consume(node, event);\n      });\n    }\n\n    return true;\n  };\n} // Creates a function that create view slots.\n//\n// @param {module:engine/model/element~Element} element\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {Function} Exposed by writer as createSlot().\n\n\nfunction createSlotFactory(element, slotsMap, conversionApi) {\n  return function (writer) {\n    var modeOrFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'children';\n    var slot = writer.createContainerElement('$slot');\n    var children = null;\n\n    if (modeOrFilter === 'children') {\n      children = Array.from(element.getChildren());\n    } else if (typeof modeOrFilter == 'function') {\n      children = Array.from(element.getChildren()).filter(function (element) {\n        return modeOrFilter(element);\n      });\n    } else {\n      /**\n       * Unknown slot mode was provided to `writer.createSlot()` in downcast converter.\n       *\n       * @error conversion-slot-mode-unknown\n       */\n      throw new CKEditorError('conversion-slot-mode-unknown', conversionApi.dispatcher, {\n        modeOrFilter: modeOrFilter\n      });\n    }\n\n    slotsMap.set(slot, children);\n    return slot;\n  };\n} // Checks if all children are covered by slots and there is no child that landed in multiple slots.\n//\n// @param {module:engine/model/element~Element}\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction validateSlotsChildren(element, slotsMap, conversionApi) {\n  var childrenInSlots = Array.from(slotsMap.values()).flat();\n  var uniqueChildrenInSlots = new Set(childrenInSlots);\n\n  if (uniqueChildrenInSlots.size != childrenInSlots.length) {\n    /**\n     * Filters provided to `writer.createSlot()` overlap (at least two filters accept the same child element).\n     *\n     * @error conversion-slot-filter-overlap\n     * @param {module:engine/model/element~Element} element The element of which children would not be properly\n     * allocated to multiple slots.\n     */\n    throw new CKEditorError('conversion-slot-filter-overlap', conversionApi.dispatcher, {\n      element: element\n    });\n  }\n\n  if (uniqueChildrenInSlots.size != element.childCount) {\n    /**\n     * Filters provided to `writer.createSlot()` are incomplete and exclude at least one children element (one of\n     * the children elements would not be assigned to any of the slots).\n     *\n     * @error conversion-slot-filter-incomplete\n     * @param {module:engine/model/element~Element} element The element of which children would not be properly\n     * allocated to multiple slots.\n     */\n    throw new CKEditorError('conversion-slot-filter-incomplete', conversionApi.dispatcher, {\n      element: element\n    });\n  }\n} // Fill slots with appropriate view elements.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Map.<module:engine/view/element~Element,Array.<module:engine/model/node~Node>>} slotsMap\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n\n\nfunction fillSlots(viewElement, slotsMap, conversionApi, options) {\n  // Set temporary position mapping to redirect child view elements into a proper slots.\n  conversionApi.mapper.on('modelToViewPosition', toViewPositionMapping, {\n    priority: 'highest'\n  });\n  var currentSlot = null;\n  var currentSlotNodes = null; // Fill slots with nested view nodes.\n\n  var _iterator17 = _createForOfIteratorHelper(slotsMap),\n      _step17;\n\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var _step17$value = _slicedToArray(_step17.value, 2);\n\n      currentSlot = _step17$value[0];\n      currentSlotNodes = _step17$value[1];\n      reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);\n      conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));\n      conversionApi.writer.remove(currentSlot);\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n\n  conversionApi.mapper.off('modelToViewPosition', toViewPositionMapping);\n\n  function toViewPositionMapping(evt, data) {\n    var element = data.modelPosition.nodeAfter; // Find the proper offset within the slot.\n\n    var index = currentSlotNodes.indexOf(element);\n\n    if (index < 0) {\n      return;\n    }\n\n    data.viewPosition = data.mapper.findPositionIn(currentSlot, index);\n  }\n} // Inserts view representation of `nodes` into the `viewElement` either by bringing back just removed view nodes\n// or by triggering conversion for them.\n//\n// @param {module:engine/view/element~Element} viewElement\n// @param {Iterable.<module:engine/model/element~Element>} modelNodes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n\n\nfunction reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {\n  // Fill with nested view nodes.\n  var _iterator18 = _createForOfIteratorHelper(modelNodes),\n      _step18;\n\n  try {\n    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n      var modelChildNode = _step18.value;\n\n      // Try reinserting the view node for the specified model node...\n      if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {\n        // ...or else convert the model element to the view.\n        conversionApi.convertItem(modelChildNode);\n      }\n    }\n  } catch (err) {\n    _iterator18.e(err);\n  } finally {\n    _iterator18.f();\n  }\n} // Checks if the view for the given model element could be reused and reinserts it to the view.\n//\n// @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewRoot\n// @param {module:engine/model/element~Element} modelElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} options\n// @param {Boolean} [options.reconversion]\n// @returns {Boolean} `false` if view element can't be reused.\n\n\nfunction reinsertNode(viewRoot, modelElement, conversionApi, options) {\n  var writer = conversionApi.writer,\n      mapper = conversionApi.mapper; // Don't reinsert if this is not a reconversion...\n\n  if (!options.reconversion) {\n    return false;\n  }\n\n  var viewChildNode = mapper.toViewElement(modelElement); // ...or there is no view to reinsert or it was already inserted to the view structure...\n\n  if (!viewChildNode || viewChildNode.root == viewRoot) {\n    return false;\n  } // ...or it was strictly marked as not to be reused.\n\n\n  if (!conversionApi.canReuseView(viewChildNode)) {\n    return false;\n  } // Otherwise reinsert the view node.\n\n\n  writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(ModelPosition._createBefore(modelElement)));\n  return true;\n} // The default consumer for insert events.\n// @param {module:engine/model/item~Item} item Model item.\n// @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The model consumable.\n// @param {Object} [options]\n// @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n// @returns {Boolean}\n\n\nfunction defaultConsumer(item, consumable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      preflight = _ref.preflight;\n\n  if (preflight) {\n    return consumable.test(item, 'insert');\n  } else {\n    return consumable.consume(item, 'insert');\n  }\n}\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n\n/**\n * A filtering function used to choose model child nodes to be downcasted into the specific view\n * {@link module:engine/view/downcastwriter~DowncastWriter#createSlot \"slot\"} while executing the\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`} converter.\n *\n * @callback module:engine/conversion/downcasthelpers~SlotFilter\n *\n * @param {module:engine/model/node~Node} node A model node.\n * @returns {Boolean} Whether the provided model node should be downcasted into this slot.\n *\n * @see module:engine/view/downcastwriter~DowncastWriter#createSlot\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n\n/**\n * A view element creator function that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi\n * downcast conversion API} as parameters and returns a view container element.\n *\n * @callback module:engine/conversion/downcasthelpers~ElementCreatorFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} event).\n * @param {module:engine/model/item~Item} data.item Inserted item.\n * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n * @returns {module:engine/view/element~Element} The view element.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement\n * @see module:engine/conversion/downcasthelpers~insertElement\n */\n\n/**\n * A function that takes the model element and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast\n * conversion API} as parameters and returns a view container element with slots for model child nodes to be converted into.\n *\n * @callback module:engine/conversion/downcasthelpers~StructureCreatorFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} event).\n * @param {module:engine/model/item~Item} data.item Inserted item.\n * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n * @returns {module:engine/view/element~Element} The view structure with slots for model child nodes.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */\n\n/**\n * A view element creator function that takes the model attribute value and\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view\n * attribute element.\n *\n * @callback module:engine/conversion/downcasthelpers~AttributeElementCreatorFunction\n * @param {*} attributeValue The model attribute value to be converted to the view attribute element.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} event).\n * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n * or converted selection.\n * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n * @param {String} data.attributeKey Attribute key.\n * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n * @param {*} data.attributeNewValue New attribute value.\n * @returns {module:engine/view/attributeelement~AttributeElement} The view attribute element.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement\n * @see module:engine/conversion/downcasthelpers~wrap\n */\n\n/**\n * A function that takes the model attribute value and\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}\n * as parameters.\n *\n * @callback module:engine/conversion/downcasthelpers~AttributeCreatorFunction\n * @param {*} attributeValue The model attribute value to be converted to the view attribute element.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion interface.\n * @param {Object} data Additional information about the change (same as for\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} event).\n * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n * or converted selection.\n * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n * @param {String} data.attributeKey Attribute key.\n * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n * @param {*} data.attributeNewValue New attribute value.\n * @returns {Object|null} A `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n *\n * @see module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute\n */\n\n/**\n * A function that is expected to consume all the consumables that were used by the element creator.\n *\n * @callback module:engine/conversion/downcasthelpers~ConsumerFunction\n * @param {module:engine/model/element~Element} element The model element to be converted to the view structure.\n * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The `ModelConsumable` same as in\n * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#consumable `DowncastConversionApi.consumable`}.\n * @param {Object} [options]\n * @param {Boolean} [options.preflight=false] Whether should consume or just check if can be consumed.\n * @returns {Boolean} `true` if all consumable values were available and were consumed, `false` otherwise.\n *\n * @see module:engine/conversion/downcasthelpers~insertStructure\n */","map":null,"metadata":{},"sourceType":"module"}