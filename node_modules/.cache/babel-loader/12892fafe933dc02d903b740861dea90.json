{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, DOMParser, Text */\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewUIElement from './uielement';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport Matcher from './matcher';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, NBSP_FILLER, MARKED_NBSP_FILLER, getDataWithoutFiller, isInlineFiller, startsWithFiller } from './filler';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport { logWarning } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isComment from '@ckeditor/ckeditor5-utils/src/dom/iscomment';\nvar BR_FILLER_REF = BR_FILLER(document); // eslint-disable-line new-cap\n\nvar NBSP_FILLER_REF = NBSP_FILLER(document); // eslint-disable-line new-cap\n\nvar MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(document); // eslint-disable-line new-cap\n\nvar UNSAFE_ATTRIBUTE_NAME_PREFIX = 'data-ck-unsafe-attribute-';\nvar UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = 'data-ck-unsafe-element';\nvar UNSAFE_ELEMENTS = ['script', 'style'];\n/**\n * `DomConverter` is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements bindings} between these nodes.\n *\n * An instance of the DOM converter is available under\n * {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * The DOM converter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep the\n * state of a tree nor keeps the synchronization between the tree view and the DOM tree (use {@link module:engine/view/document~Document}).\n *\n * The DOM converter keeps DOM elements to view element bindings, so when the converter gets destroyed, the bindings are lost.\n * Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\n\nvar DomConverter = /*#__PURE__*/function () {\n  /**\n   * Creates a DOM converter.\n   *\n   * @param {module:engine/view/document~Document} document The view document instance.\n   * @param {Object} options An object with configuration options.\n   * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode] The type of the block filler to use.\n   * Default value depends on the options.renderingMode:\n   *  'nbsp' when options.renderingMode == 'data',\n   *  'br' when options.renderingMode == 'editing'.\n   * @param {'data'|'editing'} [options.renderingMode='editing'] Whether to leave the View-to-DOM conversion result unchanged\n   * or improve editing experience by filtering out interactive data.\n   */\n  function DomConverter(document) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, DomConverter);\n\n    /**\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.\n     *\n     * @member {'data'|'editing'} module:engine/view/domconverter~DomConverter#renderingMode\n     */\n\n    this.renderingMode = options.renderingMode || 'editing';\n    /**\n     * The mode of a block filler used by the DOM converter.\n     *\n     * @member {'br'|'nbsp'|'markedNbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n     */\n\n    this.blockFillerMode = options.blockFillerMode || (this.renderingMode === 'editing' ? 'br' : 'nbsp');\n    /**\n     * Elements which are considered pre-formatted elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n     */\n\n    this.preElements = ['pre'];\n    /**\n     * Elements which are considered block elements (and hence should be filled with a\n     * {@link #isBlockFiller block filler}).\n     *\n     * Whether an element is considered a block element also affects handling of trailing whitespaces.\n     *\n     * You can extend this array if you introduce support for block elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n     */\n\n    this.blockElements = ['address', 'article', 'aside', 'blockquote', 'caption', 'center', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'legend', 'li', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'];\n    /**\n     * A list of elements that exist inline (in text) but their inner structure cannot be edited because\n     * of the way they are rendered by the browser. They are mostly HTML form elements but there are other\n     * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.\n     *\n     * Whether an element is considered an inline object has an impact on white space rendering (trimming)\n     * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.\n     *\n     * You can extend this array if you introduce support for inline object elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#inlineObjectElements\n     */\n\n    this.inlineObjectElements = ['object', 'iframe', 'input', 'button', 'textarea', 'select', 'option', 'video', 'embed', 'audio', 'img', 'canvas'];\n    /**\n     * The DOM-to-view mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n     */\n\n    this._domToViewMapping = new WeakMap();\n    /**\n     * The view-to-DOM mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n     */\n\n    this._viewToDomMapping = new WeakMap();\n    /**\n     * Holds the mapping between fake selection containers and corresponding view selections.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n     */\n\n    this._fakeSelectionMapping = new WeakMap();\n    /**\n     * Matcher for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM nodes to view elements.\n     *\n     * @private\n     * @type {module:engine/view/matcher~Matcher}\n     */\n\n    this._rawContentElementMatcher = new Matcher();\n    /**\n     * A set of encountered raw content DOM nodes. It is used for preventing left trimming of the following text node.\n     *\n     * @private\n     * @type {WeakSet.<Node>}\n     */\n\n    this._encounteredRawContentDomNodes = new WeakSet();\n  }\n  /**\n   * Binds a given DOM element that represents fake selection to a **position** of a\n   * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n   * Document selection copy is stored and can be retrieved by the\n   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n   *\n   * @param {HTMLElement} domElement\n   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n   */\n\n\n  _createClass(DomConverter, [{\n    key: \"bindFakeSelection\",\n    value: function bindFakeSelection(domElement, viewDocumentSelection) {\n      this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n    }\n    /**\n     * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given\n     * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.\n     *\n     * @param {HTMLElement} domElement\n     * @returns {module:engine/view/selection~Selection|undefined}\n     */\n\n  }, {\n    key: \"fakeSelectionToView\",\n    value: function fakeSelectionToView(domElement) {\n      return this._fakeSelectionMapping.get(domElement);\n    }\n    /**\n     * Binds DOM and view elements, so it will be possible to get corresponding elements using\n     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n     *\n     * @param {HTMLElement} domElement The DOM element to bind.\n     * @param {module:engine/view/element~Element} viewElement The view element to bind.\n     */\n\n  }, {\n    key: \"bindElements\",\n    value: function bindElements(domElement, viewElement) {\n      this._domToViewMapping.set(domElement, viewElement);\n\n      this._viewToDomMapping.set(viewElement, domElement);\n    }\n    /**\n     * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of\n     * the DOM element will be unbound too.\n     *\n     * @param {HTMLElement} domElement The DOM element to unbind.\n     */\n\n  }, {\n    key: \"unbindDomElement\",\n    value: function unbindDomElement(domElement) {\n      var viewElement = this._domToViewMapping.get(domElement);\n\n      if (viewElement) {\n        this._domToViewMapping.delete(domElement);\n\n        this._viewToDomMapping.delete(viewElement);\n\n        var _iterator = _createForOfIteratorHelper(domElement.childNodes),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var child = _step.value;\n            this.unbindDomElement(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\n     * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using\n     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n     *\n     * @param {DocumentFragment} domFragment The DOM document fragment to bind.\n     * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment The view document fragment to bind.\n     */\n\n  }, {\n    key: \"bindDocumentFragments\",\n    value: function bindDocumentFragments(domFragment, viewFragment) {\n      this._domToViewMapping.set(domFragment, viewFragment);\n\n      this._viewToDomMapping.set(viewFragment, domFragment);\n    }\n    /**\n     * Decides whether a given pair of attribute key and value should be passed further down the pipeline.\n     *\n     * @param {String} attributeKey\n     * @param {String} attributeValue\n     * @param {String} elementName Element name in lower case.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"shouldRenderAttribute\",\n    value: function shouldRenderAttribute(attributeKey, attributeValue, elementName) {\n      if (this.renderingMode === 'data') {\n        return true;\n      }\n\n      attributeKey = attributeKey.toLowerCase();\n\n      if (attributeKey.startsWith('on')) {\n        return false;\n      }\n\n      if (attributeKey === 'srcdoc' && attributeValue.match(/\\bon\\S+\\s*=|javascript:|<\\s*\\/*script/i)) {\n        return false;\n      }\n\n      if (elementName === 'img' && (attributeKey === 'src' || attributeKey === 'srcset')) {\n        return true;\n      }\n\n      if (elementName === 'source' && attributeKey === 'srcset') {\n        return true;\n      }\n\n      if (attributeValue.match(/^\\s*(javascript:|data:(image\\/svg|text\\/x?html))/i)) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.\n     *\n     * @param {Element} domElement DOM element that should have `html` set as its content.\n     * @param {String} html Textual representation of the HTML that will be set on `domElement`.\n     */\n\n  }, {\n    key: \"setContentOf\",\n    value: function setContentOf(domElement, html) {\n      // For data pipeline we pass the HTML as-is.\n      if (this.renderingMode === 'data') {\n        domElement.innerHTML = html;\n        return;\n      }\n\n      var document = new DOMParser().parseFromString(html, 'text/html');\n      var fragment = document.createDocumentFragment();\n      var bodyChildNodes = document.body.childNodes;\n\n      while (bodyChildNodes.length > 0) {\n        fragment.appendChild(bodyChildNodes[0]);\n      }\n\n      var treeWalker = document.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);\n      var nodes = [];\n      var currentNode; // eslint-disable-next-line no-cond-assign\n\n      while (currentNode = treeWalker.nextNode()) {\n        nodes.push(currentNode);\n      }\n\n      for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {\n        var _currentNode = _nodes[_i];\n\n        // Go through nodes to remove those that are prohibited in editing pipeline.\n        var _iterator2 = _createForOfIteratorHelper(_currentNode.getAttributeNames()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var attributeName = _step2.value;\n            this.setDomElementAttribute(_currentNode, attributeName, _currentNode.getAttribute(attributeName));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var elementName = _currentNode.tagName.toLowerCase(); // There are certain nodes, that should be renamed to <span> in editing pipeline.\n\n\n        if (this._shouldRenameElement(elementName)) {\n          _logUnsafeElement(elementName);\n\n          _currentNode.replaceWith(this._createReplacementDomElement(elementName, _currentNode));\n        }\n      } // Empty the target element.\n\n\n      while (domElement.firstChild) {\n        domElement.firstChild.remove();\n      }\n\n      domElement.append(fragment);\n    }\n    /**\n     * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will\n     * be created. For bound elements and document fragments the method will return corresponding items.\n     *\n     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n     * View node or document fragment to transform.\n     * @param {Document} domDocument Document which will be used to create DOM nodes.\n     * @param {Object} [options] Conversion options.\n     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n     * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n     */\n\n  }, {\n    key: \"viewToDom\",\n    value: function viewToDom(viewNode, domDocument) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (viewNode.is('$text')) {\n        var textData = this._processDataFromViewText(viewNode);\n\n        return domDocument.createTextNode(textData);\n      } else {\n        if (this.mapViewToDom(viewNode)) {\n          return this.mapViewToDom(viewNode);\n        }\n\n        var domElement;\n\n        if (viewNode.is('documentFragment')) {\n          // Create DOM document fragment.\n          domElement = domDocument.createDocumentFragment();\n\n          if (options.bind) {\n            this.bindDocumentFragments(domElement, viewNode);\n          }\n        } else if (viewNode.is('uiElement')) {\n          if (viewNode.name === '$comment') {\n            domElement = domDocument.createComment(viewNode.getCustomProperty('$rawContent'));\n          } else {\n            // UIElement has its own render() method (see #799).\n            domElement = viewNode.render(domDocument, this);\n          }\n\n          if (options.bind) {\n            this.bindElements(domElement, viewNode);\n          }\n\n          return domElement;\n        } else {\n          // Create DOM element.\n          if (this._shouldRenameElement(viewNode.name)) {\n            _logUnsafeElement(viewNode.name);\n\n            domElement = this._createReplacementDomElement(viewNode.name);\n          } else if (viewNode.hasAttribute('xmlns')) {\n            domElement = domDocument.createElementNS(viewNode.getAttribute('xmlns'), viewNode.name);\n          } else {\n            domElement = domDocument.createElement(viewNode.name);\n          } // RawElement take care of their children in RawElement#render() method which can be customized\n          // (see https://github.com/ckeditor/ckeditor5/issues/4469).\n\n\n          if (viewNode.is('rawElement')) {\n            viewNode.render(domElement, this);\n          }\n\n          if (options.bind) {\n            this.bindElements(domElement, viewNode);\n          } // Copy element's attributes.\n\n\n          var _iterator3 = _createForOfIteratorHelper(viewNode.getAttributeKeys()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var key = _step3.value;\n              this.setDomElementAttribute(domElement, key, viewNode.getAttribute(key), viewNode);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n\n        if (options.withChildren !== false) {\n          var _iterator4 = _createForOfIteratorHelper(this.viewChildrenToDom(viewNode, domDocument, options)),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var child = _step4.value;\n              domElement.appendChild(child);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        return domElement;\n      }\n    }\n    /**\n     * Sets the attribute on a DOM element.\n     *\n     * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.\n     *\n     * @param {HTMLElement} domElement The DOM element the attribute should be set on.\n     * @param {String} key The name of the attribute.\n     * @param {String} value The value of the attribute.\n     * @param {module:engine/view/element~Element} [relatedViewElement] The view element related to the `domElement` (if there is any).\n     * It helps decide whether the attribute set is unsafe. For instance, view elements created via the\n     * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.\n     */\n\n  }, {\n    key: \"setDomElementAttribute\",\n    value: function setDomElementAttribute(domElement, key, value) {\n      var relatedViewElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);\n\n      if (!shouldRenderAttribute) {\n        logWarning('domconverter-unsafe-attribute-detected', {\n          domElement: domElement,\n          key: key,\n          value: value\n        });\n      } // The old value was safe but the new value is unsafe.\n\n\n      if (domElement.hasAttribute(key) && !shouldRenderAttribute) {\n        domElement.removeAttribute(key);\n      } // The old value was unsafe (but prefixed) but the new value will be safe (will be unprefixed).\n      else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {\n        domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);\n      } // If the attribute should not be rendered, rename it (instead of removing) to give developers some idea of what\n      // is going on (https://github.com/ckeditor/ckeditor5/issues/10801).\n\n\n      domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);\n    }\n    /**\n     * Removes an attribute from a DOM element.\n     *\n     * **Note**: To set the attribute, use {@link #setDomElementAttribute}.\n     *\n     * @param {HTMLElement} domElement The DOM element the attribute should be removed from.\n     * @param {String} key The name of the attribute.\n     */\n\n  }, {\n    key: \"removeDomElementAttribute\",\n    value: function removeDomElementAttribute(domElement, key) {\n      // See #_createReplacementDomElement() to learn what this is.\n      if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {\n        return;\n      }\n\n      domElement.removeAttribute(key); // See setDomElementAttribute() to learn what this is.\n\n      domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);\n    }\n    /**\n     * Converts children of the view element to DOM using the\n     * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n     * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n     * @param {Document} domDocument Document which will be used to create DOM nodes.\n     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n     * @returns {Iterable.<Node>} DOM nodes.\n     */\n\n  }, {\n    key: \"viewChildrenToDom\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function viewChildrenToDom(viewElement, domDocument) {\n      var options,\n          fillerPositionOffset,\n          offset,\n          _iterator5,\n          _step5,\n          childView,\n          transparentRendering,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function viewChildrenToDom$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n              offset = 0;\n              _iterator5 = _createForOfIteratorHelper(viewElement.getChildren());\n              _context.prev = 4;\n\n              _iterator5.s();\n\n            case 6:\n              if ((_step5 = _iterator5.n()).done) {\n                _context.next = 22;\n                break;\n              }\n\n              childView = _step5.value;\n\n              if (!(fillerPositionOffset === offset)) {\n                _context.next = 11;\n                break;\n              }\n\n              _context.next = 11;\n              return this._getBlockFiller(domDocument);\n\n            case 11:\n              transparentRendering = childView.is('element') && childView.getCustomProperty('dataPipeline:transparentRendering');\n\n              if (!(transparentRendering && this.renderingMode == 'data')) {\n                _context.next = 16;\n                break;\n              }\n\n              return _context.delegateYield(this.viewChildrenToDom(childView, domDocument, options), \"t0\", 14);\n\n            case 14:\n              _context.next = 19;\n              break;\n\n            case 16:\n              if (transparentRendering) {\n                /**\n                 * The `dataPipeline:transparentRendering` flag is supported only in the data pipeline.\n                 *\n                 * @error domconverter-transparent-rendering-unsupported-in-editing-pipeline\n                 */\n                logWarning('domconverter-transparent-rendering-unsupported-in-editing-pipeline', {\n                  viewElement: childView\n                });\n              }\n\n              _context.next = 19;\n              return this.viewToDom(childView, domDocument, options);\n\n            case 19:\n              offset++;\n\n            case 20:\n              _context.next = 6;\n              break;\n\n            case 22:\n              _context.next = 27;\n              break;\n\n            case 24:\n              _context.prev = 24;\n              _context.t1 = _context[\"catch\"](4);\n\n              _iterator5.e(_context.t1);\n\n            case 27:\n              _context.prev = 27;\n\n              _iterator5.f();\n\n              return _context.finish(27);\n\n            case 30:\n              if (!(fillerPositionOffset === offset)) {\n                _context.next = 33;\n                break;\n              }\n\n              _context.next = 33;\n              return this._getBlockFiller(domDocument);\n\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, viewChildrenToDom, this, [[4, 24, 27, 30]]);\n    })\n    /**\n     * Converts view {@link module:engine/view/range~Range} to DOM range.\n     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n     *\n     * @param {module:engine/view/range~Range} viewRange View range.\n     * @returns {Range} DOM range.\n     */\n\n  }, {\n    key: \"viewRangeToDom\",\n    value: function viewRangeToDom(viewRange) {\n      var domStart = this.viewPositionToDom(viewRange.start);\n      var domEnd = this.viewPositionToDom(viewRange.end);\n      var domRange = document.createRange();\n      domRange.setStart(domStart.parent, domStart.offset);\n      domRange.setEnd(domEnd.parent, domEnd.offset);\n      return domRange;\n    }\n    /**\n     * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n     *\n     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n     * If the converted position is directly before inline filler it is moved inside the filler.\n     *\n     * @param {module:engine/view/position~Position} viewPosition View position.\n     * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n     * @returns {Node} position.parent DOM position parent.\n     * @returns {Number} position.offset DOM position offset.\n     */\n\n  }, {\n    key: \"viewPositionToDom\",\n    value: function viewPositionToDom(viewPosition) {\n      var viewParent = viewPosition.parent;\n\n      if (viewParent.is('$text')) {\n        var domParent = this.findCorrespondingDomText(viewParent);\n\n        if (!domParent) {\n          // Position is in a view text node that has not been rendered to DOM yet.\n          return null;\n        }\n\n        var offset = viewPosition.offset;\n\n        if (startsWithFiller(domParent)) {\n          offset += INLINE_FILLER_LENGTH;\n        }\n\n        return {\n          parent: domParent,\n          offset: offset\n        };\n      } else {\n        // viewParent is instance of ViewElement.\n        var _domParent, domBefore, domAfter;\n\n        if (viewPosition.offset === 0) {\n          _domParent = this.mapViewToDom(viewParent);\n\n          if (!_domParent) {\n            // Position is in a view element that has not been rendered to DOM yet.\n            return null;\n          }\n\n          domAfter = _domParent.childNodes[0];\n        } else {\n          var nodeBefore = viewPosition.nodeBefore;\n          domBefore = nodeBefore.is('$text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(viewPosition.nodeBefore);\n\n          if (!domBefore) {\n            // Position is after a view element that has not been rendered to DOM yet.\n            return null;\n          }\n\n          _domParent = domBefore.parentNode;\n          domAfter = domBefore.nextSibling;\n        } // If there is an inline filler at position return position inside the filler. We should never return\n        // the position before the inline filler.\n\n\n        if (isText(domAfter) && startsWithFiller(domAfter)) {\n          return {\n            parent: domAfter,\n            offset: INLINE_FILLER_LENGTH\n          };\n        }\n\n        var _offset = domBefore ? indexOf(domBefore) + 1 : 0;\n\n        return {\n          parent: _domParent,\n          offset: _offset\n        };\n      }\n    }\n    /**\n     * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n     * be created. For bound elements and document fragments function will return corresponding items. For\n     * {@link module:engine/view/filler fillers} `null` will be returned.\n     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n     *\n     * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n     * @param {Object} [options] Conversion options.\n     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n     * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converted to lower case.\n     * @param {Boolean} [options.skipComments=false] If `false`, comment nodes will be converted to `$comment`\n     * {@link module:engine/view/uielement~UIElement view UI elements}.\n     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n     * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n     */\n\n  }, {\n    key: \"domToView\",\n    value: function domToView(domNode) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.isBlockFiller(domNode)) {\n        return null;\n      } // When node is inside a UIElement or a RawElement return that parent as it's view representation.\n\n\n      var hostElement = this.getHostViewElement(domNode);\n\n      if (hostElement) {\n        return hostElement;\n      }\n\n      if (isComment(domNode) && options.skipComments) {\n        return null;\n      }\n\n      if (isText(domNode)) {\n        if (isInlineFiller(domNode)) {\n          return null;\n        } else {\n          var textData = this._processDataFromDomText(domNode);\n\n          return textData === '' ? null : new ViewText(this.document, textData);\n        }\n      } else {\n        if (this.mapDomToView(domNode)) {\n          return this.mapDomToView(domNode);\n        }\n\n        var viewElement;\n\n        if (this.isDocumentFragment(domNode)) {\n          // Create view document fragment.\n          viewElement = new ViewDocumentFragment(this.document);\n\n          if (options.bind) {\n            this.bindDocumentFragments(domNode, viewElement);\n          }\n        } else {\n          // Create view element.\n          viewElement = this._createViewElement(domNode, options);\n\n          if (options.bind) {\n            this.bindElements(domNode, viewElement);\n          } // Copy element's attributes.\n\n\n          var attrs = domNode.attributes;\n\n          if (attrs) {\n            for (var i = attrs.length - 1; i >= 0; i--) {\n              viewElement._setAttribute(attrs[i].name, attrs[i].value);\n            }\n          } // Treat this element's content as a raw data if it was registered as such.\n          // Comment node is also treated as an element with raw data.\n\n\n          if (this._isViewElementWithRawContent(viewElement, options) || isComment(domNode)) {\n            var rawContent = isComment(domNode) ? domNode.data : domNode.innerHTML;\n\n            viewElement._setCustomProperty('$rawContent', rawContent); // Store a DOM node to prevent left trimming of the following text node.\n\n\n            this._encounteredRawContentDomNodes.add(domNode);\n\n            return viewElement;\n          }\n        }\n\n        if (options.withChildren !== false) {\n          var _iterator6 = _createForOfIteratorHelper(this.domChildrenToView(domNode, options)),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var child = _step6.value;\n\n              viewElement._appendChild(child);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n\n        return viewElement;\n      }\n    }\n    /**\n     * Converts children of the DOM element to view nodes using\n     * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n     * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n     *\n     * @param {HTMLElement} domElement Parent DOM element.\n     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n     */\n\n  }, {\n    key: \"domChildrenToView\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function domChildrenToView(domElement) {\n      var options,\n          i,\n          domChild,\n          viewChild,\n          _args2 = arguments;\n      return _regeneratorRuntime.wrap(function domChildrenToView$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              i = 0;\n\n            case 2:\n              if (!(i < domElement.childNodes.length)) {\n                _context2.next = 11;\n                break;\n              }\n\n              domChild = domElement.childNodes[i];\n              viewChild = this.domToView(domChild, options);\n\n              if (!(viewChild !== null)) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 8;\n              return viewChild;\n\n            case 8:\n              i++;\n              _context2.next = 2;\n              break;\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, domChildrenToView, this);\n    })\n    /**\n     * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n     * Ranges which cannot be converted will be omitted.\n     *\n     * @param {Selection} domSelection DOM selection.\n     * @returns {module:engine/view/selection~Selection} View selection.\n     */\n\n  }, {\n    key: \"domSelectionToView\",\n    value: function domSelectionToView(domSelection) {\n      // DOM selection might be placed in fake selection container.\n      // If container contains fake selection - return corresponding view selection.\n      if (domSelection.rangeCount === 1) {\n        var container = domSelection.getRangeAt(0).startContainer; // The DOM selection might be moved to the text node inside the fake selection container.\n\n        if (isText(container)) {\n          container = container.parentNode;\n        }\n\n        var viewSelection = this.fakeSelectionToView(container);\n\n        if (viewSelection) {\n          return viewSelection;\n        }\n      }\n\n      var isBackward = this.isDomSelectionBackward(domSelection);\n      var viewRanges = [];\n\n      for (var i = 0; i < domSelection.rangeCount; i++) {\n        // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n        var domRange = domSelection.getRangeAt(i);\n        var viewRange = this.domRangeToView(domRange);\n\n        if (viewRange) {\n          viewRanges.push(viewRange);\n        }\n      }\n\n      return new ViewSelection(viewRanges, {\n        backward: isBackward\n      });\n    }\n    /**\n     * Converts DOM Range to view {@link module:engine/view/range~Range}.\n     * If the start or end position can not be converted `null` is returned.\n     *\n     * @param {Range} domRange DOM range.\n     * @returns {module:engine/view/range~Range|null} View range.\n     */\n\n  }, {\n    key: \"domRangeToView\",\n    value: function domRangeToView(domRange) {\n      var viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n      var viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n\n      if (viewStart && viewEnd) {\n        return new ViewRange(viewStart, viewEnd);\n      }\n\n      return null;\n    }\n    /**\n     * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n     *\n     * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n     * position of the filler will be converted and returned.\n     *\n     * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n     * that position will be converted to view position before that UIElement.\n     *\n     * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n     *\n     * @param {Node} domParent DOM position parent.\n     * @param {Number} [domOffset=0] DOM position offset. You can skip it when converting the inline filler node.\n     * @returns {module:engine/view/position~Position} viewPosition View position.\n     */\n\n  }, {\n    key: \"domPositionToView\",\n    value: function domPositionToView(domParent) {\n      var domOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this.isBlockFiller(domParent)) {\n        return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n      } // If position is somewhere inside UIElement or a RawElement - return position before that element.\n\n\n      var viewElement = this.mapDomToView(domParent);\n\n      if (viewElement && (viewElement.is('uiElement') || viewElement.is('rawElement'))) {\n        return ViewPosition._createBefore(viewElement);\n      }\n\n      if (isText(domParent)) {\n        if (isInlineFiller(domParent)) {\n          return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n        }\n\n        var viewParent = this.findCorrespondingViewText(domParent);\n        var offset = domOffset;\n\n        if (!viewParent) {\n          return null;\n        }\n\n        if (startsWithFiller(domParent)) {\n          offset -= INLINE_FILLER_LENGTH;\n          offset = offset < 0 ? 0 : offset;\n        }\n\n        return new ViewPosition(viewParent, offset);\n      } // domParent instanceof HTMLElement.\n      else {\n        if (domOffset === 0) {\n          var _viewParent = this.mapDomToView(domParent);\n\n          if (_viewParent) {\n            return new ViewPosition(_viewParent, 0);\n          }\n        } else {\n          var domBefore = domParent.childNodes[domOffset - 1];\n          var viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore); // TODO #663\n\n          if (viewBefore && viewBefore.parent) {\n            return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n          }\n        }\n\n        return null;\n      }\n    }\n    /**\n     * Returns corresponding view {@link module:engine/view/element~Element Element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n     * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * to the given DOM - `undefined` is returned.\n     *\n     * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or\n     * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n     *\n     * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n     * Corresponding view element, document fragment or `undefined` if no element was bound.\n     */\n\n  }, {\n    key: \"mapDomToView\",\n    value: function mapDomToView(domElementOrDocumentFragment) {\n      var hostElement = this.getHostViewElement(domElementOrDocumentFragment);\n      return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);\n    }\n    /**\n     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n     * corresponding text node is returned based on the sibling or parent.\n     *\n     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n     * to find the corresponding text node.\n     *\n     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * element, it is used to find the corresponding text node.\n     *\n     * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or\n     * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.\n     *\n     * Otherwise `null` is returned.\n     *\n     * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n     *\n     * @param {Text} domText DOM text node.\n     * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n     * corresponding node.\n     */\n\n  }, {\n    key: \"findCorrespondingViewText\",\n    value: function findCorrespondingViewText(domText) {\n      if (isInlineFiller(domText)) {\n        return null;\n      } // If DOM text was rendered by a UIElement or a RawElement - return this parent element.\n\n\n      var hostElement = this.getHostViewElement(domText);\n\n      if (hostElement) {\n        return hostElement;\n      }\n\n      var previousSibling = domText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n      if (previousSibling) {\n        if (!this.isElement(previousSibling)) {\n          // The previous is text or comment.\n          return null;\n        }\n\n        var viewElement = this.mapDomToView(previousSibling);\n\n        if (viewElement) {\n          var nextSibling = viewElement.nextSibling; // It might be filler which has no corresponding view node.\n\n          if (nextSibling instanceof ViewText) {\n            return viewElement.nextSibling;\n          } else {\n            return null;\n          }\n        }\n      } // Try to use parent to find the corresponding text node.\n      else {\n        var _viewElement = this.mapDomToView(domText.parentNode);\n\n        if (_viewElement) {\n          var firstChild = _viewElement.getChild(0); // It might be filler which has no corresponding view node.\n\n\n          if (firstChild instanceof ViewText) {\n            return firstChild;\n          } else {\n            return null;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n     * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n     * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n     * use {@link #findCorrespondingDomText}.\n     *\n     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n     * View element or document fragment.\n     * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n     */\n\n  }, {\n    key: \"mapViewToDom\",\n    value: function mapViewToDom(documentFragmentOrElement) {\n      return this._viewToDomMapping.get(documentFragmentOrElement);\n    }\n    /**\n     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n     * corresponding text node is returned based on the sibling or parent.\n     *\n     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n     * to find the corresponding text node.\n     *\n     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n     * element, it is used to find the corresponding text node.\n     *\n     * Otherwise `null` is returned.\n     *\n     * @param {module:engine/view/text~Text} viewText View text node.\n     * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n     */\n\n  }, {\n    key: \"findCorrespondingDomText\",\n    value: function findCorrespondingDomText(viewText) {\n      var previousSibling = viewText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n      if (previousSibling && this.mapViewToDom(previousSibling)) {\n        return this.mapViewToDom(previousSibling).nextSibling;\n      } // If this is a first node, try to use parent to find the corresponding text node.\n\n\n      if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n        return this.mapViewToDom(viewText.parent).childNodes[0];\n      }\n\n      return null;\n    }\n    /**\n     * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n     *\n     * @param {module:engine/view/editableelement~EditableElement} viewEditable\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus(viewEditable) {\n      var domEditable = this.mapViewToDom(viewEditable);\n\n      if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n        // Save the scrollX and scrollY positions before the focus.\n        var _global$window = global.window,\n            scrollX = _global$window.scrollX,\n            scrollY = _global$window.scrollY;\n        var scrollPositions = []; // Save all scrollLeft and scrollTop values starting from domEditable up to\n        // document#documentElement.\n\n        forEachDomNodeAncestor(domEditable, function (node) {\n          var scrollLeft = node.scrollLeft,\n              scrollTop = node.scrollTop;\n          scrollPositions.push([scrollLeft, scrollTop]);\n        });\n        domEditable.focus(); // Restore scrollLeft and scrollTop values starting from domEditable up to\n        // document#documentElement.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/951\n        // https://github.com/ckeditor/ckeditor5-engine/issues/957\n\n        forEachDomNodeAncestor(domEditable, function (node) {\n          var _scrollPositions$shif = scrollPositions.shift(),\n              _scrollPositions$shif2 = _slicedToArray(_scrollPositions$shif, 2),\n              scrollLeft = _scrollPositions$shif2[0],\n              scrollTop = _scrollPositions$shif2[1];\n\n          node.scrollLeft = scrollLeft;\n          node.scrollTop = scrollTop;\n        }); // Restore the scrollX and scrollY positions after the focus.\n        // https://github.com/ckeditor/ckeditor5-engine/issues/951\n\n        global.window.scrollTo(scrollX, scrollY);\n      }\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isElement\",\n    value: function isElement(node) {\n      return node && node.nodeType == Node.ELEMENT_NODE;\n    }\n    /**\n     * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n     *\n     * @param {Node} node Node to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isDocumentFragment\",\n    value: function isDocumentFragment(node) {\n      return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n    }\n    /**\n     * Checks if the node is an instance of the block filler for this DOM converter.\n     *\n     *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n     *\n     *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n     *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n     *\n     * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n     *\n     * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n     *\n     * @param {Node} domNode DOM node to check.\n     * @returns {Boolean} True if a node is considered a block filler for given mode.\n     */\n\n  }, {\n    key: \"isBlockFiller\",\n    value: function isBlockFiller(domNode) {\n      if (this.blockFillerMode == 'br') {\n        return domNode.isEqualNode(BR_FILLER_REF);\n      } // Special case for <p><br></p> in which <br> should be treated as filler even when we are not in the 'br' mode. See ckeditor5#5564.\n\n\n      if (domNode.tagName === 'BR' && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {\n        return true;\n      } // If not in 'br' mode, try recognizing both marked and regular nbsp block fillers.\n\n\n      return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);\n    }\n    /**\n     * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n     *\n     * @param {Selection} DOM Selection instance to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isDomSelectionBackward\",\n    value: function isDomSelectionBackward(selection) {\n      if (selection.isCollapsed) {\n        return false;\n      } // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n      // we will use the fact that range will collapse if it's end is before it's start.\n\n\n      var range = document.createRange();\n      range.setStart(selection.anchorNode, selection.anchorOffset);\n      range.setEnd(selection.focusNode, selection.focusOffset);\n      var backward = range.collapsed;\n      range.detach();\n      return backward;\n    }\n    /**\n     * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}\n     * that hosts the provided DOM node. Returns `null` if there is no such parent.\n     *\n     * @param {Node} domNode\n     * @returns {module:engine/view/uielement~UIElement|module:engine/view/rawelement~RawElement|null}\n     */\n\n  }, {\n    key: \"getHostViewElement\",\n    value: function getHostViewElement(domNode) {\n      var ancestors = getAncestors(domNode); // Remove domNode from the list.\n\n      ancestors.pop();\n\n      while (ancestors.length) {\n        var _domNode = ancestors.pop();\n\n        var viewNode = this._domToViewMapping.get(_domNode);\n\n        if (viewNode && (viewNode.is('uiElement') || viewNode.is('rawElement'))) {\n          return viewNode;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Checks if the given selection's boundaries are at correct places.\n     *\n     * The following places are considered as incorrect for selection boundaries:\n     *\n     * * before or in the middle of an inline filler sequence,\n     * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},\n     * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.\n     *\n     * @param {Selection} domSelection The DOM selection object to be checked.\n     * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n     */\n\n  }, {\n    key: \"isDomSelectionCorrect\",\n    value: function isDomSelectionCorrect(domSelection) {\n      return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n    }\n    /**\n     * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data\n     * and not processed during the conversion from DOM nodes to view elements.\n     *\n     * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and\n     * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.\n     *\n     * The raw data can be later accessed by a\n     * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `\"$rawContent\"`.\n     *\n     * @param {module:engine/view/matcher~MatcherPattern} pattern Pattern matching a view element whose content should\n     * be treated as raw data.\n     */\n\n  }, {\n    key: \"registerRawContentMatcher\",\n    value: function registerRawContentMatcher(pattern) {\n      this._rawContentElementMatcher.add(pattern);\n    }\n    /**\n     * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.\n     *\n     * @private\n     * @params {Document} domDocument\n     * @returns {Node} filler\n     */\n\n  }, {\n    key: \"_getBlockFiller\",\n    value: function _getBlockFiller(domDocument) {\n      switch (this.blockFillerMode) {\n        case 'nbsp':\n          return NBSP_FILLER(domDocument);\n        // eslint-disable-line new-cap\n\n        case 'markedNbsp':\n          return MARKED_NBSP_FILLER(domDocument);\n        // eslint-disable-line new-cap\n\n        case 'br':\n          return BR_FILLER(domDocument);\n        // eslint-disable-line new-cap\n      }\n    }\n    /**\n     * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n     *\n     * @private\n     * @param {Element} domParent Position parent.\n     * @param {Number} offset Position offset.\n     * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n     */\n\n  }, {\n    key: \"_isDomSelectionPositionCorrect\",\n    value: function _isDomSelectionPositionCorrect(domParent, offset) {\n      // If selection is before or in the middle of inline filler string, it is incorrect.\n      if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n        // Selection in a text node, at wrong position (before or in the middle of filler).\n        return false;\n      }\n\n      if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n        // Selection in an element node, before filler text node.\n        return false;\n      }\n\n      var viewParent = this.mapDomToView(domParent); // The position is incorrect when anchored inside a UIElement or a RawElement.\n      // Note: In case of UIElement and RawElement, mapDomToView() returns a parent element for any DOM child\n      // so there's no need to perform any additional checks.\n\n      if (viewParent && (viewParent.is('uiElement') || viewParent.is('rawElement'))) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n     * it is correctly displayed in the DOM.\n     *\n     * Following changes are done:\n     *\n     * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n     * element or if a previous text node ends with a space character,\n     * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n     * starts with a space or if it is the last text node in its container,\n     * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n     *\n     * Content of {@link #preElements} is not processed.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node View text node to process.\n     * @returns {String} Processed text data.\n     */\n\n  }, {\n    key: \"_processDataFromViewText\",\n    value: function _processDataFromViewText(node) {\n      var _this = this;\n\n      var data = node.data; // If any of node ancestors has a name which is in `preElements` array, then currently processed\n      // view text node is (will be) in preformatted element. We should not change whitespaces then.\n\n      if (node.getAncestors().some(function (parent) {\n        return _this.preElements.includes(parent.name);\n      })) {\n        return data;\n      } // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n      // (container element boundary).\n\n\n      if (data.charAt(0) == ' ') {\n        var prevNode = this._getTouchingInlineViewNode(node, false);\n\n        var prevEndsWithSpace = prevNode && prevNode.is('$textProxy') && this._nodeEndsWithSpace(prevNode);\n\n        if (prevEndsWithSpace || !prevNode) {\n          data = \"\\xA0\" + data.substr(1);\n        }\n      } // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n      // next node (container element boundary).\n      //\n      // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n      //\n      // Foo <span>&nbsp;bar</span>  <-- bad.\n      // Foo&nbsp;<span> bar</span>  <-- good.\n      //\n      // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\n\n      if (data.charAt(data.length - 1) == ' ') {\n        var nextNode = this._getTouchingInlineViewNode(node, true);\n\n        var nextStartsWithSpace = nextNode && nextNode.is('$textProxy') && nextNode.data.charAt(0) == ' ';\n\n        if (data.charAt(data.length - 2) == ' ' || !nextNode || nextStartsWithSpace) {\n          data = data.substr(0, data.length - 1) + \"\\xA0\";\n        }\n      } // 3. Create space+nbsp pairs.\n\n\n      return data.replace(/ {2}/g, \" \\xA0\");\n    }\n    /**\n     * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node Node to check.\n     * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n     */\n\n  }, {\n    key: \"_nodeEndsWithSpace\",\n    value: function _nodeEndsWithSpace(node) {\n      var _this2 = this;\n\n      if (node.getAncestors().some(function (parent) {\n        return _this2.preElements.includes(parent.name);\n      })) {\n        return false;\n      }\n\n      var data = this._processDataFromViewText(node);\n\n      return data.charAt(data.length - 1) == ' ';\n    }\n    /**\n     * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n     *\n     * Following changes are done:\n     *\n     * * multiple whitespaces are replaced to a single space,\n     * * space at the beginning of a text node is removed if it is the first text node in its container\n     * element or if the previous text node ends with a space character,\n     * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n     * starts with a space or if it is the last text node in its container\n     * * nbsps are converted to spaces.\n     *\n     * @param {Node} node DOM text node to process.\n     * @returns {String} Processed data.\n     * @private\n     */\n\n  }, {\n    key: \"_processDataFromDomText\",\n    value: function _processDataFromDomText(node) {\n      var data = node.data;\n\n      if (_hasDomParentOfType(node, this.preElements)) {\n        return getDataWithoutFiller(node);\n      } // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set \n      // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n      // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n      // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\n\n      data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n\n      var prevNode = this._getTouchingInlineDomNode(node, false);\n\n      var nextNode = this._getTouchingInlineDomNode(node, true);\n\n      var shouldLeftTrim = this._checkShouldLeftTrimDomText(node, prevNode);\n\n      var shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode); // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n      // of this text node. Such space character is treated as a whitespace.\n\n\n      if (shouldLeftTrim) {\n        data = data.replace(/^ /, '');\n      } // If the next text node does not exist remove space character from the end of this text node.\n\n\n      if (shouldRightTrim) {\n        data = data.replace(/ $/, '');\n      } // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n      // This means that the text node starts/end with normal space instead of non-breaking space.\n      // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n      // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\n\n      data = getDataWithoutFiller(new Text(data)); // At this point we should have removed all whitespaces from DOM text data.\n      //\n      // Now, We will reverse the process that happens in `_processDataFromViewText`.\n      //\n      // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n      // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n      // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\n      data = data.replace(/ \\u00A0/g, '  ');\n      var isNextNodeInlineObjectElement = nextNode && this.isElement(nextNode) && nextNode.tagName != 'BR';\n      var isNextNodeStartingWithSpace = nextNode && isText(nextNode) && nextNode.data.charAt(0) == ' '; // Then, let's change the last nbsp to a space.\n\n      if (/( |\\u00A0)\\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {\n        data = data.replace(/\\u00A0$/, ' ');\n      } // Then, change &nbsp; character that is at the beginning of the text node to space character.\n      // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\n\n      if (shouldLeftTrim || prevNode && this.isElement(prevNode) && prevNode.tagName != 'BR') {\n        data = data.replace(/^\\u00A0/, ' ');\n      } // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n      // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\n\n      return data;\n    }\n    /**\n     * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n     * be trimmed from the left side.\n     *\n     * @private\n     * @param {Node} node\n     * @param {Node} prevNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n     */\n\n  }, {\n    key: \"_checkShouldLeftTrimDomText\",\n    value: function _checkShouldLeftTrimDomText(node, prevNode) {\n      if (!prevNode) {\n        return true;\n      }\n\n      if (this.isElement(prevNode)) {\n        return prevNode.tagName === 'BR';\n      } // Shouldn't left trim if previous node is a node that was encountered as a raw content node.\n\n\n      if (this._encounteredRawContentDomNodes.has(node.previousSibling)) {\n        return false;\n      }\n\n      return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n    }\n    /**\n     * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n     * be trimmed from the right side.\n     *\n     * @private\n     * @param {Node} node\n     * @param {Node} nextNode Either DOM text or `<br>` or one of `#inlineObjectElements`.\n     */\n\n  }, {\n    key: \"_checkShouldRightTrimDomText\",\n    value: function _checkShouldRightTrimDomText(node, nextNode) {\n      if (nextNode) {\n        return false;\n      }\n\n      return !startsWithFiller(node);\n    }\n    /**\n     * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n     * that is contained in the same container element. If there is no such sibling, `null` is returned.\n     *\n     * @private\n     * @param {module:engine/view/text~Text} node Reference node.\n     * @param {Boolean} getNext\n     * @returns {module:engine/view/text~Text|module:engine/view/element~Element|null} Touching text node, an inline object\n     * or `null` if there is no next or previous touching text node.\n     */\n\n  }, {\n    key: \"_getTouchingInlineViewNode\",\n    value: function _getTouchingInlineViewNode(node, getNext) {\n      var treeWalker = new ViewTreeWalker({\n        startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n        direction: getNext ? 'forward' : 'backward'\n      });\n\n      var _iterator7 = _createForOfIteratorHelper(treeWalker),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var value = _step7.value;\n\n          // Found an inline object (for example an image).\n          if (value.item.is('element') && this.inlineObjectElements.includes(value.item.name)) {\n            return value.item;\n          } // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n          // text node in its container element.\n          else if (value.item.is('containerElement')) {\n            return null;\n          } // <br> found  it works like a block boundary, so do not scan further.\n          else if (value.item.is('element', 'br')) {\n            return null;\n          } // Found a text node in the same container element.\n          else if (value.item.is('$textProxy')) {\n            return value.item;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return null;\n    }\n    /**\n     * Helper function. For the given text node, it finds the closest touching node which is either\n     * a text, `<br>` or an {@link #inlineObjectElements inline object}.\n     *\n     * If no such node is found, `null` is returned.\n     *\n     * For instance, in the following DOM structure:\n     *\n     *\t\t<p>foo<b>bar</b><br>bom</p>\n     *\n     * * `foo` doesn't have its previous touching inline node (`null` is returned),\n     * * `foo`'s next touching inline node is `bar`\n     * * `bar`'s next touching inline node is `<br>`\n     *\n     * This method returns text nodes and `<br>` elements because these types of nodes affect how\n     * spaces in the given text node need to be converted.\n     *\n     * @private\n     * @param {Text} node\n     * @param {Boolean} getNext\n     * @returns {Text|Element|null}\n     */\n\n  }, {\n    key: \"_getTouchingInlineDomNode\",\n    value: function _getTouchingInlineDomNode(node, getNext) {\n      if (!node.parentNode) {\n        return null;\n      }\n\n      var stepInto = getNext ? 'firstChild' : 'lastChild';\n      var stepOver = getNext ? 'nextSibling' : 'previousSibling';\n      var skipChildren = true;\n\n      do {\n        if (!skipChildren && node[stepInto]) {\n          node = node[stepInto];\n        } else if (node[stepOver]) {\n          node = node[stepOver];\n          skipChildren = false;\n        } else {\n          node = node.parentNode;\n          skipChildren = true;\n        }\n\n        if (!node || this._isBlockElement(node)) {\n          return null;\n        }\n      } while (!(isText(node) || node.tagName == 'BR' || this._isInlineObjectElement(node)));\n\n      return node;\n    }\n    /**\n     * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.\n     *\n     * @private\n     * @param {Node} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isBlockElement\",\n    value: function _isBlockElement(node) {\n      return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());\n    }\n    /**\n     * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.\n     *\n     * @private\n     * @param {Node} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isInlineObjectElement\",\n    value: function _isInlineObjectElement(node) {\n      return this.isElement(node) && this.inlineObjectElements.includes(node.tagName.toLowerCase());\n    }\n    /**\n     * Creates view element basing on the node type.\n     *\n     * @private\n     * @param {Node} node DOM node to check.\n     * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Element}\n     */\n\n  }, {\n    key: \"_createViewElement\",\n    value: function _createViewElement(node, options) {\n      if (isComment(node)) {\n        return new ViewUIElement(this.document, '$comment');\n      }\n\n      var viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();\n      return new ViewElement(this.document, viewName);\n    }\n    /**\n     * Checks if view element's content should be treated as a raw data.\n     *\n     * @private\n     * @param {Element} viewElement View element to check.\n     * @param {Object} options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isViewElementWithRawContent\",\n    value: function _isViewElementWithRawContent(viewElement, options) {\n      return options.withChildren !== false && this._rawContentElementMatcher.match(viewElement);\n    }\n    /**\n     * Checks whether a given element name should be renamed in a current rendering mode.\n     *\n     * @private\n     * @param {String} elementName The name of view element.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_shouldRenameElement\",\n    value: function _shouldRenameElement(elementName) {\n      var name = elementName.toLowerCase();\n      return this.renderingMode === 'editing' && UNSAFE_ELEMENTS.includes(name);\n    }\n    /**\n     * Return a <span> element with a special attribute holding the name of the original element.\n     * Optionally, copy all the attributes of the original element if that element is provided.\n     *\n     * @private\n     * @param {String} elementName The name of view element.\n     * @param {Element} [originalDomElement] The original DOM element to copy attributes and content from.\n     * @returns {Element}\n     */\n\n  }, {\n    key: \"_createReplacementDomElement\",\n    value: function _createReplacementDomElement(elementName) {\n      var originalDomElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var newDomElement = document.createElement('span'); // Mark the span replacing a script as hidden.\n\n      newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);\n\n      if (originalDomElement) {\n        while (originalDomElement.firstChild) {\n          newDomElement.appendChild(originalDomElement.firstChild);\n        }\n\n        var _iterator8 = _createForOfIteratorHelper(originalDomElement.getAttributeNames()),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var attributeName = _step8.value;\n            newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n\n      return newDomElement;\n    }\n  }]);\n\n  return DomConverter;\n}(); // Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\n\n\nexport { DomConverter as default };\n\nfunction _hasDomParentOfType(node, types) {\n  var parents = getAncestors(node);\n  return parents.some(function (parent) {\n    return parent.tagName && types.includes(parent.tagName.toLowerCase());\n  });\n} // A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\n\n\nfunction forEachDomNodeAncestor(node, callback) {\n  while (node && node != global.document) {\n    callback(node);\n    node = node.parentNode;\n  }\n} // Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\n\n\nfunction isNbspBlockFiller(domNode, blockElements) {\n  var isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);\n  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;\n} // Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @param {Array.<String>} blockElements\n// @returns {Boolean}\n\n\nfunction hasBlockParent(domNode, blockElements) {\n  var parent = domNode.parentNode;\n  return parent && parent.tagName && blockElements.includes(parent.tagName.toLowerCase());\n} // Log to console the information about element that was replaced.\n// Check UNSAFE_ELEMENTS for all recognized unsafe elements.\n//\n// @param {String} elementName The name of the view element\n\n\nfunction _logUnsafeElement(elementName) {\n  if (elementName === 'script') {\n    logWarning('domconverter-unsafe-script-element-detected');\n  }\n\n  if (elementName === 'style') {\n    logWarning('domconverter-unsafe-style-element-detected');\n  }\n}\n/**\n * Enum representing the type of the block filler.\n *\n * Possible values:\n *\n * * `br` &ndash; For the `<br data-cke-filler=\"true\">` block filler used in the editing view.\n * * `nbsp` &ndash; For the `&nbsp;` block fillers used in the data.\n * * `markedNbsp` &ndash; For the `&nbsp;` block fillers wrapped in `<span>` elements: `<span data-cke-filler=\"true\">&nbsp;</span>`\n * used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */\n\n/**\n * While rendering the editor content, the {@link module:engine/view/domconverter~DomConverter} detected a `<script>` element that may\n * disrupt the editing experience. To avoid this, the `<script>` element was replaced with `<span data-ck-unsafe-element=\"script\"></span>`.\n *\n * @error domconverter-unsafe-script-element-detected\n */\n\n/**\n * While rendering the editor content, the {@link module:engine/view/domconverter~DomConverter} detected a `<style>` element that may affect\n * the editing experience. To avoid this, the `<style>` element was replaced with `<span data-ck-unsafe-element=\"style\"></span>`.\n *\n * @error domconverter-unsafe-style-element-detected\n */\n\n/**\n * The {@link module:engine/view/domconverter~DomConverter} detected an interactive attribute in the\n * {@glink framework/guides/architecture/editing-engine#editing-pipeline editing pipeline}. For the best\n * editing experience, the attribute was renamed to `data-ck-unsafe-attribute-[original attribute name]`.\n *\n * If you are the author of the plugin that generated this attribute and you want it to be preserved\n * in the editing pipeline, you can configure this when creating the element\n * using {@link module:engine/view/downcastwriter~DowncastWriter} during the\n * {@glink framework/guides/architecture/editing-engine#conversion modelview conversion}. Methods such as\n * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement},\n * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement}, or\n * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement}\n * accept an option that will disable filtering of specific attributes:\n *\n *\t\tconst paragraph = writer.createContainerElement( 'p',\n *\t\t\t{\n *\t\t\t\tclass: 'clickable-paragraph',\n *\t\t\t\tonclick: 'alert( \"Paragraph clicked!\" )'\n *\t\t\t},\n *\t\t\t{\n *\t\t\t\t// Make sure the \"onclick\" attribute will pass through.\n *\t\t\t\trenderUnsafeAttributes: [ 'onclick' ]\n *\t\t\t}\n *\t\t);\n *\n * @error domconverter-unsafe-attribute-detected\n * @param {HTMLElement} domElement The DOM element the attribute was set on.\n * @param {String} key The original name of the attribute\n * @param {String} value The value of the original attribute\n */","map":null,"metadata":{},"sourceType":"module"}