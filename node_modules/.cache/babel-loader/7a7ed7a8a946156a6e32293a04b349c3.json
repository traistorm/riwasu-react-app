{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/selectionobserver\n */\n\n/* global setInterval, clearInterval */\nimport Observer from './observer';\nimport MutationObserver from './mutationobserver';\nimport { debounce } from 'lodash-es';\n/**\n * Selection observer class observes selection changes in the document. If a selection changes on the document this\n * observer checks if there are any mutations and if the DOM selection is different from the\n * {@link module:engine/view/document~Document#selection view selection}. The selection observer fires\n * {@link module:engine/view/document~Document#event:selectionChange} event only if a selection change was the only change in the document\n * and the DOM selection is different then the view selection.\n *\n * This observer also manages the {@link module:engine/view/document~Document#isSelecting} property of the view document.\n *\n * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.\n *\n * @see module:engine/view/observer/mutationobserver~MutationObserver\n * @extends module:engine/view/observer/observer~Observer\n */\n\nvar SelectionObserver = /*#__PURE__*/function (_Observer) {\n  _inherits(SelectionObserver, _Observer);\n\n  function SelectionObserver(view) {\n    var _this;\n\n    _classCallCheck(this, SelectionObserver);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SelectionObserver).call(this, view));\n    /**\n     * Instance of the mutation observer. Selection observer calls\n     * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled\n     * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.\n     *\n     * @readonly\n     * @member {module:engine/view/observer/mutationobserver~MutationObserver}\n     * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver\n     */\n\n    _this.mutationObserver = view.getObserver(MutationObserver);\n    /**\n     * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare\n     * new selection with it.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     * module:engine/view/observer/selectionobserver~SelectionObserver#selection\n     */\n\n    _this.selection = _this.document.selection;\n    /* eslint-disable max-len */\n\n    /**\n     * Reference to the {@link module:engine/view/view~View#domConverter}.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter\n     */\n\n    /* eslint-enable max-len */\n\n    _this.domConverter = view.domConverter;\n    /**\n     * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same\n     * document.\n     *\n     * @private\n     * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents\n     */\n\n    _this._documents = new WeakSet();\n    /**\n     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n     *\n     * @private\n     * @param {Object} data Selection change data.\n     * @method #_fireSelectionChangeDoneDebounced\n     */\n\n    _this._fireSelectionChangeDoneDebounced = debounce(function (data) {\n      return _this.document.fire('selectionChangeDone', data);\n    }, 200);\n    /**\n     * When called, starts clearing the {@link #_loopbackCounter} counter in time intervals. When the number of selection\n     * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about\n     * possible infinite selection loop.\n     *\n     * @private\n     * @member {Number} #_clearInfiniteLoopInterval\n     */\n\n    _this._clearInfiniteLoopInterval = setInterval(function () {\n      return _this._clearInfiniteLoop();\n    }, 1000);\n    /**\n     * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact\n     * correctly (for whatever reason). It is a safeguard (paranoid check), that returns document to the normal state\n     * after a certain period of time (debounced, postponed by each selectionchange event).\n     *\n     * @private\n     * @method #_documentIsSelectingInactivityTimeoutDebounced\n     */\n\n    _this._documentIsSelectingInactivityTimeoutDebounced = debounce(function () {\n      return _this.document.isSelecting = false;\n    }, 5000);\n    /**\n     * Private property to check if the code does not enter infinite loop.\n     *\n     * @private\n     * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter\n     */\n\n    _this._loopbackCounter = 0;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(SelectionObserver, [{\n    key: \"observe\",\n    value: function observe(domElement) {\n      var _this2 = this;\n\n      var domDocument = domElement.ownerDocument;\n\n      var startDocumentIsSelecting = function startDocumentIsSelecting() {\n        _this2.document.isSelecting = true; // Let's activate the safety timeout each time the document enters the \"is selecting\" state.\n\n        _this2._documentIsSelectingInactivityTimeoutDebounced();\n      };\n\n      var endDocumentIsSelecting = function endDocumentIsSelecting() {\n        _this2.document.isSelecting = false; // The safety timeout can be canceled when the document leaves the \"is selecting\" state.\n\n        _this2._documentIsSelectingInactivityTimeoutDebounced.cancel();\n      }; // The document has the \"is selecting\" state while the user keeps making (extending) the selection\n      // (e.g. by holding the mouse button and moving the cursor). The state resets when they either released\n      // the mouse button or interrupted the process by pressing or releasing any key.\n\n\n      this.listenTo(domElement, 'selectstart', startDocumentIsSelecting, {\n        priority: 'highest'\n      });\n      this.listenTo(domElement, 'keydown', endDocumentIsSelecting, {\n        priority: 'highest'\n      });\n      this.listenTo(domElement, 'keyup', endDocumentIsSelecting, {\n        priority: 'highest'\n      }); // Add document-wide listeners only once. This method could be called for multiple editing roots.\n\n      if (this._documents.has(domDocument)) {\n        return;\n      }\n\n      this.listenTo(domDocument, 'mouseup', endDocumentIsSelecting, {\n        priority: 'highest'\n      });\n      this.listenTo(domDocument, 'selectionchange', function (evt, domEvent) {\n        _this2._handleSelectionChange(domEvent, domDocument); // Defer the safety timeout when the selection changes (e.g. the user keeps extending the selection\n        // using their mouse).\n\n\n        _this2._documentIsSelectingInactivityTimeoutDebounced();\n      });\n\n      this._documents.add(domDocument);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(SelectionObserver.prototype), \"destroy\", this).call(this);\n\n      clearInterval(this._clearInfiniteLoopInterval);\n\n      this._fireSelectionChangeDoneDebounced.cancel();\n\n      this._documentIsSelectingInactivityTimeoutDebounced.cancel();\n    }\n    /**\n     * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if\n     * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change\n     * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.\n     *\n     * @private\n     * @param {Event} domEvent DOM event.\n     * @param {Document} domDocument DOM document.\n     */\n\n  }, {\n    key: \"_handleSelectionChange\",\n    value: function _handleSelectionChange(domEvent, domDocument) {\n      if (!this.isEnabled) {\n        return;\n      }\n\n      var domSelection = domDocument.defaultView.getSelection();\n\n      if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {\n        return;\n      } // Ensure the mutation event will be before selection event on all browsers.\n\n\n      this.mutationObserver.flush(); // If there were mutations then the view will be re-rendered by the mutation observer and the selection\n      // will be updated, so the selections will equal and the event will not be fired, as expected.\n\n      var newViewSelection = this.domConverter.domSelectionToView(domSelection); // Do not convert selection change if the new view selection has no ranges in it.\n      //\n      // It means that the DOM selection is in some way incorrect. Ranges that were in the DOM selection could not be\n      // converted to the view. This happens when the DOM selection was moved outside of the editable element.\n\n      if (newViewSelection.rangeCount == 0) {\n        this.view.hasDomSelection = false;\n        return;\n      }\n\n      this.view.hasDomSelection = true;\n\n      if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {\n        return;\n      } // Ensure we are not in the infinite loop (#400).\n      // This counter is reset each second. 60 selection changes in 1 second is enough high number\n      // to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).\n\n\n      if (++this._loopbackCounter > 60) {\n        // Selection change observer detected an infinite rendering loop.\n        // Most probably you try to put the selection in the position which is not allowed\n        // by the browser and browser fixes it automatically what causes `selectionchange` event on\n        // which a loopback through a model tries to re-render the wrong selection and again.\n        //\n        // @if CK_DEBUG // console.warn( 'Selection change observer detected an infinite rendering loop.' );\n        return;\n      }\n\n      if (this.selection.isSimilar(newViewSelection)) {\n        // If selection was equal and we are at this point of algorithm, it means that it was incorrect.\n        // Just re-render it, no need to fire any events, etc.\n        this.view.forceRender();\n      } else {\n        var data = {\n          oldSelection: this.selection,\n          newSelection: newViewSelection,\n          domSelection: domSelection\n        }; // Prepare data for new selection and fire appropriate events.\n\n        this.document.fire('selectionChange', data); // Call `#_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n        // This function is debounced what means that `selectionChangeDone` event will be fired only when\n        // defined int the function time will elapse since the last time the function was called.\n        // So `selectionChangeDone` will be fired when selection will stop changing.\n\n        this._fireSelectionChangeDoneDebounced(data);\n      }\n    }\n    /**\n     * Clears `SelectionObserver` internal properties connected with preventing infinite loop.\n     *\n     * @protected\n     */\n\n  }, {\n    key: \"_clearInfiniteLoop\",\n    value: function _clearInfiniteLoop() {\n      this._loopbackCounter = 0;\n    }\n  }]);\n\n  return SelectionObserver;\n}(Observer);\n/**\n * Fired when a selection has changed. This event is fired only when the selection change was the only change that happened\n * in the document, and the old selection is different then the new selection.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChange\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n\n/**\n * Fired when selection stops changing.\n *\n * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n *\n * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the\n * {@link module:engine/view/view~View} this event is available by default.\n *\n * @see module:engine/view/observer/selectionobserver~SelectionObserver\n * @event module:engine/view/document~Document#event:selectionChangeDone\n * @param {Object} data\n * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is\n * {@link module:engine/view/document~Document#selection}.\n * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.\n * @param {Selection} data.domSelection Native DOM selection.\n */\n\n\nexport { SelectionObserver as default };","map":null,"metadata":{},"sourceType":"module"}