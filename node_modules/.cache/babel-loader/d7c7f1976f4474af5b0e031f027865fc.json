{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants'; // gap of tree node\n\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n */\n\nexport function flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      node.parent = parent;\n      flattenData.push(_extends({}, node));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node = findNode(_item3.children);\n\n        if (_node) {\n          return _node;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n/**\n * focus next item with keyboard\n * @param param\n */\n\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n/**\n * hooks for flatten tree structure\n * @param param0\n */\n\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n\n  var _useRef = useRef({}),\n      _useRef$current = _useRef.current,\n      flattenNodes = _useRef$current === void 0 ? {} : _useRef$current;\n\n  var flattenTreeData = useCallback(function (treeData, ref, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node, index) {\n      var _extends2;\n\n      var refKey = ref + \"-\" + index;\n      node.refKey = refKey;\n      flattenNodes[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], refKey, node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues, flattenNodes]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues; // Reset values to false\n\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    flattenTreeData(data, '0');\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n/**\n * A hook that handles tree search filter options\n * @param props\n */\n\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n/**\n * Focus to active tree node.\n * @param param0\n */\n\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  } // layer start from 1\n\n\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}","map":null,"metadata":{},"sourceType":"module"}