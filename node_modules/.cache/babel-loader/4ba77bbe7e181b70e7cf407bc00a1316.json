{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/imageuploadediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { Notification } from 'ckeditor5/src/ui';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { FileRepository } from 'ckeditor5/src/upload';\nimport { env } from 'ckeditor5/src/utils';\nimport ImageUtils from '../imageutils';\nimport UploadImageCommand from './uploadimagecommand';\nimport { fetchLocalImage, isLocalImage } from '../../src/imageupload/utils';\nimport { createImageTypeRegExp } from './utils';\n/**\n * The editing part of the image upload feature. It registers the `'uploadImage'` command\n * and the `imageUpload` command as an aliased name.\n *\n * When an image is uploaded, it fires the {@link ~ImageUploadEditing#event:uploadComplete `uploadComplete`} event\n * that allows adding custom attributes to the {@link module:engine/model/element~Element image element}.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageUploadEditing = /*#__PURE__*/function (_Plugin) {\n  _inherits(ImageUploadEditing, _Plugin);\n\n  _createClass(ImageUploadEditing, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [FileRepository, Notification, ClipboardPipeline, ImageUtils];\n    }\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageUploadEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function ImageUploadEditing(editor) {\n    var _this;\n\n    _classCallCheck(this, ImageUploadEditing);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageUploadEditing).call(this, editor));\n    editor.config.define('image', {\n      upload: {\n        types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff']\n      }\n    });\n    /**\n     * An internal mapping of {@link module:upload/filerepository~FileLoader#id file loader UIDs} and\n     * model elements during the upload.\n     *\n     * Model element of the uploaded image can change, for instance, when {@link module:image/image/imagetypecommand~ImageTypeCommand}\n     * is executed as a result of adding caption or changing image style. As a result, the upload logic must keep track of the model\n     * element (reference) and resolve the upload for the correct model element (instead of the one that landed in the `$graveyard`\n     * after image type changed).\n     *\n     * @private\n     * @readonly\n     * @member {Map.<String,module:engine/model/element~Element>}\n     */\n\n    _this._uploadImageElements = new Map();\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ImageUploadEditing, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var editor = this.editor;\n      var doc = editor.model.document;\n      var conversion = editor.conversion;\n      var fileRepository = editor.plugins.get(FileRepository);\n      var imageUtils = editor.plugins.get('ImageUtils');\n      var imageTypes = createImageTypeRegExp(editor.config.get('image.upload.types'));\n      var uploadImageCommand = new UploadImageCommand(editor); // Register `uploadImage` command and add `imageUpload` command as an alias for backward compatibility.\n\n      editor.commands.add('uploadImage', uploadImageCommand);\n      editor.commands.add('imageUpload', uploadImageCommand); // Register upcast converter for uploadId.\n\n      conversion.for('upcast').attributeToAttribute({\n        view: {\n          name: 'img',\n          key: 'uploadId'\n        },\n        model: 'uploadId'\n      }); // Handle pasted images.\n      // For every image file, a new file loader is created and a placeholder image is\n      // inserted into the content. Then, those images are uploaded once they appear in the model\n      // (see Document#change listener below).\n\n      this.listenTo(editor.editing.view.document, 'clipboardInput', function (evt, data) {\n        // Skip if non empty HTML data is included.\n        // https://github.com/ckeditor/ckeditor5-upload/issues/68\n        if (isHtmlIncluded(data.dataTransfer)) {\n          return;\n        }\n\n        var images = Array.from(data.dataTransfer.files).filter(function (file) {\n          // See https://github.com/ckeditor/ckeditor5-image/pull/254.\n          if (!file) {\n            return false;\n          }\n\n          return imageTypes.test(file.type);\n        });\n\n        if (!images.length) {\n          return;\n        }\n\n        evt.stop();\n        editor.model.change(function (writer) {\n          // Set selection to paste target.\n          if (data.targetRanges) {\n            writer.setSelection(data.targetRanges.map(function (viewRange) {\n              return editor.editing.mapper.toModelRange(viewRange);\n            }));\n          } // Upload images after the selection has changed in order to ensure the command's state is refreshed.\n\n\n          editor.model.enqueueChange(function () {\n            editor.execute('uploadImage', {\n              file: images\n            });\n          });\n        });\n      }); // Handle HTML pasted with images with base64 or blob sources.\n      // For every image file, a new file loader is created and a placeholder image is\n      // inserted into the content. Then, those images are uploaded once they appear in the model\n      // (see Document#change listener below).\n\n      this.listenTo(editor.plugins.get('ClipboardPipeline'), 'inputTransformation', function (evt, data) {\n        var fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).filter(function (value) {\n          return isLocalImage(imageUtils, value.item) && !value.item.getAttribute('uploadProcessed');\n        }).map(function (value) {\n          return {\n            promise: fetchLocalImage(value.item),\n            imageElement: value.item\n          };\n        });\n\n        if (!fetchableImages.length) {\n          return;\n        }\n\n        var writer = new UpcastWriter(editor.editing.view.document);\n\n        var _iterator = _createForOfIteratorHelper(fetchableImages),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var fetchableImage = _step.value;\n            // Set attribute marking that the image was processed already.\n            writer.setAttribute('uploadProcessed', true, fetchableImage.imageElement);\n            var loader = fileRepository.createLoader(fetchableImage.promise);\n\n            if (loader) {\n              writer.setAttribute('src', '', fetchableImage.imageElement);\n              writer.setAttribute('uploadId', loader.id, fetchableImage.imageElement);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }); // Prevents from the browser redirecting to the dropped image.\n\n      editor.editing.view.document.on('dragover', function (evt, data) {\n        data.preventDefault();\n      }); // Upload placeholder images that appeared in the model.\n\n      doc.on('change', function () {\n        // Note: Reversing changes to start with insertions and only then handle removals. If it was the other way around,\n        // loaders for **all** images that land in the $graveyard would abort while in fact only those that were **not** replaced\n        // by other images should be aborted.\n        var changes = doc.differ.getChanges({\n          includeChangesInGraveyard: true\n        }).reverse();\n        var insertedImagesIds = new Set();\n\n        var _iterator2 = _createForOfIteratorHelper(changes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var entry = _step2.value;\n\n            if (entry.type == 'insert' && entry.name != '$text') {\n              var item = entry.position.nodeAfter;\n              var isInsertedInGraveyard = entry.position.root.rootName == '$graveyard';\n\n              var _iterator3 = _createForOfIteratorHelper(getImagesFromChangeItem(editor, item)),\n                  _step3;\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var imageElement = _step3.value;\n                  // Check if the image element still has upload id.\n                  var uploadId = imageElement.getAttribute('uploadId');\n\n                  if (!uploadId) {\n                    continue;\n                  } // Check if the image is loaded on this client.\n\n\n                  var loader = fileRepository.loaders.get(uploadId);\n\n                  if (!loader) {\n                    continue;\n                  }\n\n                  if (isInsertedInGraveyard) {\n                    // If the image was inserted to the graveyard for good (**not** replaced by another image),\n                    // only then abort the loading process.\n                    if (!insertedImagesIds.has(uploadId)) {\n                      loader.abort();\n                    }\n                  } else {\n                    // Remember the upload id of the inserted image. If it acted as a replacement for another\n                    // image (which landed in the $graveyard), the related loader will not be aborted because\n                    // this is still the same image upload.\n                    insertedImagesIds.add(uploadId); // Keep the mapping between the upload ID and the image model element so the upload\n                    // can later resolve in the context of the correct model element. The model element could\n                    // change for the same upload if one image was replaced by another (e.g. image type was changed),\n                    // so this may also replace an existing mapping.\n\n                    _this2._uploadImageElements.set(uploadId, imageElement);\n\n                    if (loader.status == 'idle') {\n                      // If the image was inserted into content and has not been loaded yet, start loading it.\n                      _this2._readAndUpload(loader);\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }); // Set the default handler for feeding the image element with `src` and `srcset` attributes.\n\n      this.on('uploadComplete', function (evt, _ref) {\n        var imageElement = _ref.imageElement,\n            data = _ref.data;\n        var urls = data.urls ? data.urls : data;\n\n        _this2.editor.model.change(function (writer) {\n          writer.setAttribute('src', urls.default, imageElement);\n\n          _this2._parseAndSetSrcsetAttributeOnImage(urls, imageElement, writer);\n        });\n      }, {\n        priority: 'low'\n      });\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"afterInit\",\n    value: function afterInit() {\n      var schema = this.editor.model.schema; // Setup schema to allow uploadId and uploadStatus for images.\n      // Wait for ImageBlockEditing or ImageInlineEditing to register their elements first,\n      // that's why doing this in afterInit() instead of init().\n\n      if (this.editor.plugins.has('ImageBlockEditing')) {\n        schema.extend('imageBlock', {\n          allowAttributes: ['uploadId', 'uploadStatus']\n        });\n      }\n\n      if (this.editor.plugins.has('ImageInlineEditing')) {\n        schema.extend('imageInline', {\n          allowAttributes: ['uploadId', 'uploadStatus']\n        });\n      }\n    }\n    /**\n     * Reads and uploads an image.\n     *\n     * The image is read from the disk and as a Base64-encoded string it is set temporarily to\n     * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target\n     * image's URL (the URL to the uploaded image on the server).\n     *\n     * @protected\n     * @param {module:upload/filerepository~FileLoader} loader\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_readAndUpload\",\n    value: function _readAndUpload(loader) {\n      var _this3 = this;\n\n      var editor = this.editor;\n      var model = editor.model;\n      var t = editor.locale.t;\n      var fileRepository = editor.plugins.get(FileRepository);\n      var notification = editor.plugins.get(Notification);\n      var imageUtils = editor.plugins.get('ImageUtils');\n      var imageUploadElements = this._uploadImageElements;\n      model.enqueueChange({\n        isUndoable: false\n      }, function (writer) {\n        writer.setAttribute('uploadStatus', 'reading', imageUploadElements.get(loader.id));\n      });\n      return loader.read().then(function () {\n        var promise = loader.upload();\n        var imageElement = imageUploadElements.get(loader.id); // Force re–paint in Safari. Without it, the image will display with a wrong size.\n        // https://github.com/ckeditor/ckeditor5/issues/1975\n\n        /* istanbul ignore next */\n\n        if (env.isSafari) {\n          var viewFigure = editor.editing.mapper.toViewElement(imageElement);\n          var viewImg = imageUtils.findViewImgElement(viewFigure);\n          editor.editing.view.once('render', function () {\n            // Early returns just to be safe. There might be some code ran\n            // in between the outer scope and this callback.\n            if (!viewImg.parent) {\n              return;\n            }\n\n            var domFigure = editor.editing.view.domConverter.mapViewToDom(viewImg.parent);\n\n            if (!domFigure) {\n              return;\n            }\n\n            var originalDisplay = domFigure.style.display;\n            domFigure.style.display = 'none'; // Make sure this line will never be removed during minification for having \"no effect\".\n\n            domFigure._ckHack = domFigure.offsetHeight;\n            domFigure.style.display = originalDisplay;\n          });\n        }\n\n        model.enqueueChange({\n          isUndoable: false\n        }, function (writer) {\n          writer.setAttribute('uploadStatus', 'uploading', imageElement);\n        });\n        return promise;\n      }).then(function (data) {\n        model.enqueueChange({\n          isUndoable: false\n        }, function (writer) {\n          var imageElement = imageUploadElements.get(loader.id);\n          writer.setAttribute('uploadStatus', 'complete', imageElement);\n          /**\n           * An event fired when an image is uploaded. You can hook into this event to provide\n           * custom attributes to the {@link module:engine/model/element~Element image element} based on the data from\n           * the server.\n           *\n           * \t\tconst imageUploadEditing = editor.plugins.get( 'ImageUploadEditing' );\n           *\n           * \t\timageUploadEditing.on( 'uploadComplete', ( evt, { data, imageElement } ) => {\n           * \t\t\teditor.model.change( writer => {\n           * \t\t\t\twriter.setAttribute( 'someAttribute', 'foo', imageElement );\n           * \t\t\t} );\n           * \t\t} );\n           *\n           * You can also stop the default handler that sets the `src` and `srcset` attributes\n           * if you want to provide custom values for these attributes.\n           *\n           * \t\timageUploadEditing.on( 'uploadComplete', ( evt, { data, imageElement } ) => {\n           * \t\t\tevt.stop();\n           * \t\t} );\n           *\n           * **Note**: This event is fired by the {@link module:image/imageupload/imageuploadediting~ImageUploadEditing} plugin.\n           *\n           * @event uploadComplete\n           * @param {Object} data The `uploadComplete` event data.\n           * @param {Object} data.data The data coming from the upload adapter.\n           * @param {module:engine/model/element~Element} data.imageElement The\n           * model {@link module:engine/model/element~Element image element} that can be customized.\n           */\n\n          _this3.fire('uploadComplete', {\n            data: data,\n            imageElement: imageElement\n          });\n        });\n        clean();\n      }).catch(function (error) {\n        // If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n        // it might be generic error and it would be real pain to find what is going on.\n        if (loader.status !== 'error' && loader.status !== 'aborted') {\n          throw error;\n        } // Might be 'aborted'.\n\n\n        if (loader.status == 'error' && error) {\n          notification.showWarning(error, {\n            title: t('Upload failed'),\n            namespace: 'upload'\n          });\n        } // Permanently remove image from insertion batch.\n\n\n        model.enqueueChange({\n          isUndoable: false\n        }, function (writer) {\n          writer.remove(imageUploadElements.get(loader.id));\n        });\n        clean();\n      });\n\n      function clean() {\n        model.enqueueChange({\n          isUndoable: false\n        }, function (writer) {\n          var imageElement = imageUploadElements.get(loader.id);\n          writer.removeAttribute('uploadId', imageElement);\n          writer.removeAttribute('uploadStatus', imageElement);\n          imageUploadElements.delete(loader.id);\n        });\n        fileRepository.destroyLoader(loader);\n      }\n    }\n    /**\n     * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.\n     *\n     * @protected\n     * @param {Object} data Data object from which `srcset` will be created.\n     * @param {module:engine/model/element~Element} image The image element on which the `srcset` attribute will be set.\n     * @param {module:engine/model/writer~Writer} writer\n     */\n\n  }, {\n    key: \"_parseAndSetSrcsetAttributeOnImage\",\n    value: function _parseAndSetSrcsetAttributeOnImage(data, image, writer) {\n      // Srcset attribute for responsive images support.\n      var maxWidth = 0;\n      var srcsetAttribute = Object.keys(data) // Filter out keys that are not integers.\n      .filter(function (key) {\n        var width = parseInt(key, 10);\n\n        if (!isNaN(width)) {\n          maxWidth = Math.max(maxWidth, width);\n          return true;\n        }\n      }) // Convert each key to srcset entry.\n      .map(function (key) {\n        return \"\".concat(data[key], \" \").concat(key, \"w\");\n      }) // Join all entries.\n      .join(', ');\n\n      if (srcsetAttribute != '') {\n        writer.setAttribute('srcset', {\n          data: srcsetAttribute,\n          width: maxWidth\n        }, image);\n      }\n    }\n  }]);\n\n  return ImageUploadEditing;\n}(Plugin); // Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\n\n\nexport { ImageUploadEditing as default };\nexport function isHtmlIncluded(dataTransfer) {\n  return Array.from(dataTransfer.types).includes('text/html') && dataTransfer.getData('text/html') !== '';\n}\n\nfunction getImagesFromChangeItem(editor, item) {\n  var imageUtils = editor.plugins.get('ImageUtils');\n  return Array.from(editor.model.createRangeOn(item)).filter(function (value) {\n    return imageUtils.isImage(value.item);\n  }).map(function (value) {\n    return value.item;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}