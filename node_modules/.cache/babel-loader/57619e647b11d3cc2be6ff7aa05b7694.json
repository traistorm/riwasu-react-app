{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React, { useState, useImperativeHandle, useRef, useCallback } from 'react';\nimport { render, unmountComponentAtNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport kebabCase from 'lodash/kebabCase';\nimport Transition from '../Animation/Transition';\nimport { useClassNames, guid, createChainedFunction } from '../utils';\n\nvar useMessages = function useMessages() {\n  var _useState = useState([]),\n      messages = _useState[0],\n      setMessages = _useState[1];\n\n  var getKey = useCallback(function (key) {\n    if (typeof key === 'undefined' && messages.length) {\n      return messages[messages.length - 1].key;\n    }\n\n    return key;\n  }, [messages]);\n  var push = useCallback(function (message) {\n    var key = guid();\n    setMessages([].concat(messages, [{\n      key: key,\n      visible: true,\n      node: message\n    }]));\n    return key;\n  }, [messages]);\n  var clear = useCallback(function () {\n    // Set all existing messages to be invisible.\n    setMessages(messages.map(function (msg) {\n      return _extends({}, msg, {\n        visible: false\n      });\n    })); // Remove all invisible messages after 400ms.\n    // The delay removal here is to preserve the animation.\n\n    setTimeout(function () {\n      setMessages([]);\n    }, 400);\n  }, [messages]);\n  var remove = useCallback(function (key) {\n    // Set the message of the specified key to invisible.\n    setMessages(messages.map(function (n) {\n      if (n.key === getKey(key)) {\n        n.visible = false;\n      }\n\n      return n;\n    })); // Remove invisible messages after 400ms.\n\n    setTimeout(function () {\n      setMessages(messages.filter(function (msg) {\n        return msg.visible;\n      }));\n    }, 400);\n  }, [messages, getKey]);\n  return {\n    messages: messages,\n    push: push,\n    clear: clear,\n    remove: remove\n  };\n};\n\nvar ToastContainer = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var rootRef = useRef();\n\n  var _props$as = props.as,\n      Component = _props$as === void 0 ? 'div' : _props$as,\n      className = props.className,\n      _props$classPrefix = props.classPrefix,\n      classPrefix = _props$classPrefix === void 0 ? 'toast-container' : _props$classPrefix,\n      _props$placement = props.placement,\n      placement = _props$placement === void 0 ? 'topCenter' : _props$placement,\n      rest = _objectWithoutPropertiesLoose(props, [\"as\", \"className\", \"classPrefix\", \"placement\"]);\n\n  var _useClassNames = useClassNames(classPrefix),\n      withClassPrefix = _useClassNames.withClassPrefix,\n      merge = _useClassNames.merge,\n      rootPrefix = _useClassNames.rootPrefix;\n\n  var classes = merge(className, withClassPrefix(kebabCase(placement)));\n\n  var _useMessages = useMessages(),\n      push = _useMessages.push,\n      clear = _useMessages.clear,\n      remove = _useMessages.remove,\n      messages = _useMessages.messages;\n\n  useImperativeHandle(ref, function () {\n    return {\n      root: rootRef.current,\n      push: push,\n      clear: clear,\n      remove: remove\n    };\n  });\n  var elements = messages.map(function (item) {\n    return /*#__PURE__*/React.createElement(Transition, {\n      key: item.key,\n      in: item.visible,\n      exitedClassName: rootPrefix('toast-fade-exited'),\n      exitingClassName: rootPrefix('toast-fade-exiting'),\n      enteringClassName: rootPrefix('toast-fade-entering'),\n      enteredClassName: rootPrefix('toast-fade-entered'),\n      timeout: 300\n    }, function (transitionProps, ref) {\n      var _item$node, _item$node$props, _item$node2, _item$node2$props;\n\n      var transitionClassName = transitionProps.className,\n          rest = _objectWithoutPropertiesLoose(transitionProps, [\"className\"]);\n\n      return /*#__PURE__*/React.cloneElement(item.node, _extends({}, rest, {\n        ref: ref,\n        // Remove the message after the specified time.\n        onClose: createChainedFunction((_item$node = item.node) === null || _item$node === void 0 ? void 0 : (_item$node$props = _item$node.props) === null || _item$node$props === void 0 ? void 0 : _item$node$props.onClose, function () {\n          return remove(item.key);\n        }),\n        className: merge(rootPrefix('toast'), (_item$node2 = item.node) === null || _item$node2 === void 0 ? void 0 : (_item$node2$props = _item$node2.props) === null || _item$node2$props === void 0 ? void 0 : _item$node2$props.className, transitionClassName)\n      }));\n    });\n  });\n  return /*#__PURE__*/React.createElement(Component, _extends({}, rest, {\n    ref: rootRef,\n    className: classes\n  }), elements);\n});\n\nToastContainer.getInstance = function (props) {\n  var container = props.container,\n      rest = _objectWithoutPropertiesLoose(props, [\"container\"]);\n\n  var containerRef = /*#__PURE__*/React.createRef();\n  var mountElement = document.createElement('div');\n  var containerElement = typeof container === 'function' ? container() : container; //  Parent is document.body or the existing dom element\n\n  var parentElement = containerElement || document.body; // Add the detached element to the parent\n\n  parentElement.appendChild(mountElement);\n\n  function destroy() {\n    unmountComponentAtNode(mountElement);\n    parentElement.removeChild(mountElement);\n  }\n\n  render( /*#__PURE__*/React.createElement(ToastContainer, _extends({}, rest, {\n    ref: containerRef\n  })), mountElement);\n  return [containerRef, destroy];\n};\n\nToastContainer.displayName = 'ToastContainer';\nToastContainer.propTypes = {\n  className: PropTypes.string,\n  classPrefix: PropTypes.string,\n  placement: PropTypes.elementType,\n  container: PropTypes.oneOfType([PropTypes.node, PropTypes.func])\n};\nexport default ToastContainer;","map":null,"metadata":{},"sourceType":"module"}