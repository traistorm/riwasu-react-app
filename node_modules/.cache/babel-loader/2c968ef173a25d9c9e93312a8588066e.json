{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\n\nvar DeleteCommand = /*#__PURE__*/function (_Command) {\n  _inherits(DeleteCommand, _Command);\n\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n   * should consume the content when the selection is collapsed.\n   */\n  function DeleteCommand(editor, direction) {\n    var _this;\n\n    _classCallCheck(this, DeleteCommand);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeleteCommand).call(this, editor));\n    /**\n     * The directionality of the delete describing in what direction it should\n     * consume the content when the selection is collapsed.\n     *\n     * @readonly\n     * @member {'forward'|'backward'} #direction\n     */\n\n    _this.direction = direction;\n    /**\n     * Delete's change buffer used to group subsequent changes into batches.\n     *\n     * @readonly\n     * @private\n     * @type {module:typing/utils/changebuffer~ChangeBuffer}\n     */\n\n    _this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));\n    return _this;\n  }\n  /**\n   * The current change buffer.\n   *\n   * @type {module:typing/utils/changebuffer~ChangeBuffer}\n   */\n\n\n  _createClass(DeleteCommand, [{\n    key: \"execute\",\n\n    /**\n     * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n     * or a piece of content in the {@link #direction defined direction}.\n     *\n     * @fires execute\n     * @param {Object} [options] The command options.\n     * @param {'character'|'codePoint'|'word'} [options.unit='character']\n     * See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n     * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n     * See the {@link module:engine/view/document~Document#event:delete} event data.\n     * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n     * will be used.\n     */\n    value: function execute() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.editor.model;\n      var doc = model.document;\n      model.enqueueChange(this._buffer.batch, function (writer) {\n        _this2._buffer.lock();\n\n        var selection = writer.createSelection(options.selection || doc.selection);\n        var sequence = options.sequence || 1; // Do not replace the whole selected content if selection was collapsed.\n        // This prevents such situation:\n        //\n        // <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n        // starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\n        var doNotResetEntireContent = selection.isCollapsed; // Try to extend the selection in the specified direction.\n\n        if (selection.isCollapsed) {\n          model.modifySelection(selection, {\n            direction: _this2.direction,\n            unit: options.unit,\n            treatEmojiAsSingleUnit: true\n          });\n        } // Check if deleting in an empty editor. See #61.\n\n\n        if (_this2._shouldEntireContentBeReplacedWithParagraph(sequence)) {\n          _this2._replaceEntireContentWithParagraph(writer);\n\n          return;\n        } // Check if deleting in the first empty block.\n        // See https://github.com/ckeditor/ckeditor5/issues/8137.\n\n\n        if (_this2._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {\n          _this2.editor.execute('paragraph', {\n            selection: selection\n          });\n\n          return;\n        } // If selection is still collapsed, then there's nothing to delete.\n\n\n        if (selection.isCollapsed) {\n          return;\n        }\n\n        var changeCount = 0;\n        selection.getFirstRange().getMinimalFlatRanges().forEach(function (range) {\n          changeCount += count(range.getWalker({\n            singleCharacters: true,\n            ignoreElementEnd: true,\n            shallow: true\n          }));\n        });\n        model.deleteContent(selection, {\n          doNotResetEntireContent: doNotResetEntireContent,\n          direction: _this2.direction\n        });\n\n        _this2._buffer.input(changeCount);\n\n        writer.setSelection(selection);\n\n        _this2._buffer.unlock();\n      });\n    }\n    /**\n     * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n     * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n     * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n     *\n     * But, if the user pressed the key in an empty editable for the first time,\n     * we want to replace the entire content with a paragraph if:\n     *\n     * * the current limit element is empty,\n     * * the paragraph is allowed in the limit element,\n     * * the limit doesn't already have a paragraph inside.\n     *\n     * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n     *\n     * @private\n     * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_shouldEntireContentBeReplacedWithParagraph\",\n    value: function _shouldEntireContentBeReplacedWithParagraph(sequence) {\n      // Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n      if (sequence > 1) {\n        return false;\n      }\n\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var limitElement = model.schema.getLimitElement(selection); // If a collapsed selection contains the whole content it means that the content is empty\n      // (from the user perspective).\n\n      var limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);\n\n      if (!limitElementIsEmpty) {\n        return false;\n      }\n\n      if (!model.schema.checkChild(limitElement, 'paragraph')) {\n        return false;\n      }\n\n      var limitElementFirstChild = limitElement.getChild(0); // Does nothing if the limit element already contains only a paragraph.\n      // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n      // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\n      if (limitElementFirstChild && limitElementFirstChild.name === 'paragraph') {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer The model writer.\n     */\n\n  }, {\n    key: \"_replaceEntireContentWithParagraph\",\n    value: function _replaceEntireContentWithParagraph(writer) {\n      var model = this.editor.model;\n      var doc = model.document;\n      var selection = doc.selection;\n      var limitElement = model.schema.getLimitElement(selection);\n      var paragraph = writer.createElement('paragraph');\n      writer.remove(writer.createRangeIn(limitElement));\n      writer.insert(paragraph, limitElement);\n      writer.setSelection(paragraph, 0);\n    }\n    /**\n     * Checks if the selection is inside an empty element that is the first child of the limit element\n     * and should be replaced with a paragraph.\n     *\n     * @private\n     * @param {module:engine/model/selection~Selection} selection The selection.\n     * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_shouldReplaceFirstBlockWithParagraph\",\n    value: function _shouldReplaceFirstBlockWithParagraph(selection, sequence) {\n      var model = this.editor.model; // Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n\n      if (sequence > 1 || this.direction != 'backward') {\n        return false;\n      }\n\n      if (!selection.isCollapsed) {\n        return false;\n      }\n\n      var position = selection.getFirstPosition();\n      var limitElement = model.schema.getLimitElement(position);\n      var limitElementFirstChild = limitElement.getChild(0); // Only elements that are direct children of the limit element can be replaced.\n      // Unwrapping from a block quote should be handled in a dedicated feature.\n\n      if (position.parent != limitElementFirstChild) {\n        return false;\n      } // A block should be replaced only if it was empty.\n\n\n      if (!selection.containsEntireContent(limitElementFirstChild)) {\n        return false;\n      } // Replace with a paragraph only if it's allowed there.\n\n\n      if (!model.schema.checkChild(limitElement, 'paragraph')) {\n        return false;\n      } // Does nothing if the limit element already contains only a paragraph.\n\n\n      if (limitElementFirstChild.name == 'paragraph') {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buffer;\n    }\n  }]);\n\n  return DeleteCommand;\n}(Command);\n\nexport { DeleteCommand as default };","map":null,"metadata":{},"sourceType":"module"}