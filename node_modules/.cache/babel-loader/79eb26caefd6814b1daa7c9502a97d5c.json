{"ast":null,"code":"/*\r\n * wysiwyg web editor\r\n *\r\n * suneditor.js\r\n * Copyright 2017 JiHong Lee.\r\n * MIT license.\r\n */\n'use strict';\n/**\r\n * @description utility function\r\n */\n\nvar util = {\n  _d: null,\n  _w: null,\n  isIE: null,\n  isIE_Edge: null,\n  isOSX_IOS: null,\n  isChromium: null,\n  _propertiesInit: function _propertiesInit() {\n    if (this._d) return;\n    this._d = document;\n    this._w = window;\n    this.isIE = navigator.userAgent.indexOf('Trident') > -1;\n    this.isIE_Edge = navigator.userAgent.indexOf('Trident') > -1 || navigator.appVersion.indexOf('Edge') > -1;\n    this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);\n    this.isChromium = !!window.chrome;\n  },\n  _allowedEmptyNodeList: '.se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas',\n\n  /**\r\n   * @description HTML Reserved Word Converter.\r\n   * @param {String} contents \r\n   * @returns {String} HTML string\r\n   * @private\r\n   */\n  _HTMLConvertor: function _HTMLConvertor(contents) {\n    var ec = {\n      '&': '&amp;',\n      \"\\xA0\": '&nbsp;',\n      '\\'': '&apos;',\n      '\"': '&quot;',\n      '<': '&lt;',\n      '>': '&gt;'\n    };\n    return contents.replace(/&|\\u00A0|'|\"|<|>/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description Unicode Character 'ZERO WIDTH SPACE' (\\u200B)\r\n   */\n  zeroWidthSpace: String.fromCharCode(8203),\n\n  /**\r\n   * @description Regular expression to find 'zero width space' (/\\u200B/g)\r\n   */\n  zeroWidthRegExp: new RegExp(String.fromCharCode(8203), 'g'),\n\n  /**\r\n   * @description Regular expression to find only 'zero width space' (/^\\u200B+$/)\r\n   */\n  onlyZeroWidthRegExp: new RegExp('^' + String.fromCharCode(8203) + '+$'),\n\n  /**\r\n   * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)\r\n   * @param {String|Node} text String value or Node\r\n   * @returns {Boolean}\r\n   */\n  onlyZeroWidthSpace: function onlyZeroWidthSpace(text) {\n    if (text === null || text === undefined) return false;\n    if (typeof text !== 'string') text = text.textContent;\n    return text === '' || this.onlyZeroWidthRegExp.test(text);\n  },\n\n  /**\r\n   * @description Gets XMLHttpRequest object\r\n   * @returns {XMLHttpRequest|ActiveXObject}\r\n   */\n  getXMLHttpRequest: function getXMLHttpRequest() {\n    /** IE */\n    if (this._w.ActiveXObject) {\n      try {\n        return new ActiveXObject('Msxml2.XMLHTTP');\n      } catch (e) {\n        try {\n          return new ActiveXObject('Microsoft.XMLHTTP');\n        } catch (e1) {\n          return null;\n        }\n      }\n    }\n    /** netscape */\n    else if (this._w.XMLHttpRequest) {\n      return new XMLHttpRequest();\n    }\n    /** fail */\n    else {\n      return null;\n    }\n  },\n\n  /**\r\n   * @description Object.values\r\n   * @param {Object|null} obj Object parameter.\r\n   * @returns {Array}\r\n   */\n  getValues: function getValues(obj) {\n    return !obj ? [] : this._w.Object.keys(obj).map(function (i) {\n      return obj[i];\n    });\n  },\n\n  /**\r\n   * @description Convert the CamelCase To the KebabCase.\r\n   * @param {String|Array} param [Camel string]\r\n   * @returns {String|Array}\r\n   */\n  camelToKebabCase: function camelToKebabCase(param) {\n    if (typeof param === 'string') {\n      return param.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n      });\n    } else {\n      return param.map(function (str) {\n        return util.camelToKebabCase(str);\n      });\n    }\n  },\n\n  /**\r\n   * @description Create Element node\r\n   * @param {String} elementName Element name\r\n   * @returns {Element}\r\n   */\n  createElement: function createElement(elementName) {\n    return this._d.createElement(elementName);\n  },\n\n  /**\r\n   * @description Create text node\r\n   * @param {String} text text contents\r\n   * @returns {Node}\r\n   */\n  createTextNode: function createTextNode(text) {\n    return this._d.createTextNode(text || '');\n  },\n\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * When using an attribute with \"<\" or \">\", use \"HTMLEncoder\" to save. (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLEncoder: function HTMLEncoder(contents) {\n    var ec = {\n      '<': '$lt;',\n      '>': '$gt;'\n    };\n    return contents.replace(/<|>/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * Decoder of data stored as \"HTMLEncoder\" (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLDecoder: function HTMLDecoder(contents) {\n    var ec = {\n      '$lt;': '<',\n      '$gt;': '>'\n    };\n    return contents.replace(/\\$lt;|\\$gt;/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description This method run Object.prototype.hasOwnProperty.call(obj, key)\r\n   * @param {Object} obj Object\r\n   * @param {String} key obj.key\r\n   * @returns {Boolean}\r\n   */\n  hasOwn: function hasOwn(obj, key) {\n    return this._hasOwn.call(obj, key);\n  },\n  _hasOwn: Object.prototype.hasOwnProperty,\n\n  /**\r\n   * @deprecated\r\n   * @description Get the the tag path of the arguments value\r\n   * If not found, return the first found value\r\n   * @param {Array} nameArray File name array\r\n   * @param {String} extension js, css\r\n   * @returns {String}\r\n   */\n  getIncludePath: function getIncludePath(nameArray, extension) {\n    var path = '';\n    var pathList = [];\n    var tagName = extension === 'js' ? 'script' : 'link';\n    var src = extension === 'js' ? 'src' : 'href';\n    var fileName = '(?:';\n\n    for (var i = 0, len = nameArray.length; i < len; i++) {\n      fileName += nameArray[i] + (i < len - 1 ? '|' : ')');\n    }\n\n    var regExp = new this._w.RegExp('(^|.*[\\\\/])' + fileName + '(\\\\.[^\\\\/]+)?\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\n    var extRegExp = new this._w.RegExp('.+\\\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\n\n    for (var c = this._d.getElementsByTagName(tagName), _i = 0; _i < c.length; _i++) {\n      if (extRegExp.test(c[_i][src])) {\n        pathList.push(c[_i]);\n      }\n    }\n\n    for (var _i2 = 0; _i2 < pathList.length; _i2++) {\n      var editorTag = pathList[_i2][src].match(regExp);\n\n      if (editorTag) {\n        path = editorTag[0];\n        break;\n      }\n    }\n\n    if (path === '') path = pathList.length > 0 ? pathList[0][src] : '';\n    -1 === path.indexOf(':/') && '//' !== path.slice(0, 2) && (path = 0 === path.indexOf('/') ? location.href.match(/^.*?:\\/\\/[^\\/]*/)[0] + path : location.href.match(/^[^\\?]*\\/(?:)/)[0] + path);\n    if (!path) throw '[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +' + name + ', extension: ' + extension + ')';\n    return path;\n  },\n\n  /**\r\n   * @deprecated\r\n   * @description Returns the CSS text that has been applied to the current page.\r\n   * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.\r\n   * @returns {String} Styles string\r\n   */\n  getPageStyle: function getPageStyle(doc) {\n    var cssText = '';\n    var sheets = (doc || this._d).styleSheets;\n\n    for (var i = 0, len = sheets.length, rules; i < len; i++) {\n      try {\n        rules = sheets[i].cssRules;\n      } catch (e) {\n        continue;\n      }\n\n      if (rules) {\n        for (var c = 0, cLen = rules.length; c < cLen; c++) {\n          cssText += rules[c].cssText;\n        }\n      }\n    }\n\n    return cssText;\n  },\n\n  /**\r\n   * @description Get the argument iframe's document object\r\n   * @param {Element} iframe Iframe element (context.element.wysiwygFrame)\r\n   * @returns {Document}\r\n   */\n  getIframeDocument: function getIframeDocument(iframe) {\n    var wDocument = iframe.contentWindow || iframe.contentDocument;\n    if (wDocument.document) wDocument = wDocument.document;\n    return wDocument;\n  },\n\n  /**\r\n   * @description Get attributes of argument element to string ('class=\"---\" name=\"---\" ')\r\n   * @param {Element} element Element object\r\n   * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result\r\n   * @returns {String}\r\n   */\n  getAttributesToString: function getAttributesToString(element, exceptAttrs) {\n    if (!element.attributes) return '';\n    var attrs = element.attributes;\n    var attrString = '';\n\n    for (var i = 0, len = attrs.length; i < len; i++) {\n      if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;\n      attrString += attrs[i].name + '=\"' + attrs[i].value + '\" ';\n    }\n\n    return attrString;\n  },\n\n  /**\r\n   * @descriptionGets Get the length in bytes of a string.\r\n   * referencing code: \"https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11\"\r\n   * @param {String} text String text\r\n   * @returns {Number}\r\n   */\n  getByteLength: function getByteLength(text) {\n    if (!text || !text.toString) return 0;\n    text = text.toString();\n    var encoder = this._w.encodeURIComponent;\n    var cr, cl;\n\n    if (this.isIE_Edge) {\n      cl = this._w.unescape(encoder(text)).length;\n      cr = 0;\n\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n\n      return cl + cr;\n    } else {\n      cl = new this._w.TextEncoder('utf-8').encode(text).length;\n      cr = 0;\n\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n\n      return cl + cr;\n    }\n  },\n\n  /**\r\n   * @description It is judged whether it is the edit region top div element or iframe's body tag.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isWysiwygDiv: function isWysiwygDiv(element) {\n    return element && element.nodeType === 1 && (this.hasClass(element, 'se-wrapper-wysiwyg') || /^BODY$/i.test(element.nodeName));\n  },\n\n  /**\r\n   * @description It is judged whether it is the contenteditable property is false.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNonEditable: function isNonEditable(element) {\n    return element && element.nodeType === 1 && element.getAttribute('contenteditable') === 'false';\n  },\n\n  /**\r\n   * @description It is judged whether it is a node related to the text style.\r\n   * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isTextStyleElement: function isTextStyleElement(element) {\n    return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);\n  },\n\n  /**\r\n   * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class=\"__se__format__replace_xxx\")\r\n   * Format element also contain \"free format Element\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFormatElement: function isFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__replace_.+(\\\\s|$)|(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n\n  /**\r\n   * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class=\"__se__format__range_xxx\")\r\n   * Range format element is wrap the \"format element\" and \"component\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isRangeFormatElement: function isRangeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range_.+(\\\\s|$)'));\n  },\n\n  /**\r\n   * @description It is judged whether it is the closure range format element. (TH, TD | class=\"__se__format__range__closure_xxx\")\r\n   * Closure range format elements is included in the range format element.\r\n   *  - Closure range format element is wrap the \"format element\" and \"component\"\r\n   * ※ You cannot exit this format with the Enter key or Backspace key.\r\n   * ※ Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureRangeFormatElement: function isClosureRangeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range__closure_.+(\\\\s|$)'));\n  },\n\n  /**\r\n   * @description It is judged whether it is the free format element. (PRE | class=\"__se__format__free_xxx\")\r\n   * Free format elements is included in the format element.\r\n   * Free format elements's line break is \"BR\" tag.\r\n   * ※ Entering the Enter key in the space on the last line ends \"Free Format\" and appends \"Format\".\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFreeFormatElement: function isFreeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n\n  /**\r\n   * @description It is judged whether it is the closure free format element. (class=\"__se__format__free__closure_xxx\")\r\n   * Closure free format elements is included in the free format element.\r\n   *  - Closure free format elements's line break is \"BR\" tag.\r\n   * ※ You cannot exit this format with the Enter key or Backspace key.\r\n   * ※ Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureFreeFormatElement: function isClosureFreeFormatElement(element) {\n    return element && element.nodeType === 1 && this.hasClass(element, '(\\\\s|^)__se__format__free__closure_.+(\\\\s|$)');\n  },\n\n  /**\r\n   * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class=\"se-component\") and table, hr\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isComponent: function isComponent(element) {\n    return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));\n  },\n\n  /**\r\n   * @description Checks for \"__se__uneditable\" in the class list.\r\n   * Components with class \"__se__uneditable\" cannot be modified.\r\n   * @param {Element} element The element to check\r\n   * @returns {Boolean}\r\n   */\n  isUneditableComponent: function isUneditableComponent(element) {\n    return element && this.hasClass(element, '__se__uneditable');\n  },\n\n  /**\r\n   * @description It is judged whether it is the component [img, iframe] cover(class=\"se-component\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isMediaComponent: function isMediaComponent(element) {\n    return element && /se-component/.test(element.className);\n  },\n\n  /**\r\n   * @description It is judged whether it is the not checking node. (class=\"katex\", \"__se__tag\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNotCheckingNode: function isNotCheckingNode(element) {\n    return element && /katex|__se__tag/.test(element.className);\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFormatElement: function getFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element)) element.firstElementChild;\n      if (this.isFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getRangeFormatElement: function getRangeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFreeFormatElement: function getFreeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getClosureFreeFormatElement: function getClosureFreeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isClosureFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description Add style and className of copyEl to originEl\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyTagAttributes: function copyTagAttributes(originEl, copyEl) {\n    if (copyEl.style.cssText) {\n      originEl.style.cssText += copyEl.style.cssText;\n    }\n\n    var classes = copyEl.classList;\n\n    for (var i = 0, len = classes.length; i < len; i++) {\n      this.addClass(originEl, classes[i]);\n    }\n\n    if (!originEl.style.cssText) originEl.removeAttribute('style');\n    if (!originEl.className.trim()) originEl.removeAttribute('class');\n  },\n\n  /**\r\n   * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore \"__se__format__\" class\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyFormatAttributes: function copyFormatAttributes(originEl, copyEl) {\n    copyEl = copyEl.cloneNode(false);\n    copyEl.className = copyEl.className.replace(/(\\s|^)__se__format__[^\\s]+/g, '');\n    this.copyTagAttributes(originEl, copyEl);\n  },\n\n  /**\r\n   * @description Get the item from the array that matches the condition.\r\n   * @param {Array|HTMLCollection|NodeList} array Array to get item\r\n   * @param {Function|null} validation Conditional function\r\n   * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.\r\n   * If false, returns only one item that meet the criteria otherwise return null.\r\n   * @returns {Array|Node|null}\r\n   */\n  getArrayItem: function getArrayItem(array, validation, multi) {\n    if (!array || array.length === 0) return null;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    var arr = [];\n\n    for (var i = 0, len = array.length, a; i < len; i++) {\n      a = array[i];\n\n      if (validation(a)) {\n        if (!multi) return a;else arr.push(a);\n      }\n    }\n\n    return !multi ? null : arr;\n  },\n\n  /**\r\n   * @description Check if an array contains an element \r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to check for\r\n   * @returns {Boolean}\r\n   */\n  arrayIncludes: function arrayIncludes(array, element) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === element) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * @description Get the index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to find index\r\n   * @returns {Number}\r\n   */\n  getArrayIndex: function getArrayIndex(array, element) {\n    var idx = -1;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === element) {\n        idx = i;\n        break;\n      }\n    }\n\n    return idx;\n  },\n\n  /**\r\n   * @description Get the next index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  nextIdx: function nextIdx(array, item) {\n    var idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx + 1;\n  },\n\n  /**\r\n   * @description Get the previous index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array Element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  prevIdx: function prevIdx(array, item) {\n    var idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx - 1;\n  },\n\n  /**\r\n   * @description Returns the index compared to other sibling nodes.\r\n   * @param {Node} node The Node to find index\r\n   * @returns {Number}\r\n   */\n  getPositionIndex: function getPositionIndex(node) {\n    var idx = 0;\n\n    while (node = node.previousSibling) {\n      idx += 1;\n    }\n\n    return idx;\n  },\n\n  /**\r\n   * @description Returns the position of the \"node\" in the \"parentNode\" in a numerical array.\r\n   * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: \"bb\", parentNode: \"<P>\") -> [1, 0]\r\n   * @param {Node} node The Node to find position path\r\n   * @param {Node|null} parentNode Parent node. If null, wysiwyg div area\r\n   * @param {Object|null} _newOffsets If you send an object of the form \"{s: 0, e: 0}\", the text nodes that are attached together are merged into one, centered on the \"node\" argument.\r\n   * \"_newOffsets.s\" stores the length of the combined characters after \"node\" and \"_newOffsets.e\" stores the length of the combined characters before \"node\".\r\n   * Do not use unless absolutely necessary.\r\n   * @returns {Array}\r\n   */\n  getNodePath: function getNodePath(node, parentNode, _newOffsets) {\n    var path = [];\n    var finds = true;\n    this.getParentElement(node, function (el) {\n      if (el === parentNode) finds = false;\n\n      if (finds && !this.isWysiwygDiv(el)) {\n        // merge text nodes\n        if (_newOffsets && el.nodeType === 3) {\n          var temp = null,\n              tempText = null;\n          _newOffsets.s = _newOffsets.e = 0;\n          var previous = el.previousSibling;\n\n          while (previous && previous.nodeType === 3) {\n            tempText = previous.textContent.replace(this.zeroWidthRegExp, '');\n            _newOffsets.s += tempText.length;\n            el.textContent = tempText + el.textContent;\n            temp = previous;\n            previous = previous.previousSibling;\n            this.removeItem(temp);\n          }\n\n          var next = el.nextSibling;\n\n          while (next && next.nodeType === 3) {\n            tempText = next.textContent.replace(this.zeroWidthRegExp, '');\n            _newOffsets.e += tempText.length;\n            el.textContent += tempText;\n            temp = next;\n            next = next.nextSibling;\n            this.removeItem(temp);\n          }\n        } // index push\n\n\n        path.push(el);\n      }\n\n      return false;\n    }.bind(this));\n    return path.map(this.getPositionIndex).reverse();\n  },\n\n  /**\r\n   * @description Returns the node in the location of the path array obtained from \"util.getNodePath\".\r\n   * @param {Array} offsets Position array, array obtained from \"util.getNodePath\"\r\n   * @param {Node} parentNode Base parent element\r\n   * @returns {Node}\r\n   */\n  getNodeFromPath: function getNodeFromPath(offsets, parentNode) {\n    var current = parentNode;\n    var nodes;\n\n    for (var i = 0, len = offsets.length; i < len; i++) {\n      nodes = current.childNodes;\n      if (nodes.length === 0) break;\n\n      if (nodes.length <= offsets[i]) {\n        current = nodes[nodes.length - 1];\n      } else {\n        current = nodes[offsets[i]];\n      }\n    }\n\n    return current;\n  },\n\n  /**\r\n   * @description Compares the style and class for equal values.\r\n   * Returns true if both are text nodes.\r\n   * @param {Node} a Node to compare\r\n   * @param {Node} b Node to compare\r\n   * @returns {Boolean}\r\n   */\n  isSameAttributes: function isSameAttributes(a, b) {\n    if (a.nodeType === 3 && b.nodeType === 3) return true;\n    if (a.nodeType === 3 || b.nodeType === 3) return false;\n    var style_a = a.style;\n    var style_b = b.style;\n    var compStyle = 0;\n\n    for (var i = 0, len = style_a.length; i < len; i++) {\n      if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;\n    }\n\n    var class_a = a.classList;\n    var class_b = b.classList;\n    var reg = this._w.RegExp;\n    var compClass = 0;\n\n    for (var _i3 = 0, _len = class_a.length; _i3 < _len; _i3++) {\n      if (reg('(\\s|^)' + class_a[_i3] + '(\\s|$)').test(class_b.value)) compClass++;\n    }\n\n    return compStyle === style_b.length && compStyle === style_a.length && compClass === class_b.length && compClass === class_a.length;\n  },\n\n  /**\r\n   * @description Check the line element(util.isFormatElement) is empty.\r\n   * @param {Element} element Format element node\r\n   * @returns {Boolean}\r\n   */\n  isEmptyLine: function isEmptyLine(element) {\n    return !element || !element.parentNode || !element.querySelector('IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE') && this.onlyZeroWidthSpace(element.textContent);\n  },\n\n  /**\r\n   * @description Check the node is a list (ol, ul)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isList: function isList(node) {\n    return node && /^(OL|UL)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a list cell (li)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isListCell: function isListCell(node) {\n    return node && /^LI$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a table (table, thead, tbody, tr, th, td)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isTable: function isTable(node) {\n    return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a table cell (td, th)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isCell: function isCell(node) {\n    return node && /^(TD|TH)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a break node (BR)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isBreak: function isBreak(node) {\n    return node && /^BR$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a anchor node (A)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isAnchor: function isAnchor(node) {\n    return node && /^A$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a media node (img, iframe, audio, video, canvas)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isMedia: function isMedia(node) {\n    return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Checks for numeric (with decimal point).\r\n   * @param {String|Number} text Text string or number\r\n   * @returns {Boolean}\r\n   */\n  isNumber: function isNumber(text) {\n    return !!text && /^-?\\d+(\\.\\d+)?$/.test(text + '');\n  },\n\n  /**\r\n   * @description Get a number.\r\n   * @param {String|Number} text Text string or number\r\n   * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)\r\n   * @returns {Number}\r\n   */\n  getNumber: function getNumber(text, maxDec) {\n    if (!text) return 0;\n    var number = (text + '').match(/-?\\d+(\\.\\d+)?/);\n    if (!number || !number[0]) return 0;\n    number = number[0];\n    return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;\n  },\n\n  /**\r\n   * @description Get all \"children\" of the argument value element (Without text nodes)\r\n   * @param {Element} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildren: function getListChildren(element, validation) {\n    var children = [];\n    if (!element || !element.children || element.children.length === 0) return children;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n\n      if (!!current.children) {\n        for (var i = 0, len = current.children.length; i < len; i++) {\n          recursionFunc(current.children[i]);\n        }\n      }\n    })(element);\n\n    return children;\n  },\n\n  /**\r\n   * @description Get all \"childNodes\" of the argument value element (Include text nodes)\r\n   * @param {Node} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildNodes: function getListChildNodes(element, validation) {\n    var children = [];\n    if (!element || element.childNodes.length === 0) return children;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n\n      for (var i = 0, len = current.childNodes.length; i < len; i++) {\n        recursionFunc(current.childNodes[i]);\n      }\n    })(element);\n\n    return children;\n  },\n\n  /**\r\n   * @description Returns the number of parents nodes.\r\n   * \"0\" when the parent node is the WYSIWYG area.\r\n   * \"-1\" when the element argument is the WYSIWYG area.\r\n   * @param {Node} element The element to check\r\n   * @returns {Number}\r\n   */\n  getElementDepth: function getElementDepth(element) {\n    if (!element || this.isWysiwygDiv(element)) return -1;\n    var depth = 0;\n    element = element.parentNode;\n\n    while (element && !this.isWysiwygDiv(element)) {\n      depth += 1;\n      element = element.parentNode;\n    }\n\n    return depth;\n  },\n\n  /**\r\n   * @description Compares two elements to find a common ancestor, and returns the order of the two elements.\r\n   * @param {Node} a Node to compare.\r\n   * @param {Node} b Node to compare.\r\n   * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };\r\n   */\n  compareElements: function compareElements(a, b) {\n    var aNode = a,\n        bNode = b;\n\n    while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {\n      aNode = aNode.parentNode;\n      bNode = bNode.parentNode;\n    }\n\n    if (!aNode || !bNode) return {\n      ancestor: null,\n      a: a,\n      b: b,\n      result: 0\n    };\n    var children = aNode.parentNode.childNodes;\n    var aIndex = this.getArrayIndex(children, aNode);\n    var bIndex = this.getArrayIndex(children, bNode);\n    return {\n      ancestor: aNode.parentNode,\n      a: aNode,\n      b: bNode,\n      result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0\n    };\n  },\n\n  /**\r\n   * @description Get the parent element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getParentElement: function getParentElement(element, query) {\n    var check;\n\n    if (typeof query === 'function') {\n      check = query;\n    } else {\n      var attr;\n\n      if (/^\\./.test(query)) {\n        attr = 'className';\n        query = query.split('.')[1];\n      } else if (/^#/.test(query)) {\n        attr = 'id';\n        query = '^' + query.split('#')[1] + '$';\n      } else if (/^:/.test(query)) {\n        attr = 'name';\n        query = '^' + query.split(':')[1] + '$';\n      } else {\n        attr = 'nodeName';\n        query = '^' + query + '$';\n      }\n\n      var regExp = new this._w.RegExp(query, 'i');\n\n      check = function check(el) {\n        return regExp.test(el[attr]);\n      };\n    }\n\n    while (element && !check(element)) {\n      if (this.isWysiwygDiv(element)) {\n        return null;\n      }\n\n      element = element.parentNode;\n    }\n\n    return element;\n  },\n\n  /**\r\n   * @description Get the child element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getChildElement: function getChildElement(element, query, last) {\n    var check;\n\n    if (typeof query === 'function') {\n      check = query;\n    } else {\n      var attr;\n\n      if (/^\\./.test(query)) {\n        attr = 'className';\n        query = query.split('.')[1];\n      } else if (/^#/.test(query)) {\n        attr = 'id';\n        query = '^' + query.split('#')[1] + '$';\n      } else if (/^:/.test(query)) {\n        attr = 'name';\n        query = '^' + query.split(':')[1] + '$';\n      } else {\n        attr = 'nodeName';\n        query = '^' + (query === 'text' ? '#' + query : query) + '$';\n      }\n\n      var regExp = new this._w.RegExp(query, 'i');\n\n      check = function check(el) {\n        return regExp.test(el[attr]);\n      };\n    }\n\n    var childList = this.getListChildNodes(element, function (current) {\n      return check(current);\n    });\n    return childList[last ? childList.length - 1 : 0];\n  },\n\n  /**\r\n   * @description 1. The first node of all the child nodes of the \"first\" element is returned.\r\n   * 2. The last node of all the child nodes of the \"last\" element is returned.\r\n   * 3. When there is no \"last\" element, the first and last nodes of all the children of the \"first\" element are returned.\r\n   * { sc: \"first\", ec: \"last\" }\r\n   * @param {Node} first First element\r\n   * @param {Node|null} last Last element\r\n   * @returns {Object}\r\n   */\n  getEdgeChildNodes: function getEdgeChildNodes(first, last) {\n    if (!first) return;\n    if (!last) last = first;\n\n    while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) {\n      first = first.firstChild;\n    }\n\n    while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) {\n      last = last.lastChild;\n    }\n\n    return {\n      sc: first,\n      ec: last || first\n    };\n  },\n\n  /**\r\n   * @description Returns the position of the left and top of argument. {left:0, top:0}\r\n   * @param {Node} element Target node\r\n   * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)\r\n   * @returns {Object}\r\n   */\n  getOffset: function getOffset(element, wysiwygFrame) {\n    var offsetLeft = 0;\n    var offsetTop = 0;\n    var offsetElement = element.nodeType === 3 ? element.parentElement : element;\n    var wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));\n\n    while (offsetElement && !this.hasClass(offsetElement, 'se-container') && offsetElement !== wysiwyg) {\n      offsetLeft += offsetElement.offsetLeft;\n      offsetTop += offsetElement.offsetTop;\n      offsetElement = offsetElement.offsetParent;\n    }\n\n    var iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);\n    return {\n      left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),\n      top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)\n    };\n  },\n\n  /**\r\n   * @description It compares the start and end indexes of \"a\" and \"b\" and returns the number of overlapping indexes in the range.\r\n   * ex) 1, 5, 4, 6 => \"2\" (4 ~ 5)\r\n   * @param {Number} aStart Start index of \"a\"\r\n   * @param {Number} aEnd End index of \"a\"\r\n   * @param {Number} bStart Start index of \"b\"\r\n   * @param {Number} bEnd Start index of \"b\"\r\n   * @returns {Number}\r\n   */\n  getOverlapRangeAtIndex: function getOverlapRangeAtIndex(aStart, aEnd, bStart, bEnd) {\n    if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;\n    var overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);\n    return (overlap < 0 ? overlap * -1 : overlap) + 1;\n  },\n\n  /**\r\n   * @description Set the text content value of the argument value element\r\n   * @param {Node} element Element to replace text content\r\n   * @param {String} txt Text to be applied\r\n   */\n  changeTxt: function changeTxt(element, txt) {\n    if (!element || !txt) return;\n    element.textContent = txt;\n  },\n\n  /**\r\n   * @description Replace element\r\n   * @param {Element} element Target element\r\n   * @param {String|Element} newElement String or element of the new element to apply\r\n   */\n  changeElement: function changeElement(element, newElement) {\n    if (typeof newElement === 'string') {\n      if (element.outerHTML) {\n        element.outerHTML = newElement;\n      } else {\n        var doc = this.createElement('DIV');\n        doc.innerHTML = newElement;\n        newElement = doc.firstChild;\n        element.parentNode.replaceChild(newElement, element);\n      }\n    } else if (newElement.nodeType === 1) {\n      element.parentNode.replaceChild(newElement, element);\n    }\n  },\n\n  /**\r\n   * @description Set style, if all styles are deleted, the style properties are deleted.\r\n   * @param {Element} element Element to set style\r\n   * @param {String} styleName Style attribute name (marginLeft, textAlign...)\r\n   * @param {String|Number} value Style value\r\n   */\n  setStyle: function setStyle(element, styleName, value) {\n    element.style[styleName] = value;\n\n    if (!value && !element.style.cssText) {\n      element.removeAttribute('style');\n    }\n  },\n\n  /**\r\n   * @description Determine whether any of the matched elements are assigned the given class\r\n   * @param {Element} element Elements to search class name\r\n   * @param {String} className Class name to search for\r\n   * @returns {Boolean}\r\n   */\n  hasClass: function hasClass(element, className) {\n    if (!element) return;\n    return new this._w.RegExp(className).test(element.className);\n  },\n\n  /**\r\n   * @description Append the className value of the argument value element\r\n   * @param {Element} element Elements to add class name\r\n   * @param {String} className Class name to be add\r\n   */\n  addClass: function addClass(element, className) {\n    if (!element) return;\n    var check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    if (check.test(element.className)) return;\n    element.className += (element.className.length > 0 ? ' ' : '') + className;\n  },\n\n  /**\r\n   * @description Delete the className value of the argument value element\r\n   * @param {Element} element Elements to remove class name\r\n   * @param {String} className Class name to be remove\r\n   */\n  removeClass: function removeClass(element, className) {\n    if (!element) return;\n    var check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    element.className = element.className.replace(check, ' ').trim();\n    if (!element.className.trim()) element.removeAttribute('class');\n  },\n\n  /**\r\n   * @description Argument value If there is no class name, insert it and delete the class name if it exists\r\n   * @param {Element} element Elements to replace class name\r\n   * @param {String} className Class name to be change\r\n   * @returns {Boolean|undefined}\r\n   */\n  toggleClass: function toggleClass(element, className) {\n    if (!element) return;\n    var result = false;\n    var check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n\n    if (check.test(element.className)) {\n      element.className = element.className.replace(check, ' ').trim();\n    } else {\n      element.className += ' ' + className;\n      result = true;\n    }\n\n    if (!element.className.trim()) element.removeAttribute('class');\n    return result;\n  },\n\n  /**\r\n   * @description Checks if element can't be easily enabled\r\n   * @param {Element} element Element to check for\r\n   */\n  isImportantDisabled: function isImportantDisabled(element) {\n    return element.hasAttribute('data-important-disabled');\n  },\n\n  /**\r\n   * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.\r\n   * core.codeViewDisabledButtons (An array of buttons whose class name is not \"se-code-view-enabled\")\r\n   * core.resizingDisabledButtons (An array of buttons whose class name is not \"se-resizing-enabled\")\r\n   * @param {Boolean} disabled Disabled value\r\n   * @param {Array|HTMLCollection|NodeList} buttonList Button array\r\n   * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)\r\n   */\n  setDisabledButtons: function setDisabledButtons(disabled, buttonList, important) {\n    for (var i = 0, len = buttonList.length; i < len; i++) {\n      var button = buttonList[i];\n      if (important || !this.isImportantDisabled(button)) button.disabled = disabled;\n\n      if (important) {\n        if (disabled) {\n          button.setAttribute('data-important-disabled', '');\n        } else {\n          button.removeAttribute('data-important-disabled');\n        }\n      }\n    }\n  },\n\n  /**\r\n   * @description Delete argumenu value element\r\n   * @param {Node} item Node to be remove\r\n   */\n  removeItem: function removeItem(item) {\n    if (!item) return;\n    if (typeof item.remove === 'function') item.remove();else if (item.parentNode) item.parentNode.removeChild(item);\n  },\n\n  /**\r\n   * @description Delete all parent nodes that match the condition.\r\n   * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.\r\n   * @param {Node} item Node to be remove\r\n   * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)\r\n   * @param {Element|null} stopParent Stop when the parent node reaches stopParent\r\n   * @returns {Object|null} {sc: previousSibling, ec: nextSibling}\r\n   */\n  removeItemAllParents: function removeItemAllParents(item, validation, stopParent) {\n    if (!item) return null;\n    var cc = null;\n\n    if (!validation) {\n      validation = function (current) {\n        if (current === stopParent || this.isComponent(current)) return false;\n        var text = current.textContent.trim();\n        return text.length === 0 || /^(\\n|\\u200B)+$/.test(text);\n      }.bind(this);\n    }\n\n    (function recursionFunc(element) {\n      if (!util.isWysiwygDiv(element)) {\n        var parent = element.parentNode;\n\n        if (parent && validation(element)) {\n          cc = {\n            sc: element.previousElementSibling,\n            ec: element.nextElementSibling\n          };\n          util.removeItem(element);\n          recursionFunc(parent);\n        }\n      }\n    })(item);\n\n    return cc;\n  },\n\n  /**\r\n   * @description Detach Nested all nested lists under the \"baseNode\".\r\n   * Returns a list with nested removed.\r\n   * @param {Node} baseNode Element on which to base.\r\n   * @param {Boolean} all If true, it also detach all nested lists of a returned list.\r\n   * @returns {Element}\r\n   */\n  detachNestedList: function detachNestedList(baseNode, all) {\n    var rNode = this._deleteNestedList(baseNode);\n\n    var rangeElement, cNodes;\n\n    if (rNode) {\n      rangeElement = rNode.cloneNode(false);\n      cNodes = rNode.childNodes;\n      var index = this.getPositionIndex(baseNode);\n\n      while (cNodes[index]) {\n        rangeElement.appendChild(cNodes[index]);\n      }\n    } else {\n      rangeElement = baseNode;\n    }\n\n    var rChildren;\n\n    if (!all) {\n      var depth = this.getElementDepth(baseNode) + 2;\n      rChildren = this.getListChildren(baseNode, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;\n      }.bind(this));\n    } else {\n      rChildren = this.getListChildren(rangeElement, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling;\n      }.bind(this));\n    }\n\n    for (var i = 0, len = rChildren.length; i < len; i++) {\n      this._deleteNestedList(rChildren[i]);\n    }\n\n    if (rNode) {\n      rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);\n      if (cNodes && cNodes.length === 0) this.removeItem(rNode);\n    }\n\n    return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;\n  },\n\n  /**\r\n   * @description Sub function of util.detachNestedList method.\r\n   * @private\r\n   */\n  _deleteNestedList: function _deleteNestedList(baseNode) {\n    var baseParent = baseNode.parentNode;\n    var sibling = baseParent;\n    var parent = sibling.parentNode;\n    var liSibling, liParent, child, index, c;\n\n    while (this.isListCell(parent)) {\n      index = this.getPositionIndex(baseNode);\n      liSibling = parent.nextElementSibling;\n      liParent = parent.parentNode;\n      child = sibling;\n\n      while (child) {\n        sibling = sibling.nextSibling;\n\n        if (this.isList(child)) {\n          c = child.childNodes;\n\n          while (c[index]) {\n            liParent.insertBefore(c[index], liSibling);\n          }\n\n          if (c.length === 0) this.removeItem(child);\n        } else {\n          liParent.appendChild(child);\n        }\n\n        child = sibling;\n      }\n\n      sibling = liParent;\n      parent = liParent.parentNode;\n    }\n\n    if (baseParent.children.length === 0) this.removeItem(baseParent);\n    return liParent;\n  },\n\n  /**\r\n   * @description Split all tags based on \"baseNode\"\r\n   * Returns the last element of the splited tag.\r\n   * @param {Node} baseNode Element or text node on which to base\r\n   * @param {Number|null} offset Text offset of \"baseNode\" (Only valid when \"baseNode\" is a text node)\r\n   * @param {Number} depth The nesting depth of the element being split. (default: 0)\r\n   * @returns {Element}\r\n   */\n  splitElement: function splitElement(baseNode, offset, depth) {\n    if (this.isWysiwygDiv(baseNode)) return baseNode;\n    var bp = baseNode.parentNode;\n    var index = 0,\n        newEl,\n        children,\n        temp;\n    var next = true;\n    if (!depth || depth < 0) depth = 0;\n\n    if (baseNode.nodeType === 3) {\n      index = this.getPositionIndex(baseNode);\n\n      if (offset >= 0) {\n        baseNode.splitText(offset);\n        var after = this.getNodeFromPath([index + 1], bp);\n        if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;\n      }\n    } else if (baseNode.nodeType === 1) {\n      if (!baseNode.previousSibling) {\n        if (this.getElementDepth(baseNode) === depth) next = false;\n      } else {\n        baseNode = baseNode.previousSibling;\n      }\n    }\n\n    var depthEl = baseNode;\n\n    while (this.getElementDepth(depthEl) > depth) {\n      index = this.getPositionIndex(depthEl) + 1;\n      depthEl = depthEl.parentNode;\n      temp = newEl;\n      newEl = depthEl.cloneNode(false);\n      children = depthEl.childNodes;\n\n      if (temp) {\n        if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {\n          newEl.innerHTML = temp.firstElementChild.innerHTML;\n          util.removeItem(temp.firstElementChild);\n          if (temp.children.length > 0) newEl.appendChild(temp);\n        } else {\n          newEl.appendChild(temp);\n        }\n      }\n\n      while (children[index]) {\n        newEl.appendChild(children[index]);\n      }\n    }\n\n    if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = '<br>';\n    var pElement = depthEl.parentNode;\n    if (next) depthEl = depthEl.nextSibling;\n    if (!newEl) return depthEl;\n    this.mergeSameTags(newEl, null, false);\n    this.mergeNestedTags(newEl, function (current) {\n      return this.isList(current);\n    }.bind(this));\n    if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);else newEl = depthEl;\n    if (bp.childNodes.length === 0) this.removeItem(bp);\n    return newEl;\n  },\n\n  /**\r\n   * @description Use with \"npdePath (util.getNodePath)\" to merge the same attributes and tags if they are present and modify the nodepath.\r\n   * If \"offset\" has been changed, it will return as much \"offset\" as it has been modified.\r\n   * An array containing change offsets is returned in the order of the \"nodePathArray\" array.\r\n   * @param {Element} element Element\r\n   * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])\r\n   * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.\r\n   * @returns {Array} [offset, ..]\r\n   */\n  mergeSameTags: function mergeSameTags(element, nodePathArray, onlyText) {\n    var inst = this;\n    var nodePathLen = nodePathArray ? nodePathArray.length : 0;\n    var offsets = null;\n\n    if (nodePathLen) {\n      offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);\n    }\n\n    (function recursionFunc(current, depth, depthIndex) {\n      var children = current.childNodes;\n\n      for (var i = 0, len = children.length, child, next; i < len; i++) {\n        child = children[i];\n        next = children[i + 1];\n        if (!child) break;\n\n        if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {\n          if (inst.isTable(child) || inst.isListCell(child)) {\n            recursionFunc(child, depth + 1, i);\n          }\n\n          continue;\n        }\n\n        if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {\n          // update nodePath\n          if (nodePathLen) {\n            var path = void 0,\n                c = void 0,\n                p = void 0,\n                cDepth = void 0,\n                spliceDepth = void 0;\n\n            for (var n = 0; n < nodePathLen; n++) {\n              path = nodePathArray[n];\n\n              if (path && path[depth] === i) {\n                c = child, p = current, cDepth = depth, spliceDepth = true;\n\n                while (cDepth >= 0) {\n                  if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {\n                    spliceDepth = false;\n                    break;\n                  }\n\n                  c = child.parentNode;\n                  p = c.parentNode;\n                  cDepth--;\n                }\n\n                if (spliceDepth) {\n                  path.splice(depth, 1);\n                  path[depth] = i;\n                }\n              }\n            }\n          } // merge tag\n\n\n          inst.copyTagAttributes(child, current);\n          current.parentNode.insertBefore(child, current);\n          inst.removeItem(current);\n        }\n\n        if (!next) {\n          if (child.nodeType === 1) recursionFunc(child, depth + 1, i);\n          break;\n        }\n\n        if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {\n          var childs = child.childNodes;\n          var childLength = 0;\n\n          for (var _n = 0, nLen = childs.length; _n < nLen; _n++) {\n            if (childs[_n].textContent.length > 0) childLength++;\n          }\n\n          var l = child.lastChild;\n          var r = next.firstChild;\n          var addOffset = 0;\n\n          if (l && r) {\n            var textOffset = l.nodeType === 3 && r.nodeType === 3;\n            addOffset = l.textContent.length;\n            var tempL = l.previousSibling;\n\n            while (tempL && tempL.nodeType === 3) {\n              addOffset += tempL.textContent.length;\n              tempL = tempL.previousSibling;\n            }\n\n            if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;\n\n            if (nodePathLen) {\n              var _path = null;\n\n              for (var _n2 = 0; _n2 < nodePathLen; _n2++) {\n                _path = nodePathArray[_n2];\n\n                if (_path && _path[depth] > i) {\n                  if (depth > 0 && _path[depth - 1] !== depthIndex) continue;\n                  _path[depth] -= 1;\n\n                  if (_path[depth + 1] >= 0 && _path[depth] === i) {\n                    _path[depth + 1] += childLength;\n\n                    if (textOffset) {\n                      if (l && l.nodeType === 3 && r && r.nodeType === 3) {\n                        offsets[_n2] += addOffset;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (child.nodeType === 3) {\n            addOffset = child.textContent.length;\n            child.textContent += next.textContent;\n\n            if (nodePathLen) {\n              var _path2 = null;\n\n              for (var _n3 = 0; _n3 < nodePathLen; _n3++) {\n                _path2 = nodePathArray[_n3];\n\n                if (_path2 && _path2[depth] > i) {\n                  if (depth > 0 && _path2[depth - 1] !== depthIndex) continue;\n                  _path2[depth] -= 1;\n\n                  if (_path2[depth + 1] >= 0 && _path2[depth] === i) {\n                    _path2[depth + 1] += childLength;\n                    offsets[_n3] += addOffset;\n                  }\n                }\n              }\n            }\n          } else {\n            child.innerHTML += next.innerHTML;\n          }\n\n          inst.removeItem(next);\n          i--;\n        } else if (child.nodeType === 1) {\n          recursionFunc(child, depth + 1, i);\n        }\n      }\n    })(element, 0, 0);\n\n    return offsets;\n  },\n\n  /**\r\n   * @description Remove nested tags without other child nodes.\r\n   * @param {Element} element Element object\r\n   * @param {Function|String|null} validation Validation function / String(\"tag1|tag2..\") / If null, all tags are applicable.\r\n   */\n  mergeNestedTags: function mergeNestedTags(element, validation) {\n    if (typeof validation === 'string') {\n      validation = function (current) {\n        return this.test(current.tagName);\n      }.bind(new this._w.RegExp('^(' + (validation ? validation : '.+') + ')$', 'i'));\n    } else if (typeof validation !== 'function') {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    (function recursionFunc(current) {\n      var children = current.children;\n\n      if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {\n        var temp = children[0];\n        children = temp.children;\n\n        while (children[0]) {\n          current.appendChild(children[0]);\n        }\n\n        current.removeChild(temp);\n      }\n\n      for (var i = 0, len = current.children.length; i < len; i++) {\n        recursionFunc(current.children[i]);\n      }\n    })(element);\n  },\n\n  /**\r\n   * @description Delete a empty child node of argument element\r\n   * @param {Element} element Element node\r\n   * @param {Node|null} notRemoveNode Do not remove node\r\n   */\n  removeEmptyNode: function removeEmptyNode(element, notRemoveNode) {\n    var inst = this;\n\n    if (notRemoveNode) {\n      notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {\n        return element === current.parentElement;\n      });\n    }\n\n    (function recursionFunc(current) {\n      if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;\n\n      if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n          return -1;\n        }\n      } else {\n        var children = current.children;\n\n        for (var i = 0, len = children.length, r = 0; i < len; i++) {\n          if (!children[i + r] || inst.isComponent(children[i + r])) continue;\n          r += recursionFunc(children[i + r]);\n        }\n      }\n\n      return 0;\n    })(element);\n\n    if (element.childNodes.length === 0) element.innerHTML = '<br>';\n  },\n\n  /**\r\n   * @description Remove whitespace between tags in HTML string.\r\n   * @param {String} html HTML string\r\n   * @returns {String}\r\n   */\n  htmlRemoveWhiteSpace: function htmlRemoveWhiteSpace(html) {\n    if (!html) return '';\n    return html.trim().replace(/<\\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\\s+(?=<)/ig, function (m) {\n      return m.replace(/\\n/g, '').replace(/\\s+/, ' ');\n    });\n  },\n\n  /**\r\n   * @description Sort a element array by depth of element.\r\n   * @param {Array} array Array object\r\n   * @param {Boolean} des true: descending order / false: ascending order\r\n   */\n  sortByDepth: function sortByDepth(array, des) {\n    var t = !des ? -1 : 1;\n    var f = t * -1;\n    array.sort(function (a, b) {\n      if (!this.isListCell(a) || !this.isListCell(b)) return 0;\n      a = this.getElementDepth(a);\n      b = this.getElementDepth(b);\n      return a > b ? t : a < b ? f : 0;\n    }.bind(this));\n  },\n\n  /**\r\n   * @description Nodes that need to be added without modification when changing text nodes\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isIgnoreNodeChange: function _isIgnoreNodeChange(element) {\n    return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));\n  },\n\n  /**\r\n   * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)\r\n   * @param {Node|String} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isMaintainedNode: function _isMaintainedNode(element) {\n    return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === 'string' ? element : element.nodeName);\n  },\n\n  /**\r\n   * @description Node with font-size style\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isSizeNode: function _isSizeNode(element) {\n    return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;\n  },\n\n  /**\r\n   * @description Nodes without text\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _notTextNode: function _notTextNode(element) {\n    return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === 'string' ? element : element.nodeName));\n  },\n\n  /**\r\n   * @description Check disallowed tags\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _disallowedTags: function _disallowedTags(element) {\n    return /^(meta|script|link|style|[a-z]+\\:[a-z]+)$/i.test(element.nodeName);\n  },\n\n  /**\r\n   * @description Create whitelist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?!\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsWhitelist: function createTagsWhitelist(list) {\n    return new RegExp('<\\\\/?\\\\b(?!\\\\b' + (list || '').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\n  },\n\n  /**\r\n   * @description Create blacklist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?:\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsBlacklist: function createTagsBlacklist(list) {\n    return new RegExp('<\\\\/?\\\\b(?:\\\\b' + (list || '^').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\n  },\n\n  /**\r\n   * @description Fix tags that do not fit the editor format.\r\n   * @param {Element} documentFragment Document fragment \"DOCUMENT_FRAGMENT_NODE\" (nodeType === 11)\r\n   * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)\r\n   * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)\r\n   * @param {Boolean} lowLevelCheck Row level check\r\n   * @private\r\n   */\n  _consistencyCheckOfHTML: function _consistencyCheckOfHTML(documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, lowLevelCheck) {\n    /**\r\n     * It is can use \".children(util.getListChildren)\" to exclude text nodes, but \"documentFragment.children\" is not supported in IE.\r\n     * So check the node type and exclude the text no (current.nodeType !== 1)\r\n     */\n    var removeTags = [],\n        emptyTags = [],\n        wrongList = [],\n        withoutFormatCells = []; // wrong position\n\n    var wrongTags = this.getListChildNodes(documentFragment, function (current) {\n      if (current.nodeType !== 1) {\n        if (this.isList(current.parentNode)) removeTags.push(current);\n        return false;\n      } // white list\n\n\n      if (htmlCheckBlacklistRegExp.test(current.nodeName) || !htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {\n        removeTags.push(current);\n        return false;\n      }\n\n      var nrtag = !this.getParentElement(current, this.isNotCheckingNode); // empty tags\n\n      if (!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {\n        emptyTags.push(current);\n        return false;\n      } // wrong list\n\n\n      if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {\n        wrongList.push(current);\n        return false;\n      } // table cells\n\n\n      if (this.isCell(current)) {\n        var fel = current.firstElementChild;\n\n        if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {\n          withoutFormatCells.push(current);\n          return false;\n        }\n      }\n\n      var result = current.parentNode !== documentFragment && nrtag && (this.isListCell(current) && !this.isList(current.parentNode) || lowLevelCheck && (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent));\n      return result;\n    }.bind(this));\n\n    for (var i = 0, len = removeTags.length; i < len; i++) {\n      this.removeItem(removeTags[i]);\n    }\n\n    var checkTags = [];\n\n    for (var _i4 = 0, _len2 = wrongTags.length, t, p; _i4 < _len2; _i4++) {\n      t = wrongTags[_i4];\n      p = t.parentNode;\n      if (!p || !p.parentNode) continue;\n\n      if (this.getParentElement(t, this.isListCell)) {\n        var cellChildren = t.childNodes;\n\n        for (var j = cellChildren.length - 1; _len2 >= 0; j--) {\n          p.insertBefore(t, cellChildren[j]);\n        }\n\n        checkTags.push(t);\n      } else {\n        p.parentNode.insertBefore(t, p);\n        checkTags.push(p);\n      }\n    }\n\n    for (var _i5 = 0, _len3 = checkTags.length, _t; _i5 < _len3; _i5++) {\n      _t = checkTags[_i5];\n\n      if (this.onlyZeroWidthSpace(_t.textContent.trim())) {\n        this.removeItem(_t);\n      }\n    }\n\n    for (var _i6 = 0, _len4 = emptyTags.length; _i6 < _len4; _i6++) {\n      this.removeItem(emptyTags[_i6]);\n    }\n\n    for (var _i7 = 0, _len5 = wrongList.length, _t2, tp, children, _p; _i7 < _len5; _i7++) {\n      _t2 = wrongList[_i7];\n      _p = _t2.parentNode;\n      if (!_p) continue;\n      tp = this.createElement('LI');\n\n      if (this.isFormatElement(_t2)) {\n        children = _t2.childNodes;\n\n        while (children[0]) {\n          tp.appendChild(children[0]);\n        }\n\n        _p.insertBefore(tp, _t2);\n\n        this.removeItem(_t2);\n      } else {\n        _t2 = _t2.nextSibling;\n        tp.appendChild(wrongList[_i7]);\n\n        _p.insertBefore(tp, _t2);\n      }\n    }\n\n    for (var _i8 = 0, _len6 = withoutFormatCells.length, _t3, f; _i8 < _len6; _i8++) {\n      _t3 = withoutFormatCells[_i8];\n      f = this.createElement('DIV');\n      f.innerHTML = _t3.textContent.trim().length === 0 && _t3.children.length === 0 ? '<br>' : _t3.innerHTML;\n      _t3.innerHTML = f.outerHTML;\n    }\n  },\n  _setDefaultOptionStyle: function _setDefaultOptionStyle(options, defaultStyle) {\n    var optionStyle = '';\n    if (options.height) optionStyle += 'height:' + options.height + ';';\n    if (options.minHeight) optionStyle += 'min-height:' + options.minHeight + ';';\n    if (options.maxHeight) optionStyle += 'max-height:' + options.maxHeight + ';';\n    if (options.position) optionStyle += 'position:' + options.position + ';';\n    if (options.width) optionStyle += 'width:' + options.width + ';';\n    if (options.minWidth) optionStyle += 'min-width:' + options.minWidth + ';';\n    if (options.maxWidth) optionStyle += 'max-width:' + options.maxWidth + ';';\n    var top = '',\n        frame = '',\n        editor = '';\n    defaultStyle = optionStyle + defaultStyle;\n    var styleArr = defaultStyle.split(';');\n\n    for (var i = 0, len = styleArr.length, s; i < len; i++) {\n      s = styleArr[i].trim();\n      if (!s) continue;\n\n      if (/^(min-|max-)?width\\s*:/.test(s) || /^(z-index|position)\\s*:/.test(s)) {\n        top += s + ';';\n        continue;\n      }\n\n      if (/^(min-|max-)?height\\s*:/.test(s)) {\n        if (/^height/.test(s) && s.split(':')[1].trim() === 'auto') {\n          options.height = 'auto';\n        }\n\n        frame += s + ';';\n        continue;\n      }\n\n      editor += s + ';';\n    }\n\n    return {\n      top: top,\n      frame: frame,\n      editor: editor\n    };\n  },\n  _setIframeDocument: function _setIframeDocument(frame, options) {\n    frame.setAttribute('scrolling', 'auto');\n    frame.contentDocument.head.innerHTML = '' + '<meta charset=\"utf-8\" />' + '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">' + this._setIframeCssTags(options);\n    frame.contentDocument.body.className = options._editableClass;\n    frame.contentDocument.body.setAttribute('contenteditable', true);\n  },\n  _setIframeCssTags: function _setIframeCssTags(options) {\n    var linkNames = options.iframeCSSFileName;\n    var wRegExp = this._w.RegExp;\n    var tagString = '';\n\n    for (var f = 0, len = linkNames.length, path; f < len; f++) {\n      path = [];\n\n      if (/(^https?:\\/\\/)|(^data:text\\/css,)/.test(linkNames[f])) {\n        path.push(linkNames[f]);\n      } else {\n        var CSSFileName = new wRegExp('(^|.*[\\\\/])' + linkNames[f] + '(\\\\..+)?\\\\.css(?:\\\\?.*|;.*)?$', 'i');\n\n        for (var c = document.getElementsByTagName('link'), i = 0, _len7 = c.length, styleTag; i < _len7; i++) {\n          styleTag = c[i].href.match(CSSFileName);\n          if (styleTag) path.push(styleTag[0]);\n        }\n      }\n\n      if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property \"iframeCSSFileName\" before creating editor instances.';\n\n      for (var _i9 = 0, _len8 = path.length; _i9 < _len8; _i9++) {\n        tagString += '<link href=\"' + path[_i9] + '\" rel=\"stylesheet\">';\n      }\n    }\n\n    return tagString + (options.height === 'auto' ? '<style>\\n/** Iframe height auto */\\nbody{height: min-content; overflow: hidden;}\\n</style>' : '');\n  }\n};\nexport default util;","map":null,"metadata":{},"sourceType":"module"}