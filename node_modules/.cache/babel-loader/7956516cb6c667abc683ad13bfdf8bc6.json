{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\n/**\n * @module widget/verticalnavigationhandler\n */\n\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n * @returns {Function}\n */\n\nexport default function verticalNavigationHandler(editing) {\n  var model = editing.model;\n  return function (evt, data) {\n    var arrowUpPressed = data.keyCode == keyCodes.arrowup;\n    var arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n    var expandSelection = data.shiftKey;\n    var selection = model.document.selection;\n\n    if (!arrowUpPressed && !arrowDownPressed) {\n      return;\n    }\n\n    var isForward = arrowDownPressed; // Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n    // Selection for sure will not approach any object.\n\n    if (expandSelection && selectionWillShrink(selection, isForward)) {\n      return;\n    } // Find a range between selection and closest limit element.\n\n\n    var range = findTextRangeFromSelection(editing, selection, isForward); // There is no selection position inside the limit element.\n\n    if (!range) {\n      return;\n    } // If already at the edge of a limit element.\n\n\n    if (range.isCollapsed) {\n      // A collapsed selection at limit edge - nothing more to do.\n      if (selection.isCollapsed) {\n        return;\n      } // A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n      else if (expandSelection) {\n        return;\n      }\n    } // If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n    //\n    // We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n    // of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n\n\n    if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {\n      model.change(function (writer) {\n        var newPosition = isForward ? range.end : range.start;\n\n        if (expandSelection) {\n          var newSelection = model.createSelection(selection.anchor);\n          newSelection.setFocus(newPosition);\n          writer.setSelection(newSelection);\n        } else {\n          writer.setSelection(newPosition);\n        }\n      });\n      evt.stop();\n      data.preventDefault();\n      data.stopPropagation();\n    }\n  };\n} // Finds the range between selection and closest limit element (in the direction of navigation).\n// The position next to limit element is adjusted to the closest allowed `$text` position.\n//\n// Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/selection~Selection} selection The current selection.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {module:engine/model/range~Range|null}\n//\n\nfunction findTextRangeFromSelection(editing, selection, isForward) {\n  var model = editing.model;\n\n  if (isForward) {\n    var startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n    var endPosition = getNearestNonInlineLimit(model, startPosition, 'forward'); // There is no limit element, browser should handle this.\n\n    if (!endPosition) {\n      return null;\n    }\n\n    var range = model.createRange(startPosition, endPosition);\n    var lastRangePosition = getNearestTextPosition(model.schema, range, 'backward');\n\n    if (lastRangePosition) {\n      return model.createRange(startPosition, lastRangePosition);\n    }\n\n    return null;\n  } else {\n    var _endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n\n    var _startPosition = getNearestNonInlineLimit(model, _endPosition, 'backward'); // There is no limit element, browser should handle this.\n\n\n    if (!_startPosition) {\n      return null;\n    }\n\n    var _range = model.createRange(_startPosition, _endPosition);\n\n    var firstRangePosition = getNearestTextPosition(model.schema, _range, 'forward');\n\n    if (firstRangePosition) {\n      return model.createRange(firstRangePosition, _endPosition);\n    }\n\n    return null;\n  }\n} // Finds the limit element position that is closest to startPosition.\n//\n// @param {module:engine/model/model~Model} model\n// @param {<module:engine/model/position~Position>} startPosition\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {<module:engine/model/position~Position>|null}\n//\n\n\nfunction getNearestNonInlineLimit(model, startPosition, direction) {\n  var schema = model.schema;\n  var range = model.createRangeIn(startPosition.root);\n  var walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n\n  var _iterator = _createForOfIteratorHelper(range.getWalker({\n    startPosition: startPosition,\n    direction: direction\n  })),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          previousPosition = _step$value.previousPosition,\n          item = _step$value.item,\n          type = _step$value.type;\n\n      if (schema.isLimit(item) && !schema.isInline(item)) {\n        return previousPosition;\n      } // Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n\n\n      if (type == walkerValueType && schema.isBlock(item)) {\n        return null;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n} // Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n// that can contain `$text` (according to schema).\n//\n// @param {module:engine/model/schema~Schema} schema The schema.\n// @param {module:engine/model/range~Range} range The range to find the position in.\n// @param {'forward'|'backward'} direction Search direction.\n// @returns {module:engine/model/position~Position|null} The nearest selection position.\n//\n\n\nfunction getNearestTextPosition(schema, range, direction) {\n  var position = direction == 'backward' ? range.end : range.start;\n\n  if (schema.checkChild(position, '$text')) {\n    return position;\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(range.getWalker({\n    direction: direction\n  })),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var nextPosition = _step2.value.nextPosition;\n\n      if (schema.checkChild(nextPosition, '$text')) {\n        return nextPosition;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return null;\n} // Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n// (verifying if they visually wrap content to the next line).\n//\n// @param {module:engine/controller/editingcontroller~EditingController} editing The editing controller.\n// @param {module:engine/model/range~Range} modelRange The current table cell content range.\n// @param {Boolean} isForward The expected navigation direction.\n// @returns {Boolean}\n//\n\n\nfunction isSingleLineRange(editing, modelRange, isForward) {\n  var model = editing.model;\n  var domConverter = editing.view.domConverter; // Wrapped lines contain exactly the same position at the end of current line\n  // and at the beginning of next line. That position's client rect is at the end\n  // of current line. In case of caret at first position of the last line that 'dual'\n  // position would be detected as it's not the last line.\n\n  if (isForward) {\n    var probe = model.createSelection(modelRange.start);\n    model.modifySelection(probe); // If the new position is at the end of the container then we can't use this position\n    // because it would provide incorrect result for eg caption of image and selection\n    // just before end of it. Also in this case there is no \"dual\" position.\n\n    if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {\n      modelRange = model.createRange(probe.focus, modelRange.end);\n    }\n  }\n\n  var viewRange = editing.mapper.toViewRange(modelRange);\n  var domRange = domConverter.viewRangeToDom(viewRange);\n  var rects = Rect.getDomRangeRects(domRange);\n  var boundaryVerticalPosition;\n\n  var _iterator3 = _createForOfIteratorHelper(rects),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var rect = _step3.value;\n\n      if (boundaryVerticalPosition === undefined) {\n        boundaryVerticalPosition = Math.round(rect.bottom);\n        continue;\n      } // Let's check if this rect is in new line.\n\n\n      if (Math.round(rect.top) >= boundaryVerticalPosition) {\n        return false;\n      }\n\n      boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return true;\n}\n\nfunction selectionWillShrink(selection, isForward) {\n  return !selection.isCollapsed && selection.isBackward == isForward;\n}","map":null,"metadata":{},"sourceType":"module"}