{"ast":null,"code":"import e from \"../../node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\";\nimport t from \"react\";\n\nfunction s(e) {\n  return e && e.stopPropagation && e.stopPropagation(), e && e.preventDefault && e.preventDefault(), !1;\n}\n\nfunction n(e) {\n  return null == e ? [] : Array.isArray(e) ? e.slice() : [e];\n}\n\nfunction i(e) {\n  return null !== e && 1 === e.length ? e[0] : e.slice();\n}\n\nfunction o(e) {\n  Object.keys(e).forEach(function (t) {\n    \"undefined\" != typeof document && document.addEventListener(t, e[t], !1);\n  });\n}\n\nfunction r(e, t) {\n  return a(function (e, t) {\n    var s = e;\n    s <= t.min && (s = t.min);\n    s >= t.max && (s = t.max);\n    return s;\n  }(e, t), t);\n}\n\nfunction a(e, t) {\n  var s = (e - t.min) % t.step;\n  var n = e - s;\n  return 2 * Math.abs(s) >= t.step && (n += s > 0 ? t.step : -t.step), parseFloat(n.toFixed(5));\n}\n\nvar p = function (p) {\n  function u(e) {\n    var a;\n    (a = p.call(this, e) || this).onKeyUp = function () {\n      a.onEnd();\n    }, a.onMouseUp = function () {\n      a.onEnd(a.getMouseEventMap());\n    }, a.onTouchEnd = function () {\n      a.onEnd(a.getTouchEventMap());\n    }, a.onBlur = function () {\n      a.setState({\n        index: -1\n      }, a.onEnd(a.getKeyDownEventMap()));\n    }, a.onMouseMove = function (e) {\n      a.setState({\n        pending: !0\n      });\n      var t = a.getMousePosition(e),\n          s = a.getDiffPosition(t[0]),\n          n = a.getValueFromPosition(s);\n      a.move(n);\n    }, a.onTouchMove = function (e) {\n      if (e.touches.length > 1) return;\n      a.setState({\n        pending: !0\n      });\n      var t = a.getTouchPosition(e);\n\n      if (void 0 === a.isScrolling) {\n        var _e = t[0] - a.startPosition[0],\n            _s = t[1] - a.startPosition[1];\n\n        a.isScrolling = Math.abs(_s) > Math.abs(_e);\n      }\n\n      if (a.isScrolling) return void a.setState({\n        index: -1\n      });\n      var s = a.getDiffPosition(t[0]),\n          n = a.getValueFromPosition(s);\n      a.move(n);\n    }, a.onKeyDown = function (e) {\n      if (!(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey)) switch (a.setState({\n        pending: !0\n      }), e.key) {\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n        case \"Left\":\n        case \"Down\":\n          e.preventDefault(), a.moveDownByStep();\n          break;\n\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"Right\":\n        case \"Up\":\n          e.preventDefault(), a.moveUpByStep();\n          break;\n\n        case \"Home\":\n          e.preventDefault(), a.move(a.props.min);\n          break;\n\n        case \"End\":\n          e.preventDefault(), a.move(a.props.max);\n          break;\n\n        case \"PageDown\":\n          e.preventDefault(), a.moveDownByStep(a.props.pageFn(a.props.step));\n          break;\n\n        case \"PageUp\":\n          e.preventDefault(), a.moveUpByStep(a.props.pageFn(a.props.step));\n      }\n    }, a.onSliderMouseDown = function (e) {\n      if (!a.props.disabled && 2 !== e.button) {\n        if (a.setState({\n          pending: !0\n        }), !a.props.snapDragDisabled) {\n          var _t = a.getMousePosition(e);\n\n          a.forceValueFromPosition(_t[0], function (e) {\n            a.start(e, _t[0]), o(a.getMouseEventMap());\n          });\n        }\n\n        s(e);\n      }\n    }, a.onSliderClick = function (e) {\n      if (!a.props.disabled && a.props.onSliderClick && !a.hasMoved) {\n        var _t2 = a.getMousePosition(e),\n            _s2 = r(a.calcValue(a.calcOffsetFromPosition(_t2[0])), a.props);\n\n        a.props.onSliderClick(_s2);\n      }\n    }, a.createOnKeyDown = function (e) {\n      return function (t) {\n        a.props.disabled || (a.start(e), o(a.getKeyDownEventMap()), s(t));\n      };\n    }, a.createOnMouseDown = function (e) {\n      return function (t) {\n        if (a.props.disabled || 2 === t.button) return;\n        a.setState({\n          pending: !0\n        });\n        var n = a.getMousePosition(t);\n        a.start(e, n[0]), o(a.getMouseEventMap()), s(t);\n      };\n    }, a.createOnTouchStart = function (e) {\n      return function (t) {\n        if (a.props.disabled || t.touches.length > 1) return;\n        a.setState({\n          pending: !0\n        });\n        var s = a.getTouchPosition(t);\n        a.startPosition = s, a.isScrolling = void 0, a.start(e, s[0]), o(a.getTouchEventMap()), function (e) {\n          e.stopPropagation && e.stopPropagation();\n        }(t);\n      };\n    }, a.handleResize = function () {\n      var e = window.setTimeout(function () {\n        a.pendingResizeTimeouts.shift(), a.resize();\n      }, 0);\n      a.pendingResizeTimeouts.push(e);\n    }, a.renderThumb = function (e, t) {\n      var s = a.props.thumbClassName + \" \" + a.props.thumbClassName + \"-\" + t + \" \" + (a.state.index === t ? a.props.thumbActiveClassName : \"\"),\n          n = {\n        ref: function ref(e) {\n          a[\"thumb\" + t] = e;\n        },\n        key: a.props.thumbClassName + \"-\" + t,\n        className: s,\n        style: e,\n        onMouseDown: a.createOnMouseDown(t),\n        onTouchStart: a.createOnTouchStart(t),\n        onFocus: a.createOnKeyDown(t),\n        tabIndex: 0,\n        role: \"slider\",\n        \"aria-orientation\": a.props.orientation,\n        \"aria-valuenow\": a.state.value[t],\n        \"aria-valuemin\": a.props.min,\n        \"aria-valuemax\": a.props.max,\n        \"aria-label\": Array.isArray(a.props.ariaLabel) ? a.props.ariaLabel[t] : a.props.ariaLabel,\n        \"aria-labelledby\": Array.isArray(a.props.ariaLabelledby) ? a.props.ariaLabelledby[t] : a.props.ariaLabelledby\n      },\n          o = {\n        index: t,\n        value: i(a.state.value),\n        valueNow: a.state.value[t]\n      };\n      return a.props.ariaValuetext && (n[\"aria-valuetext\"] = \"string\" == typeof a.props.ariaValuetext ? a.props.ariaValuetext : a.props.ariaValuetext(o)), a.props.renderThumb(n, o);\n    }, a.renderTrack = function (e, t, s) {\n      var n = {\n        key: a.props.trackClassName + \"-\" + e,\n        className: a.props.trackClassName + \" \" + a.props.trackClassName + \"-\" + e,\n        style: a.buildTrackStyle(t, a.state.upperBound - s)\n      },\n          o = {\n        index: e,\n        value: i(a.state.value)\n      };\n      return a.props.renderTrack(n, o);\n    };\n    var u = n(e.value);\n    u.length || (u = n(e.defaultValue)), a.pendingResizeTimeouts = [];\n    var h = [];\n\n    for (var _t3 = 0; _t3 < u.length; _t3 += 1) {\n      u[_t3] = r(u[_t3], e), h.push(_t3);\n    }\n\n    return a.resizeObserver = null, a.resizeElementRef = t.createRef(), a.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value: u,\n      zIndices: h\n    }, a;\n  }\n\n  e(u, p);\n  var h = u.prototype;\n  return h.componentDidMount = function () {\n    \"undefined\" != typeof window && (this.resizeObserver = new ResizeObserver(this.handleResize), this.resizeObserver.observe(this.resizeElementRef.current), this.resize());\n  }, u.getDerivedStateFromProps = function (e, t) {\n    var s = n(e.value);\n    return s.length ? t.pending ? null : {\n      value: s.map(function (t) {\n        return r(t, e);\n      })\n    } : null;\n  }, h.componentDidUpdate = function () {\n    0 === this.state.upperBound && this.resize();\n  }, h.componentWillUnmount = function () {\n    this.clearPendingResizeTimeouts(), this.resizeObserver && this.resizeObserver.disconnect();\n  }, h.onEnd = function (e) {\n    e && function (e) {\n      Object.keys(e).forEach(function (t) {\n        \"undefined\" != typeof document && document.removeEventListener(t, e[t], !1);\n      });\n    }(e), this.hasMoved && this.fireChangeEvent(\"onAfterChange\"), this.setState({\n      pending: !1\n    }), this.hasMoved = !1;\n  }, h.getValue = function () {\n    return i(this.state.value);\n  }, h.getClosestIndex = function (e) {\n    var t = Number.MAX_VALUE,\n        s = -1;\n    var n = this.state.value,\n        i = n.length;\n\n    for (var _o = 0; _o < i; _o += 1) {\n      var _i = this.calcOffset(n[_o]),\n          _r = Math.abs(e - _i);\n\n      _r < t && (t = _r, s = _o);\n    }\n\n    return s;\n  }, h.getMousePosition = function (e) {\n    return [e[\"page\" + this.axisKey()], e[\"page\" + this.orthogonalAxisKey()]];\n  }, h.getTouchPosition = function (e) {\n    var t = e.touches[0];\n    return [t[\"page\" + this.axisKey()], t[\"page\" + this.orthogonalAxisKey()]];\n  }, h.getKeyDownEventMap = function () {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  }, h.getMouseEventMap = function () {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  }, h.getTouchEventMap = function () {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  }, h.getValueFromPosition = function (e) {\n    var t = e / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return r(this.state.startValue + t, this.props);\n  }, h.getDiffPosition = function (e) {\n    var t = e - this.state.startPosition;\n    return this.props.invert && (t *= -1), t;\n  }, h.resize = function () {\n    var e = this.slider,\n        t = this.thumb0;\n    if (!e || !t) return;\n    var s = this.sizeKey(),\n        n = e.getBoundingClientRect(),\n        i = e[s],\n        o = n[this.posMaxKey()],\n        r = n[this.posMinKey()],\n        a = t.getBoundingClientRect()[s.replace(\"client\", \"\").toLowerCase()],\n        p = i - a,\n        u = Math.abs(o - r);\n    this.state.upperBound === p && this.state.sliderLength === u && this.state.thumbSize === a || this.setState({\n      upperBound: p,\n      sliderLength: u,\n      thumbSize: a\n    });\n  }, h.calcOffset = function (e) {\n    var t = this.props.max - this.props.min;\n    if (0 === t) return 0;\n    return (e - this.props.min) / t * this.state.upperBound;\n  }, h.calcValue = function (e) {\n    return e / this.state.upperBound * (this.props.max - this.props.min) + this.props.min;\n  }, h.calcOffsetFromPosition = function (e) {\n    var t = this.slider,\n        s = t.getBoundingClientRect(),\n        n = s[this.posMaxKey()],\n        i = s[this.posMinKey()];\n    var o = e - (window[\"page\" + this.axisKey() + \"Offset\"] + (this.props.invert ? n : i));\n    return this.props.invert && (o = this.state.sliderLength - o), o -= this.state.thumbSize / 2, o;\n  }, h.forceValueFromPosition = function (e, t) {\n    var _this = this;\n\n    var s = this.calcOffsetFromPosition(e),\n        n = this.getClosestIndex(s),\n        i = r(this.calcValue(s), this.props),\n        o = this.state.value.slice();\n    o[n] = i;\n\n    for (var _e2 = 0; _e2 < o.length - 1; _e2 += 1) {\n      if (o[_e2 + 1] - o[_e2] < this.props.minDistance) return;\n    }\n\n    this.fireChangeEvent(\"onBeforeChange\"), this.hasMoved = !0, this.setState({\n      value: o\n    }, function () {\n      t(n), _this.fireChangeEvent(\"onChange\");\n    });\n  }, h.clearPendingResizeTimeouts = function () {\n    do {\n      var _e3 = this.pendingResizeTimeouts.shift();\n\n      clearTimeout(_e3);\n    } while (this.pendingResizeTimeouts.length);\n  }, h.start = function (e, t) {\n    var s = this[\"thumb\" + e];\n    s && s.focus();\n    var n = this.state.zIndices;\n    n.splice(n.indexOf(e), 1), n.push(e), this.setState(function (s) {\n      return {\n        startValue: s.value[e],\n        startPosition: void 0 !== t ? t : s.startPosition,\n        index: e,\n        zIndices: n\n      };\n    });\n  }, h.moveUpByStep = function (e) {\n    void 0 === e && (e = this.props.step);\n    var t = r(this.state.value[this.state.index] + e, this.props);\n    this.move(Math.min(t, this.props.max));\n  }, h.moveDownByStep = function (e) {\n    void 0 === e && (e = this.props.step);\n    var t = r(this.state.value[this.state.index] - e, this.props);\n    this.move(Math.max(t, this.props.min));\n  }, h.move = function (e) {\n    var _this$state = this.state,\n        t = _this$state.index,\n        s = _this$state.value,\n        n = s.length,\n        i = s[t];\n    if (e === i) return;\n    this.hasMoved || this.fireChangeEvent(\"onBeforeChange\"), this.hasMoved = !0;\n    var _this$props = this.props,\n        o = _this$props.pearling,\n        r = _this$props.max,\n        a = _this$props.min,\n        p = _this$props.minDistance;\n\n    if (!o) {\n      if (t > 0) {\n        var _n = s[t - 1];\n        e < _n + p && (e = _n + p);\n      }\n\n      if (t < n - 1) {\n        var _n2 = s[t + 1];\n        e > _n2 - p && (e = _n2 - p);\n      }\n    }\n\n    s[t] = e, o && n > 1 && (e > i ? (this.pushSucceeding(s, p, t), function (e, t, s, n) {\n      for (var _i2 = 0; _i2 < e; _i2 += 1) {\n        var _o2 = n - _i2 * s;\n\n        t[e - 1 - _i2] > _o2 && (t[e - 1 - _i2] = _o2);\n      }\n    }(n, s, p, r)) : e < i && (this.pushPreceding(s, p, t), function (e, t, s, n) {\n      for (var _i3 = 0; _i3 < e; _i3 += 1) {\n        var _e4 = n + _i3 * s;\n\n        t[_i3] < _e4 && (t[_i3] = _e4);\n      }\n    }(n, s, p, a))), this.setState({\n      value: s\n    }, this.fireChangeEvent.bind(this, \"onChange\"));\n  }, h.pushSucceeding = function (e, t, s) {\n    var n, i;\n\n    for (n = s, i = e[n] + t; null !== e[n + 1] && i > e[n + 1]; n += 1, i = e[n] + t) {\n      e[n + 1] = a(i, this.props);\n    }\n  }, h.pushPreceding = function (e, t, s) {\n    for (var _n3 = s, _i4 = e[_n3] - t; null !== e[_n3 - 1] && _i4 < e[_n3 - 1]; _n3 -= 1, _i4 = e[_n3] - t) {\n      e[_n3 - 1] = a(_i4, this.props);\n    }\n  }, h.axisKey = function () {\n    return \"vertical\" === this.props.orientation ? \"Y\" : \"X\";\n  }, h.orthogonalAxisKey = function () {\n    return \"vertical\" === this.props.orientation ? \"X\" : \"Y\";\n  }, h.posMinKey = function () {\n    return \"vertical\" === this.props.orientation ? this.props.invert ? \"bottom\" : \"top\" : this.props.invert ? \"right\" : \"left\";\n  }, h.posMaxKey = function () {\n    return \"vertical\" === this.props.orientation ? this.props.invert ? \"top\" : \"bottom\" : this.props.invert ? \"left\" : \"right\";\n  }, h.sizeKey = function () {\n    return \"vertical\" === this.props.orientation ? \"clientHeight\" : \"clientWidth\";\n  }, h.fireChangeEvent = function (e) {\n    this.props[e] && this.props[e](i(this.state.value), this.state.index);\n  }, h.buildThumbStyle = function (e, t) {\n    var s = {\n      position: \"absolute\",\n      touchAction: \"none\",\n      willChange: this.state.index >= 0 ? this.posMinKey() : \"\",\n      zIndex: this.state.zIndices.indexOf(t) + 1\n    };\n    return s[this.posMinKey()] = e + \"px\", s;\n  }, h.buildTrackStyle = function (e, t) {\n    var s = {\n      position: \"absolute\",\n      willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : \"\"\n    };\n    return s[this.posMinKey()] = e, s[this.posMaxKey()] = t, s;\n  }, h.buildMarkStyle = function (e) {\n    var t;\n    return (t = {\n      position: \"absolute\"\n    })[this.posMinKey()] = e, t;\n  }, h.renderThumbs = function (e) {\n    var t = e.length,\n        s = [];\n\n    for (var _n4 = 0; _n4 < t; _n4 += 1) {\n      s[_n4] = this.buildThumbStyle(e[_n4], _n4);\n    }\n\n    var n = [];\n\n    for (var _e5 = 0; _e5 < t; _e5 += 1) {\n      n[_e5] = this.renderThumb(s[_e5], _e5);\n    }\n\n    return n;\n  }, h.renderTracks = function (e) {\n    var t = [],\n        s = e.length - 1;\n    t.push(this.renderTrack(0, 0, e[0]));\n\n    for (var _n5 = 0; _n5 < s; _n5 += 1) {\n      t.push(this.renderTrack(_n5 + 1, e[_n5], e[_n5 + 1]));\n    }\n\n    return t.push(this.renderTrack(s + 1, e[s], this.state.upperBound)), t;\n  }, h.renderMarks = function () {\n    var _this2 = this;\n\n    var e = this.props.marks;\n    var t = this.props.max - this.props.min + 1;\n    return \"boolean\" == typeof e ? e = Array.from({\n      length: t\n    }).map(function (e, t) {\n      return t;\n    }) : \"number\" == typeof e && (e = Array.from({\n      length: t\n    }).map(function (e, t) {\n      return t;\n    }).filter(function (t) {\n      return t % e == 0;\n    })), e.map(parseFloat).sort(function (e, t) {\n      return e - t;\n    }).map(function (e) {\n      var t = _this2.calcOffset(e),\n          s = {\n        key: e,\n        className: _this2.props.markClassName,\n        style: _this2.buildMarkStyle(t)\n      };\n\n      return _this2.props.renderMark(s);\n    });\n  }, h.render = function () {\n    var _this3 = this;\n\n    var e = [],\n        s = this.state.value,\n        n = s.length;\n\n    for (var _t4 = 0; _t4 < n; _t4 += 1) {\n      e[_t4] = this.calcOffset(s[_t4], _t4);\n    }\n\n    var i = this.props.withTracks ? this.renderTracks(e) : null,\n        o = this.renderThumbs(e),\n        r = this.props.marks ? this.renderMarks() : null;\n    return t.createElement(\"div\", {\n      ref: function ref(e) {\n        _this3.slider = e, _this3.resizeElementRef.current = e;\n      },\n      style: {\n        position: \"relative\"\n      },\n      className: this.props.className + (this.props.disabled ? \" disabled\" : \"\"),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, i, o, r);\n  }, u;\n}(t.Component);\n\np.displayName = \"ReactSlider\", p.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: function pageFn(e) {\n    return 10 * e;\n  },\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: \"horizontal\",\n  className: \"slider\",\n  thumbClassName: \"thumb\",\n  thumbActiveClassName: \"active\",\n  trackClassName: \"track\",\n  markClassName: \"mark\",\n  withTracks: !0,\n  pearling: !1,\n  disabled: !1,\n  snapDragDisabled: !1,\n  invert: !1,\n  marks: [],\n  renderThumb: function renderThumb(e) {\n    return t.createElement(\"div\", e);\n  },\n  renderTrack: function renderTrack(e) {\n    return t.createElement(\"div\", e);\n  },\n  renderMark: function renderMark(e) {\n    return t.createElement(\"span\", e);\n  }\n};\nvar u = p;\nexport { u as default };","map":null,"metadata":{},"sourceType":"module"}