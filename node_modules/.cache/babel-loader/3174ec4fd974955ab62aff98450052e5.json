{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/treewalker\n */\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\n\nvar TreeWalker = /*#__PURE__*/function () {\n  /**\n   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n   *\n   * @constructor\n   * @param {Object} options Object with configuration.\n   * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n   * @param {module:engine/view/position~Position} [options.startPosition] Starting position.\n   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from\n   * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as\n   * {@link module:engine/view/textproxy~TextProxy} (`true`).\n   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n   * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned\n   * twice: for `'elementStart'` and `'elementEnd'`.\n   */\n  function TreeWalker() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TreeWalker);\n\n    if (!options.boundaries && !options.startPosition) {\n      /**\n       * Neither boundaries nor starting position have been defined.\n       *\n       * @error view-tree-walker-no-start-position\n       */\n      throw new CKEditorError('view-tree-walker-no-start-position', null);\n    }\n\n    if (options.direction && options.direction != 'forward' && options.direction != 'backward') {\n      /**\n       * Only `backward` and `forward` direction allowed.\n       *\n       * @error view-tree-walker-unknown-direction\n       */\n      throw new CKEditorError('view-tree-walker-unknown-direction', options.startPosition, {\n        direction: options.direction\n      });\n    }\n    /**\n     * Iterator boundaries.\n     *\n     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n     * on the start of boundary, then `{ done: true }` is returned.\n     *\n     * If boundaries are not defined they are set before first and after last child of the root node.\n     *\n     * @readonly\n     * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries\n     */\n\n\n    this.boundaries = options.boundaries || null;\n    /**\n     * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is\n     * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.\n     *\n     * @readonly\n     * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position\n     */\n\n    if (options.startPosition) {\n      this.position = Position._createAt(options.startPosition);\n    } else {\n      this.position = Position._createAt(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);\n    }\n    /**\n     * Walking direction. Defaults `'forward'`.\n     *\n     * @readonly\n     * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction\n     */\n\n\n    this.direction = options.direction || 'forward';\n    /**\n     * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one\n     * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters\n     */\n\n    this.singleCharacters = !!options.singleCharacters;\n    /**\n     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n     * iterated node will not be returned along with `elementEnd` tag.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow\n     */\n\n    this.shallow = !!options.shallow;\n    /**\n     * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not\n     * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.\n     * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.\n     *\n     * @readonly\n     * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd\n     */\n\n    this.ignoreElementEnd = !!options.ignoreElementEnd;\n    /**\n     * Start boundary parent.\n     *\n     * @private\n     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent\n     */\n\n    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n    /**\n     * End boundary parent.\n     *\n     * @private\n     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent\n     */\n\n    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n   */\n\n\n  _createClass(TreeWalker, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n    /**\n     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n     *\n     * For example:\n     *\n     * \t\twalker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>\n     * \t\twalker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]\n     * \t\twalker.skip( value => false ); // Do not move the position.\n     *\n     * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should\n     * return `true` if the value should be skipped or `false` if not.\n     */\n\n  }, {\n    key: \"skip\",\n    value: function skip(_skip) {\n      var done, value, prevPosition;\n\n      do {\n        prevPosition = this.position;\n\n        var _this$next = this.next();\n\n        done = _this$next.done;\n        value = _this$next.value;\n      } while (!done && _skip(value));\n\n      if (!done) {\n        this.position = prevPosition;\n      }\n    }\n    /**\n     * Gets the next tree walker's value.\n     *\n     * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning\n     * information about taken step.\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.direction == 'forward') {\n        return this._next();\n      } else {\n        return this._previous();\n      }\n    }\n    /**\n     * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.\n     * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n     */\n\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      var position = this.position.clone();\n      var previousPosition = this.position;\n      var parent = position.parent; // We are at the end of the root.\n\n      if (parent.parent === null && position.offset === parent.childCount) {\n        return {\n          done: true\n        };\n      } // We reached the walker boundary.\n\n\n      if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {\n        return {\n          done: true\n        };\n      } // Get node just after current position.\n\n\n      var node; // Text is a specific parent because it contains string instead of child nodes.\n\n      if (parent instanceof Text) {\n        if (position.isAtEnd) {\n          // Prevent returning \"elementEnd\" for Text node. Skip that value and return the next walker step.\n          this.position = Position._createAfter(parent);\n          return this._next();\n        }\n\n        node = parent.data[position.offset];\n      } else {\n        node = parent.getChild(position.offset);\n      }\n\n      if (node instanceof Element) {\n        if (!this.shallow) {\n          position = new Position(node, 0);\n        } else {\n          position.offset++;\n        }\n\n        this.position = position;\n        return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n      } else if (node instanceof Text) {\n        if (this.singleCharacters) {\n          position = new Position(node, 0);\n          this.position = position;\n          return this._next();\n        } else {\n          var charactersCount = node.data.length;\n          var item; // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\n          if (node == this._boundaryEndParent) {\n            charactersCount = this.boundaries.end.offset;\n            item = new TextProxy(node, 0, charactersCount);\n            position = Position._createAfter(item);\n          } else {\n            item = new TextProxy(node, 0, node.data.length); // If not just keep moving forward.\n\n            position.offset++;\n          }\n\n          this.position = position;\n          return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n        }\n      } else if (typeof node == 'string') {\n        var textLength;\n\n        if (this.singleCharacters) {\n          textLength = 1;\n        } else {\n          // Check if text stick out of walker range.\n          var endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;\n          textLength = endOffset - position.offset;\n        }\n\n        var textProxy = new TextProxy(parent, position.offset, textLength);\n        position.offset += textLength;\n        this.position = position;\n        return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n      } else {\n        // `node` is not set, we reached the end of current `parent`.\n        position = Position._createAfter(parent);\n        this.position = position;\n\n        if (this.ignoreElementEnd) {\n          return this._next();\n        } else {\n          return this._formatReturnValue('elementEnd', parent, previousPosition, position);\n        }\n      }\n    }\n    /**\n     * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.\n     *\n     * @private\n     * @returns {Object}\n     * @returns {Boolean} return.done True if iterator is done.\n     * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.\n     */\n\n  }, {\n    key: \"_previous\",\n    value: function _previous() {\n      var position = this.position.clone();\n      var previousPosition = this.position;\n      var parent = position.parent; // We are at the beginning of the root.\n\n      if (parent.parent === null && position.offset === 0) {\n        return {\n          done: true\n        };\n      } // We reached the walker boundary.\n\n\n      if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {\n        return {\n          done: true\n        };\n      } // Get node just before current position.\n\n\n      var node; // Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.\n\n      if (parent instanceof Text) {\n        if (position.isAtStart) {\n          // Prevent returning \"elementStart\" for Text node. Skip that value and return the next walker step.\n          this.position = Position._createBefore(parent);\n          return this._previous();\n        }\n\n        node = parent.data[position.offset - 1];\n      } else {\n        node = parent.getChild(position.offset - 1);\n      }\n\n      if (node instanceof Element) {\n        if (!this.shallow) {\n          position = new Position(node, node.childCount);\n          this.position = position;\n\n          if (this.ignoreElementEnd) {\n            return this._previous();\n          } else {\n            return this._formatReturnValue('elementEnd', node, previousPosition, position);\n          }\n        } else {\n          position.offset--;\n          this.position = position;\n          return this._formatReturnValue('elementStart', node, previousPosition, position, 1);\n        }\n      } else if (node instanceof Text) {\n        if (this.singleCharacters) {\n          position = new Position(node, node.data.length);\n          this.position = position;\n          return this._previous();\n        } else {\n          var charactersCount = node.data.length;\n          var item; // If text stick out of walker range, we need to cut it and wrap in TextProxy.\n\n          if (node == this._boundaryStartParent) {\n            var offset = this.boundaries.start.offset;\n            item = new TextProxy(node, offset, node.data.length - offset);\n            charactersCount = item.data.length;\n            position = Position._createBefore(item);\n          } else {\n            item = new TextProxy(node, 0, node.data.length); // If not just keep moving backward.\n\n            position.offset--;\n          }\n\n          this.position = position;\n          return this._formatReturnValue('text', item, previousPosition, position, charactersCount);\n        }\n      } else if (typeof node == 'string') {\n        var textLength;\n\n        if (!this.singleCharacters) {\n          // Check if text stick out of walker range.\n          var startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;\n          textLength = position.offset - startOffset;\n        } else {\n          textLength = 1;\n        }\n\n        position.offset -= textLength;\n        var textProxy = new TextProxy(parent, position.offset, textLength);\n        this.position = position;\n        return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);\n      } else {\n        // `node` is not set, we reached the beginning of current `parent`.\n        position = Position._createBefore(parent);\n        this.position = position;\n        return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);\n      }\n    }\n    /**\n     * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.\n     *\n     * @private\n     * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.\n     * @param {module:engine/view/item~Item} item Item between old and new position.\n     * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.\n     * @param {module:engine/view/position~Position} nextPosition Next position of iterator.\n     * @param {Number} [length] Length of the item.\n     * @returns {module:engine/view/treewalker~TreeWalkerValue}\n     */\n\n  }, {\n    key: \"_formatReturnValue\",\n    value: function _formatReturnValue(type, item, previousPosition, nextPosition, length) {\n      // Text is a specific parent, because contains string instead of children.\n      // Walker doesn't enter to the Text except situations when walker is iterating over every single character,\n      // or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text\n      // we move it just before or just after Text.\n      if (item instanceof TextProxy) {\n        // Position is at the end of Text.\n        if (item.offsetInText + item.data.length == item.textNode.data.length) {\n          if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {\n            nextPosition = Position._createAfter(item.textNode); // When we change nextPosition of returned value we need also update walker current position.\n\n            this.position = nextPosition;\n          } else {\n            previousPosition = Position._createAfter(item.textNode);\n          }\n        } // Position is at the begining ot the text.\n\n\n        if (item.offsetInText === 0) {\n          if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {\n            nextPosition = Position._createBefore(item.textNode); // When we change nextPosition of returned value we need also update walker current position.\n\n            this.position = nextPosition;\n          } else {\n            previousPosition = Position._createBefore(item.textNode);\n          }\n        }\n      }\n\n      return {\n        done: false,\n        value: {\n          type: type,\n          item: item,\n          previousPosition: previousPosition,\n          nextPosition: nextPosition,\n          length: length\n        }\n      };\n    }\n  }]);\n\n  return TreeWalker;\n}();\n/**\n * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end\n * of node, or `'text'` if walker traversed over single and multiple characters.\n * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.\n *\n * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.\n *\n * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue\n * @property {module:engine/view/treewalker~TreeWalkerValueType} type\n * @property {module:engine/view/item~Item} item Item between the old and the new positions\n * of the tree walker.\n * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the\n * inside of the text to its parent just before or just after that text.\n * @property {Number} [length] Length of the item. For `'elementStart'` it is `1`. For `'text'` it is\n * the length of that text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */\n\n\nexport { TreeWalker as default };","map":null,"metadata":{},"sourceType":"module"}