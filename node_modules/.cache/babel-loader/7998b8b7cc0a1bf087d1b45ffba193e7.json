{"ast":null,"code":"import _objectSpread from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es'; // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nvar graveyardName = '$graveyard';\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots â€“ e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nvar Document = /*#__PURE__*/function () {\n  /**\n   * Creates an empty document instance with no {@link #roots} (other than\n   * the {@link #graveyard graveyard root}).\n   */\n  function Document(model) {\n    var _this = this;\n\n    _classCallCheck(this, Document);\n\n    /**\n     * The {@link module:engine/model/model~Model model} that the document is a part of.\n     *\n     * @readonly\n     * @type {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * The document's history.\n     *\n     * @readonly\n     * @type {module:engine/model/history~History}\n     */\n\n    this.history = new History();\n    /**\n     * The selection in this document.\n     *\n     * @readonly\n     * @type {module:engine/model/documentselection~DocumentSelection}\n     */\n\n    this.selection = new DocumentSelection(this);\n    /**\n     * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n     * {@link #getRoot} to manipulate it.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n     *\n     * @readonly\n     * @type {module:engine/model/differ~Differ}\n     */\n\n    this.differ = new Differ(model.markers);\n    /**\n     * Post-fixer callbacks registered to the model document.\n     *\n     * @private\n     * @type {Set.<Function>}\n     */\n\n    this._postFixers = new Set();\n    /**\n     * A boolean indicates whether the selection has changed until\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    this._hasSelectionChangedFromTheLastChangeBlock = false; // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\n    this.createRoot('$root', graveyardName); // Then, still before an operation is applied on model, buffer the change in differ.\n\n    this.listenTo(model, 'applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        _this.differ.bufferOperation(operation);\n      }\n    }, {\n      priority: 'high'\n    }); // After the operation is applied, bump document's version and add the operation to the history.\n\n    this.listenTo(model, 'applyOperation', function (evt, args) {\n      var operation = args[0];\n\n      if (operation.isDocumentOperation) {\n        _this.history.addOperation(operation);\n      }\n    }, {\n      priority: 'low'\n    }); // Listen to selection changes. If selection changed, mark it.\n\n    this.listenTo(this.selection, 'change', function () {\n      _this._hasSelectionChangedFromTheLastChangeBlock = true;\n    }); // Buffer marker changes.\n    // This is not covered in buffering operations because markers may change outside of them (when they\n    // are modified using `model.markers` collection, not through `MarkerOperation`).\n\n    this.listenTo(model.markers, 'update', function (evt, marker, oldRange, newRange, oldMarkerData) {\n      // Copy the `newRange` to the new marker data as during the marker removal the range is not updated.\n      var newMarkerData = _objectSpread({}, marker.getData(), {\n        range: newRange\n      }); // Whenever marker is updated, buffer that change.\n\n\n      _this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);\n\n      if (oldRange === null) {\n        // If this is a new marker, add a listener that will buffer change whenever marker changes.\n        marker.on('change', function (evt, oldRange) {\n          var markerData = marker.getData();\n\n          _this.differ.bufferMarkerChange(marker.name, _objectSpread({}, markerData, {\n            range: oldRange\n          }), markerData);\n        });\n      }\n    });\n  }\n  /**\n   * The document version. Every applied operation increases the version number. It is used to\n   * ensure that operations are applied on a proper document version.\n   *\n   * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.\n   *\n   * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n   * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.\n   *\n   * @type {Number}\n   */\n\n\n  _createClass(Document, [{\n    key: \"createRoot\",\n\n    /**\n     * Creates a new root.\n     *\n     * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n     * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n     * @param {String} [rootName='main'] A unique root name.\n     * @returns {module:engine/model/rootelement~RootElement} The created root.\n     */\n    value: function createRoot() {\n      var elementName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$root';\n      var rootName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';\n\n      if (this.roots.get(rootName)) {\n        /**\n         * A root with the specified name already exists.\n         *\n         * @error model-document-createroot-name-exists\n         * @param {module:engine/model/document~Document} doc\n         * @param {String} name\n         */\n        throw new CKEditorError('model-document-createroot-name-exists', this, {\n          name: rootName\n        });\n      }\n\n      var root = new RootElement(this, elementName, rootName);\n      this.roots.add(root);\n      return root;\n    }\n    /**\n     * Removes all event listeners set by the document instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.selection.destroy();\n      this.stopListening();\n    }\n    /**\n     * Returns a root by its name.\n     *\n     * @param {String} [name='main'] A unique root name.\n     * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n     * there is no root with the given name.\n     */\n\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n      return this.roots.get(name);\n    }\n    /**\n     * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n     *\n     * @returns {Array.<String>} Roots names.\n     */\n\n  }, {\n    key: \"getRootNames\",\n    value: function getRootNames() {\n      return Array.from(this.roots, function (root) {\n        return root.rootName;\n      }).filter(function (name) {\n        return name != graveyardName;\n      });\n    }\n    /**\n     * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n     * will operate on a correct model state.\n     *\n     * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n     * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n     * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n     * not be fixed in the new document tree state.\n     *\n     * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n     * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n     * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n     * for the user.\n     *\n     * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n     * callback should add an empty paragraph so that the editor is never empty:\n     *\n     *\t\tdocument.registerPostFixer( writer => {\n     *\t\t\tconst changes = document.differ.getChanges();\n     *\n     *\t\t\t// Check if the changes lead to an empty root in the editor.\n     *\t\t\tfor ( const entry of changes ) {\n     *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n     *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n     *\n     *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n     *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n     *\t\t\t\t\treturn true;\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @param {Function} postFixer\n     */\n\n  }, {\n    key: \"registerPostFixer\",\n    value: function registerPostFixer(postFixer) {\n      this._postFixers.add(postFixer);\n    }\n    /**\n     * A custom `toJSON()` method to solve child-parent circular dependencies.\n     *\n     * @returns {Object} A clone of this object with the document property changed to a string.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = clone(this); // Due to circular references we need to remove parent reference.\n\n      json.selection = '[engine.model.DocumentSelection]';\n      json.model = '[engine.model.Model]';\n      return json;\n    }\n    /**\n     * Check if there were any changes done on document, and if so, call post-fixers,\n     * fire `change` event for features and conversion and then reset the differ.\n     * Fire `change:data` event when at least one operation or buffered marker changes the data.\n     *\n     * @protected\n     * @fires change\n     * @fires change:data\n     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n     */\n\n  }, {\n    key: \"_handleChangeBlock\",\n    value: function _handleChangeBlock(writer) {\n      if (this._hasDocumentChangedFromTheLastChangeBlock()) {\n        this._callPostFixers(writer); // Refresh selection attributes according to the final position in the model after the change.\n\n\n        this.selection.refresh();\n\n        if (this.differ.hasDataChanges()) {\n          this.fire('change:data', writer.batch);\n        } else {\n          this.fire('change', writer.batch);\n        } // Theoretically, it is not necessary to refresh selection after change event because\n        // post-fixers are the last who should change the model, but just in case...\n\n\n        this.selection.refresh();\n        this.differ.reset();\n      }\n\n      this._hasSelectionChangedFromTheLastChangeBlock = false;\n    }\n    /**\n     * Returns whether there is a buffered change or if the selection has changed from the last\n     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n     * or {@link module:engine/model/model~Model#change `change()` block}.\n     *\n     * @protected\n     * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n     */\n\n  }, {\n    key: \"_hasDocumentChangedFromTheLastChangeBlock\",\n    value: function _hasDocumentChangedFromTheLastChangeBlock() {\n      return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n    }\n    /**\n     * Returns the default root for this document which is either the first root that was added to the document using\n     * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n     *\n     * @protected\n     * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n     */\n\n  }, {\n    key: \"_getDefaultRoot\",\n    value: function _getDefaultRoot() {\n      var _iterator = _createForOfIteratorHelper(this.roots),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n\n          if (root !== this.graveyard) {\n            return root;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this.graveyard;\n    }\n    /**\n     * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n     * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n     *\n     * @protected\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"_getDefaultRange\",\n    value: function _getDefaultRange() {\n      var defaultRoot = this._getDefaultRoot();\n\n      var model = this.model;\n      var schema = model.schema; // Find the first position where the selection can be put.\n\n      var position = model.createPositionFromPath(defaultRoot, [0]);\n      var nearestRange = schema.getNearestSelectionRange(position); // If valid selection range is not found - return range collapsed at the beginning of the root.\n\n      return nearestRange || model.createRange(position);\n    }\n    /**\n     * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n     * the {@link #selection document's selection}.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range A range to check.\n     * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n     */\n\n  }, {\n    key: \"_validateSelectionRange\",\n    value: function _validateSelectionRange(range) {\n      return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);\n    }\n    /**\n     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n     *\n     * @private\n     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n     */\n\n  }, {\n    key: \"_callPostFixers\",\n    value: function _callPostFixers(writer) {\n      var wasFixed = false;\n\n      do {\n        var _iterator2 = _createForOfIteratorHelper(this._postFixers),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var callback = _step2.value;\n            // Ensure selection attributes are up to date before each post-fixer.\n            // https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n            //\n            // It might be good to refresh the selection after each operation but at the moment it leads\n            // to losing attributes for composition or and spell checking\n            // https://github.com/ckeditor/ckeditor5-typing/issues/188\n            this.selection.refresh();\n            wasFixed = callback(writer);\n\n            if (wasFixed) {\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } while (wasFixed);\n    }\n    /**\n     * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n     * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n     * during that block's execution.\n     *\n     * The changes which this event will cover include:\n     *\n     * * document structure changes,\n     * * selection changes,\n     * * marker changes.\n     *\n     * If you want to be notified about all these changes, then simply listen to this event like this:\n     *\n     *\t\tmodel.document.on( 'change', () => {\n     *\t\t\tconsole.log( 'The document has changed!' );\n     *\t\t} );\n     *\n     * If, however, you only want to be notified about the data changes, then use the\n     * {@link module:engine/model/document~Document#event:change:data change:data} event,\n     * which is fired for document structure changes and marker changes (which affects the data).\n     *\n     *\t\tmodel.document.on( 'change:data', () => {\n     *\t\t\tconsole.log( 'The data has changed!' );\n     *\t\t} );\n     *\n     * @event change\n     * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n     */\n\n    /**\n     * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n     * affect the editor data. This is:\n     *\n     * * document structure changes,\n     * * marker changes (which affects the data).\n     *\n     * If you want to be notified about the data changes, then listen to this event:\n     *\n     *\t\tmodel.document.on( 'change:data', () => {\n     *\t\t\tconsole.log( 'The data has changed!' );\n     *\t\t} );\n     *\n     * If you would like to listen to all document changes, then check out the\n     * {@link module:engine/model/document~Document#event:change change} event.\n     *\n     * @event change:data\n     * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n     */\n    // @if CK_DEBUG_ENGINE // log( version = null ) {\n    // @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n    // @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n    // @if CK_DEBUG_ENGINE // }\n\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this.history.version;\n    },\n    set: function set(version) {\n      this.history.version = version;\n    }\n    /**\n     * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n     *\n     * @readonly\n     * @member {module:engine/model/rootelement~RootElement}\n     */\n\n  }, {\n    key: \"graveyard\",\n    get: function get() {\n      return this.getRoot(graveyardName);\n    }\n  }]);\n\n  return Document;\n}();\n\nexport { Document as default };\nmix(Document, EmitterMixin); // Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\n\nfunction validateTextNodePosition(rangeBoundary) {\n  var textNode = rangeBoundary.textNode;\n\n  if (textNode) {\n    var data = textNode.data;\n    var offset = rangeBoundary.offset - textNode.startOffset;\n    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"module"}