{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widgetresize/resizer\n */\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ResizeState from './resizerstate';\nimport SizeView from './sizeview';\n/**\n * Represents a resizer for a single resizable object.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Resizer = /*#__PURE__*/function () {\n  /**\n   * @param {module:widget/widgetresize~ResizerOptions} options Resizer options.\n   */\n  function Resizer(options) {\n    var _this = this;\n\n    _classCallCheck(this, Resizer);\n\n    /**\n     * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.\n     *\n     * Note that a new state is created for each resize transaction.\n     *\n     * @readonly\n     * @member {module:widget/widgetresize/resizerstate~ResizerState} #state\n     */\n\n    /**\n     * A view displaying the proposed new element size during the resizing.\n     *\n     * @protected\n     * @readonly\n     * @member {module:widget/widgetresize/sizeview~SizeView} #_sizeView\n     */\n\n    /**\n     * Options passed to the {@link #constructor}.\n     *\n     * @private\n     * @type {module:widget/widgetresize~ResizerOptions}\n     */\n    this._options = options;\n    /**\n     * A wrapper that is controlled by the resizer. This is usually a widget element.\n     *\n     * @private\n     * @type {module:engine/view/element~Element|null}\n     */\n\n    this._viewResizerWrapper = null;\n    /**\n     * The width of the resized {@link module:widget/widgetresize~ResizerOptions#viewElement viewElement} before the resizing started.\n     *\n     * @private\n     * @member {Number|String|undefined} #_initialViewWidth\n     */\n\n    /**\n     * @observable\n     */\n\n    this.set('isEnabled', true);\n    this.decorate('begin');\n    this.decorate('cancel');\n    this.decorate('commit');\n    this.decorate('updateSize');\n    this.on('commit', function (event) {\n      // State might not be initialized yet. In this case, prevent further handling and make sure that the resizer is\n      // cleaned up (#5195).\n      if (!_this.state.proposedWidth && !_this.state.proposedWidthPercents) {\n        _this._cleanup();\n\n        event.stop();\n      }\n    }, {\n      priority: 'high'\n    });\n    this.on('change:isEnabled', function () {\n      // We should redraw the resize handles when the plugin is enabled again.\n      // Otherwise they won't show up.\n      if (_this.isEnabled) {\n        _this.redraw();\n      }\n    });\n  }\n  /**\n   * Attaches the resizer to the DOM.\n   */\n\n\n  _createClass(Resizer, [{\n    key: \"attach\",\n    value: function attach() {\n      var _this2 = this;\n\n      var that = this;\n      var widgetElement = this._options.viewElement;\n      var editingView = this._options.editor.editing.view;\n      editingView.change(function (writer) {\n        var viewResizerWrapper = writer.createUIElement('div', {\n          class: 'ck ck-reset_all ck-widget__resizer'\n        }, function (domDocument) {\n          var domElement = this.toDomElement(domDocument);\n\n          that._appendHandles(domElement);\n\n          that._appendSizeUI(domElement);\n\n          that.on('change:isEnabled', function (evt, propName, newValue) {\n            domElement.style.display = newValue ? '' : 'none';\n          });\n          domElement.style.display = that.isEnabled ? '' : 'none';\n          return domElement;\n        }); // Append the resizer wrapper to the widget's wrapper.\n\n        writer.insert(writer.createPositionAt(widgetElement, 'end'), viewResizerWrapper);\n        writer.addClass('ck-widget_with-resizer', widgetElement);\n        _this2._viewResizerWrapper = viewResizerWrapper;\n      });\n    }\n    /**\n     * Starts the resizing process.\n     *\n     * Creates a new {@link #state} for the current process.\n     *\n     * @fires begin\n     * @param {HTMLElement} domResizeHandle Clicked handle.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin(domResizeHandle) {\n      this.state = new ResizeState(this._options);\n\n      this._sizeView._bindToState(this._options, this.state);\n\n      this._initialViewWidth = this._options.viewElement.getStyle('width');\n      this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());\n    }\n    /**\n     * Updates the proposed size based on `domEventData`.\n     *\n     * @fires updateSize\n     * @param {Event} domEventData\n     */\n\n  }, {\n    key: \"updateSize\",\n    value: function updateSize(domEventData) {\n      var _this3 = this;\n\n      var newSize = this._proposeNewSize(domEventData);\n\n      var editingView = this._options.editor.editing.view;\n      editingView.change(function (writer) {\n        var unit = _this3._options.unit || '%';\n        var newWidth = (unit === '%' ? newSize.widthPercents : newSize.width) + unit;\n        writer.setStyle('width', newWidth, _this3._options.viewElement);\n      }); // Get an actual image width, and:\n      // * reflect this size to the resize wrapper\n      // * apply this **real** size to the state\n\n      var domHandleHost = this._getHandleHost();\n\n      var domHandleHostRect = new Rect(domHandleHost);\n      newSize.handleHostWidth = Math.round(domHandleHostRect.width);\n      newSize.handleHostHeight = Math.round(domHandleHostRect.height); // Handle max-width limitation.\n\n      var domResizeHostRect = new Rect(domHandleHost);\n      newSize.width = Math.round(domResizeHostRect.width);\n      newSize.height = Math.round(domResizeHostRect.height);\n      this.redraw(domHandleHostRect);\n      this.state.update(newSize);\n    }\n    /**\n     * Applies the geometry proposed with the resizer.\n     *\n     * @fires commit\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var _this4 = this;\n\n      var unit = this._options.unit || '%';\n      var newValue = (unit === '%' ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit; // Both cleanup and onCommit callback are very likely to make view changes. Ensure that it is made in a single step.\n\n      this._options.editor.editing.view.change(function () {\n        _this4._cleanup();\n\n        _this4._options.onCommit(newValue);\n      });\n    }\n    /**\n     * Cancels and rejects the proposed resize dimensions, hiding the UI.\n     *\n     * @fires cancel\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._cleanup();\n    }\n    /**\n     * Destroys the resizer.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.cancel();\n    }\n    /**\n     * Redraws the resizer.\n     *\n     * @param {module:utils/dom/rect~Rect} [handleHostRect] Handle host rectangle might be given to improve performance.\n     */\n\n  }, {\n    key: \"redraw\",\n    value: function redraw(handleHostRect) {\n      var domWrapper = this._domResizerWrapper; // Refresh only if resizer exists in the DOM.\n\n      if (!existsInDom(domWrapper)) {\n        return;\n      }\n\n      var widgetWrapper = domWrapper.parentElement;\n\n      var handleHost = this._getHandleHost();\n\n      var resizerWrapper = this._viewResizerWrapper;\n      var currentDimensions = [resizerWrapper.getStyle('width'), resizerWrapper.getStyle('height'), resizerWrapper.getStyle('left'), resizerWrapper.getStyle('top')];\n      var newDimensions;\n\n      if (widgetWrapper.isSameNode(handleHost)) {\n        var clientRect = handleHostRect || new Rect(handleHost);\n        newDimensions = [clientRect.width + 'px', clientRect.height + 'px', undefined, undefined];\n      } // In case a resizing host is not a widget wrapper, we need to compensate\n      // for any additional offsets the resize host might have. E.g. wrapper padding\n      // or simply another editable. By doing that the border and resizers are shown\n      // only around the resize host.\n      else {\n        newDimensions = [handleHost.offsetWidth + 'px', handleHost.offsetHeight + 'px', handleHost.offsetLeft + 'px', handleHost.offsetTop + 'px'];\n      } // Make changes to the view only if the resizer should actually get new dimensions.\n      // Otherwise, if View#change() was always called, this would cause EditorUI#update\n      // loops because the WidgetResize plugin listens to EditorUI#update and updates\n      // the resizer.\n      // https://github.com/ckeditor/ckeditor5/issues/7633\n\n\n      if (compareArrays(currentDimensions, newDimensions) !== 'same') {\n        this._options.editor.editing.view.change(function (writer) {\n          writer.setStyle({\n            width: newDimensions[0],\n            height: newDimensions[1],\n            left: newDimensions[2],\n            top: newDimensions[3]\n          }, resizerWrapper);\n        });\n      }\n    }\n  }, {\n    key: \"containsHandle\",\n    value: function containsHandle(domElement) {\n      return this._domResizerWrapper.contains(domElement);\n    }\n  }, {\n    key: \"_cleanup\",\n\n    /**\n     * Cleans up the context state.\n     *\n     * @protected\n     */\n    value: function _cleanup() {\n      var _this5 = this;\n\n      this._sizeView._dismiss();\n\n      var editingView = this._options.editor.editing.view;\n      editingView.change(function (writer) {\n        writer.setStyle('width', _this5._initialViewWidth, _this5._options.viewElement);\n      });\n    }\n    /**\n     * Calculates the proposed size as the resize handles are dragged.\n     *\n     * @private\n     * @param {Event} domEventData Event data that caused the size update request. It should be used to calculate the proposed size.\n     * @returns {Object} return\n     * @returns {Number} return.width Proposed width.\n     * @returns {Number} return.height Proposed height.\n     */\n\n  }, {\n    key: \"_proposeNewSize\",\n    value: function _proposeNewSize(domEventData) {\n      var state = this.state;\n      var currentCoordinates = extractCoordinates(domEventData);\n      var isCentered = this._options.isCentered ? this._options.isCentered(this) : true; // Enlargement defines how much the resize host has changed in a given axis. Naturally it could be a negative number\n      // meaning that it has been shrunk.\n      //\n      // +----------------+--+\n      // |                |  |\n      // |       img      |  |\n      // |  /handle host  |  |\n      // +----------------+  | ^\n      // |                   | | - enlarge y\n      // +-------------------+ v\n      // \t\t\t\t\t<-->\n      // \t\t\t\t\t enlarge x\n\n      var enlargement = {\n        x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),\n        y: currentCoordinates.y - state.originalHeight - state._referenceCoordinates.y\n      };\n\n      if (isCentered && state.activeHandlePosition.endsWith('-right')) {\n        enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);\n      } // Objects needs to be resized twice as much in horizontal axis if centered, since enlargement is counted from\n      // one resized corner to your cursor. It needs to be duplicated to compensate for the other side too.\n\n\n      if (isCentered) {\n        enlargement.x *= 2;\n      } // const resizeHost = this._getResizeHost();\n      // The size proposed by the user. It does not consider the aspect ratio.\n\n\n      var proposedSize = {\n        width: Math.abs(state.originalWidth + enlargement.x),\n        height: Math.abs(state.originalHeight + enlargement.y)\n      }; // Dominant determination must take the ratio into account.\n\n      proposedSize.dominant = proposedSize.width / state.aspectRatio > proposedSize.height ? 'width' : 'height';\n      proposedSize.max = proposedSize[proposedSize.dominant]; // Proposed size, respecting the aspect ratio.\n\n      var targetSize = {\n        width: proposedSize.width,\n        height: proposedSize.height\n      };\n\n      if (proposedSize.dominant == 'width') {\n        targetSize.height = targetSize.width / state.aspectRatio;\n      } else {\n        targetSize.width = targetSize.height * state.aspectRatio;\n      }\n\n      return {\n        width: Math.round(targetSize.width),\n        height: Math.round(targetSize.height),\n        widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * targetSize.width * 100) / 100, 100)\n      };\n    }\n    /**\n     * Obtains the resize host.\n     *\n     * Resize host is an object that receives dimensions which are the result of resizing.\n     *\n     * @protected\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"_getResizeHost\",\n    value: function _getResizeHost() {\n      var widgetWrapper = this._domResizerWrapper.parentElement;\n      return this._options.getResizeHost(widgetWrapper);\n    }\n    /**\n     * Obtains the handle host.\n     *\n     * Handle host is an object that the handles are aligned to.\n     *\n     * Handle host will not always be an entire widget itself. Take an image as an example. The image widget\n     * contains an image and a caption. Only the image should be surrounded with handles.\n     *\n     * @protected\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"_getHandleHost\",\n    value: function _getHandleHost() {\n      var widgetWrapper = this._domResizerWrapper.parentElement;\n      return this._options.getHandleHost(widgetWrapper);\n    }\n    /**\n     * DOM container of the entire resize UI.\n     *\n     * Note that this property will have a value only after the element bound with the resizer is rendered\n     * (otherwise `null`).\n     *\n     * @private\n     * @member {HTMLElement|null}\n     */\n\n  }, {\n    key: \"_appendHandles\",\n\n    /**\n     * Renders the resize handles in the DOM.\n     *\n     * @private\n     * @param {HTMLElement} domElement The resizer wrapper.\n     */\n    value: function _appendHandles(domElement) {\n      var resizerPositions = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];\n\n      for (var _i = 0, _resizerPositions = resizerPositions; _i < _resizerPositions.length; _i++) {\n        var currentPosition = _resizerPositions[_i];\n        domElement.appendChild(new Template({\n          tag: 'div',\n          attributes: {\n            class: \"ck-widget__resizer__handle \".concat(getResizerClass(currentPosition))\n          }\n        }).render());\n      }\n    }\n    /**\n     * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.\n     *\n     * @private\n     * @param {HTMLElement} domElement\n     */\n\n  }, {\n    key: \"_appendSizeUI\",\n    value: function _appendSizeUI(domElement) {\n      this._sizeView = new SizeView(); // Make sure icon#element is rendered before passing to appendChild().\n\n      this._sizeView.render();\n\n      domElement.appendChild(this._sizeView.element);\n    }\n    /**\n     * @event begin\n     */\n\n    /**\n     * @event updateSize\n     */\n\n    /**\n     * @event commit\n     */\n\n    /**\n     * @event cancel\n     */\n\n  }, {\n    key: \"_domResizerWrapper\",\n    get: function get() {\n      return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);\n    }\n  }], [{\n    key: \"isResizeHandle\",\n    value: function isResizeHandle(domElement) {\n      return domElement.classList.contains('ck-widget__resizer__handle');\n    }\n  }]);\n\n  return Resizer;\n}();\n\nexport { Resizer as default };\nmix(Resizer, ObservableMixin); // @private\n// @param {String} resizerPosition Expected resizer position like `\"top-left\"`, `\"bottom-right\"`.\n// @returns {String} A prefixed HTML class name for the resizer element\n\nfunction getResizerClass(resizerPosition) {\n  return \"ck-widget__resizer__handle-\".concat(resizerPosition);\n}\n\nfunction extractCoordinates(event) {\n  return {\n    x: event.pageX,\n    y: event.pageY\n  };\n}\n\nfunction existsInDom(element) {\n  return element && element.ownerDocument && element.ownerDocument.contains(element);\n}","map":null,"metadata":{},"sourceType":"module"}