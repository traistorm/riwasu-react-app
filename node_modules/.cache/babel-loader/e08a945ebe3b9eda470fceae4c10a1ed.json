{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/attributeoperation\n */\nimport Operation from './operation';\nimport Range from '../range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport { _setAttribute } from './utils';\nimport { isEqual } from 'lodash-es';\n/**\n * Operation to change nodes' attribute.\n *\n * Using this class you can add, remove or change value of the attribute.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\n\nvar AttributeOperation = /*#__PURE__*/function (_Operation) {\n  _inherits(AttributeOperation, _Operation);\n\n  /**\n   * Creates an operation that changes, removes or adds attributes.\n   *\n   * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not\n   * have an attribute with the same key as the added attribute.\n   *\n   * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range\n   * must have an attribute with that key added.\n   *\n   * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in\n   * operation's ranges must already have an attribute with given key and `oldValue` as value\n   *\n   * @param {module:engine/model/range~Range} range Range on which the operation should be applied. Must be a flat range.\n   * @param {String} key Key of an attribute to change or remove.\n   * @param {*} oldValue Old value of the attribute with given key or `null`, if attribute was not set before.\n   * @param {*} newValue New value of the attribute with given key or `null`, if operation should remove attribute.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  function AttributeOperation(range, key, oldValue, newValue, baseVersion) {\n    var _this;\n\n    _classCallCheck(this, AttributeOperation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AttributeOperation).call(this, baseVersion));\n    /**\n     * Range on which operation should be applied.\n     *\n     * @readonly\n     * @member {module:engine/model/range~Range}\n     */\n\n    _this.range = range.clone();\n    /**\n     * Key of an attribute to change or remove.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    _this.key = key;\n    /**\n     * Old value of the attribute with given key or `null`, if attribute was not set before.\n     *\n     * @readonly\n     * @member {*}\n     */\n\n    _this.oldValue = oldValue === undefined ? null : oldValue;\n    /**\n     * New value of the attribute with given key or `null`, if operation should remove attribute.\n     *\n     * @readonly\n     * @member {*}\n     */\n\n    _this.newValue = newValue === undefined ? null : newValue;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(AttributeOperation, [{\n    key: \"clone\",\n\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation} Clone of this operation.\n     */\n    value: function clone() {\n      return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}\n     */\n\n  }, {\n    key: \"getReversed\",\n    value: function getReversed() {\n      return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(AttributeOperation.prototype), \"toJSON\", this).call(this);\n\n      json.range = this.range.toJSON();\n      return json;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate() {\n      if (!this.range.isFlat) {\n        /**\n         * The range to change is not flat.\n         *\n         * @error attribute-operation-range-not-flat\n         */\n        throw new CKEditorError('attribute-operation-range-not-flat', this);\n      }\n\n      var _iterator = _createForOfIteratorHelper(this.range.getItems({\n        shallow: true\n      })),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n\n          if (this.oldValue !== null && !isEqual(item.getAttribute(this.key), this.oldValue)) {\n            /**\n             * Changed node has different attribute value than operation's old attribute value.\n             *\n             * @error attribute-operation-wrong-old-value\n             * @param {module:engine/model/item~Item} item\n             * @param {String} key\n             * @param {*} value\n             */\n            throw new CKEditorError('attribute-operation-wrong-old-value', this, {\n              item: item,\n              key: this.key,\n              value: this.oldValue\n            });\n          }\n\n          if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {\n            /**\n             * The attribute with given key already exists for the given node.\n             *\n             * @error attribute-operation-attribute-exists\n             * @param {module:engine/model/node~Node} node\n             * @param {String} key\n             */\n            throw new CKEditorError('attribute-operation-attribute-exists', this, {\n              node: item,\n              key: this.key\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute() {\n      // If value to set is same as old value, don't do anything.\n      if (!isEqual(this.oldValue, this.newValue)) {\n        // Execution.\n        _setAttribute(this.range, this.key, this.newValue);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      if (this.oldValue === null) {\n        return 'addAttribute';\n      } else if (this.newValue === null) {\n        return 'removeAttribute';\n      } else {\n        return 'changeAttribute';\n      }\n    }\n  }], [{\n    key: \"fromJSON\",\n\n    /**\n     * Creates `AttributeOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}\n     */\n    value: function fromJSON(json, document) {\n      return new AttributeOperation(Range.fromJSON(json.range, document), json.key, json.oldValue, json.newValue, json.baseVersion);\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \treturn `AttributeOperation( ${ this.baseVersion } ): ` +\n    // @if CK_DEBUG_ENGINE //\t\t`\"${ this.key }\": ${ JSON.stringify( this.oldValue ) }` +\n    // @if CK_DEBUG_ENGINE //\t\t` -> ${ JSON.stringify( this.newValue ) }, ${ this.range }`;\n    // @if CK_DEBUG_ENGINE // }\n\n  }, {\n    key: \"className\",\n    get: function get() {\n      return 'AttributeOperation';\n    }\n  }]);\n\n  return AttributeOperation;\n}(Operation);\n\nexport { AttributeOperation as default };","map":null,"metadata":{},"sourceType":"module"}