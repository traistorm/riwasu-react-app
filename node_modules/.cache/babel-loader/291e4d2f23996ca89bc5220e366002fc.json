{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/range\n */\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\n\nvar Range = /*#__PURE__*/function () {\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * @param {module:engine/model/position~Position} start The start position.\n   * @param {module:engine/model/position~Position} [end] The end position. If not set,\n   * the range will be collapsed at the `start` position.\n   */\n  function Range(start) {\n    var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Range);\n\n    /**\n     * Start position.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position}\n     */\n    this.start = Position._createAt(start);\n    /**\n     * End position.\n     *\n     * @readonly\n     * @member {module:engine/model/position~Position}\n     */\n\n    this.end = end ? Position._createAt(end) : Position._createAt(start); // If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n    // In other case, make the boundaries stick to the \"inside\" of the range.\n\n    this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n    this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n  }\n  /**\n   * Iterable interface.\n   *\n   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n   * them together with additional information like length or {@link module:engine/model/position~Position positions},\n   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n   *\n   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n   * and `ignoreElementEnd` option set to `true`.\n   *\n   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n   */\n\n\n  _createClass(Range, [{\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(new TreeWalker({\n                boundaries: this,\n                ignoreElementEnd: true\n              }), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this);\n    })\n    /**\n     * Returns whether the range is collapsed, that is if {@link #start} and\n     * {@link #end} positions are equal.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"containsPosition\",\n\n    /**\n     * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n     *\n     * @param {module:engine/model/position~Position} position Position to check.\n     * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n     * in this range,`false` otherwise.\n     */\n    value: function containsPosition(position) {\n      return position.isAfter(this.start) && position.isBefore(this.end);\n    }\n    /**\n     * Checks whether this range contains given {@link ~Range range}.\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to check.\n     * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n     * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n     */\n\n  }, {\n    key: \"containsRange\",\n    value: function containsRange(otherRange) {\n      var loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (otherRange.isCollapsed) {\n        loose = false;\n      }\n\n      var containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);\n      var containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);\n      return containsStart && containsEnd;\n    }\n    /**\n     * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n     *\n     * @param {module:engine/model/item~Item} item Model item to check.\n     */\n\n  }, {\n    key: \"containsItem\",\n    value: function containsItem(item) {\n      var pos = Position._createBefore(item);\n\n      return this.containsPosition(pos) || this.start.isEqual(pos);\n    }\n    /**\n     * Checks whether this object is of the given.\n     *\n     *\t\trange.is( 'range' ); // -> true\n     *\t\trange.is( 'model:range' ); // -> true\n     *\n     *\t\trange.is( 'view:range' ); // -> false\n     *\t\trange.is( 'documentSelection' ); // -> false\n     *\n     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n     *\n     * @param {String} type\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type === 'range' || type === 'model:range';\n    }\n    /**\n     * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(otherRange) {\n      return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);\n    }\n    /**\n     * Checks and returns whether this range intersects with given range.\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to compare with.\n     * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n     */\n\n  }, {\n    key: \"isIntersecting\",\n    value: function isIntersecting(otherRange) {\n      return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);\n    }\n    /**\n     * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n     * Returned array contains zero, one or two {@link ~Range ranges}.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n     *\t\tlet transformed = range.getDifference( otherRange );\n     *\t\t// transformed array has no ranges because `otherRange` contains `range`\n     *\n     *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n     *\n     *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n     *\t\ttransformed = range.getDifference( otherRange );\n     *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n     * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n     */\n\n  }, {\n    key: \"getDifference\",\n    value: function getDifference(otherRange) {\n      var ranges = [];\n\n      if (this.isIntersecting(otherRange)) {\n        // Ranges intersect.\n        if (this.containsPosition(otherRange.start)) {\n          // Given range start is inside this range. This means that we have to\n          // add shrunken range - from the start to the middle of this range.\n          ranges.push(new Range(this.start, otherRange.start));\n        }\n\n        if (this.containsPosition(otherRange.end)) {\n          // Given range end is inside this range. This means that we have to\n          // add shrunken range - from the middle of this range to the end.\n          ranges.push(new Range(otherRange.end, this.end));\n        }\n      } else {\n        // Ranges do not intersect, return the original range.\n        ranges.push(new Range(this.start, this.end));\n      }\n\n      return ranges;\n    }\n    /**\n     * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n     *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n     *\n     *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n     *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n     * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(otherRange) {\n      if (this.isIntersecting(otherRange)) {\n        // Ranges intersect, so a common range will be returned.\n        // At most, it will be same as this range.\n        var commonRangeStart = this.start;\n        var commonRangeEnd = this.end;\n\n        if (this.containsPosition(otherRange.start)) {\n          // Given range start is inside this range. This means thaNt we have to\n          // shrink common range to the given range start.\n          commonRangeStart = otherRange.start;\n        }\n\n        if (this.containsPosition(otherRange.end)) {\n          // Given range end is inside this range. This means that we have to\n          // shrink common range to the given range end.\n          commonRangeEnd = otherRange.end;\n        }\n\n        return new Range(commonRangeStart, commonRangeEnd);\n      } // Ranges do not intersect, so they do not have common part.\n\n\n      return null;\n    }\n    /**\n     * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.\n     * If ranges have no common part, returns `null`.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet otherRange = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 1 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 2 ] )\n    \t *\t\t);\n     *\t\tlet transformed = range.getJoined( otherRange ); // null - ranges have no common part\n     *\n     *\t\totherRange = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 3 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 5 ] )\n     *\t\t);\n     *\t\ttransformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]\n     *\n     * @param {module:engine/model/range~Range} otherRange Range to be joined.\n     * @param {Boolean} [loose=false] Whether the intersection check is loose or strict. If the check is strict (`false`),\n     * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),\n     * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.\n     * @returns {module:engine/model/range~Range|null} A sum of given ranges or `null` if ranges have no common part.\n     */\n\n  }, {\n    key: \"getJoined\",\n    value: function getJoined(otherRange) {\n      var loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var shouldJoin = this.isIntersecting(otherRange);\n\n      if (!shouldJoin) {\n        if (this.start.isBefore(otherRange.start)) {\n          shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);\n        } else {\n          shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);\n        }\n      }\n\n      if (!shouldJoin) {\n        return null;\n      }\n\n      var startPosition = this.start;\n      var endPosition = this.end;\n\n      if (otherRange.start.isBefore(startPosition)) {\n        startPosition = otherRange.start;\n      }\n\n      if (otherRange.end.isAfter(endPosition)) {\n        endPosition = otherRange.end;\n      }\n\n      return new Range(startPosition, endPosition);\n    }\n    /**\n     * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n     *\n     * See an example of a model structure (`[` and `]` are range boundaries):\n     *\n     *\t\troot                                                            root\n     *\t\t |- element DIV                         DIV             P2              P3             DIV\n     *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n     *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n     *\t\t |   |- element P1\n     *\t\t |   |   |- \"lorem\"                                              ||\n     *\t\t |- element P2                                                   ||\n     *\t\t |   |- \"foo\"                                                    VV\n     *\t\t |- element P3\n     *\t\t |   |- \"bar\"                                                   root\n     *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n     *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n     *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n     *\t\t |   |- element P4\n     *\t\t |   |   |- \"ipsum\"\n     *\n     * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n     * We are looking for minimal set of flat ranges that contains the same nodes.\n     *\n     * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n     *\n     *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n     *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n     *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n     *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n     *\n     * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n     * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n     * were omitted. Only their parts that were wholly in the range were returned.\n     *\n     * **Note:** this method is not returning flat ranges that contain no nodes.\n     *\n     * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n     */\n\n  }, {\n    key: \"getMinimalFlatRanges\",\n    value: function getMinimalFlatRanges() {\n      var ranges = [];\n      var diffAt = this.start.getCommonPath(this.end).length;\n\n      var pos = Position._createAt(this.start);\n\n      var posParent = pos.parent; // Go up.\n\n      while (pos.path.length > diffAt + 1) {\n        var howMany = posParent.maxOffset - pos.offset;\n\n        if (howMany !== 0) {\n          ranges.push(new Range(pos, pos.getShiftedBy(howMany)));\n        }\n\n        pos.path = pos.path.slice(0, -1);\n        pos.offset++;\n        posParent = posParent.parent;\n      } // Go down.\n\n\n      while (pos.path.length <= this.end.path.length) {\n        var offset = this.end.path[pos.path.length - 1];\n\n        var _howMany = offset - pos.offset;\n\n        if (_howMany !== 0) {\n          ranges.push(new Range(pos, pos.getShiftedBy(_howMany)));\n        }\n\n        pos.offset = offset;\n        pos.path.push(0);\n      }\n\n      return ranges;\n    }\n    /**\n     * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n     *\n     * For example, to iterate over all items in the entire document root:\n     *\n     *\t\t// Create a range spanning over the entire root content:\n     *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n     *\n     *\t\t// Iterate over all items in this range:\n     *\t\tfor ( const value of range.getWalker() ) {\n     *\t\t\tconsole.log( value.item );\n     *\t\t}\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     * @param {module:engine/model/position~Position} [options.startPosition]\n     * @param {Boolean} [options.singleCharacters=false]\n     * @param {Boolean} [options.shallow=false]\n     * @param {Boolean} [options.ignoreElementEnd=false]\n     * @returns {module:engine/model/treewalker~TreeWalker}\n     */\n\n  }, {\n    key: \"getWalker\",\n    value: function getWalker() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      options.boundaries = this;\n      return new TreeWalker(options);\n    }\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n     * them.\n     *\n     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n     * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n     * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} [options] Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/model/item~Item>}\n     */\n\n  }, {\n    key: \"getItems\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getItems() {\n      var options,\n          treeWalker,\n          _iterator,\n          _step,\n          _value,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.wrap(function getItems$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n              options.boundaries = this;\n              options.ignoreElementEnd = true;\n              treeWalker = new TreeWalker(options);\n              _iterator = _createForOfIteratorHelper(treeWalker);\n              _context2.prev = 5;\n\n              _iterator.s();\n\n            case 7:\n              if ((_step = _iterator.n()).done) {\n                _context2.next = 13;\n                break;\n              }\n\n              _value = _step.value;\n              _context2.next = 11;\n              return _value.item;\n\n            case 11:\n              _context2.next = 7;\n              break;\n\n            case 13:\n              _context2.next = 18;\n              break;\n\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](5);\n\n              _iterator.e(_context2.t0);\n\n            case 18:\n              _context2.prev = 18;\n\n              _iterator.f();\n\n              return _context2.finish(18);\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getItems, this, [[5, 15, 18, 21]]);\n    })\n    /**\n     * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n     * contained in this range.\n     *\n     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n     * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n     *\n     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n     * a full list of available options.\n     *\n     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n     * @returns {Iterable.<module:engine/model/position~Position>}\n     */\n\n  }, {\n    key: \"getPositions\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getPositions() {\n      var options,\n          treeWalker,\n          _iterator2,\n          _step2,\n          _value2,\n          _args3 = arguments;\n\n      return _regeneratorRuntime.wrap(function getPositions$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n              options.boundaries = this;\n              treeWalker = new TreeWalker(options);\n              _context3.next = 5;\n              return treeWalker.position;\n\n            case 5:\n              _iterator2 = _createForOfIteratorHelper(treeWalker);\n              _context3.prev = 6;\n\n              _iterator2.s();\n\n            case 8:\n              if ((_step2 = _iterator2.n()).done) {\n                _context3.next = 14;\n                break;\n              }\n\n              _value2 = _step2.value;\n              _context3.next = 12;\n              return _value2.nextPosition;\n\n            case 12:\n              _context3.next = 8;\n              break;\n\n            case 14:\n              _context3.next = 19;\n              break;\n\n            case 16:\n              _context3.prev = 16;\n              _context3.t0 = _context3[\"catch\"](6);\n\n              _iterator2.e(_context3.t0);\n\n            case 19:\n              _context3.prev = 19;\n\n              _iterator2.f();\n\n              return _context3.finish(19);\n\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, getPositions, this, [[6, 16, 19, 22]]);\n    })\n    /**\n     * Returns a range that is a result of transforming this range by given `operation`.\n     *\n     * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n     * moved to a different part of document tree). For this reason, an array is returned by this method and it\n     * may contain one or more `Range` instances.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n     * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n     */\n\n  }, {\n    key: \"getTransformedByOperation\",\n    value: function getTransformedByOperation(operation) {\n      switch (operation.type) {\n        case 'insert':\n          return this._getTransformedByInsertOperation(operation);\n\n        case 'move':\n        case 'remove':\n        case 'reinsert':\n          return this._getTransformedByMoveOperation(operation);\n\n        case 'split':\n          return [this._getTransformedBySplitOperation(operation)];\n\n        case 'merge':\n          return [this._getTransformedByMergeOperation(operation)];\n      }\n\n      return [new Range(this.start, this.end)];\n    }\n    /**\n     * Returns a range that is a result of transforming this range by multiple `operations`.\n     *\n     * @see ~Range#getTransformedByOperation\n     * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n     * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n     */\n\n  }, {\n    key: \"getTransformedByOperations\",\n    value: function getTransformedByOperations(operations) {\n      var ranges = [new Range(this.start, this.end)];\n\n      var _iterator3 = _createForOfIteratorHelper(operations),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var operation = _step3.value;\n\n          for (var _i = 0; _i < ranges.length; _i++) {\n            var result = ranges[_i].getTransformedByOperation(operation);\n\n            ranges.splice.apply(ranges, [_i, 1].concat(_toConsumableArray(result)));\n            _i += result.length - 1;\n          }\n        } // It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n        // \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n        // because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n        // are inside other ranges and we simply remove them.\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n\n        for (var j = i + 1; j < ranges.length; j++) {\n          var next = ranges[j];\n\n          if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {\n            ranges.splice(j, 1);\n          }\n        }\n      }\n\n      return ranges;\n    }\n    /**\n     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n     * which is a common ancestor of the range's both ends (in which the entire range is contained).\n     *\n     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor() {\n      return this.start.getCommonAncestor(this.end);\n    }\n    /**\n     * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n     * The element will be returned when it is the **only** node within the range and **fully–contained**\n     * at the same time.\n     *\n     * @returns {module:engine/model/element~Element|null}\n     */\n\n  }, {\n    key: \"getContainedElement\",\n    value: function getContainedElement() {\n      if (this.isCollapsed) {\n        return null;\n      }\n\n      var nodeAfterStart = this.start.nodeAfter;\n      var nodeBeforeEnd = this.end.nodeBefore;\n\n      if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {\n        return nodeAfterStart;\n      }\n\n      return null;\n    }\n    /**\n     * Converts `Range` to plain object and returns it.\n     *\n     * @returns {Object} `Node` converted to plain object.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        start: this.start.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n    /**\n     * Returns a new range that is equal to current range.\n     *\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.start, this.end);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by insert operation.\n     *\n     * One or more ranges may be returned as a result of this transformation.\n     *\n     * @protected\n     * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n     * @returns {Array.<module:engine/model/range~Range>}\n     */\n\n  }, {\n    key: \"_getTransformedByInsertOperation\",\n    value: function _getTransformedByInsertOperation(operation) {\n      var spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this._getTransformedByInsertion(operation.position, operation.howMany, spread);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by move operation.\n     *\n     * One or more ranges may be returned as a result of this transformation.\n     *\n     * @protected\n     * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n     * @returns {Array.<module:engine/model/range~Range>}\n     */\n\n  }, {\n    key: \"_getTransformedByMoveOperation\",\n    value: function _getTransformedByMoveOperation(operation) {\n      var spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var sourcePosition = operation.sourcePosition;\n      var howMany = operation.howMany;\n      var targetPosition = operation.targetPosition;\n      return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by split operation.\n     *\n     * Always one range is returned. The transformation is done in a way to not break the range.\n     *\n     * @protected\n     * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"_getTransformedBySplitOperation\",\n    value: function _getTransformedBySplitOperation(operation) {\n      var start = this.start._getTransformedBySplitOperation(operation);\n\n      var end = this.end._getTransformedBySplitOperation(operation);\n\n      if (this.end.isEqual(operation.insertionPosition)) {\n        end = this.end.getShiftedBy(1);\n      } // Below may happen when range contains graveyard element used by split operation.\n\n\n      if (start.root != end.root) {\n        // End position was next to the moved graveyard element and was moved with it.\n        // Fix it by using old `end` which has proper `root`.\n        end = this.end.getShiftedBy(-1);\n      }\n\n      return new Range(start, end);\n    }\n    /**\n     * Returns a result of transforming a copy of this range by merge operation.\n     *\n     * Always one range is returned. The transformation is done in a way to not break the range.\n     *\n     * @protected\n     * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"_getTransformedByMergeOperation\",\n    value: function _getTransformedByMergeOperation(operation) {\n      // Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n      // transformations, especially when a content of a few block elements were removed. For example:\n      //\n      // {} is the transformed range, [] is the removed range.\n      // <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n      //\n      // <p>Fo{o</p><p>B}ar</p><p>z</p>\n      // <p>F{</p><p>B}ar</p><p>z</p>\n      // <p>F{</p>}<p>z</p>\n      // <p>F{}z</p>\n      //\n      if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {\n        return new Range(this.start);\n      }\n\n      var start = this.start._getTransformedByMergeOperation(operation);\n\n      var end = this.end._getTransformedByMergeOperation(operation);\n\n      if (start.root != end.root) {\n        // This happens when the end position was next to the merged (deleted) element.\n        // Then, the end position was moved to the graveyard root. In this case we need to fix\n        // the range cause its boundaries would be in different roots.\n        end = this.end.getShiftedBy(-1);\n      }\n\n      if (start.isAfter(end)) {\n        // This happens in three following cases:\n        //\n        // Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n        //         This means that start can be moved before the end of the range.\n        //\n        // Before: <p>a{a</p><p>b}b</p><p>cc</p>\n        // Merge:  <p>b}b</p><p>cca{a</p>\n        // Fix:    <p>{b}b</p><p>ccaa</p>\n        //\n        // Case 2: Range start is before merged node but not directly.\n        //         Result should include all nodes that were in the original range.\n        //\n        // Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n        // Merge:  <p>aab}b</p>{<p>cc</p>\n        // Fix:    <p>aa{bb</p><p>cc</p>}\n        //\n        //         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n        //\n        // Case 3: Range start is directly before merged node.\n        //         Resulting range should include only nodes from the merged element:\n        //\n        // Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n        // Merge:  <p>aab}b</p>{<p>cc</p>\n        // Fix:    <p>aa{b}b</p><p>cc</p>\n        //\n        if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n          // Case 1.\n          start = Position._createAt(end);\n          start.offset = 0;\n        } else {\n          if (!operation.deletionPosition.isEqual(start)) {\n            // Case 2.\n            end = operation.deletionPosition;\n          } // In both case 2 and 3 start is at the end of the merge-to element.\n\n\n          start = operation.targetPosition;\n        }\n\n        return new Range(start, end);\n      }\n\n      return new Range(start, end);\n    }\n    /**\n     * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n     * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n     * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n     *\n     * Examples:\n     *\n     *\t\tlet range = model.createRange(\n     *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n     *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n     *\t\t);\n     *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n     *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n     *\n     *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n     *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n     *\n     *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n     *\t\t// transformed array has one range, which is equal to original range\n     *\n     *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n     *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n     * @param {Number} howMany How many nodes are inserted.\n     * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n     * was inside the range. Defaults to `false`.\n     * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n     */\n\n  }, {\n    key: \"_getTransformedByInsertion\",\n    value: function _getTransformedByInsertion(insertPosition, howMany) {\n      var spread = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (spread && this.containsPosition(insertPosition)) {\n        // Range has to be spread. The first part is from original start to the spread point.\n        // The other part is from spread point to the original end, but transformed by\n        // insertion to reflect insertion changes.\n        return [new Range(this.start, insertPosition), new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))];\n      } else {\n        var range = new Range(this.start, this.end);\n        range.start = range.start._getTransformedByInsertion(insertPosition, howMany);\n        range.end = range.end._getTransformedByInsertion(insertPosition, howMany);\n        return [range];\n      }\n    }\n    /**\n     * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n     * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n     * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n     * @param {Number} howMany How many nodes are moved.\n     * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n     * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n     */\n\n  }, {\n    key: \"_getTransformedByMove\",\n    value: function _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n      var spread = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      // Special case for transforming a collapsed range. Just transform it like a position.\n      if (this.isCollapsed) {\n        var newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n\n        return [new Range(newPos)];\n      } // Special case for transformation when a part of the range is moved towards the range.\n      //\n      // Examples:\n      //\n      // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n      // <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n      //\n      // Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n      //\n      // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n      //\n      // This special case is applied only if the range is to be kept together (not spread).\n\n\n      var moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);\n\n      var insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n\n      if (this.containsPosition(targetPosition) && !spread) {\n        if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {\n          var start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);\n\n          var end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);\n\n          return [new Range(start, end)];\n        }\n      } // Default algorithm.\n\n\n      var result;\n      var differenceSet = this.getDifference(moveRange);\n      var difference = null;\n      var common = this.getIntersection(moveRange);\n\n      if (differenceSet.length == 1) {\n        // `moveRange` and this range may intersect but may be separate.\n        difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));\n      } else if (differenceSet.length == 2) {\n        // `moveRange` is inside this range.\n        difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));\n      } // else, `moveRange` contains this range.\n\n\n      if (difference) {\n        result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);\n      } else {\n        result = [];\n      }\n\n      if (common) {\n        var transformedCommon = new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));\n\n        if (result.length == 2) {\n          result.splice(1, 0, transformedCommon);\n        } else {\n          result.push(transformedCommon);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n     *\n     * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n     *\n     * If the deleted range contains transformed range, `null` will be returned.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n     * @param {Number} howMany How many nodes are removed.\n     * @returns {module:engine/model/range~Range|null} Result of the transformation.\n     */\n\n  }, {\n    key: \"_getTransformedByDeletion\",\n    value: function _getTransformedByDeletion(deletePosition, howMany) {\n      var newStart = this.start._getTransformedByDeletion(deletePosition, howMany);\n\n      var newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);\n\n      if (newStart == null && newEnd == null) {\n        return null;\n      }\n\n      if (newStart == null) {\n        newStart = deletePosition;\n      }\n\n      if (newEnd == null) {\n        newEnd = deletePosition;\n      }\n\n      return new Range(newStart, newEnd);\n    }\n    /**\n     * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} position Beginning of the range.\n     * @param {Number} shift How long the range should be.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      return this.start.isEqual(this.end);\n    }\n    /**\n     * Returns whether this range is flat, that is if {@link #start} position and\n     * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n     *\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isFlat\",\n    get: function get() {\n      var startParentPath = this.start.getParentPath();\n      var endParentPath = this.end.getParentPath();\n      return compareArrays(startParentPath, endParentPath) == 'same';\n    }\n    /**\n     * Range root element.\n     *\n     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this.start.root;\n    }\n  }], [{\n    key: \"_createFromPositionAndShift\",\n    value: function _createFromPositionAndShift(position, shift) {\n      var start = position;\n      var end = position.getShiftedBy(shift);\n      return shift > 0 ? new this(start, end) : new this(end, start);\n    }\n    /**\n     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n     * that element and ends after the last child of that element.\n     *\n     * @protected\n     * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"_createIn\",\n    value: function _createIn(element) {\n      return new this(Position._createAt(element, 0), Position._createAt(element, element.maxOffset));\n    }\n    /**\n     * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n     *\n     * @protected\n     * @param {module:engine/model/item~Item} item\n     * @returns {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"_createOn\",\n    value: function _createOn(item) {\n      return this._createFromPositionAndShift(Position._createBefore(item), item.offsetSize);\n    }\n    /**\n     * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n     * Passed ranges must not have common parts.\n     *\n     * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n     * the reference range, they get combined into one range.\n     *\n     *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n     *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n     *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n     *\t                                           [  ]  // The result of the function if the last range was a reference range.\n     *\n     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n     * @returns {module:engine/model/range~Range} Combined range.\n     */\n\n  }, {\n    key: \"_createFromRanges\",\n    value: function _createFromRanges(ranges) {\n      if (ranges.length === 0) {\n        /**\n         * At least one range has to be passed to\n         * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n         *\n         * @error range-create-from-ranges-empty-array\n         */\n        throw new CKEditorError('range-create-from-ranges-empty-array', null);\n      } else if (ranges.length == 1) {\n        return ranges[0].clone();\n      } // 1. Set the first range in `ranges` array as a reference range.\n      // If we are going to return just a one range, one of the ranges need to be the reference one.\n      // Other ranges will be stuck to that range, if possible.\n\n\n      var ref = ranges[0]; // 2. Sort all the ranges so it's easier to process them.\n\n      ranges.sort(function (a, b) {\n        return a.start.isAfter(b.start) ? 1 : -1;\n      }); // 3. Check at which index the reference range is now.\n\n      var refIndex = ranges.indexOf(ref); // 4. At this moment we don't need the original range.\n      // We are going to modify the result and we need to return a new instance of Range.\n      // We have to create a copy of the reference range.\n\n      var result = new this(ref.start, ref.end); // 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n      // Since ranges are sorted, start with the range with index that is closest to reference range index.\n\n      if (refIndex > 0) {\n        for (var i = refIndex - 1; true; i++) {\n          if (ranges[i].end.isEqual(result.start)) {\n            result.start = Position._createAt(ranges[i].start);\n          } else {\n            // If ranges are not starting/ending at the same position there is no point in looking further.\n            break;\n          }\n        }\n      } // 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n      // Since ranges are sorted, start with the range with index that is closest to reference range index.\n\n\n      for (var _i2 = refIndex + 1; _i2 < ranges.length; _i2++) {\n        if (ranges[_i2].start.isEqual(result.end)) {\n          result.end = Position._createAt(ranges[_i2].end);\n        } else {\n          // If ranges are not starting/ending at the same position there is no point in looking further.\n          break;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n     *\n     * @param {Object} json Plain object to be converted to `Range`.\n     * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n     * @returns {module:engine/model/range~Range} `Range` instance created using given plain object.\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json, doc) {\n      return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;\n    // @if CK_DEBUG_ENGINE // }\n    // @if CK_DEBUG_ENGINE // log() {\n    // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n    // @if CK_DEBUG_ENGINE // }\n\n  }]);\n\n  return Range;\n}();\n\nexport { Range as default };","map":null,"metadata":{},"sourceType":"module"}