{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * The downcast dispatcher is a central point of downcasting (conversion from the model to the view), which is a process of reacting\n * to changes in the model and firing a set of events. The callbacks listening to these events are called converters. The\n * converters' role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During the conversion process, downcast dispatcher fires events basing on the state of the model and prepares\n * data for these events. It is important to understand that the events are connected with the changes done on the model,\n * for example: \"a node has been inserted\" or \"an attribute has changed\". This is in contrary to upcasting (a view-to-model conversion)\n * where you convert the view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by the {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to the downcast dispatcher as a diff between the old model state and the new model state.\n *\n * Note that because the changes are converted, there is a need to have a mapping between the model structure and the view structure.\n * To map positions and elements during the downcast (a model-to-view conversion), use {@link module:engine/conversion/mapper~Mapper}.\n *\n * Downcast dispatcher fires the following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`} &ndash;\n * If a range of nodes was inserted to the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove `remove`} &ndash;\n * If a range of nodes was removed from the model tree.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`} &ndash;\n * If an attribute was added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert`}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`},\n * the downcast dispatcher generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have control over which changes have already been consumed. It is useful when some converters\n * overwrite others or convert multiple changes (for example, it converts an insertion of an element and also converts that\n * element's attributes during the insertion).\n *\n * Additionally, downcast dispatcher fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`} &ndash; If a marker was added.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker `removeMarker`} &ndash; If a marker was\n * removed.\n *\n * Note that changing a marker is done through removing the marker from the old range and adding it to the new range,\n * so both of these events are fired.\n *\n * Finally, a downcast dispatcher also handles firing events for the {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection `selection`}\n * &ndash; Converts the selection from the model to the view.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute`}\n * &ndash; Fired for every selection attribute.\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker `addMarker`}\n * &ndash; Fired for every marker that contains a selection.\n *\n * Unlike the model tree and the markers, the events for selection are not fired for changes but for a selection state.\n *\n * When providing custom listeners for a downcast dispatcher, remember to check whether a given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for a downcast dispatcher, keep in mind that you **should not** stop the event. If you stop it,\n * then the default converter at the `lowest` priority will not trigger the conversion of this node's attributes and child nodes.\n *\n * When providing custom listeners for a downcast dispatcher, remember to use the provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * You can read more about conversion in the following guide:\n *\n * * {@glink framework/guides/deep-dive/conversion/downcast Downcast conversion}\n *\n * An example of a custom converter for the downcast dispatcher:\n *\n *\t\t// You will convert inserting a \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate the position in the model to a position in the view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create a <p> element that will be inserted into the view at the `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to the model element so positions will map accordingly in the future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\t\t} );\n */\n\nvar DowncastDispatcher = /*#__PURE__*/function () {\n  /**\n   * Creates a downcast dispatcher instance.\n   *\n   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n   * @param {Object} conversionApi Additional properties for an interface that will be passed to events fired\n   * by the downcast dispatcher.\n   */\n  function DowncastDispatcher(conversionApi) {\n    _classCallCheck(this, DowncastDispatcher);\n\n    /**\n     * A template for an interface passed by the dispatcher to the event callbacks.\n     *\n     * @protected\n     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n     */\n    this._conversionApi = _objectSpread({\n      dispatcher: this\n    }, conversionApi);\n    /**\n     * A map of already fired events for a given `ModelConsumable`.\n     *\n     * @private\n     * @member {WeakMap.<module:engine/conversion/downcastdispatcher~DowncastConversionApi,Map>}\n     */\n\n    this._firedEventsMap = new WeakMap();\n  }\n  /**\n   * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}\n   * and fires conversion events based on it.\n   *\n   * @fires insert\n   * @fires remove\n   * @fires attribute\n   * @fires addMarker\n  \t * @fires removeMarker\n   * @fires reduceChanges\n   * @param {module:engine/model/differ~Differ} differ The differ object with buffered changes.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers related to the model fragment to convert.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n   */\n\n\n  _createClass(DowncastDispatcher, [{\n    key: \"convertChanges\",\n    value: function convertChanges(differ, markers, writer) {\n      var conversionApi = this._createConversionApi(writer, differ.getRefreshedItems()); // Before the view is updated, remove markers which have changed.\n\n\n      var _iterator = _createForOfIteratorHelper(differ.getMarkersToRemove()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var change = _step.value;\n\n          this._convertMarkerRemove(change.name, change.range, conversionApi);\n        } // Let features modify the change list (for example to allow reconversion).\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var changes = this._reduceChanges(differ.getChanges()); // Convert changes that happened on model tree.\n\n\n      var _iterator2 = _createForOfIteratorHelper(changes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var entry = _step2.value;\n\n          if (entry.type === 'insert') {\n            this._convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n          } else if (entry.type === 'reinsert') {\n            this._convertReinsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);\n          } else if (entry.type === 'remove') {\n            this._convertRemove(entry.position, entry.length, entry.name, conversionApi);\n          } else {\n            // Defaults to 'attribute' change.\n            this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(conversionApi.mapper.flushUnboundMarkerNames()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var markerName = _step3.value;\n          var markerRange = markers.get(markerName).getRange();\n\n          this._convertMarkerRemove(markerName, markerRange, conversionApi);\n\n          this._convertMarkerAdd(markerName, markerRange, conversionApi);\n        } // After the view is updated, convert markers which have changed.\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(differ.getMarkersToAdd()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _change = _step4.value;\n\n          this._convertMarkerAdd(_change.name, _change.range, conversionApi);\n        } // Remove mappings for all removed view elements.\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      conversionApi.mapper.flushDeferredBindings(); // Verify if all insert consumables were consumed.\n\n      conversionApi.consumable.verifyAllConsumed('insert');\n    }\n    /**\n     * Starts a conversion of a model range and the provided markers.\n     *\n     * @fires insert\n     * @fires attribute\n     * @fires addMarker\n     * @param {module:engine/model/range~Range} range The inserted range.\n     * @param {Map<String,module:engine/model/range~Range>} markers The map of markers that should be down-casted.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer The view writer that should be used to modify the view document.\n     * @param {Object} [options] Optional options object passed to `convertionApi.options`.\n     */\n\n  }, {\n    key: \"convert\",\n    value: function convert(range, markers, writer) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var conversionApi = this._createConversionApi(writer, undefined, options);\n\n      this._convertInsert(range, conversionApi);\n\n      var _iterator5 = _createForOfIteratorHelper(markers),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              name = _step5$value[0],\n              _range = _step5$value[1];\n\n          this._convertMarkerAdd(name, _range, conversionApi);\n        } // Verify if all insert consumables were consumed.\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      conversionApi.consumable.verifyAllConsumed('insert');\n    }\n    /**\n     * Starts the model selection conversion.\n     *\n     * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.\n     *\n     * @fires selection\n     * @fires addMarker\n     * @fires attribute\n     * @param {module:engine/model/selection~Selection} selection The selection to convert.\n     * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with the converted model.\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n     */\n\n  }, {\n    key: \"convertSelection\",\n    value: function convertSelection(selection, markers, writer) {\n      var markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n\n      var conversionApi = this._createConversionApi(writer);\n\n      this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);\n\n      this.fire('selection', {\n        selection: selection\n      }, conversionApi);\n\n      if (!selection.isCollapsed) {\n        return;\n      }\n\n      for (var _i = 0, _markersAtSelection = markersAtSelection; _i < _markersAtSelection.length; _i++) {\n        var marker = _markersAtSelection[_i];\n        var markerRange = marker.getRange();\n\n        if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {\n          continue;\n        }\n\n        var data = {\n          item: selection,\n          markerName: marker.name,\n          markerRange: markerRange\n        };\n\n        if (conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n          this.fire('addMarker:' + marker.name, data, conversionApi);\n        }\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(selection.getAttributeKeys()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var key = _step6.value;\n          var _data = {\n            item: selection,\n            range: selection.getFirstRange(),\n            attributeKey: key,\n            attributeOldValue: null,\n            attributeNewValue: selection.getAttribute(key)\n          }; // Do not fire event if the attribute has been consumed.\n\n          if (conversionApi.consumable.test(selection, 'attribute:' + _data.attributeKey)) {\n            this.fire('attribute:' + _data.attributeKey + ':$text', _data, conversionApi);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /**\n     * Fires insertion conversion of a range of nodes.\n     *\n     * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,\n     * {@link #event:attribute `attribute` event is fired}.\n     *\n     * @protected\n     * @fires insert\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range The inserted range.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     * @param {Object} [options]\n     * @param {Boolean} [options.doNotAddConsumables=false] Whether the ModelConsumable should not get populated\n     * for items in the provided range.\n     */\n\n  }, {\n    key: \"_convertInsert\",\n    value: function _convertInsert(range, conversionApi) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!options.doNotAddConsumables) {\n        // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n        this._addConsumablesForInsert(conversionApi.consumable, Array.from(range));\n      } // Fire a separate insert event for each node and text fragment contained in the range.\n\n\n      var _iterator7 = _createForOfIteratorHelper(Array.from(range.getWalker({\n        shallow: true\n      })).map(walkerValueToEventData)),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var data = _step7.value;\n\n          this._testAndFire('insert', data, conversionApi);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n    /**\n     * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n     *\n     * @protected\n     * @param {module:engine/model/position~Position} position Position from which node was removed.\n     * @param {Number} length Offset size of removed node.\n     * @param {String} name Name of removed node.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_convertRemove\",\n    value: function _convertRemove(position, length, name, conversionApi) {\n      this.fire('remove:' + name, {\n        position: position,\n        length: length\n      }, conversionApi);\n    }\n    /**\n     * Starts a conversion of an attribute change on a given `range`.\n     *\n     * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n     *\n     * @protected\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range Changed range.\n     * @param {String} key Key of the attribute that has changed.\n     * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n     * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_convertAttribute\",\n    value: function _convertAttribute(range, key, oldValue, newValue, conversionApi) {\n      // Create a list with attributes to consume.\n      this._addConsumablesForRange(conversionApi.consumable, range, \"attribute:\".concat(key)); // Create a separate attribute event for each node in the range.\n\n\n      var _iterator8 = _createForOfIteratorHelper(range),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var value = _step8.value;\n          var data = {\n            item: value.item,\n            range: Range._createFromPositionAndShift(value.previousPosition, value.length),\n            attributeKey: key,\n            attributeOldValue: oldValue,\n            attributeNewValue: newValue\n          };\n\n          this._testAndFire(\"attribute:\".concat(key), data, conversionApi);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n    /**\n     * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)\n     * of a range of elements (only elements on the range depth, without children).\n     *\n     * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.\n     * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.\n     *\n     * @protected\n     * @fires insert\n     * @fires attribute\n     * @param {module:engine/model/range~Range} range The range to reinsert.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_convertReinsert\",\n    value: function _convertReinsert(range, conversionApi) {\n      // Convert the elements - without converting children.\n      var walkerValues = Array.from(range.getWalker({\n        shallow: true\n      })); // Collect a list of things that can be consumed, consisting of nodes and their attributes.\n\n      this._addConsumablesForInsert(conversionApi.consumable, walkerValues); // Fire a separate insert event for each node and text fragment contained shallowly in the range.\n\n\n      var _iterator9 = _createForOfIteratorHelper(walkerValues.map(walkerValueToEventData)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var data = _step9.value;\n\n          this._testAndFire('insert', _objectSpread({}, data, {\n            reconversion: true\n          }), conversionApi);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n    /**\n     * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item\n     * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.\n     *\n     * @protected\n     * @fires addMarker\n     * @param {String} markerName Marker name.\n     * @param {module:engine/model/range~Range} markerRange The marker range.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_convertMarkerAdd\",\n    value: function _convertMarkerAdd(markerName, markerRange, conversionApi) {\n      // Do not convert if range is in graveyard.\n      if (markerRange.root.rootName == '$graveyard') {\n        return;\n      } // In markers' case, event name == consumable name.\n\n\n      var eventName = 'addMarker:' + markerName; //\n      // First, fire an event for the whole marker.\n      //\n\n      conversionApi.consumable.add(markerRange, eventName);\n      this.fire(eventName, {\n        markerName: markerName,\n        markerRange: markerRange\n      }, conversionApi); //\n      // Do not fire events for each item inside the range if the range got consumed.\n      // Also consume the whole marker consumable if it wasn't consumed.\n      //\n\n      if (!conversionApi.consumable.consume(markerRange, eventName)) {\n        return;\n      } //\n      // Then, fire an event for each item inside the marker range.\n      //\n\n\n      this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);\n\n      var _iterator10 = _createForOfIteratorHelper(markerRange.getItems()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var item = _step10.value;\n\n          // Do not fire event for already consumed items.\n          if (!conversionApi.consumable.test(item, eventName)) {\n            continue;\n          }\n\n          var data = {\n            item: item,\n            range: Range._createOn(item),\n            markerName: markerName,\n            markerRange: markerRange\n          };\n          this.fire(eventName, data, conversionApi);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n    /**\n     * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.\n     *\n     * @protected\n     * @fires removeMarker\n     * @param {String} markerName Marker name.\n     * @param {module:engine/model/range~Range} markerRange The marker range.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_convertMarkerRemove\",\n    value: function _convertMarkerRemove(markerName, markerRange, conversionApi) {\n      // Do not convert if range is in graveyard.\n      if (markerRange.root.rootName == '$graveyard') {\n        return;\n      }\n\n      this.fire('removeMarker:' + markerName, {\n        markerName: markerName,\n        markerRange: markerRange\n      }, conversionApi);\n    }\n    /**\n     * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.\n     *\n     * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger\n     * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n     * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.\n     *\n     * @private\n     * @fires reduceChanges\n     * @param {Iterable.<module:engine/model/differ~DiffItem>} changes\n     * @returns {Iterable.<module:engine/model/differ~DiffItem>}\n     */\n\n  }, {\n    key: \"_reduceChanges\",\n    value: function _reduceChanges(changes) {\n      var data = {\n        changes: changes\n      };\n      this.fire('reduceChanges', data);\n      return data.changes;\n    }\n    /**\n     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,\n     * assuming that the range has just been inserted to the model.\n     *\n     * @private\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n     * @param {Iterable.<module:engine/model/treewalker~TreeWalkerValue>} walkerValues The walker values for the inserted range.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n     */\n\n  }, {\n    key: \"_addConsumablesForInsert\",\n    value: function _addConsumablesForInsert(consumable, walkerValues) {\n      var _iterator11 = _createForOfIteratorHelper(walkerValues),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var value = _step11.value;\n          var item = value.item; // Add consumable if it wasn't there yet.\n\n          if (consumable.test(item, 'insert') === null) {\n            consumable.add(item, 'insert');\n\n            var _iterator12 = _createForOfIteratorHelper(item.getAttributeKeys()),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var key = _step12.value;\n                consumable.add(item, 'attribute:' + key);\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return consumable;\n    }\n    /**\n     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.\n     *\n     * @private\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n     * @param {module:engine/model/range~Range} range The affected range.\n     * @param {String} type Consumable type.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n     */\n\n  }, {\n    key: \"_addConsumablesForRange\",\n    value: function _addConsumablesForRange(consumable, range, type) {\n      var _iterator13 = _createForOfIteratorHelper(range.getItems()),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var item = _step13.value;\n          consumable.add(item, type);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return consumable;\n    }\n    /**\n     * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n     *\n     * @private\n     * @param {module:engine/conversion/modelconsumable~ModelConsumable} consumable The consumable.\n     * @param {module:engine/model/selection~Selection} selection The selection to create the consumable from.\n     * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers that contain the selection.\n     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} The values to consume.\n     */\n\n  }, {\n    key: \"_addConsumablesForSelection\",\n    value: function _addConsumablesForSelection(consumable, selection, markers) {\n      consumable.add(selection, 'selection');\n\n      var _iterator14 = _createForOfIteratorHelper(markers),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var marker = _step14.value;\n          consumable.add(selection, 'addMarker:' + marker.name);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      var _iterator15 = _createForOfIteratorHelper(selection.getAttributeKeys()),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var key = _step15.value;\n          consumable.add(selection, 'attribute:' + key);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      return consumable;\n    }\n    /**\n     * Tests whether given event wasn't already fired and if so, fires it.\n     *\n     * @private\n     * @fires insert\n     * @fires attribute\n     * @param {String} type Event type.\n     * @param {Object} data Event data.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_testAndFire\",\n    value: function _testAndFire(type, data, conversionApi) {\n      var eventName = getEventName(type, data);\n      var itemKey = data.item.is('$textProxy') ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;\n\n      var eventsFiredForConversion = this._firedEventsMap.get(conversionApi);\n\n      var eventsFiredForItem = eventsFiredForConversion.get(itemKey);\n\n      if (!eventsFiredForItem) {\n        eventsFiredForConversion.set(itemKey, new Set([eventName]));\n      } else if (!eventsFiredForItem.has(eventName)) {\n        eventsFiredForItem.add(eventName);\n      } else {\n        return;\n      }\n\n      this.fire(eventName, data, conversionApi);\n    }\n    /**\n     * Fires not already fired events for setting attributes on just inserted item.\n     *\n     * @private\n     * @param {module:engine/model/item~Item} item The model item to convert attributes for.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi The conversion API object.\n     */\n\n  }, {\n    key: \"_testAndFireAddAttributes\",\n    value: function _testAndFireAddAttributes(item, conversionApi) {\n      var data = {\n        item: item,\n        range: Range._createOn(item)\n      };\n\n      var _iterator16 = _createForOfIteratorHelper(data.item.getAttributeKeys()),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var key = _step16.value;\n          data.attributeKey = key;\n          data.attributeOldValue = null;\n          data.attributeNewValue = data.item.getAttribute(key);\n\n          this._testAndFire(\"attribute:\".concat(key), data, conversionApi);\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    }\n    /**\n     * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given\n     * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.\n     *\n     * @private\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify the view document.\n     * @param {Set.<module:engine/model/element~Element>} [refreshedItems] A set of model elements that should not reuse their\n     * previous view representations.\n     * @param {Object} [options] Optional options passed to `convertionApi.options`.\n     * @return {module:engine/conversion/downcastdispatcher~DowncastConversionApi} The conversion API object.\n     */\n\n  }, {\n    key: \"_createConversionApi\",\n    value: function _createConversionApi(writer) {\n      var _this = this;\n\n      var refreshedItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var conversionApi = _objectSpread({}, this._conversionApi, {\n        consumable: new Consumable(),\n        writer: writer,\n        options: options,\n        convertItem: function convertItem(item) {\n          return _this._convertInsert(Range._createOn(item), conversionApi);\n        },\n        convertChildren: function convertChildren(element) {\n          return _this._convertInsert(Range._createIn(element), conversionApi, {\n            doNotAddConsumables: true\n          });\n        },\n        convertAttributes: function convertAttributes(item) {\n          return _this._testAndFireAddAttributes(item, conversionApi);\n        },\n        canReuseView: function canReuseView(viewElement) {\n          return !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement));\n        }\n      });\n\n      this._firedEventsMap.set(conversionApi, new Map());\n\n      return conversionApi;\n    }\n    /**\n     * Fired to enable reducing (transforming) changes buffered in the {@link module:engine/model/differ~Differ `Differ`} before\n     * {@link #convertChanges `convertChanges()`} will fire any conversion events.\n     *\n     * For instance, a feature can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with a `reinsert` entry\n     * to trigger reconversion of an element when e.g. its attribute has changes.\n     * The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure\n     * `DowncastHelpers.elementToStructure()`} helper is using this event to trigger reconversion of an element when the element,\n     * its attributes or direct children changed.\n     *\n     * @param {Object} data\n     * @param {Iterable.<module:engine/model/differ~DiffItem>} data.changes A buffered changes to get reduced.\n     * @event reduceChanges\n     */\n\n    /**\n     * Fired for inserted nodes.\n     *\n     * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n     * or {@link module:engine/model/element~Element#name name} of inserted element.\n     *\n     * This way, the listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n     *\n     * @event insert\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/item~Item} data.item The inserted item.\n     * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in the `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired for removed nodes.\n     *\n     * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `remove:name`. `name` is either `'$text'`, when a {@link module:engine/model/text~Text a text node} has been removed,\n     * or the {@link module:engine/model/element~Element#name name} of removed element.\n     *\n     * This way, listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n     *\n     * @event remove\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n     * @param {Number} data.length Offset size of the removed node.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired in the following cases:\n     *\n     * * when an attribute has been added, changed, or removed from a node,\n     * * when a node with an attribute is inserted,\n     * * when a collapsed model selection attribute is converted.\n     *\n     * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n     * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n     * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n     *\n     * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:imageBlock`).\n     *\n     * @event attribute\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n     * or converted selection.\n     * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n     * @param {String} data.attributeKey Attribute key.\n     * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n     * @param {*} data.attributeNewValue New attribute value.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired for {@link module:engine/model/selection~Selection selection} changes.\n     *\n     * @event selection\n     * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired when a new marker is added to the model. Also fired when a collapsed model selection that is inside a marker is converted.\n     *\n     * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n     * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n     * `addMarker:foo:bar` events.\n     *\n     * If the marker range is not collapsed:\n     *\n     * * the event is fired for each item in the marker range one by one,\n     * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as the event name.\n     *\n     * If the marker range is collapsed:\n     *\n     * * there is only one event,\n     * * `conversionApi.consumable` includes marker range with the event name.\n     *\n     * If the selection inside a marker is converted:\n     *\n     * * there is only one event,\n     * * `conversionApi.consumable` includes the selection instance with the event name.\n     *\n     * @event addMarker\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n     * the selection that is being converted.\n     * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n     * the marker range was not collapsed.\n     * @param {module:engine/model/range~Range} data.markerRange Marker range.\n     * @param {String} data.markerName Marker name.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n    /**\n     * Fired when a marker is removed from the model.\n     *\n     * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n     * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n     * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n     * `removeMarker:foo:bar` events.\n     *\n     * @event removeMarker\n     * @param {Object} data Additional information about the change.\n     * @param {module:engine/model/range~Range} data.markerRange Marker range.\n     * @param {String} data.markerName Marker name.\n     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n     * to be used by callback, passed in `DowncastDispatcher` constructor.\n     */\n\n  }]);\n\n  return DowncastDispatcher;\n}();\n\nexport { DowncastDispatcher as default };\nmix(DowncastDispatcher, EmitterMixin); // Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\n\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n  var range = marker.getRange();\n  var ancestors = Array.from(modelPosition.getAncestors());\n  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\n  ancestors.reverse();\n  var hasCustomHandling = ancestors.some(function (element) {\n    if (range.containsItem(element)) {\n      var viewElement = mapper.toViewElement(element);\n      return !!viewElement.getCustomProperty('addHighlight');\n    }\n  });\n  return !hasCustomHandling;\n}\n\nfunction getEventName(type, data) {\n  var name = data.item.name || '$text';\n  return \"\".concat(type, \":\").concat(name);\n}\n\nfunction walkerValueToEventData(value) {\n  var item = value.item;\n\n  var itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n  return {\n    item: item,\n    range: itemRange\n  };\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires its events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores the information about what parts of a processed model item are still waiting to be handled. After a piece of a model item was\n * converted, an appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/model/schema~Schema} instance set for the model that is downcast.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate the data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n\n/**\n * Triggers conversion of a specified item.\n * This conversion is triggered within (as a separate process of) the parent conversion.\n *\n * @method #convertItem\n * @param {module:engine/model/item~Item} item The model item to trigger nested insert conversion on.\n */\n\n/**\n * Triggers conversion of children of a specified element.\n *\n * @method #convertChildren\n * @param {module:engine/model/element~Element} element The model element to trigger children insert conversion on.\n */\n\n/**\n * Triggers conversion of attributes of a specified item.\n *\n * @method #convertAttributes\n * @param {module:engine/model/item~Item} item The model item to trigger attribute conversion on.\n */\n\n/**\n * An object with an additional configuration which can be used during the conversion process. Available only for data downcast conversion.\n *\n * @member {Object} #options\n */","map":null,"metadata":{},"sourceType":"module"}