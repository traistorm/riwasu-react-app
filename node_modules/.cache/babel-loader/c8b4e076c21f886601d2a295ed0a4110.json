{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/document\n */\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport BubblingEmitterMixin from './observer/bubblingemittermixin';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin'; // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\n/**\n * Document class creates an abstract layer over the content editable area, contains a tree of view elements and\n * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.\n *\n * @mixes module:engine/view/observer/bubblingemittermixin~BubblingEmitterMixin\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Document = /*#__PURE__*/function () {\n  /**\n   * Creates a Document instance.\n   *\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  function Document(stylesProcessor) {\n    _classCallCheck(this, Document);\n\n    /**\n     * Selection done on this document.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection\n     */\n    this.selection = new DocumentSelection();\n    /**\n     * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.\n     *\n     * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and\n     * {@link module:engine/model/document~Document#roots} and this is handled by\n     * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create\n     * model root using {@link module:engine/model/document~Document#createRoot}.\n     *\n     * @readonly\n     * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots\n     */\n\n    this.roots = new Collection({\n      idProperty: 'rootName'\n    });\n    /**\n     * The styles processor instance used by this document when normalizing styles.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Defines whether document is in read-only mode.\n     *\n     * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.\n     *\n     * @observable\n     * @member {Boolean} #isReadOnly\n     */\n\n    this.set('isReadOnly', false);\n    /**\n     * True if document is focused.\n     *\n     * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.\n     * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isFocused\n     */\n\n    this.set('isFocused', false);\n    /**\n     * `true` while the user is making a selection in the document (e.g. holding the mouse button and moving the cursor).\n     * When they stop selecting, the property goes back to `false`.\n     *\n     * This property is updated by the {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isSelecting\n     */\n\n    this.set('isSelecting', false);\n    /**\n     * True if composition is in progress inside the document.\n     *\n     * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.\n     * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.\n     *\n     * @readonly\n     * @observable\n     * @member {Boolean} module:engine/view/document~Document#isComposing\n     */\n\n    this.set('isComposing', false);\n    /**\n     * Post-fixer callbacks registered to the view document.\n     *\n     * @private\n     * @member {Set}\n     */\n\n    this._postFixers = new Set();\n  }\n  /**\n   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not\n   * specific \"main\" root is returned.\n   *\n   * @param {String} [name='main'] Name of the root.\n   * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name\n   * or null when there is no root of given name.\n   */\n\n\n  _createClass(Document, [{\n    key: \"getRoot\",\n    value: function getRoot() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n      return this.roots.get(name);\n    }\n    /**\n     * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered\n     * to the DOM.\n     *\n     * Post-fixers are executed right after all changes from the outermost change block were applied but\n     * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made\n     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n     * not be fixed in the new document tree state.\n     *\n     * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that\n     * changes executed in a view post-fixer should not break model-view mapping.\n     *\n     * The types of changes which should be safe:\n     *\n     * * adding or removing attribute from elements,\n     * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},\n     * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be\n     * re-converted}.\n     *\n     * Try to avoid changes which touch view structure:\n     *\n     * * you should not add or remove nor wrap or unwrap any view elements,\n     * * you should not change the editor data model in a view post-fixer.\n     *\n     * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.\n     *\n     * Typically, a post-fixer will look like this:\n     *\n     *\t\teditor.editing.view.document.registerPostFixer( writer => {\n     *\t\t\tif ( checkSomeCondition() ) {\n     *\t\t\t\twriter.doSomething();\n     *\n     *\t\t\t\t// Let other post-fixers know that something changed.\n     *\t\t\t\treturn true;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).\n     * That is because adding a post-fixer does not execute it.\n     * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.\n     * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling\n     * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.\n     *\n     * If you need to register a callback which is executed when DOM elements are already updated,\n     * use {@link module:engine/view/view~View#event:render render event}.\n     *\n     * @param {Function} postFixer\n     */\n\n  }, {\n    key: \"registerPostFixer\",\n    value: function registerPostFixer(postFixer) {\n      this._postFixers.add(postFixer);\n    }\n    /**\n     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.roots.map(function (root) {\n        return root.destroy();\n      });\n      this.stopListening();\n    }\n    /**\n     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n     *\n     * @protected\n     * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n     */\n\n  }, {\n    key: \"_callPostFixers\",\n    value: function _callPostFixers(writer) {\n      var wasFixed = false;\n\n      do {\n        var _iterator = _createForOfIteratorHelper(this._postFixers),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var callback = _step.value;\n            wasFixed = callback(writer);\n\n            if (wasFixed) {\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } while (wasFixed);\n    }\n    /**\n     * Event fired whenever document content layout changes. It is fired whenever content is\n     * {@link module:engine/view/view~View#event:render rendered}, but should be also fired by observers in case of\n     * other actions which may change layout, for instance when image loads.\n     *\n     * @event layoutChanged\n     */\n    // @if CK_DEBUG_ENGINE // log( version ) {\n    // @if CK_DEBUG_ENGINE //\tlogDocument( this, version );\n    // @if CK_DEBUG_ENGINE // }\n\n  }]);\n\n  return Document;\n}();\n\nexport { Document as default };\nmix(Document, BubblingEmitterMixin);\nmix(Document, ObservableMixin);\n/**\n * Enum representing type of the change.\n *\n * Possible values:\n *\n * * `children` - for child list changes,\n * * `attributes` - for element attributes changes,\n * * `text` - for text nodes changes.\n *\n * @typedef {String} module:engine/view/document~ChangeType\n */","map":null,"metadata":{},"sourceType":"module"}