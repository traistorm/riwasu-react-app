{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/moveoperation\n */\nimport Operation from './operation';\nimport Position from '../position';\nimport Range from '../range';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport { _move } from './utils'; // @if CK_DEBUG_ENGINE // const ModelRange = require( '../range' ).default;\n\n/**\n * Operation to move a range of {@link module:engine/model/item~Item model items}\n * to given {@link module:engine/model/position~Position target position}.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\n\nvar MoveOperation = /*#__PURE__*/function (_Operation) {\n  _inherits(MoveOperation, _Operation);\n\n  /**\n   * Creates a move operation.\n   *\n   * @param {module:engine/model/position~Position} sourcePosition\n   * Position before the first {@link module:engine/model/item~Item model item} to move.\n   * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at\n   * `sourcePosition` with offset shifted by `howMany`.\n   * @param {module:engine/model/position~Position} targetPosition Position at which moved nodes will be inserted.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  function MoveOperation(sourcePosition, howMany, targetPosition, baseVersion) {\n    var _this;\n\n    _classCallCheck(this, MoveOperation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MoveOperation).call(this, baseVersion));\n    /**\n     * Position before the first {@link module:engine/model/item~Item model item} to move.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#sourcePosition\n     */\n\n    _this.sourcePosition = sourcePosition.clone(); // `'toNext'` because `sourcePosition` is a bit like a start of the moved range.\n\n    _this.sourcePosition.stickiness = 'toNext';\n    /**\n     * Offset size of moved range.\n     *\n     * @member {Number} module:engine/model/operation/moveoperation~MoveOperation#howMany\n     */\n\n    _this.howMany = howMany;\n    /**\n     * Position at which moved nodes will be inserted.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#targetPosition\n     */\n\n    _this.targetPosition = targetPosition.clone();\n    _this.targetPosition.stickiness = 'toNone';\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(MoveOperation, [{\n    key: \"clone\",\n\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/moveoperation~MoveOperation} Clone of this operation.\n     */\n    value: function clone() {\n      return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);\n    }\n    /**\n     * Returns the start position of the moved range after it got moved. This may be different than\n     * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved\n     * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}\n     * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.\n     *\n     *\t\t vv              vv\n     *\t\tabcdefg ===> adefbcg\n     *\t\t     ^          ^\n     *\t\t     targetPos\tmovedRangeStart\n     *\t\t     offset 6\toffset 4\n     *\n     * @returns {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"getMovedRangeStart\",\n    value: function getMovedRangeStart() {\n      return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/moveoperation~MoveOperation}\n     */\n\n  }, {\n    key: \"getReversed\",\n    value: function getReversed() {\n      var newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);\n\n      return new this.constructor(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate() {\n      var sourceElement = this.sourcePosition.parent;\n      var targetElement = this.targetPosition.parent;\n      var sourceOffset = this.sourcePosition.offset;\n      var targetOffset = this.targetPosition.offset; // Validate whether move operation has correct parameters.\n      // Validation is pretty complex but move operation is one of the core ways to manipulate the document state.\n      // We expect that many errors might be connected with one of scenarios described below.\n\n      if (sourceOffset + this.howMany > sourceElement.maxOffset) {\n        /**\n         * The nodes which should be moved do not exist.\n         *\n         * @error move-operation-nodes-do-not-exist\n         */\n        throw new CKEditorError('move-operation-nodes-do-not-exist', this);\n      } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {\n        /**\n         * Trying to move a range of nodes into the middle of that range.\n         *\n         * @error move-operation-range-into-itself\n         */\n        throw new CKEditorError('move-operation-range-into-itself', this);\n      } else if (this.sourcePosition.root == this.targetPosition.root) {\n        if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == 'prefix') {\n          var i = this.sourcePosition.path.length - 1;\n\n          if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {\n            /**\n             * Trying to move a range of nodes into one of nodes from that range.\n             *\n             * @error move-operation-node-into-itself\n             */\n            throw new CKEditorError('move-operation-node-into-itself', this);\n          }\n        }\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute() {\n      _move(Range._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(MoveOperation.prototype), \"toJSON\", this).call(this);\n\n      json.sourcePosition = this.sourcePosition.toJSON();\n      json.targetPosition = this.targetPosition.toJSON();\n      return json;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      if (this.targetPosition.root.rootName == '$graveyard') {\n        return 'remove';\n      } else if (this.sourcePosition.root.rootName == '$graveyard') {\n        return 'reinsert';\n      }\n\n      return 'move';\n    }\n  }], [{\n    key: \"fromJSON\",\n\n    /**\n     * Creates `MoveOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/moveoperation~MoveOperation}\n     */\n    value: function fromJSON(json, document) {\n      var sourcePosition = Position.fromJSON(json.sourcePosition, document);\n      var targetPosition = Position.fromJSON(json.targetPosition, document);\n      return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \tconst range = ModelRange._createFromPositionAndShift( this.sourcePosition, this.howMany );\n    // @if CK_DEBUG_ENGINE //\treturn `MoveOperation( ${ this.baseVersion } ): ${ range } -> ${ this.targetPosition }`;\n    // @if CK_DEBUG_ENGINE // }\n\n  }, {\n    key: \"className\",\n    get: function get() {\n      return 'MoveOperation';\n    }\n  }]);\n\n  return MoveOperation;\n}(Operation);\n\nexport { MoveOperation as default };","map":null,"metadata":{},"sourceType":"module"}