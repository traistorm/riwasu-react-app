{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/emittermixin\n */\nimport { default as EmitterMixin, _getEmitterListenedTo, _setEmitterId } from '../emittermixin';\nimport uid from '../uid';\nimport isNode from './isnode';\nimport isWindow from './iswindow';\nimport { extend } from 'lodash-es';\n/**\n * Mixin that injects the DOM events API into its host. It provides the API\n * compatible with {@link module:utils/emittermixin~EmitterMixin}.\n *\n * DOM emitter mixin is by default available in the {@link module:ui/view~View} class,\n * but it can also be mixed into any other class:\n *\n *\t\timport mix from '../utils/mix.js';\n *\t\timport DomEmitterMixin from '../utils/dom/emittermixin.js';\n *\n *\t\tclass SomeView {}\n *\t\tmix( SomeView, DomEmitterMixin );\n *\n *\t\tconst view = new SomeView();\n *\t\tview.listenTo( domElement, ( evt, domEvt ) => {\n *\t\t\tconsole.log( evt, domEvt );\n *\t\t} );\n *\n * @mixin EmitterMixin\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/dom/emittermixin~Emitter\n */\n\nvar DomEmitterMixin = extend({}, EmitterMixin, {\n  /**\n   * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.\n   * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.\n   *\n   * @param {module:utils/emittermixin~Emitter|Node} emitter The object that fires the event.\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to be called on event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n   * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n   * order they were added.\n   * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n   * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n   * @param {Boolean} [options.usePassive=false] Indicates that the function specified by listener will never call preventDefault()\n   * and prevents blocking browser's main thread by this event handler.\n   */\n  listenTo: function listenTo(emitter, event, callback) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    // Check if emitter is an instance of DOM Node. If so, use corresponding ProxyEmitter (or create one if not existing).\n    if (isNode(emitter) || isWindow(emitter)) {\n      var proxyOptions = {\n        capture: !!options.useCapture,\n        passive: !!options.usePassive\n      };\n      var proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);\n      this.listenTo(proxyEmitter, event, callback, options);\n    } else {\n      // Execute parent class method with Emitter (or ProxyEmitter) instance.\n      EmitterMixin.listenTo.call(this, emitter, event, callback, options);\n    }\n  },\n\n  /**\n   * Stops listening for events. It can be used at different levels:\n   * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.\n   *\n   * * To stop listening to a specific callback.\n   * * To stop listening to a specific event.\n   * * To stop listening to all events fired by a specific object.\n   * * To stop listening to all events fired by all object.\n   *\n   * @param {module:utils/emittermixin~Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n   * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n   * for all events from `emitter`.\n   * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n   * `event`.\n   */\n  stopListening: function stopListening(emitter, event, callback) {\n    // Check if the emitter is an instance of DOM Node. If so, forward the call to the corresponding ProxyEmitters.\n    if (isNode(emitter) || isWindow(emitter)) {\n      var proxyEmitters = this._getAllProxyEmitters(emitter);\n\n      var _iterator = _createForOfIteratorHelper(proxyEmitters),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var proxy = _step.value;\n          this.stopListening(proxy, event, callback);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else {\n      // Execute parent class method with Emitter (or ProxyEmitter) instance.\n      EmitterMixin.stopListening.call(this, emitter, event, callback);\n    }\n  },\n\n  /**\n   * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.\n   *\n   * @private\n   * @param {Node} node DOM Node of the ProxyEmitter.\n   * @param {Object} [options] Additional options.\n   * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n   * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n   * @param {Boolean} [options.usePassive=false] Indicates that the function specified by listener will never call preventDefault()\n   * and prevents blocking browser's main thread by this event handler.\n   * @returns {module:utils/dom/emittermixin~ProxyEmitter|null} ProxyEmitter instance bound to the DOM Node.\n   */\n  _getProxyEmitter: function _getProxyEmitter(node, options) {\n    return _getEmitterListenedTo(this, getProxyEmitterId(node, options));\n  },\n\n  /**\n   * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.\n   *\n   * @private\n   * @param {Node} node DOM Node of the ProxyEmitter.\n   * @returns {Array.<module:utils/dom/emittermixin~ProxyEmitter>}\n   */\n  _getAllProxyEmitters: function _getAllProxyEmitters(node) {\n    var _this = this;\n\n    return [{\n      capture: false,\n      passive: false\n    }, {\n      capture: false,\n      passive: true\n    }, {\n      capture: true,\n      passive: false\n    }, {\n      capture: true,\n      passive: true\n    }].map(function (options) {\n      return _this._getProxyEmitter(node, options);\n    }).filter(function (proxy) {\n      return !!proxy;\n    });\n  }\n});\nexport default DomEmitterMixin;\n/**\n * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events\n * and any Host listening to them. It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#on}.\n * There is a separate instance for each combination of modes (useCapture & usePassive). The mode is concatenated with\n * UID stored in HTMLElement to give each instance unique identifier.\n *\n *                                  listenTo( click, ... )\n *                    +-----------------------------------------+\n *                    |              stopListening( ... )       |\n *     +----------------------------+                           |             addEventListener( click, ... )\n *     | Host                       |                           |   +---------------------------------------------+\n *     +----------------------------+                           |   |       removeEventListener( click, ... )     |\n *     | _listeningTo: {            |                +----------v-------------+                                   |\n *     |   UID+mode: {              |                | ProxyEmitter           |                                   |\n *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+\n *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |\n *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+\n *     |     }                      |                | },                     |                      | data-ck-expando: UID  |\n *     |   }                        |                | _domNode: Node,        |                      +-----------------------+\n *     | }                          |                | _domListeners: {},     |                                   |\n *     | +------------------------+ |                | _emitterId: UID+mode   |                                   |\n *     | | DomEmitterMixin        | |                +--------------^---------+                                   |\n *     | +------------------------+ |                           |   |                                             |\n *     +--------------^-------------+                           |   +---------------------------------------------+\n *                    |                                         |                  click (DOM Event)\n *                    +-----------------------------------------+\n *                                fire( click, DOM Event )\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @implements module:utils/dom/emittermixin~Emitter\n * @private\n */\n\nvar ProxyEmitter =\n/**\n * @param {Node} node DOM Node that fires events.\n * @param {Object} [options] Additional options.\n * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered\n * listener before being dispatched to any EventTarget beneath it in the DOM tree.\n * @param {Boolean} [options.usePassive=false] Indicates that the function specified by listener will never call preventDefault()\n * and prevents blocking browser's main thread by this event handler.\n */\nfunction ProxyEmitter(node, options) {\n  _classCallCheck(this, ProxyEmitter);\n\n  // Set emitter ID to match DOM Node \"expando\" property.\n  _setEmitterId(this, getProxyEmitterId(node, options)); // Remember the DOM Node this ProxyEmitter is bound to.\n\n\n  this._domNode = node; // And given options.\n\n  this._options = options;\n};\n\nextend(ProxyEmitter.prototype, EmitterMixin, {\n  /**\n   * Collection of native DOM listeners.\n   *\n   * @private\n   * @member {Object} module:utils/dom/emittermixin~ProxyEmitter#_domListeners\n   */\n\n  /**\n   * Registers a callback function to be executed when an event is fired.\n   *\n   * It attaches a native DOM listener to the DOM Node. When fired,\n   * a corresponding Emitter event will also fire with DOM Event object as an argument.\n   *\n   * **Note**: This is automatically called by the\n   * {@link module:utils/emittermixin~EmitterMixin#listenTo `EmitterMixin#listenTo()`}.\n   *\n   * @method module:utils/dom/emittermixin~ProxyEmitter#attach\n   * @param {String} event The name of the event.\n   */\n  attach: function attach(event) {\n    // If the DOM Listener for given event already exist it is pointless\n    // to attach another one.\n    if (this._domListeners && this._domListeners[event]) {\n      return;\n    }\n\n    var domListener = this._createDomListener(event); // Attach the native DOM listener to DOM Node.\n\n\n    this._domNode.addEventListener(event, domListener, this._options);\n\n    if (!this._domListeners) {\n      this._domListeners = {};\n    } // Store the native DOM listener in this ProxyEmitter. It will be helpful\n    // when stopping listening to the event.\n\n\n    this._domListeners[event] = domListener;\n  },\n\n  /**\n   * Stops executing the callback on the given event.\n   *\n   * **Note**: This is automatically called by the\n   * {@link module:utils/emittermixin~EmitterMixin#stopListening `EmitterMixin#stopListening()`}.\n   *\n   * @method module:utils/dom/emittermixin~ProxyEmitter#detach\n   * @param {String} event The name of the event.\n   */\n  detach: function detach(event) {\n    var events; // Remove native DOM listeners which are orphans. If no callbacks\n    // are awaiting given event, detach native DOM listener from DOM Node.\n    // See: {@link attach}.\n\n    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {\n      this._domListeners[event].removeListener();\n    }\n  },\n\n  /**\n   * Adds callback to emitter for given event.\n   *\n   * @protected\n   * @method module:utils/dom/emittermixin~ProxyEmitter#_addEventListener\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to be called on event.\n   * @param {Object} [options={}] Additional options.\n   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n   * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n   * order they were added.\n   */\n  _addEventListener: function _addEventListener(event, callback, options) {\n    this.attach(event);\n\n    EmitterMixin._addEventListener.call(this, event, callback, options);\n  },\n\n  /**\n   * Removes callback from emitter for given event.\n   *\n   * @protected\n   * @method module:utils/dom/emittermixin~ProxyEmitter#_removeEventListener\n   * @param {String} event The name of the event.\n   * @param {Function} callback The function to stop being called.\n   */\n  _removeEventListener: function _removeEventListener(event, callback) {\n    EmitterMixin._removeEventListener.call(this, event, callback);\n\n    this.detach(event);\n  },\n\n  /**\n   * Creates a native DOM listener callback. When the native DOM event\n   * is fired it will fire corresponding event on this ProxyEmitter.\n   * Note: A native DOM Event is passed as an argument.\n   *\n   * @private\n   * @method module:utils/dom/emittermixin~ProxyEmitter#_createDomListener\n   * @param {String} event The name of the event.\n   * @returns {Function} The DOM listener callback.\n   */\n  _createDomListener: function _createDomListener(event) {\n    var _this2 = this;\n\n    var domListener = function domListener(domEvt) {\n      _this2.fire(event, domEvt);\n    }; // Supply the DOM listener callback with a function that will help\n    // detach it from the DOM Node, when it is no longer necessary.\n    // See: {@link detach}.\n\n\n    domListener.removeListener = function () {\n      _this2._domNode.removeEventListener(event, domListener, _this2._options);\n\n      delete _this2._domListeners[event];\n    };\n\n    return domListener;\n  }\n}); // Gets an unique DOM Node identifier. The identifier will be set if not defined.\n//\n// @private\n// @param {Node} node\n// @returns {String} UID for given DOM Node.\n\nfunction getNodeUID(node) {\n  return node['data-ck-expando'] || (node['data-ck-expando'] = uid());\n} // Gets id of the ProxyEmitter for the given node.\n//\n// Combines DOM Node identifier and additional options.\n//\n// @private\n// @param {Node} node\n// @param {Object} options Additional options.\n// @returns {String} ProxyEmitter id.\n\n\nfunction getProxyEmitterId(node, options) {\n  var id = getNodeUID(node);\n\n  var _iterator2 = _createForOfIteratorHelper(Object.keys(options).sort()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var option = _step2.value;\n\n      if (options[option]) {\n        id += '-' + option;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return id;\n}\n/**\n * Interface representing classes which mix in {@link module:utils/dom/emittermixin~EmitterMixin}.\n *\n * @interface Emitter\n */","map":null,"metadata":{},"sourceType":"module"}