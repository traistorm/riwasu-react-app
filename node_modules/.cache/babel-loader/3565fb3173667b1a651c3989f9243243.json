{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/splitoperation\n */\nimport Operation from './operation';\nimport MergeOperation from './mergeoperation';\nimport Position from '../position';\nimport Range from '../range';\nimport { _insert, _move } from './utils';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Operation to split {@link module:engine/model/element~Element an element} at given\n * {@link module:engine/model/operation/splitoperation~SplitOperation#splitPosition split position} into two elements,\n * both containing a part of the element's original content.\n *\n * @extends module:engine/model/operation/operation~Operation\n */\n\nvar SplitOperation = /*#__PURE__*/function (_Operation) {\n  _inherits(SplitOperation, _Operation);\n\n  /**\n   * Creates a split operation.\n   *\n   * @param {module:engine/model/position~Position} splitPosition Position at which an element should be split.\n   * @param {Number} howMany Total offset size of elements that are in the split element after `position`.\n   * @param {module:engine/model/position~Position} insertionPosition Position at which the clone of split element\n   * (or element from graveyard) will be inserted.\n   * @param {module:engine/model/position~Position|null} graveyardPosition Position in the graveyard root before the element which\n   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.\n   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation\n   * can be applied or `null` if the operation operates on detached (non-document) tree.\n   */\n  function SplitOperation(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {\n    var _this;\n\n    _classCallCheck(this, SplitOperation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SplitOperation).call(this, baseVersion));\n    /**\n     * Position at which an element should be split.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#splitPosition\n     */\n\n    _this.splitPosition = splitPosition.clone(); // Keep position sticking to the next node. This way any new content added at the place where the element is split\n    // will be left in the original element.\n\n    _this.splitPosition.stickiness = 'toNext';\n    /**\n     * Total offset size of elements that are in the split element after `position`.\n     *\n     * @member {Number} module:engine/model/operation/splitoperation~SplitOperation#howMany\n     */\n\n    _this.howMany = howMany;\n    /**\n     * Position at which the clone of split element (or element from graveyard) will be inserted.\n     *\n     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#insertionPosition\n     */\n\n    _this.insertionPosition = insertionPosition;\n    /**\n     * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.\n     * If it is not set, a copy of the the `position` parent will be used.\n     *\n     * The default behavior is to clone the split element. Element from graveyard is used during undo.\n     *\n     * @member {module:engine/model/position~Position|null} #graveyardPosition\n     */\n\n    _this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;\n\n    if (_this.graveyardPosition) {\n      _this.graveyardPosition.stickiness = 'toNext';\n    }\n\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(SplitOperation, [{\n    key: \"clone\",\n\n    /**\n     * Creates and returns an operation that has the same parameters as this operation.\n     *\n     * @returns {module:engine/model/operation/splitoperation~SplitOperation} Clone of this operation.\n     */\n    value: function clone() {\n      return new this.constructor(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);\n    }\n    /**\n     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.\n     *\n     * @returns {module:engine/model/operation/mergeoperation~MergeOperation}\n     */\n\n  }, {\n    key: \"getReversed\",\n    value: function getReversed() {\n      var graveyard = this.splitPosition.root.document.graveyard;\n      var graveyardPosition = new Position(graveyard, [0]);\n      return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate() {\n      var element = this.splitPosition.parent;\n      var offset = this.splitPosition.offset; // Validate whether split operation has correct parameters.\n\n      if (!element || element.maxOffset < offset) {\n        /**\n         * Split position is invalid.\n         *\n         * @error split-operation-position-invalid\n         */\n        throw new CKEditorError('split-operation-position-invalid', this);\n      } else if (!element.parent) {\n        /**\n         * Cannot split root element.\n         *\n         * @error split-operation-split-in-root\n         */\n        throw new CKEditorError('split-operation-split-in-root', this);\n      } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {\n        /**\n         * Split operation specifies wrong number of nodes to move.\n         *\n         * @error split-operation-how-many-invalid\n         */\n        throw new CKEditorError('split-operation-how-many-invalid', this);\n      } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {\n        /**\n         * Graveyard position invalid.\n         *\n         * @error split-operation-graveyard-position-invalid\n         */\n        throw new CKEditorError('split-operation-graveyard-position-invalid', this);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute() {\n      var splitElement = this.splitPosition.parent;\n\n      if (this.graveyardPosition) {\n        _move(Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);\n      } else {\n        var newElement = splitElement._clone();\n\n        _insert(this.insertionPosition, newElement);\n      }\n\n      var sourceRange = new Range(Position._createAt(splitElement, this.splitPosition.offset), Position._createAt(splitElement, splitElement.maxOffset));\n\n      _move(sourceRange, this.moveTargetPosition);\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(SplitOperation.prototype), \"toJSON\", this).call(this);\n\n      json.splitPosition = this.splitPosition.toJSON();\n      json.insertionPosition = this.insertionPosition.toJSON();\n\n      if (this.graveyardPosition) {\n        json.graveyardPosition = this.graveyardPosition.toJSON();\n      }\n\n      return json;\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'split';\n    }\n    /**\n     * Position inside the new clone of a split element.\n     *\n     * This is a position where nodes that are after the split position will be moved to.\n     *\n     * @readonly\n     * @type {module:engine/model/position~Position}\n     */\n\n  }, {\n    key: \"moveTargetPosition\",\n    get: function get() {\n      var path = this.insertionPosition.path.slice();\n      path.push(0);\n      return new Position(this.insertionPosition.root, path);\n    }\n    /**\n     * Artificial range that contains all the nodes from the split element that will be moved to the new element.\n     * The range starts at {@link ~#splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.\n     *\n     * @readonly\n     * @type {module:engine/model/range~Range}\n     */\n\n  }, {\n    key: \"movedRange\",\n    get: function get() {\n      var end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);\n      return new Range(this.splitPosition, end);\n    }\n  }], [{\n    key: \"getInsertionPosition\",\n\n    /**\n     * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion\n     * position is after the split element.\n     *\n     * @param {module:engine/model/position~Position} splitPosition\n     * @returns {module:engine/model/position~Position}\n     */\n    value: function getInsertionPosition(splitPosition) {\n      var path = splitPosition.path.slice(0, -1);\n      path[path.length - 1]++;\n      return new Position(splitPosition.root, path, 'toPrevious');\n    }\n    /**\n     * Creates `SplitOperation` object from deserilized object, i.e. from parsed JSON string.\n     *\n     * @param {Object} json Deserialized JSON object.\n     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.\n     * @returns {module:engine/model/operation/splitoperation~SplitOperation}\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json, document) {\n      var splitPosition = Position.fromJSON(json.splitPosition, document);\n      var insertionPosition = Position.fromJSON(json.insertionPosition, document);\n      var graveyardPosition = json.graveyardPosition ? Position.fromJSON(json.graveyardPosition, document) : null;\n      return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);\n    } // @if CK_DEBUG_ENGINE // toString() {\n    // @if CK_DEBUG_ENGINE // \treturn `SplitOperation( ${ this.baseVersion } ): ${ this.splitPosition } ` +\n    // @if CK_DEBUG_ENGINE //\t\t`( ${ this.howMany } ) -> ${ this.insertionPosition }` +\n    // @if CK_DEBUG_ENGINE //\t\t`${ this.graveyardPosition ? ' with ' + this.graveyardPosition : '' }`;\n    // @if CK_DEBUG_ENGINE // }\n\n  }, {\n    key: \"className\",\n    get: function get() {\n      return 'SplitOperation';\n    }\n  }]);\n\n  return SplitOperation;\n}(Operation);\n\nexport { SplitOperation as default };","map":null,"metadata":{},"sourceType":"module"}