{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module ui/editableui/editableuiview\n */\nimport View from '../view';\n/**\n * The editable UI view class.\n *\n * @extends module:ui/view~View\n */\n\nvar EditableUIView = /*#__PURE__*/function (_View) {\n  _inherits(EditableUIView, _View);\n\n  /**\n   * Creates an instance of EditableUIView class.\n   *\n   * @param {module:utils/locale~Locale} [locale] The locale instance.\n   * @param {module:engine/view/view~View} editingView The editing view instance the editable is related to.\n   * @param {HTMLElement} [editableElement] The editable element. If not specified, this view\n   * should create it. Otherwise, the existing element should be used.\n   */\n  function EditableUIView(locale, editingView, editableElement) {\n    var _this;\n\n    _classCallCheck(this, EditableUIView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditableUIView).call(this, locale));\n\n    _this.setTemplate({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-content', 'ck-editor__editable', 'ck-rounded-corners'],\n        lang: locale.contentLanguage,\n        dir: locale.contentLanguageDirection\n      }\n    });\n    /**\n     * The name of the editable UI view.\n     *\n     * @member {String} #name\n     */\n\n\n    _this.name = null;\n    /**\n     * Controls whether the editable is focused, i.e. the user is typing in it.\n     *\n     * @observable\n     * @member {Boolean} #isFocused\n     */\n\n    _this.set('isFocused', false);\n    /**\n     * The element which is the main editable element (usually the one with `contentEditable=\"true\"`).\n     *\n     * @private\n     * @type {HTMLElement}\n     */\n\n\n    _this._editableElement = editableElement;\n    /**\n     * Whether an external {@link #_editableElement} was passed into the constructor, which also means\n     * the view will not render its {@link #template}.\n     *\n     * @private\n     * @type {Boolean}\n     */\n\n    _this._hasExternalElement = !!_this._editableElement;\n    /**\n     * The editing view instance the editable is related to. Editable uses the editing\n     * view to dynamically modify its certain DOM attributes after {@link #render rendering}.\n     *\n     * **Note**: The DOM attributes are performed by the editing view and not UI\n     * {@link module:ui/view~View#bindTemplate template bindings} because once rendered,\n     * the editable DOM element must remain under the full control of the engine to work properly.\n     *\n     * @protected\n     * @type {module:engine/view/view~View}\n     */\n\n    _this._editingView = editingView;\n    return _this;\n  }\n  /**\n   * Renders the view by either applying the {@link #template} to the existing\n   * {@link #_editableElement} or assigning {@link #element} as {@link #_editableElement}.\n   */\n\n\n  _createClass(EditableUIView, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(EditableUIView.prototype), \"render\", this).call(this);\n\n      if (this._hasExternalElement) {\n        this.template.apply(this.element = this._editableElement);\n      } else {\n        this._editableElement = this.element;\n      }\n\n      this.on('change:isFocused', function () {\n        return _this2._updateIsFocusedClasses();\n      });\n\n      this._updateIsFocusedClasses();\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._hasExternalElement) {\n        this.template.revert(this._editableElement);\n      }\n\n      _get(_getPrototypeOf(EditableUIView.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to\n     * the {@link #isFocused} property value using the {@link #_editingView editing view} API.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_updateIsFocusedClasses\",\n    value: function _updateIsFocusedClasses() {\n      var editingView = this._editingView;\n\n      if (editingView.isRenderingInProgress) {\n        updateAfterRender(this);\n      } else {\n        update(this);\n      }\n\n      function update(view) {\n        editingView.change(function (writer) {\n          var viewRoot = editingView.document.getRoot(view.name);\n          writer.addClass(view.isFocused ? 'ck-focused' : 'ck-blurred', viewRoot);\n          writer.removeClass(view.isFocused ? 'ck-blurred' : 'ck-focused', viewRoot);\n        });\n      } // In a case of a multi-root editor, a callback will be attached more than once (one callback for each root).\n      // While executing one callback the `isRenderingInProgress` observable is changing what causes executing another\n      // callback and render is called inside the already pending render.\n      // We need to be sure that callback is executed only when the value has changed from `true` to `false`.\n      // See https://github.com/ckeditor/ckeditor5/issues/1676.\n\n\n      function updateAfterRender(view) {\n        editingView.once('change:isRenderingInProgress', function (evt, name, value) {\n          if (!value) {\n            update(view);\n          } else {\n            updateAfterRender(view);\n          }\n        });\n      }\n    }\n  }]);\n\n  return EditableUIView;\n}(View);\n\nexport { EditableUIView as default };","map":null,"metadata":{},"sourceType":"module"}