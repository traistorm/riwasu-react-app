{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\nimport Position from './position';\nimport Range from './range';\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\n\nvar Differ = /*#__PURE__*/function () {\n  /**\n   * Creates a `Differ` instance.\n   *\n   * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n   */\n  function Differ(markerCollection) {\n    _classCallCheck(this, Differ);\n\n    /**\n     * Reference to the model's marker collection.\n     *\n     * @private\n     * @type {module:engine/model/markercollection~MarkerCollection}\n     */\n    this._markerCollection = markerCollection;\n    /**\n     * A map that stores changes that happened in a given element.\n     *\n     * The keys of the map are references to the model elements.\n     * The values of the map are arrays with changes that were done on this element.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._changesInElement = new Map();\n    /**\n     * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n     * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n     * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n     *\n     * @private\n     * @type {Map}\n     */\n\n    this._elementSnapshots = new Map();\n    /**\n     * A map that stores all changed markers.\n     *\n     * The keys of the map are marker names.\n     * The values of the map are objects with the following properties:\n     * - `oldMarkerData`,\n     * - `newMarkerData`.\n     *\n     * @private\n     * @type {Map.<String, Object>}\n     */\n\n    this._changedMarkers = new Map();\n    /**\n     * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n     * when changes are sorted.\n     *\n     * @private\n     * @type {Number}\n     */\n\n    this._changeCount = 0;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n     * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores those changes that did not take place in graveyard root.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChanges = null;\n    /**\n     * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n     * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n     * return the cached value instead of calculating it again.\n     *\n     * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n     *\n     * @private\n     * @type {Array.<Object>|null}\n     */\n\n    this._cachedChangesWithGraveyard = null;\n    /**\n     * Set of model items that were marked to get refreshed in {@link #_refreshItem}.\n     *\n     * @private\n     * @type {Set.<module:engine/model/item~Item>}\n     */\n\n    this._refreshedItems = new Set();\n  }\n  /**\n   * Informs whether there are any changes buffered in `Differ`.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  _createClass(Differ, [{\n    key: \"bufferOperation\",\n\n    /**\n     * Buffers the given operation. An operation has to be buffered before it is executed.\n     *\n     * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n     * in the state before the operation is executed.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n     */\n    value: function bufferOperation(operation) {\n      // Below we take an operation, check its type, then use its parameters in marking (private) methods.\n      // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n      // Marking changes in them would cause a \"double\" changing then.\n      //\n      switch (operation.type) {\n        case 'insert':\n          {\n            if (this._isInInsertedElement(operation.position.parent)) {\n              return;\n            }\n\n            this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);\n\n            break;\n          }\n\n        case 'addAttribute':\n        case 'removeAttribute':\n        case 'changeAttribute':\n          {\n            var _iterator = _createForOfIteratorHelper(operation.range.getItems({\n              shallow: true\n            })),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n\n                if (this._isInInsertedElement(item.parent)) {\n                  continue;\n                }\n\n                this._markAttribute(item);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            break;\n          }\n\n        case 'remove':\n        case 'move':\n        case 'reinsert':\n          {\n            // When range is moved to the same position then not mark it as a change.\n            // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n            if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {\n              return;\n            }\n\n            var sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);\n\n            var targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);\n\n            if (!sourceParentInserted) {\n              this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);\n            }\n\n            if (!targetParentInserted) {\n              this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);\n            }\n\n            break;\n          }\n\n        case 'rename':\n          {\n            if (this._isInInsertedElement(operation.position.parent)) {\n              return;\n            }\n\n            this._markRemove(operation.position.parent, operation.position.offset, 1);\n\n            this._markInsert(operation.position.parent, operation.position.offset, 1);\n\n            var range = Range._createFromPositionAndShift(operation.position, 1);\n\n            var _iterator2 = _createForOfIteratorHelper(this._markerCollection.getMarkersIntersectingRange(range)),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var marker = _step2.value;\n                var markerData = marker.getData();\n                this.bufferMarkerChange(marker.name, markerData, markerData);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            break;\n          }\n\n        case 'split':\n          {\n            var splitElement = operation.splitPosition.parent; // Mark that children of the split element were removed.\n\n            if (!this._isInInsertedElement(splitElement)) {\n              this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);\n            } // Mark that the new element (split copy) was inserted.\n\n\n            if (!this._isInInsertedElement(operation.insertionPosition.parent)) {\n              this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);\n            } // If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\n\n            if (operation.graveyardPosition) {\n              this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);\n            }\n\n            break;\n          }\n\n        case 'merge':\n          {\n            // Mark that the merged element was removed.\n            var mergedElement = operation.sourcePosition.parent;\n\n            if (!this._isInInsertedElement(mergedElement.parent)) {\n              this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);\n            } // Mark that the merged element was inserted into graveyard.\n\n\n            var graveyardParent = operation.graveyardPosition.parent;\n\n            this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1); // Mark that children of merged element were inserted at new parent.\n\n\n            var mergedIntoElement = operation.targetPosition.parent;\n\n            if (!this._isInInsertedElement(mergedIntoElement)) {\n              this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);\n            }\n\n            break;\n          }\n      } // Clear cache after each buffered operation as it is no longer valid.\n\n\n      this._cachedChanges = null;\n    }\n    /**\n     * Buffers a marker change.\n     *\n     * @param {String} markerName The name of the marker that changed.\n     * @param {module:engine/model/markercollection~MarkerData} oldMarkerData Marker data before the change.\n     * @param {module:engine/model/markercollection~MarkerData} newMarkerData Marker data after the change.\n     */\n\n  }, {\n    key: \"bufferMarkerChange\",\n    value: function bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {\n      var buffered = this._changedMarkers.get(markerName);\n\n      if (!buffered) {\n        this._changedMarkers.set(markerName, {\n          newMarkerData: newMarkerData,\n          oldMarkerData: oldMarkerData\n        });\n      } else {\n        buffered.newMarkerData = newMarkerData;\n\n        if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {\n          // The marker is going to be removed (`newMarkerData.range == null`) but it did not exist before the first buffered change\n          // (`buffered.oldMarkerData.range == null`). In this case, do not keep the marker in buffer at all.\n          this._changedMarkers.delete(markerName);\n        }\n      }\n    }\n    /**\n     * Returns all markers that should be removed as a result of buffered changes.\n     *\n     * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n     */\n\n  }, {\n    key: \"getMarkersToRemove\",\n    value: function getMarkersToRemove() {\n      var result = [];\n\n      var _iterator3 = _createForOfIteratorHelper(this._changedMarkers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              name = _step3$value[0],\n              change = _step3$value[1];\n\n          if (change.oldMarkerData.range != null) {\n            result.push({\n              name: name,\n              range: change.oldMarkerData.range\n            });\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return result;\n    }\n    /**\n     * Returns all markers which should be added as a result of buffered changes.\n     *\n     * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n     */\n\n  }, {\n    key: \"getMarkersToAdd\",\n    value: function getMarkersToAdd() {\n      var result = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this._changedMarkers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              name = _step4$value[0],\n              change = _step4$value[1];\n\n          if (change.newMarkerData.range != null) {\n            result.push({\n              name: name,\n              range: change.newMarkerData.range\n            });\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return result;\n    }\n    /**\n     * Returns all markers which changed.\n     *\n     * @returns {Array.<Object>}\n     */\n\n  }, {\n    key: \"getChangedMarkers\",\n    value: function getChangedMarkers() {\n      return Array.from(this._changedMarkers).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            change = _ref2[1];\n\n        return {\n          name: name,\n          data: {\n            oldRange: change.oldMarkerData.range,\n            newRange: change.newMarkerData.range\n          }\n        };\n      });\n    }\n    /**\n     * Checks whether some of the buffered changes affect the editor data.\n     *\n     * Types of changes which affect the editor data:\n     *\n     * * model structure changes,\n     * * attribute changes,\n     * * changes of markers which were defined as `affectsData`,\n     * * changes of markers' `affectsData` property.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasDataChanges\",\n    value: function hasDataChanges() {\n      if (this._changesInElement.size > 0) {\n        return true;\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(this._changedMarkers.values()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _step5.value,\n              newMarkerData = _step5$value.newMarkerData,\n              oldMarkerData = _step5$value.oldMarkerData;\n\n          if (newMarkerData.affectsData !== oldMarkerData.affectsData) {\n            return true;\n          }\n\n          if (newMarkerData.affectsData) {\n            var markerAdded = newMarkerData.range && !oldMarkerData.range;\n            var markerRemoved = !newMarkerData.range && oldMarkerData.range;\n            var markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);\n\n            if (markerAdded || markerRemoved || markerChanged) {\n              return true;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return false;\n    }\n    /**\n     * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n     * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n     *\n     * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done\n     * on the model. The items are sorted by the position on which the change happened. If a position\n     * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.\n     *\n     * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.\n     *\n     * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n     * previous {@link #getChanges} call, the next call will return the cached value.\n     *\n     * @param {Object} options Additional options.\n     * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n     * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n     * @returns {Array.<module:engine/model/differ~DiffItem>} Diff between the old and the new model tree state.\n     */\n\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        includeChangesInGraveyard: false\n      };\n\n      // If there are cached changes, just return them instead of calculating changes again.\n      if (this._cachedChanges) {\n        if (options.includeChangesInGraveyard) {\n          return this._cachedChangesWithGraveyard.slice();\n        } else {\n          return this._cachedChanges.slice();\n        }\n      } // Will contain returned results.\n\n\n      var diffSet = []; // Check all changed elements.\n\n      var _iterator6 = _createForOfIteratorHelper(this._changesInElement.keys()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var element = _step6.value;\n\n          // Get changes for this element and sort them.\n          var changes = this._changesInElement.get(element).sort(function (a, b) {\n            if (a.offset === b.offset) {\n              if (a.type != b.type) {\n                // If there are multiple changes at the same position, \"remove\" change should be first.\n                // If the order is different, for example, we would first add some nodes and then removed them\n                // (instead of the nodes that we should remove).\n                return a.type == 'remove' ? -1 : 1;\n              }\n\n              return 0;\n            }\n\n            return a.offset < b.offset ? -1 : 1;\n          }); // Get children of this element before any change was applied on it.\n\n\n          var snapshotChildren = this._elementSnapshots.get(element); // Get snapshot of current element's children.\n\n\n          var elementChildren = _getChildrenSnapshot(element.getChildren()); // Generate actions basing on changes done on element.\n\n\n          var actions = _generateActionsFromChanges(snapshotChildren.length, changes);\n\n          var _i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\n          var j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n          // Process every action.\n\n          var _iterator8 = _createForOfIteratorHelper(actions),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var action = _step8.value;\n\n              if (action === 'i') {\n                // Generate diff item for this element and insert it into the diff set.\n                diffSet.push(this._getInsertDiff(element, _i, elementChildren[_i]));\n                _i++;\n              } else if (action === 'r') {\n                // Generate diff item for this element and insert it into the diff set.\n                diffSet.push(this._getRemoveDiff(element, _i, snapshotChildren[j]));\n                j++;\n              } else if (action === 'a') {\n                var _diffSet;\n\n                // Take attributes from saved and current children.\n                var elementAttributes = elementChildren[_i].attributes;\n                var snapshotAttributes = snapshotChildren[j].attributes;\n                var range = void 0;\n\n                if (elementChildren[_i].name == '$text') {\n                  range = new Range(Position._createAt(element, _i), Position._createAt(element, _i + 1));\n                } else {\n                  var index = element.offsetToIndex(_i);\n                  range = new Range(Position._createAt(element, _i), Position._createAt(element.getChild(index), 0));\n                } // Generate diff items for this change (there might be multiple attributes changed and\n                // there is a single diff for each of them) and insert them into the diff set.\n\n\n                (_diffSet = diffSet).push.apply(_diffSet, _toConsumableArray(this._getAttributesDiff(range, snapshotAttributes, elementAttributes)));\n\n                _i++;\n                j++;\n              } else {\n                // `action` is 'equal'. Child not changed.\n                _i++;\n                j++;\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        } // Then, sort the changes by the position (change at position before other changes is first).\n\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      diffSet.sort(function (a, b) {\n        // If the change is in different root, we don't care much, but we'd like to have all changes in given\n        // root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n        // will be processed first.\n        if (a.position.root != b.position.root) {\n          return a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n        } // If change happens at the same position...\n\n\n        if (a.position.isEqual(b.position)) {\n          // Keep chronological order of operations.\n          return a.changeCount - b.changeCount;\n        } // If positions differ, position \"on the left\" should be earlier in the result.\n\n\n        return a.position.isBefore(b.position) ? -1 : 1;\n      }); // Glue together multiple changes (mostly on text nodes).\n\n      for (var i = 1, prevIndex = 0; i < diffSet.length; i++) {\n        var prevDiff = diffSet[prevIndex];\n        var thisDiff = diffSet[i]; // Glue remove changes if they happen on text on same position.\n\n        var isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.isEqual(thisDiff.position); // Glue insert changes if they happen on text on consecutive fragments.\n\n        var isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset; // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\n        var isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n        if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {\n          prevDiff.length++;\n\n          if (isConsecutiveAttributeChange) {\n            prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);\n          }\n\n          diffSet[i] = null;\n        } else {\n          prevIndex = i;\n        }\n      }\n\n      diffSet = diffSet.filter(function (v) {\n        return v;\n      }); // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\n      var _iterator7 = _createForOfIteratorHelper(diffSet),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var item = _step7.value;\n          delete item.changeCount;\n\n          if (item.type == 'attribute') {\n            delete item.position;\n            delete item.length;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this._changeCount = 0; // Cache changes.\n\n      this._cachedChangesWithGraveyard = diffSet;\n      this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);\n\n      if (options.includeChangesInGraveyard) {\n        return this._cachedChangesWithGraveyard.slice();\n      } else {\n        return this._cachedChanges.slice();\n      }\n    }\n    /**\n     * Returns a set of model items that were marked to get refreshed.\n     *\n     * @return {Set.<module:engine/model/item~Item>}\n     */\n\n  }, {\n    key: \"getRefreshedItems\",\n    value: function getRefreshedItems() {\n      return new Set(this._refreshedItems);\n    }\n    /**\n     * Resets `Differ`. Removes all buffered changes.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._changesInElement.clear();\n\n      this._elementSnapshots.clear();\n\n      this._changedMarkers.clear();\n\n      this._refreshedItems = new Set();\n      this._cachedChanges = null;\n    }\n    /**\n     * Marks the given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted\n     * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.\n     *\n     * @protected\n     * @param {module:engine/model/item~Item} item Item to refresh.\n     */\n\n  }, {\n    key: \"_refreshItem\",\n    value: function _refreshItem(item) {\n      if (this._isInInsertedElement(item.parent)) {\n        return;\n      }\n\n      this._markRemove(item.parent, item.startOffset, item.offsetSize);\n\n      this._markInsert(item.parent, item.startOffset, item.offsetSize);\n\n      this._refreshedItems.add(item);\n\n      var range = Range._createOn(item);\n\n      var _iterator9 = _createForOfIteratorHelper(this._markerCollection.getMarkersIntersectingRange(range)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var marker = _step9.value;\n          var markerData = marker.getData();\n          this.bufferMarkerChange(marker.name, markerData, markerData);\n        } // Clear cache after each buffered operation as it is no longer valid.\n\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      this._cachedChanges = null;\n    }\n    /**\n     * Saves and handles an insert change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n\n  }, {\n    key: \"_markInsert\",\n    value: function _markInsert(parent, offset, howMany) {\n      var changeItem = {\n        type: 'insert',\n        offset: offset,\n        howMany: howMany,\n        count: this._changeCount++\n      };\n\n      this._markChange(parent, changeItem);\n    }\n    /**\n     * Saves and handles a remove change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n\n  }, {\n    key: \"_markRemove\",\n    value: function _markRemove(parent, offset, howMany) {\n      var changeItem = {\n        type: 'remove',\n        offset: offset,\n        howMany: howMany,\n        count: this._changeCount++\n      };\n\n      this._markChange(parent, changeItem);\n\n      this._removeAllNestedChanges(parent, offset, howMany);\n    }\n    /**\n     * Saves and handles an attribute change.\n     *\n     * @private\n     * @param {module:engine/model/item~Item} item\n     */\n\n  }, {\n    key: \"_markAttribute\",\n    value: function _markAttribute(item) {\n      var changeItem = {\n        type: 'attribute',\n        offset: item.startOffset,\n        howMany: item.offsetSize,\n        count: this._changeCount++\n      };\n\n      this._markChange(item.parent, changeItem);\n    }\n    /**\n     * Saves and handles a model change.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Object} changeItem\n     */\n\n  }, {\n    key: \"_markChange\",\n    value: function _markChange(parent, changeItem) {\n      // First, make a snapshot of this parent's children (it will be made only if it was not made before).\n      this._makeSnapshot(parent); // Then, get all changes that already were done on the element (empty array if this is the first change).\n\n\n      var changes = this._getChangesForElement(parent); // Then, look through all the changes, and transform them or the new change.\n\n\n      this._handleChange(changeItem, changes); // Add the new change.\n\n\n      changes.push(changeItem); // Remove incorrect changes. During transformation some change might be, for example, included in another.\n      // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\n      for (var i = 0; i < changes.length; i++) {\n        if (changes[i].howMany < 1) {\n          changes.splice(i, 1);\n          i--;\n        }\n      }\n    }\n    /**\n     * Gets an array of changes that have already been saved for a given element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element\n     * @returns {Array.<Object>}\n     */\n\n  }, {\n    key: \"_getChangesForElement\",\n    value: function _getChangesForElement(element) {\n      var changes;\n\n      if (this._changesInElement.has(element)) {\n        changes = this._changesInElement.get(element);\n      } else {\n        changes = [];\n\n        this._changesInElement.set(element, changes);\n      }\n\n      return changes;\n    }\n    /**\n     * Saves a children snapshot for a given element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element\n     */\n\n  }, {\n    key: \"_makeSnapshot\",\n    value: function _makeSnapshot(element) {\n      if (!this._elementSnapshots.has(element)) {\n        this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));\n      }\n    }\n    /**\n     * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n     * change and/or the old change.\n     *\n     * @private\n     * @param {Object} inc Incoming (new) change.\n     * @param {Array.<Object>} changes An array containing all the changes done on that element.\n     */\n\n  }, {\n    key: \"_handleChange\",\n    value: function _handleChange(inc, changes) {\n      // We need a helper variable that will store how many nodes are to be still handled for this change item.\n      // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n      // needs to be differentiated.\n      //\n      // This comes up when there are multiple changes that are affected by `inc` change item.\n      //\n      // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n      // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n      //\n      // Then, we:\n      // - \"forget\" about first insert change (it is \"eaten\" by remove),\n      // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n      // - but still we have to change offset of the second insert change from `5` to `3`!\n      //\n      // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n      // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n      inc.nodesToHandle = inc.howMany;\n\n      var _iterator10 = _createForOfIteratorHelper(changes),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var old = _step10.value;\n          var incEnd = inc.offset + inc.howMany;\n          var oldEnd = old.offset + old.howMany;\n\n          if (inc.type == 'insert') {\n            if (old.type == 'insert') {\n              if (inc.offset <= old.offset) {\n                old.offset += inc.howMany;\n              } else if (inc.offset < oldEnd) {\n                old.howMany += inc.nodesToHandle;\n                inc.nodesToHandle = 0;\n              }\n            }\n\n            if (old.type == 'remove') {\n              if (inc.offset < old.offset) {\n                old.offset += inc.howMany;\n              }\n            }\n\n            if (old.type == 'attribute') {\n              if (inc.offset <= old.offset) {\n                old.offset += inc.howMany;\n              } else if (inc.offset < oldEnd) {\n                // This case is more complicated, because attribute change has to be split into two.\n                // Example (assume that uppercase and lowercase letters mean different attributes):\n                //\n                // initial state:\t\tabcxyz\n                // attribute change:\taBCXYz\n                // incoming insert:\t\taBCfooXYz\n                //\n                // Change ranges cannot intersect because each item has to be described exactly (it was either\n                // not changed, inserted, removed, or its attribute was changed). That's why old attribute\n                // change has to be split and both parts has to be handled separately from now on.\n                var howMany = old.howMany;\n                old.howMany = inc.offset - old.offset; // Add the second part of attribute change to the beginning of processed array so it won't\n                // be processed again in this loop.\n\n                changes.unshift({\n                  type: 'attribute',\n                  offset: incEnd,\n                  howMany: howMany - old.howMany,\n                  count: this._changeCount++\n                });\n              }\n            }\n          }\n\n          if (inc.type == 'remove') {\n            if (old.type == 'insert') {\n              if (incEnd <= old.offset) {\n                old.offset -= inc.howMany;\n              } else if (incEnd <= oldEnd) {\n                if (inc.offset < old.offset) {\n                  var intersectionLength = incEnd - old.offset;\n                  old.offset = inc.offset;\n                  old.howMany -= intersectionLength;\n                  inc.nodesToHandle -= intersectionLength;\n                } else {\n                  old.howMany -= inc.nodesToHandle;\n                  inc.nodesToHandle = 0;\n                }\n              } else {\n                if (inc.offset <= old.offset) {\n                  inc.nodesToHandle -= old.howMany;\n                  old.howMany = 0;\n                } else if (inc.offset < oldEnd) {\n                  var _intersectionLength = oldEnd - inc.offset;\n\n                  old.howMany -= _intersectionLength;\n                  inc.nodesToHandle -= _intersectionLength;\n                }\n              }\n            }\n\n            if (old.type == 'remove') {\n              if (incEnd <= old.offset) {\n                old.offset -= inc.howMany;\n              } else if (inc.offset < old.offset) {\n                inc.nodesToHandle += old.howMany;\n                old.howMany = 0;\n              }\n            }\n\n            if (old.type == 'attribute') {\n              if (incEnd <= old.offset) {\n                old.offset -= inc.howMany;\n              } else if (inc.offset < old.offset) {\n                var _intersectionLength2 = incEnd - old.offset;\n\n                old.offset = inc.offset;\n                old.howMany -= _intersectionLength2;\n              } else if (inc.offset < oldEnd) {\n                if (incEnd <= oldEnd) {\n                  // On first sight in this case we don't need to split attribute operation into two.\n                  // However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n                  // For that reason, no two changes may intersect.\n                  // So we cannot have an attribute change that \"contains\" remove change.\n                  // Attribute change needs to be split.\n                  var _howMany = old.howMany;\n                  old.howMany = inc.offset - old.offset;\n                  var howManyAfter = _howMany - old.howMany - inc.nodesToHandle; // Add the second part of attribute change to the beginning of processed array so it won't\n                  // be processed again in this loop.\n\n                  changes.unshift({\n                    type: 'attribute',\n                    offset: inc.offset,\n                    howMany: howManyAfter,\n                    count: this._changeCount++\n                  });\n                } else {\n                  old.howMany -= oldEnd - inc.offset;\n                }\n              }\n            }\n          }\n\n          if (inc.type == 'attribute') {\n            // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n            if (old.type == 'insert') {\n              if (inc.offset < old.offset && incEnd > old.offset) {\n                if (incEnd > oldEnd) {\n                  // This case is similar to a case described when incoming change was insert and old change was attribute.\n                  // See comment above.\n                  //\n                  // This time incoming change is attribute. We need to split incoming change in this case too.\n                  // However this time, the second part of the attribute change needs to be processed further\n                  // because there might be other changes that it collides with.\n                  var attributePart = {\n                    type: 'attribute',\n                    offset: oldEnd,\n                    howMany: incEnd - oldEnd,\n                    count: this._changeCount++\n                  };\n\n                  this._handleChange(attributePart, changes);\n\n                  changes.push(attributePart);\n                }\n\n                inc.nodesToHandle = old.offset - inc.offset;\n                inc.howMany = inc.nodesToHandle;\n              } else if (inc.offset >= old.offset && inc.offset < oldEnd) {\n                if (incEnd > oldEnd) {\n                  inc.nodesToHandle = incEnd - oldEnd;\n                  inc.offset = oldEnd;\n                } else {\n                  inc.nodesToHandle = 0;\n                }\n              }\n            }\n\n            if (old.type == 'remove') {\n              // This is a case when attribute change \"contains\" remove change.\n              // The attribute change needs to be split into two because changes cannot intersect.\n              if (inc.offset < old.offset && incEnd > old.offset) {\n                var _attributePart = {\n                  type: 'attribute',\n                  offset: old.offset,\n                  howMany: incEnd - old.offset,\n                  count: this._changeCount++\n                };\n\n                this._handleChange(_attributePart, changes);\n\n                changes.push(_attributePart);\n                inc.nodesToHandle = old.offset - inc.offset;\n                inc.howMany = inc.nodesToHandle;\n              }\n            }\n\n            if (old.type == 'attribute') {\n              // There are only two conflicting scenarios possible here:\n              if (inc.offset >= old.offset && incEnd <= oldEnd) {\n                // `old` change includes `inc` change, or they are the same.\n                inc.nodesToHandle = 0;\n                inc.howMany = 0;\n                inc.offset = 0;\n              } else if (inc.offset <= old.offset && incEnd >= oldEnd) {\n                // `inc` change includes `old` change.\n                old.howMany = 0;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      inc.howMany = inc.nodesToHandle;\n      delete inc.nodesToHandle;\n    }\n    /**\n     * Returns an object with a single insert change description.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent The element in which the change happened.\n     * @param {Number} offset The offset at which change happened.\n     * @param {Object} elementSnapshot The snapshot of the removed element a character.\n     * @returns {Object} The diff item.\n     */\n\n  }, {\n    key: \"_getInsertDiff\",\n    value: function _getInsertDiff(parent, offset, elementSnapshot) {\n      return {\n        type: 'insert',\n        position: Position._createAt(parent, offset),\n        name: elementSnapshot.name,\n        attributes: new Map(elementSnapshot.attributes),\n        length: 1,\n        changeCount: this._changeCount++\n      };\n    }\n    /**\n     * Returns an object with a single remove change description.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent The element in which change happened.\n     * @param {Number} offset The offset at which change happened.\n     * @param {Object} elementSnapshot The snapshot of the removed element a character.\n     * @returns {Object} The diff item.\n     */\n\n  }, {\n    key: \"_getRemoveDiff\",\n    value: function _getRemoveDiff(parent, offset, elementSnapshot) {\n      return {\n        type: 'remove',\n        position: Position._createAt(parent, offset),\n        name: elementSnapshot.name,\n        attributes: new Map(elementSnapshot.attributes),\n        length: 1,\n        changeCount: this._changeCount++\n      };\n    }\n    /**\n     * Returns an array of objects where each one is a single attribute change description.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range The range where the change happened.\n     * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n     * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n     * @returns {Array.<Object>} An array containing one or more diff items.\n     */\n\n  }, {\n    key: \"_getAttributesDiff\",\n    value: function _getAttributesDiff(range, oldAttributes, newAttributes) {\n      // Results holder.\n      var diffs = []; // Clone new attributes as we will be performing changes on this object.\n\n      newAttributes = new Map(newAttributes); // Look through old attributes.\n\n      var _iterator11 = _createForOfIteratorHelper(oldAttributes),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _step11$value = _slicedToArray(_step11.value, 2),\n              key = _step11$value[0],\n              oldValue = _step11$value[1];\n\n          // Check what is the new value of the attribute (or if it was removed).\n          var newValue = newAttributes.has(key) ? newAttributes.get(key) : null; // If values are different (or attribute was removed)...\n\n          if (newValue !== oldValue) {\n            // Add diff item.\n            diffs.push({\n              type: 'attribute',\n              position: range.start,\n              range: range.clone(),\n              length: 1,\n              attributeKey: key,\n              attributeOldValue: oldValue,\n              attributeNewValue: newValue,\n              changeCount: this._changeCount++\n            });\n          } // Prevent returning two diff items for the same change.\n\n\n          newAttributes.delete(key);\n        } // Look through new attributes that weren't handled above.\n\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(newAttributes),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _step12$value = _slicedToArray(_step12.value, 2),\n              _key = _step12$value[0],\n              _newValue = _step12$value[1];\n\n          // Each of them is a new attribute. Add diff item.\n          diffs.push({\n            type: 'attribute',\n            position: range.start,\n            range: range.clone(),\n            length: 1,\n            attributeKey: _key,\n            attributeOldValue: null,\n            attributeNewValue: _newValue,\n            changeCount: this._changeCount++\n          });\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return diffs;\n    }\n    /**\n     * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} element Element to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isInInsertedElement\",\n    value: function _isInInsertedElement(element) {\n      var parent = element.parent;\n\n      if (!parent) {\n        return false;\n      }\n\n      var changes = this._changesInElement.get(parent);\n\n      var offset = element.startOffset;\n\n      if (changes) {\n        var _iterator13 = _createForOfIteratorHelper(changes),\n            _step13;\n\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var change = _step13.value;\n\n            if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n\n      return this._isInInsertedElement(parent);\n    }\n    /**\n     * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n     * and `howMany`.\n     *\n     * @private\n     * @param {module:engine/model/element~Element} parent\n     * @param {Number} offset\n     * @param {Number} howMany\n     */\n\n  }, {\n    key: \"_removeAllNestedChanges\",\n    value: function _removeAllNestedChanges(parent, offset, howMany) {\n      var range = new Range(Position._createAt(parent, offset), Position._createAt(parent, offset + howMany));\n\n      var _iterator14 = _createForOfIteratorHelper(range.getItems({\n        shallow: true\n      })),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var item = _step14.value;\n\n          if (item.is('element')) {\n            this._elementSnapshots.delete(item);\n\n            this._changesInElement.delete(item);\n\n            this._removeAllNestedChanges(item, 0, item.maxOffset);\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n    }\n  }]);\n\n  return Differ;\n}(); // Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\n\n\nexport { Differ as default };\n\nfunction _getChildrenSnapshot(children) {\n  var snapshot = [];\n\n  var _iterator15 = _createForOfIteratorHelper(children),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var child = _step15.value;\n\n      if (child.is('$text')) {\n        for (var i = 0; i < child.data.length; i++) {\n          snapshot.push({\n            name: '$text',\n            attributes: new Map(child.getAttributes())\n          });\n        }\n      } else {\n        snapshot.push({\n          name: child.name,\n          attributes: new Map(child.getAttributes())\n        });\n      }\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  return snapshot;\n} // Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\n\n\nfunction _generateActionsFromChanges(oldChildrenLength, changes) {\n  var actions = [];\n  var offset = 0;\n  var oldChildrenHandled = 0; // Go through all buffered changes.\n\n  var _iterator16 = _createForOfIteratorHelper(changes),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var change = _step16.value;\n\n      // First, fill \"holes\" between changes with \"equal\" actions.\n      if (change.offset > offset) {\n        for (var _i2 = 0; _i2 < change.offset - offset; _i2++) {\n          actions.push('e');\n        }\n\n        oldChildrenHandled += change.offset - offset;\n      } // Then, fill up actions accordingly to change type.\n\n\n      if (change.type == 'insert') {\n        for (var _i3 = 0; _i3 < change.howMany; _i3++) {\n          actions.push('i');\n        } // The last handled offset is after inserted range.\n\n\n        offset = change.offset + change.howMany;\n      } else if (change.type == 'remove') {\n        for (var _i4 = 0; _i4 < change.howMany; _i4++) {\n          actions.push('r');\n        } // The last handled offset is at the position where the nodes were removed.\n\n\n        offset = change.offset; // We removed `howMany` old nodes, update `oldChildrenHandled`.\n\n        oldChildrenHandled += change.howMany;\n      } else {\n        actions.push.apply(actions, _toConsumableArray('a'.repeat(change.howMany).split(''))); // The last handled offset is at the position after the changed range.\n\n        offset = change.offset + change.howMany; // We changed `howMany` old nodes, update `oldChildrenHandled`.\n\n        oldChildrenHandled += change.howMany;\n      }\n    } // Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n    // has not been changed / removed at the end of their parent.\n\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  if (oldChildrenHandled < oldChildrenLength) {\n    for (var i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {\n      actions.push('e');\n    }\n  }\n\n  return actions;\n} // Filter callback for Array.filter that filters out change entries that are in graveyard.\n\n\nfunction _changesInGraveyardFilter(entry) {\n  var posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n  var rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n  return !posInGy && !rangeInGy;\n}\n/**\n * The single diff item.\n *\n * Could be one of:\n *\n * * {@link module:engine/model/differ~DiffItemInsert `DiffItemInsert`},\n * * {@link module:engine/model/differ~DiffItemRemove `DiffItemRemove`},\n * * {@link module:engine/model/differ~DiffItemAttribute `DiffItemAttribute`}.\n *\n * @interface DiffItem\n */\n\n/**\n * The single diff item for inserted nodes.\n *\n * @class DiffItemInsert\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'insert'} module:engine/model/differ~DiffItemInsert#type\n */\n\n/**\n * The name of the inserted elements or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemInsert#name\n */\n\n/**\n * Map of attributes that were set on the item while it was inserted.\n *\n * @member {Map.<String,*>} module:engine/model/differ~DiffItemInsert#attributes\n */\n\n/**\n * The position where the node was inserted.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemInsert#position\n */\n\n/**\n * The length of an inserted text node. For elements it is always 1 as each inserted element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemInsert#length\n */\n\n/**\n * The single diff item for removed nodes.\n *\n * @class DiffItemRemove\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'remove'} module:engine/model/differ~DiffItemRemove#type\n */\n\n/**\n * The name of the removed element or `'$text'` for a text node.\n *\n * @member {String} module:engine/model/differ~DiffItemRemove#name\n */\n\n/**\n * Map of attributes that were set on the item while it was removed.\n *\n * @member {Map.<String,*>} module:engine/model/differ~DiffItemRemove#attributes\n */\n\n/**\n * The position where the node was removed.\n *\n * @member {module:engine/model/position~Position} module:engine/model/differ~DiffItemRemove#position\n */\n\n/**\n * The length of a removed text node. For elements it is always 1 as each removed element is counted as a one.\n *\n * @member {Number} module:engine/model/differ~DiffItemRemove#length\n */\n\n/**\n * The single diff item for attribute change.\n *\n * @class DiffItemAttribute\n * @implements module:engine/model/differ~DiffItem\n */\n\n/**\n * The type of diff item.\n *\n * @member {'attribute'} module:engine/model/differ~DiffItemAttribute#type\n */\n\n/**\n * The name of the changed attribute.\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeKey\n */\n\n/**\n * An attribute previous value (before change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeOldValue\n */\n\n/**\n * An attribute new value (after change).\n *\n * @member {String} module:engine/model/differ~DiffItemAttribute#attributeNewValue\n */\n\n/**\n * The range where the change happened.\n *\n * @member {module:engine/model/range~Range} module:engine/model/differ~DiffItemAttribute#range\n */","map":null,"metadata":{},"sourceType":"module"}