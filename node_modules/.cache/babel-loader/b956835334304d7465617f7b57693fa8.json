{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/image/imageblockediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { ClipboardPipeline } from 'ckeditor5/src/clipboard';\nimport { UpcastWriter } from 'ckeditor5/src/engine';\nimport { downcastImageAttribute, downcastSrcsetAttribute, upcastImageFigure } from './converters';\nimport ImageEditing from './imageediting';\nimport ImageTypeCommand from './imagetypecommand';\nimport ImageUtils from '../imageutils';\nimport { getImgViewElementMatcher, createBlockImageViewElement, determineImageTypeForInsertionAtSelection } from '../image/utils';\n/**\n * The image block plugin.\n *\n * It registers:\n *\n * * `<imageBlock>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.\n * * converters for editing and data pipelines.,\n * * {@link module:image/image/imagetypecommand~ImageTypeCommand `'imageTypeBlock'`} command that converts inline images into\n * block images.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageBlockEditing = /*#__PURE__*/function (_Plugin) {\n  _inherits(ImageBlockEditing, _Plugin);\n\n  function ImageBlockEditing() {\n    _classCallCheck(this, ImageBlockEditing);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageBlockEditing).apply(this, arguments));\n  }\n\n  _createClass(ImageBlockEditing, [{\n    key: \"init\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema; // Converters 'alt' and 'srcset' are added in 'ImageEditing' plugin.\n\n      schema.register('imageBlock', {\n        inheritAllFrom: '$blockObject',\n        allowAttributes: ['alt', 'src', 'srcset']\n      });\n\n      this._setupConversion();\n\n      if (editor.plugins.has('ImageInlineEditing')) {\n        editor.commands.add('imageTypeBlock', new ImageTypeCommand(this.editor, 'imageBlock'));\n\n        this._setupClipboardIntegration();\n      }\n    }\n    /**\n     * Configures conversion pipelines to support upcasting and downcasting\n     * block images (block image widgets) and their attributes.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupConversion\",\n    value: function _setupConversion() {\n      var editor = this.editor;\n      var t = editor.t;\n      var conversion = editor.conversion;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      conversion.for('dataDowncast').elementToStructure({\n        model: 'imageBlock',\n        view: function view(modelElement, _ref) {\n          var writer = _ref.writer;\n          return createBlockImageViewElement(writer);\n        }\n      });\n      conversion.for('editingDowncast').elementToStructure({\n        model: 'imageBlock',\n        view: function view(modelElement, _ref2) {\n          var writer = _ref2.writer;\n          return imageUtils.toImageWidget(createBlockImageViewElement(writer), writer, t('image widget'));\n        }\n      });\n      conversion.for('downcast').add(downcastImageAttribute(imageUtils, 'imageBlock', 'src')).add(downcastImageAttribute(imageUtils, 'imageBlock', 'alt')).add(downcastSrcsetAttribute(imageUtils, 'imageBlock')); // More image related upcasts are in 'ImageEditing' plugin.\n\n      conversion.for('upcast').elementToElement({\n        view: getImgViewElementMatcher(editor, 'imageBlock'),\n        model: function model(viewImage, _ref3) {\n          var writer = _ref3.writer;\n          return writer.createElement('imageBlock', viewImage.hasAttribute('src') ? {\n            src: viewImage.getAttribute('src')\n          } : null);\n        }\n      }).add(upcastImageFigure(imageUtils));\n    }\n    /**\n     * Integrates the plugin with the clipboard pipeline.\n     *\n     * Idea is that the feature should recognize the user's intent when an **inline** image is\n     * pasted or dropped. If such an image is pasted/dropped:\n     *\n     * * into an empty block (e.g. an empty paragraph),\n     * * on another object (e.g. some block widget).\n     *\n     * it gets converted into a block image on the fly. We assume this is the user's intent\n     * if they decided to put their image there.\n     *\n     * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupClipboardIntegration\",\n    value: function _setupClipboardIntegration() {\n      var editor = this.editor;\n      var model = editor.model;\n      var editingView = editor.editing.view;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      this.listenTo(editor.plugins.get('ClipboardPipeline'), 'inputTransformation', function (evt, data) {\n        var docFragmentChildren = Array.from(data.content.getChildren());\n        var modelRange; // Make sure only <img> elements are dropped or pasted. Otherwise, if there some other HTML\n        // mixed up, this should be handled as a regular paste.\n\n        if (!docFragmentChildren.every(imageUtils.isInlineImageView)) {\n          return;\n        } // When drag and dropping, data.targetRanges specifies where to drop because\n        // this is usually a different place than the current model selection (the user\n        // uses a drop marker to specify the drop location).\n\n\n        if (data.targetRanges) {\n          modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);\n        } // Pasting, however, always occurs at the current model selection.\n        else {\n          modelRange = model.document.selection.getFirstRange();\n        }\n\n        var selection = model.createSelection(modelRange); // Convert inline images into block images only when the currently selected block is empty\n        // (e.g. an empty paragraph) or some object is selected (to replace it).\n\n        if (determineImageTypeForInsertionAtSelection(model.schema, selection) === 'imageBlock') {\n          var writer = new UpcastWriter(editingView.document); // Wrap <img ... /> -> <figure class=\"image\"><img .../></figure>\n\n          var blockViewImages = docFragmentChildren.map(function (inlineViewImage) {\n            return writer.createElement('figure', {\n              class: 'image'\n            }, inlineViewImage);\n          });\n          data.content = writer.createDocumentFragment(blockViewImages);\n        }\n      });\n    }\n  }], [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ImageEditing, ImageUtils, ClipboardPipeline];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageBlockEditing';\n    }\n  }]);\n\n  return ImageBlockEditing;\n}(Plugin);\n\nexport { ImageBlockEditing as default };","map":null,"metadata":{},"sourceType":"module"}