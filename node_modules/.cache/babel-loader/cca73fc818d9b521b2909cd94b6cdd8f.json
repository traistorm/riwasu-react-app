{"ast":null,"code":"import _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/stylesmap\n */\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\n\nvar StylesMap = /*#__PURE__*/function () {\n  /**\n   * Creates Styles instance.\n   *\n   * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n   */\n  function StylesMap(styleProcessor) {\n    _classCallCheck(this, StylesMap);\n\n    /**\n     * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n     * value access model using lodash's get, set, unset, etc methods.\n     *\n     * When no style processor rules are defined it acts as simple key-value storage.\n     *\n     * @private\n     * @type {Object}\n     */\n    this._styles = {};\n    /**\n     * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n     *\n     * @private\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this._styleProcessor = styleProcessor;\n  }\n  /**\n   * Returns true if style map has no styles set.\n   *\n   * @type {Boolean}\n   */\n\n\n  _createClass(StylesMap, [{\n    key: \"setTo\",\n\n    /**\n     * Set styles map to a new value.\n     *\n     *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n     *\n     * @param {String} inlineStyle\n     */\n    value: function setTo(inlineStyle) {\n      this.clear();\n      var parsedStyles = Array.from(parseInlineStyles(inlineStyle).entries());\n\n      for (var _i = 0, _parsedStyles = parsedStyles; _i < _parsedStyles.length; _i++) {\n        var _parsedStyles$_i = _slicedToArray(_parsedStyles[_i], 2),\n            key = _parsedStyles$_i[0],\n            value = _parsedStyles$_i[1];\n\n        this._styleProcessor.toNormalizedForm(key, value, this._styles);\n      }\n    }\n    /**\n     * Checks if a given style is set.\n     *\n     *\t\tstyles.setTo( 'margin-left:1px;' );\n     *\n     *\t\tstyles.has( 'margin-left' );    // -> true\n     *\t\tstyles.has( 'padding' );        // -> false\n     *\n     * **Note**: This check supports normalized style names.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.setTo( 'margin:2px;' );\n     *\n     *\t\tstyles.has( 'margin' );         // -> true\n     *\t\tstyles.has( 'margin-top' );     // -> true\n     *\t\tstyles.has( 'margin-left' );    // -> true\n     *\n     *\t\tstyles.remove( 'margin-top' );\n     *\n     *\t\tstyles.has( 'margin' );         // -> false\n     *\t\tstyles.has( 'margin-top' );     // -> false\n     *\t\tstyles.has( 'margin-left' );    // -> true\n     *\n     * @param {String} name Style name.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      if (this.isEmpty) {\n        return false;\n      }\n\n      var styles = this._styleProcessor.getReducedForm(name, this._styles);\n\n      var propertyDescriptor = styles.find(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            property = _ref2[0];\n\n        return property === name;\n      }); // Only return a value if it is set;\n\n      return Array.isArray(propertyDescriptor);\n    }\n    /**\n     * Sets a given style.\n     *\n     * Can insert one by one:\n     *\n     *\t\tstyles.set( 'color', 'blue' );\n     *\t\tstyles.set( 'margin-right', '1em' );\n     *\n     * or many styles at once:\n     *\n     *\t\tstyles.set( {\n     *\t\t\tcolor: 'blue',\n     *\t\t\t'margin-right': '1em'\n     *\t\t} );\n     *\n     * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n     * enabled style processor rules} to normalize passed values.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.set( 'margin', '2px' );\n     *\n     * The above code will set margin to:\n     *\n     *\t\tstyles.getNormalized( 'margin' );\n     *\t\t// -> { top: '2px', right: '2px', bottom: '2px', left: '2px' }\n     *\n     * Which makes it possible to retrieve a \"sub-value\":\n     *\n     *\t\tstyles.get( 'margin-left' );       // -> '2px'\n     *\n     * Or modify it:\n     *\n     *\t\tstyles.remove( 'margin-left' );\n     *\n     *\t\tstyles.getNormalized( 'margin' );  // -> { top: '1px', bottom: '1px', right: '1px' }\n     *\t\tstyles.toString();                 // -> 'margin-bottom:1px;margin-right:1px;margin-top:1px;'\n     *\n     * This method also allows to set normalized values directly (if a particular styles processor rule was enabled):\n     *\n     *\t\tstyles.set( 'border-color', { top: 'blue' } );\n     *\t\tstyles.set( 'margin', { right: '2em' } );\n     *\n     *\t\tstyles.toString();                 // -> 'border-color-top:blue;margin-right:2em;'\n     *\n     * @param {String|Object} nameOrObject Style property name or object with multiple properties.\n     * @param {String|Object} valueOrObject Value to set.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(nameOrObject, valueOrObject) {\n      if (isObject(nameOrObject)) {\n        for (var _i2 = 0, _Object$entries = Object.entries(nameOrObject); _i2 < _Object$entries.length; _i2++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n              key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          this._styleProcessor.toNormalizedForm(key, value, this._styles);\n        }\n      } else {\n        this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);\n      }\n    }\n    /**\n     * Removes given style.\n     *\n     *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n     *\n     *\t\tstyles.remove( 'background' );\n     *\n     *\t\tstyles.toString();   // -> 'margin-right:2px;'\n     *\n     * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n     * enabled style processor rules} to normalize passed values.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.setTo( 'margin:1px' );\n     *\n     *\t\tstyles.remove( 'margin-top' );\n     *\t\tstyles.remove( 'margin-right' );\n     *\n     *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n     *\n     * @param {String} name Style name.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(name) {\n      var path = toPath(name);\n      unset(this._styles, path);\n      delete this._styles[name];\n\n      this._cleanEmptyObjectsOnPath(path);\n    }\n    /**\n     * Returns a normalized style object or a single value.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n     *\n     *\t\tstyles.getNormalized( 'margin' );\n     *\t\t// will log:\n     *\t\t// {\n     *\t\t//     top: '1px',\n     *\t\t//     right: '2px',\n     *\t\t//     bottom: '3em',\n     *\t\t//     left: '2px'     // normalized value from margin shorthand\n     *\t\t// }\n     *\n     *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n     *\n     * **Note**: This method will only return normalized styles if a style processor was defined.\n     *\n     * @param {String} name Style name.\n     * @returns {Object|String|undefined}\n     */\n\n  }, {\n    key: \"getNormalized\",\n    value: function getNormalized(name) {\n      return this._styleProcessor.getNormalized(name, this._styles);\n    }\n    /**\n     * Returns a normalized style string. Styles are sorted by name.\n     *\n     *\t\tstyles.set( 'margin' , '1px' );\n     *\t\tstyles.set( 'background', '#f00' );\n     *\n     *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n     *\n     * **Note**: This method supports normalized styles if defined.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tstyles.set( 'margin' , '1px' );\n     *\t\tstyles.set( 'background', '#f00' );\n     *\t\tstyles.remove( 'margin-top' );\n     *\t\tstyles.remove( 'margin-right' );\n     *\n     *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.isEmpty) {\n        return '';\n      }\n\n      return this._getStylesEntries().map(function (arr) {\n        return arr.join(':');\n      }).sort().join(';') + ';';\n    }\n    /**\n     * Returns property as a value string or undefined if property is not set.\n     *\n     *\t\t// Enable 'margin' shorthand processing:\n     *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\t\tstyles.set( 'margin-bottom', '3em' );\n     *\n     *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n     *\n     * Note, however, that all sub-values must be set for the longhand property name to return a value:\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\t\tstyles.remove( 'margin-bottom' );\n     *\n     *\t\tstyles.getAsString( 'margin' ); // -> undefined\n     *\n     * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n     * Instead, you should use:\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\t\tstyles.remove( 'margin-bottom' );\n     *\n     *\t\tfor ( const styleName of styles.getStyleNames() ) {\n     *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n     *\t\t}\n     *\t\t// 'margin-top', '1px'\n     *\t\t// 'margin-right', '1px'\n     *\t\t// 'margin-left', '1px'\n     *\n     * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n     * the currently set style values. So, if all the 4 margin values would be set\n     * the for-of loop above would yield only `'margin'`, `'1px'`:\n     *\n     *\t\tconst styles = new Styles();\n     *\t\tstyles.setTo( 'margin:1px;' );\n     *\n     *\t\tfor ( const styleName of styles.getStyleNames() ) {\n     *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n     *\t\t}\n     *\t\t// 'margin', '1px'\n     *\n     * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n     *\n     * @param {String} propertyName\n     * @returns {String|undefined}\n     */\n\n  }, {\n    key: \"getAsString\",\n    value: function getAsString(propertyName) {\n      if (this.isEmpty) {\n        return;\n      }\n\n      if (this._styles[propertyName] && !isObject(this._styles[propertyName])) {\n        // Try return styles set directly - values that are not parsed.\n        return this._styles[propertyName];\n      }\n\n      var styles = this._styleProcessor.getReducedForm(propertyName, this._styles);\n\n      var propertyDescriptor = styles.find(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            property = _ref4[0];\n\n        return property === propertyName;\n      }); // Only return a value if it is set;\n\n      if (Array.isArray(propertyDescriptor)) {\n        return propertyDescriptor[1];\n      }\n    }\n    /**\n     * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.\n     *\n     * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:\n     *\n     * \t\tstylesMap.setTo( 'margin: 1em' )\n     *\n     * will be expanded to:\n     *\n     * \t\t[ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]\n     *\n     * @param {Boolean} [expand=false] Expand shorthand style properties and all return equivalent style representations.\n     * @returns {Array.<String>}\n     */\n\n  }, {\n    key: \"getStyleNames\",\n    value: function getStyleNames() {\n      var expand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.isEmpty) {\n        return [];\n      }\n\n      if (expand) {\n        return this._styleProcessor.getStyleNames(this._styles);\n      }\n\n      var entries = this._getStylesEntries();\n\n      return entries.map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n            key = _ref6[0];\n\n        return key;\n      });\n    }\n    /**\n     * Removes all styles.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._styles = {};\n    }\n    /**\n     * Returns normalized styles entries for further processing.\n     *\n     * @private\n     * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n     */\n\n  }, {\n    key: \"_getStylesEntries\",\n    value: function _getStylesEntries() {\n      var parsed = [];\n      var keys = Object.keys(this._styles);\n\n      for (var _i3 = 0, _keys = keys; _i3 < _keys.length; _i3++) {\n        var key = _keys[_i3];\n        parsed.push.apply(parsed, _toConsumableArray(this._styleProcessor.getReducedForm(key, this._styles)));\n      }\n\n      return parsed;\n    }\n    /**\n     * Removes empty objects upon removing an entry from internal object.\n     *\n     * @param {String} path\n     * @private\n     */\n\n  }, {\n    key: \"_cleanEmptyObjectsOnPath\",\n    value: function _cleanEmptyObjectsOnPath(path) {\n      var pathParts = path.split('.');\n      var isChildPath = pathParts.length > 1;\n\n      if (!isChildPath) {\n        return;\n      }\n\n      var parentPath = pathParts.splice(0, pathParts.length - 1).join('.');\n      var parentObject = get(this._styles, parentPath);\n\n      if (!parentObject) {\n        return;\n      }\n\n      var isParentEmpty = !Array.from(Object.keys(parentObject)).length;\n\n      if (isParentEmpty) {\n        this.remove(parentPath);\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      var entries = Object.entries(this._styles);\n      var from = Array.from(entries);\n      return !from.length;\n    }\n    /**\n     * Number of styles defined.\n     *\n     * @type {Number}\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this.isEmpty) {\n        return 0;\n      }\n\n      return this.getStyleNames().length;\n    }\n  }]);\n\n  return StylesMap;\n}();\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\n\n\nexport { StylesMap as default };\nexport var StylesProcessor = /*#__PURE__*/function () {\n  /**\n   * Creates StylesProcessor instance.\n   *\n   * @private\n   */\n  function StylesProcessor() {\n    _classCallCheck(this, StylesProcessor);\n\n    this._normalizers = new Map();\n    this._extractors = new Map();\n    this._reducers = new Map();\n    this._consumables = new Map();\n  }\n  /**\n   * Parse style string value to a normalized object and appends it to styles object.\n   *\n   *\t\tconst styles = {};\n   *\n   *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n   *\n   *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n   *\n   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n   *\n   * @param {String} name Name of style property.\n   * @param {String} propertyValue Value of style property.\n   * @param {Object} styles Object holding normalized styles.\n   */\n\n\n  _createClass(StylesProcessor, [{\n    key: \"toNormalizedForm\",\n    value: function toNormalizedForm(name, propertyValue, styles) {\n      if (isObject(propertyValue)) {\n        appendStyleValue(styles, toPath(name), propertyValue);\n        return;\n      }\n\n      if (this._normalizers.has(name)) {\n        var normalizer = this._normalizers.get(name);\n\n        var _normalizer = normalizer(propertyValue),\n            path = _normalizer.path,\n            value = _normalizer.value;\n\n        appendStyleValue(styles, path, value);\n      } else {\n        appendStyleValue(styles, name, propertyValue);\n      }\n    }\n    /**\n     * Returns a normalized version of a style property.\n     *\t\tconst styles = {\n     *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n     *\t\t\tbackground: { color: '#f00' }\n     *\t\t};\n     *\n     *\t\tstylesProcessor.getNormalized( 'background' );\n     *\t\t// will return: { color: '#f00' }\n     *\n     *\t\tstylesProcessor.getNormalized( 'margin-top' );\n     *\t\t// will return: '1px'\n     *\n     * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n     *\n     * @param {String} name Name of style property.\n     * @param {Object} styles Object holding normalized styles.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getNormalized\",\n    value: function getNormalized(name, styles) {\n      if (!name) {\n        return merge({}, styles);\n      } // Might be empty string.\n\n\n      if (styles[name] !== undefined) {\n        return styles[name];\n      }\n\n      if (this._extractors.has(name)) {\n        var extractor = this._extractors.get(name);\n\n        if (typeof extractor === 'string') {\n          return get(styles, extractor);\n        }\n\n        var value = extractor(name, styles);\n\n        if (value) {\n          return value;\n        }\n      }\n\n      return get(styles, toPath(name));\n    }\n    /**\n     * Returns a reduced form of style property form normalized object.\n     *\n     * For default margin reducer, the below code:\n     *\n     *\t\tstylesProcessor.getReducedForm( 'margin', {\n     *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n     *\t\t} );\n     *\n     * will return:\n     *\n     *\t\t[\n     *\t\t\t[ 'margin', '1px 1px 2px' ]\n     *\t\t]\n     *\n     * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n     *\n     *\t\t[\n     *\t\t\t[ 'margin-top', '1px' ],\n     *\t\t\t[ 'margin-right', '1px' ],\n     *\t\t\t[ 'margin-bottom', '2px' ]\n     *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n     *\t\t]\n     *\n     * **Note**: To define reducer callbacks use {@link #setReducer}.\n     *\n     * @param {String} name Name of style property.\n     * @param {Object} styles Object holding normalized styles.\n     * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n     */\n\n  }, {\n    key: \"getReducedForm\",\n    value: function getReducedForm(name, styles) {\n      var normalizedValue = this.getNormalized(name, styles); // Might be empty string.\n\n      if (normalizedValue === undefined) {\n        return [];\n      }\n\n      if (this._reducers.has(name)) {\n        var reducer = this._reducers.get(name);\n\n        return reducer(normalizedValue);\n      }\n\n      return [[name, normalizedValue]];\n    }\n    /**\n     * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.\n     *\n     * @param {Object} styles Object holding normalized styles.\n     * @returns {Array.<String>}\n     */\n\n  }, {\n    key: \"getStyleNames\",\n    value: function getStyleNames(styles) {\n      var _this = this;\n\n      // Find all extractable styles that have a value.\n      var expandedStyleNames = Array.from(this._consumables.keys()).filter(function (name) {\n        var style = _this.getNormalized(name, styles);\n\n        if (style && typeof style == 'object') {\n          return Object.keys(style).length;\n        }\n\n        return style;\n      }); // For simple styles (for example `color`) we don't have a map of those styles\n      // but they are 1 to 1 with normalized object keys.\n\n      var styleNamesKeysSet = new Set([].concat(_toConsumableArray(expandedStyleNames), _toConsumableArray(Object.keys(styles))));\n      return Array.from(styleNamesKeysSet.values());\n    }\n    /**\n     * Returns related style names.\n     *\n     *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n     *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n     *\n     *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n     *\t\t// will return: [ 'margin' ];\n     *\n     * **Note**: To define new style relations load an existing style processor or use\n     * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n     *\n     * @param {String} name\n     * @returns {Array.<String>}\n     */\n\n  }, {\n    key: \"getRelatedStyles\",\n    value: function getRelatedStyles(name) {\n      return this._consumables.get(name) || [];\n    }\n    /**\n     * Adds a normalizer method for a style property.\n     *\n     * A normalizer returns describing how the value should be normalized.\n     *\n     * For instance 'margin' style is a shorthand for four margin values:\n     *\n     * - 'margin-top'\n     * - 'margin-right'\n     * - 'margin-bottom'\n     * - 'margin-left'\n     *\n     * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n     * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n     *\n     * A normalizer should parse various margin notations as a single object:\n     *\n     *\t\tconst styles = {\n     *\t\t\tmargin: {\n     *\t\t\t\ttop: '1px',\n     *\t\t\t\tright: '2em',\n     *\t\t\t\tbottom: '1px',\n     *\t\t\t\tleft: '2em'\n     *\t\t\t}\n     *\t\t};\n     *\n     * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n     *\n     *\t\tconst returnValue = {\n     *\t\t\tpath: 'margin',\n     *\t\t\tvalue: {\n     *\t\t\t\ttop: '1px',\n     *\t\t\t\tright: '2em',\n     *\t\t\t\tbottom: '1px',\n     *\t\t\t\tleft: '2em'\n     *\t\t\t}\n     *\t\t};\n     *\n     * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n     * is an example for 'margin-top' style property normalizer:\n     *\n     *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n     *\t\t\treturn {\n     *\t\t\t\tpath: 'margin.top',\n     *\t\t\t\tvalue: valueString\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @param {String} name\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"setNormalizer\",\n    value: function setNormalizer(name, callback) {\n      this._normalizers.set(name, callback);\n    }\n    /**\n     * Adds a extractor callback for a style property.\n     *\n     * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n     *\n     *\t\tconst styles = {\n     *\t\t\tmargin: {\n     *\t\t\t\ttop: 'value'\n     *\t\t\t}\n     *\t\t}\n     *\n     * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n     * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n     * shorthands. The default border styles processors stores styles as:\n     *\n     *\t\tconst styles = {\n     *\t\t\tborder: {\n     *\t\t\t\tstyle: {\n     *\t\t\t\t\ttop: 'solid'\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t}\n     *\n     * as it is better to modify border style independently from other values. On the other part the output of the border might be\n     * desired as `border-top`, `border-left`, etc notation.\n     *\n     * In the above example a reducer should return a side border value that combines style, color and width:\n     *\n     *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n     *\t\t\treturn {\n     *\t\t\t\tcolor: styles.border.color.top,\n     *\t\t\t\tstyle: styles.border.style.top,\n     *\t\t\t\twidth: styles.border.width.top\n     *\t\t\t}\n     *\t\t} );\n     *\n     * @param {String} name\n     * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n     */\n\n  }, {\n    key: \"setExtractor\",\n    value: function setExtractor(name, callbackOrPath) {\n      this._extractors.set(name, callbackOrPath);\n    }\n    /**\n     * Adds a reducer callback for a style property.\n     *\n     * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n     * by default the direct value from style path is taken.\n     *\n     * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n     * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n     *\n     *\t\tconst marginShortHandTuple = [\n     *\t\t\t[ 'margin', '1px 1px 2px' ]\n     *\t\t];\n     *\n     * or a longhand tuples for defined values:\n     *\n     *\t\t// Considering margin.bottom and margin.left are undefined.\n     *\t\tconst marginLonghandsTuples = [\n     *\t\t\t[ 'margin-top', '1px' ],\n     *\t\t\t[ 'margin-right', '1px' ]\n     *\t\t];\n     *\n     * A reducer obtains a normalized style value:\n     *\n     *\t\t// Simplified reducer that always outputs 4 values which are always present:\n     *\t\tstylesProcessor.setReducer( 'margin', margin => {\n     *\t\t\treturn [\n     *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n     *\t\t\t]\n     *\t\t} );\n     *\n     * @param {String} name\n     * @param {Function} callback\n     */\n\n  }, {\n    key: \"setReducer\",\n    value: function setReducer(name, callback) {\n      this._reducers.set(name, callback);\n    }\n    /**\n     * Defines a style shorthand relation to other style notations.\n     *\n     *\t\tstylesProcessor.setStyleRelation( 'margin', [\n     *\t\t\t'margin-top',\n     *\t\t\t'margin-right',\n     *\t\t\t'margin-bottom',\n     *\t\t\t'margin-left'\n     *\t\t] );\n     *\n     * This enables expanding of style names for shorthands. For instance, if defined,\n     * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n     * for long-hand margin style notation alongside the `'margin'` item.\n     *\n     * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n     * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n     * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n     * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n     *\n     * @param {String} shorthandName\n     * @param {Array.<String>} styleNames\n     */\n\n  }, {\n    key: \"setStyleRelation\",\n    value: function setStyleRelation(shorthandName, styleNames) {\n      this._mapStyleNames(shorthandName, styleNames);\n\n      var _iterator = _createForOfIteratorHelper(styleNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var alsoName = _step.value;\n\n          this._mapStyleNames(alsoName, [shorthandName]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Set two-way binding of style names.\n     *\n     * @param {String} name\n     * @param {Array.<String>} styleNames\n     * @private\n     */\n\n  }, {\n    key: \"_mapStyleNames\",\n    value: function _mapStyleNames(name, styleNames) {\n      var _this$_consumables$ge;\n\n      if (!this._consumables.has(name)) {\n        this._consumables.set(name, []);\n      }\n\n      (_this$_consumables$ge = this._consumables.get(name)).push.apply(_this$_consumables$ge, _toConsumableArray(styleNames));\n    }\n  }]);\n\n  return StylesProcessor;\n}(); // Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\n\nfunction parseInlineStyles(stylesString) {\n  // `null` if no quote was found in input string or last found quote was a closing quote. See below.\n  var quoteType = null;\n  var propertyNameStart = 0;\n  var propertyValueStart = 0;\n  var propertyName = null;\n  var stylesMap = new Map(); // Do not set anything if input string is empty.\n\n  if (stylesString === '') {\n    return stylesMap;\n  } // Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\n\n  if (stylesString.charAt(stylesString.length - 1) != ';') {\n    stylesString = stylesString + ';';\n  } // Seek the whole string for \"special characters\".\n\n\n  for (var i = 0; i < stylesString.length; i++) {\n    var char = stylesString.charAt(i);\n\n    if (quoteType === null) {\n      // No quote found yet or last found quote was a closing quote.\n      switch (char) {\n        case ':':\n          // Most of time colon means that property name just ended.\n          // Sometimes however `:` is found inside property value (for example in background image url).\n          if (!propertyName) {\n            // Treat this as end of property only if property name is not already saved.\n            // Save property name.\n            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart); // Save this point as the start of property value.\n\n            propertyValueStart = i + 1;\n          }\n\n          break;\n\n        case '\"':\n        case '\\'':\n          // Opening quote found (this is an opening quote, because `quoteType` is `null`).\n          quoteType = char;\n          break;\n\n        case ';':\n          {\n            // Property value just ended.\n            // Use previously stored property value start to obtain property value.\n            var propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);\n\n            if (propertyName) {\n              // Save parsed part.\n              stylesMap.set(propertyName.trim(), propertyValue.trim());\n            }\n\n            propertyName = null; // Save this point as property name start. Property name starts immediately after previous property value ends.\n\n            propertyNameStart = i + 1;\n            break;\n          }\n      }\n    } else if (char === quoteType) {\n      // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n      quoteType = null;\n    }\n  }\n\n  return stylesMap;\n} // Return lodash compatible path from style name.\n\n\nfunction toPath(name) {\n  return name.replace('-', '.');\n} // Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\n\n\nfunction appendStyleValue(stylesObject, nameOrPath, valueOrObject) {\n  var valueToSet = valueOrObject;\n\n  if (isObject(valueOrObject)) {\n    valueToSet = merge({}, get(stylesObject, nameOrPath), valueOrObject);\n  }\n\n  set(stylesObject, nameOrPath, valueToSet);\n}\n/**\n * A CSS style property descriptor that contains tuplet of two strings:\n *\n * - first string describes property name\n * - second string describes property value\n *\n *\t\tconst marginDescriptor = [ 'margin', '2px 3em' ];\n *\t\tconst marginTopDescriptor = [ 'margin-top', '2px' ];\n *\n * @typedef {Array.<String, String>} module:engine/view/stylesmap~PropertyDescriptor\n */\n\n/**\n * An object describing values associated with the sides of a box, for instance margins, paddings,\n * border widths, border colors, etc.\n *\n *\t\tconst margin = {\n *\t\t\ttop: '1px',\n *\t\t\tright: '3px',\n *\t\t\tbottom: '3px',\n *\t\t\tleft: '7px'\n *\t\t};\n *\n *\t\tconst borderColor = {\n *\t\t\ttop: 'red',\n *\t\t\tright: 'blue',\n *\t\t\tbottom: 'blue',\n *\t\t\tleft: 'red'\n *\t\t};\n *\n * @typedef {Object} module:engine/view/stylesmap~BoxSides\n *\n * @property {String} top Top side value.\n * @property {String} right Right side value.\n * @property {String} bottom Bottom side value.\n * @property {String} left Left side value.\n */","map":null,"metadata":{},"sourceType":"module"}