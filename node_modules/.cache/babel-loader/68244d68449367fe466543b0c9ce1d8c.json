{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/node\n */\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\n\nvar Node = /*#__PURE__*/function () {\n  /**\n   * Creates a model node.\n   *\n   * This is an abstract class, so this constructor should not be used directly.\n   *\n   * @abstract\n   * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   */\n  function Node(attrs) {\n    _classCallCheck(this, Node);\n\n    /**\n     * Parent of this node. It could be {@link module:engine/model/element~Element}\n     * or {@link module:engine/model/documentfragment~DocumentFragment}.\n     * Equals to `null` if the node has no parent.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n    this.parent = null;\n    /**\n     * Attributes set on this node.\n     *\n     * @private\n     * @member {Map} module:engine/model/node~Node#_attrs\n     */\n\n    this._attrs = toMap(attrs);\n  }\n  /**\n   * Index of this node in it's parent or `null` if the node has no parent.\n   *\n   * Accessing this property throws an error if this node's parent element does not contain it.\n   * This means that model tree got broken.\n   *\n   * @readonly\n   * @type {Number|null}\n   */\n\n\n  _createClass(Node, [{\n    key: \"isAttached\",\n\n    /**\n     * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n     *\n     * @returns {Boolean}\n     */\n    value: function isAttached() {\n      return this.root.is('rootElement');\n    }\n    /**\n     * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n     * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n     * create {@link module:engine/model/position~Position Position} instance.\n     *\n     *\t\tconst abc = new Text( 'abc' );\n     *\t\tconst foo = new Text( 'foo' );\n     *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n     *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n     *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n     *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n     *\t\th1.getPath(); // Returns [ 0 ].\n     *\t\tdiv.getPath(); // Returns [].\n     *\n     * @returns {Array.<Number>} The path.\n     */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      var path = [];\n      var node = this; // eslint-disable-line consistent-this\n\n      while (node.parent) {\n        path.unshift(node.startOffset);\n        node = node.parent;\n      }\n\n      return path;\n    }\n    /**\n     * Returns ancestors array of this node.\n     *\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n     * otherwise root element will be the first item in the array.\n     * @returns {Array} Array with ancestors.\n     */\n\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        includeSelf: false,\n        parentFirst: false\n      };\n      var ancestors = [];\n      var parent = options.includeSelf ? this : this.parent;\n\n      while (parent) {\n        ancestors[options.parentFirst ? 'push' : 'unshift'](parent);\n        parent = parent.parent;\n      }\n\n      return ancestors;\n    }\n    /**\n     * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n     * which is a common ancestor of both nodes.\n     *\n     * @param {module:engine/model/node~Node} node The second node.\n     * @param {Object} options Options object.\n     * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n     * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ancestorsA = this.getAncestors(options);\n      var ancestorsB = node.getAncestors(options);\n      var i = 0;\n\n      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n        i++;\n      }\n\n      return i === 0 ? null : ancestorsA[i - 1];\n    }\n    /**\n     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n     * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n     *\n     * @param {module:engine/model/node~Node} node Node to compare with.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isBefore\",\n    value: function isBefore(node) {\n      // Given node is not before this node if they are same.\n      if (this == node) {\n        return false;\n      } // Return `false` if it is impossible to compare nodes.\n\n\n      if (this.root !== node.root) {\n        return false;\n      }\n\n      var thisPath = this.getPath();\n      var nodePath = node.getPath();\n      var result = compareArrays(thisPath, nodePath);\n\n      switch (result) {\n        case 'prefix':\n          return true;\n\n        case 'extension':\n          return false;\n\n        default:\n          return thisPath[result] < nodePath[result];\n      }\n    }\n    /**\n     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n     * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n     *\n     * @param {module:engine/model/node~Node} node Node to compare with.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isAfter\",\n    value: function isAfter(node) {\n      // Given node is not before this node if they are same.\n      if (this == node) {\n        return false;\n      } // Return `false` if it is impossible to compare nodes.\n\n\n      if (this.root !== node.root) {\n        return false;\n      } // In other cases, just check if the `node` is before, and return the opposite.\n\n\n      return !this.isBefore(node);\n    }\n    /**\n     * Checks if the node has an attribute with given key.\n     *\n     * @param {String} key Key of attribute to check.\n     * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n     */\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(key) {\n      return this._attrs.has(key);\n    }\n    /**\n     * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n     *\n     * @param {String} key Key of attribute to look for.\n     * @returns {*} Attribute value or `undefined`.\n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(key) {\n      return this._attrs.get(key);\n    }\n    /**\n     * Returns iterator that iterates over this node's attributes.\n     *\n     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n     *\n     * @returns {Iterable.<*>}\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this._attrs.entries();\n    }\n    /**\n     * Returns iterator that iterates over this node's attribute keys.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getAttributeKeys\",\n    value: function getAttributeKeys() {\n      return this._attrs.keys();\n    }\n    /**\n     * Converts `Node` to plain object and returns it.\n     *\n     * @returns {Object} `Node` converted to plain object.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {}; // Serializes attributes to the object.\n      // attributes = { a: 'foo', b: 1, c: true }.\n\n      if (this._attrs.size) {\n        json.attributes = Array.from(this._attrs).reduce(function (result, attr) {\n          result[attr[0]] = attr[1];\n          return result;\n        }, {});\n      }\n\n      return json;\n    }\n    /**\n     * Checks whether this object is of the given type.\n     *\n     * This method is useful when processing model objects that are of unknown type. For example, a function\n     * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}\n     * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n     *\n     *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n     *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n     *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n     *\n     * Since this method is also available on a range of view objects, you can prefix the type of the object with\n     * `model:` or `view:` to check, for example, if this is the model's or view's element:\n     *\n     *\t\tmodelElement.is( 'model:element' ); // -> true\n     *\t\tmodelElement.is( 'view:element' ); // -> false\n     *\n     * By using this method it is also possible to check a name of an element:\n     *\n     *\t\timageElement.is( 'element', 'imageBlock' ); // -> true\n     *\t\timageElement.is( 'element', 'imageBlock' ); // -> same as above\n     *\t\timageElement.is( 'model:element', 'imageBlock' ); // -> same as above, but more precise\n     *\n     * The list of model objects which implement the `is()` method:\n     *\n     * * {@link module:engine/model/node~Node#is `Node#is()`}\n     * * {@link module:engine/model/text~Text#is `Text#is()`}\n     * * {@link module:engine/model/element~Element#is `Element#is()`}\n     * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}\n     * * {@link module:engine/model/position~Position#is `Position#is()`}\n     * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}\n     * * {@link module:engine/model/range~Range#is `Range#is()`}\n     * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}\n     * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n     * * {@link module:engine/model/selection~Selection#is `Selection#is()`}\n     * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n     * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}\n     * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}\n     *\n     * @method #is\n     * @param {String} type Type to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return type === 'node' || type === 'model:node';\n    }\n    /**\n     * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n     *\n     * @protected\n     * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n     */\n\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      return new Node(this._attrs);\n    }\n    /**\n     * Removes this node from it's parent.\n     *\n     * @see module:engine/model/writer~Writer#remove\n     * @protected\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove() {\n      this.parent._removeChildren(this.index);\n    }\n    /**\n     * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n     *\n     * @see module:engine/model/writer~Writer#setAttribute\n     * @protected\n     * @param {String} key Key of attribute to set.\n     * @param {*} value Attribute value.\n     */\n\n  }, {\n    key: \"_setAttribute\",\n    value: function _setAttribute(key, value) {\n      this._attrs.set(key, value);\n    }\n    /**\n     * Removes all attributes from the node and sets given attributes.\n     *\n     * @see module:engine/model/writer~Writer#setAttributes\n     * @protected\n     * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n     */\n\n  }, {\n    key: \"_setAttributesTo\",\n    value: function _setAttributesTo(attrs) {\n      this._attrs = toMap(attrs);\n    }\n    /**\n     * Removes an attribute with given key from the node.\n     *\n     * @see module:engine/model/writer~Writer#removeAttribute\n     * @protected\n     * @param {String} key Key of attribute to remove.\n     * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n     */\n\n  }, {\n    key: \"_removeAttribute\",\n    value: function _removeAttribute(key) {\n      return this._attrs.delete(key);\n    }\n    /**\n     * Removes all attributes from the node.\n     *\n     * @see module:engine/model/writer~Writer#clearAttributes\n     * @protected\n     */\n\n  }, {\n    key: \"_clearAttributes\",\n    value: function _clearAttributes() {\n      this._attrs.clear();\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      var pos;\n\n      if (!this.parent) {\n        return null;\n      }\n\n      if ((pos = this.parent.getChildIndex(this)) === null) {\n        throw new CKEditorError('model-node-not-found-in-parent', this);\n      }\n\n      return pos;\n    }\n    /**\n     * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n     * of all it's previous siblings. Equals to `null` if node has no parent.\n     *\n     * Accessing this property throws an error if this node's parent element does not contain it.\n     * This means that model tree got broken.\n     *\n     * @readonly\n     * @type {Number|null}\n     */\n\n  }, {\n    key: \"startOffset\",\n    get: function get() {\n      var pos;\n\n      if (!this.parent) {\n        return null;\n      }\n\n      if ((pos = this.parent.getChildStartOffset(this)) === null) {\n        throw new CKEditorError('model-node-not-found-in-parent', this);\n      }\n\n      return pos;\n    }\n    /**\n     * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n     * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n     * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n     * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n     *\n     * @readonly\n     * @type {Number}\n     */\n\n  }, {\n    key: \"offsetSize\",\n    get: function get() {\n      return 1;\n    }\n    /**\n     * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n     * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n     * Equals to `null` if the node has no parent.\n     *\n     * @readonly\n     * @type {Number|null}\n     */\n\n  }, {\n    key: \"endOffset\",\n    get: function get() {\n      if (!this.parent) {\n        return null;\n      }\n\n      return this.startOffset + this.offsetSize;\n    }\n    /**\n     * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|null}\n     */\n\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var index = this.index;\n      return index !== null && this.parent.getChild(index + 1) || null;\n    }\n    /**\n     * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|null}\n     */\n\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      var index = this.index;\n      return index !== null && this.parent.getChild(index - 1) || null;\n    }\n    /**\n     * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n     * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n     *\n     * @readonly\n     * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n     */\n\n  }, {\n    key: \"root\",\n    get: function get() {\n      var root = this; // eslint-disable-line consistent-this\n\n      while (root.parent) {\n        root = root.parent;\n      }\n\n      return root;\n    }\n  }]);\n\n  return Node;\n}();\n/**\n * The node's parent does not contain this node.\n *\n * @error model-node-not-found-in-parent\n */\n\n\nexport { Node as default };","map":null,"metadata":{},"sourceType":"module"}