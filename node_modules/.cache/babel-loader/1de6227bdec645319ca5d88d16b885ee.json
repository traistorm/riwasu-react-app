{"ast":null,"code":"import _objectSpread from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { FileRepository } from 'ckeditor5/src/upload';\nimport { Command } from 'ckeditor5/src/core';\nimport { toArray } from 'ckeditor5/src/utils';\n/**\n * @module image/imageupload/uploadimagecommand\n */\n\n/**\n * The upload image command.\n *\n * The command is registered by the {@link module:image/imageupload/imageuploadediting~ImageUploadEditing} plugin as `uploadImage`\n * and it is also available via aliased `imageUpload` name.\n *\n * In order to upload an image at the current selection position\n * (according to the {@link module:widget/utils~findOptimalInsertionRange} algorithm),\n * execute the command and pass the native image file instance:\n *\n *\t\tthis.listenTo( editor.editing.view.document, 'clipboardInput', ( evt, data ) => {\n *\t\t\t// Assuming that only images were pasted:\n *\t\t\tconst images = Array.from( data.dataTransfer.files );\n *\n *\t\t\t// Upload the first image:\n *\t\t\teditor.execute( 'uploadImage', { file: images[ 0 ] } );\n *\t\t} );\n *\n * It is also possible to insert multiple images at once:\n *\n *\t\teditor.execute( 'uploadImage', {\n *\t\t\tfile: [\n *\t\t\t\tfile1,\n *\t\t\t\tfile2\n *\t\t\t]\n *\t\t} );\n *\n * @extends module:core/command~Command\n */\n\nvar UploadImageCommand = /*#__PURE__*/function (_Command) {\n  _inherits(UploadImageCommand, _Command);\n\n  function UploadImageCommand() {\n    _classCallCheck(this, UploadImageCommand);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UploadImageCommand).apply(this, arguments));\n  }\n\n  _createClass(UploadImageCommand, [{\n    key: \"refresh\",\n\n    /**\n     * @inheritDoc\n     */\n    value: function refresh() {\n      var editor = this.editor;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      var selectedElement = editor.model.document.selection.getSelectedElement(); // TODO: This needs refactoring.\n\n      this.isEnabled = imageUtils.isImageAllowed() || imageUtils.isImage(selectedElement);\n    }\n    /**\n     * Executes the command.\n     *\n     * @fires execute\n     * @param {Object} options Options for the executed command.\n     * @param {File|Array.<File>} options.file The image file or an array of image files to upload.\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(options) {\n      var _this = this;\n\n      var files = toArray(options.file);\n      var selection = this.editor.model.document.selection;\n      var imageUtils = this.editor.plugins.get('ImageUtils'); // In case of multiple files, each file (starting from the 2nd) will be inserted at a position that\n      // follows the previous one. That will move the selection and, to stay on the safe side and make sure\n      // all images inherit the same selection attributes, they are collected beforehand.\n      //\n      // Applying these attributes ensures, for instance, that inserting an (inline) image into a link does\n      // not split that link but preserves its continuity.\n      //\n      // Note: Selection attributes that do not make sense for images will be filtered out by insertImage() anyway.\n\n      var selectionAttributes = Object.fromEntries(selection.getAttributes());\n      files.forEach(function (file, index) {\n        var selectedElement = selection.getSelectedElement(); // Inserting of an inline image replace the selected element and make a selection on the inserted image.\n        // Therefore inserting multiple inline images requires creating position after each element.\n\n        if (index && selectedElement && imageUtils.isImage(selectedElement)) {\n          var position = _this.editor.model.createPositionAfter(selectedElement);\n\n          _this._uploadImage(file, selectionAttributes, position);\n        } else {\n          _this._uploadImage(file, selectionAttributes);\n        }\n      });\n    }\n    /**\n     * Handles uploading single file.\n     *\n     * @private\n     * @param {File} file\n     * @param {Object} attributes\n     * @param {module:engine/model/position~Position} position\n     */\n\n  }, {\n    key: \"_uploadImage\",\n    value: function _uploadImage(file, attributes, position) {\n      var editor = this.editor;\n      var fileRepository = editor.plugins.get(FileRepository);\n      var loader = fileRepository.createLoader(file);\n      var imageUtils = editor.plugins.get('ImageUtils'); // Do not throw when upload adapter is not set. FileRepository will log an error anyway.\n\n      if (!loader) {\n        return;\n      }\n\n      imageUtils.insertImage(_objectSpread({}, attributes, {\n        uploadId: loader.id\n      }), position);\n    }\n  }]);\n\n  return UploadImageCommand;\n}(Command);\n\nexport { UploadImageCommand as default };","map":null,"metadata":{},"sourceType":"module"}