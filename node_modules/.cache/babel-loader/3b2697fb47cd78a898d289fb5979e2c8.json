{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _toConsumableArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(combineWalkers),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(convertToMinimalFlatRanges);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n/**\n * The model's schema. It defines the allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by the features and based on them, the editing framework and features\n * make decisions on how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * The {@glink framework/guides/architecture/editing-engine#schema schema section} of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture} guide.\n * * The {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nvar Schema = /*#__PURE__*/function () {\n  /**\n   * Creates a schema instance.\n   */\n  function Schema() {\n    var _this = this;\n\n    _classCallCheck(this, Schema);\n\n    this._sourceDefinitions = {};\n    /**\n     * A dictionary containing attribute properties.\n     *\n     * @private\n     * @member {Object.<String,String>}\n     */\n\n    this._attributeProperties = {};\n    this.decorate('checkChild');\n    this.decorate('checkAttribute');\n    this.on('checkAttribute', function (evt, args) {\n      args[0] = new SchemaContext(args[0]);\n    }, {\n      priority: 'highest'\n    });\n    this.on('checkChild', function (evt, args) {\n      args[0] = new SchemaContext(args[0]);\n      args[1] = _this.getDefinition(args[1]);\n    }, {\n      priority: 'highest'\n    });\n  }\n  /**\n   * Registers a schema item. Can only be called once for every item name.\n   *\n   *\t\tschema.register( 'paragraph', {\n   *\t\t\tinheritAllFrom: '$block'\n   *\t\t} );\n   *\n   * @param {String} itemName\n   * @param {module:engine/model/schema~SchemaItemDefinition} definition\n   */\n\n\n  _createClass(Schema, [{\n    key: \"register\",\n    value: function register(itemName, definition) {\n      if (this._sourceDefinitions[itemName]) {\n        /**\n         * A single item cannot be registered twice in the schema.\n         *\n         * This situation may happen when:\n         *\n         * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n         * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n         * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n         * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n         * and usually means one or more of the following issues:\n         *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n         *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n         *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n         *\n         * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n         *\n         * @param itemName The name of the model element that is being registered twice.\n         * @error schema-cannot-register-item-twice\n         */\n        throw new CKEditorError('schema-cannot-register-item-twice', this, {\n          itemName: itemName\n        });\n      }\n\n      this._sourceDefinitions[itemName] = [Object.assign({}, definition)];\n\n      this._clearCache();\n    }\n    /**\n     * Extends a {@link #register registered} item's definition.\n     *\n     * Extending properties such as `allowIn` will add more items to the existing properties,\n     * while redefining properties such as `isBlock` will override the previously defined ones.\n     *\n     *\t\tschema.register( 'foo', {\n     *\t\t\tallowIn: '$root',\n     *\t\t\tisBlock: true;\n     *\t\t} );\n     *\t\tschema.extend( 'foo', {\n     *\t\t\tallowIn: 'blockQuote',\n     *\t\t\tisBlock: false\n     *\t\t} );\n     *\n     *\t\tschema.getDefinition( 'foo' );\n     *\t\t//\t{\n     *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n     *\t\t// \t\tisBlock: false\n     *\t\t//\t}\n     *\n     * @param {String} itemName\n     * @param {module:engine/model/schema~SchemaItemDefinition} definition\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend(itemName, definition) {\n      if (!this._sourceDefinitions[itemName]) {\n        /**\n         * Cannot extend an item which was not registered yet.\n         *\n         * This error happens when a plugin tries to extend the schema definition of an item which was not\n         * {@link #register registered} yet.\n         *\n         * @param itemName The name of the model element which is being extended.\n         * @error schema-cannot-extend-missing-item\n         */\n        throw new CKEditorError('schema-cannot-extend-missing-item', this, {\n          itemName: itemName\n        });\n      }\n\n      this._sourceDefinitions[itemName].push(Object.assign({}, definition));\n\n      this._clearCache();\n    }\n    /**\n     * Returns data of all registered items.\n     *\n     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n     * checking a list of all block elements, etc).\n     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n     * in other cases.\n     *\n     * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n     */\n\n  }, {\n    key: \"getDefinitions\",\n    value: function getDefinitions() {\n      if (!this._compiledDefinitions) {\n        this._compile();\n      }\n\n      return this._compiledDefinitions;\n    }\n    /**\n     * Returns a definition of the given item or `undefined` if an item is not registered.\n     *\n     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,\n     * checking a list of all block elements, etc).\n     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})\n     * in other cases.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n     */\n\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(item) {\n      var itemName;\n\n      if (typeof item == 'string') {\n        itemName = item;\n      } else if (item.is && (item.is('$text') || item.is('$textProxy'))) {\n        itemName = '$text';\n      } // Element or module:engine/model/schema~SchemaContextItem.\n      else {\n        itemName = item.name;\n      }\n\n      return this.getDefinitions()[itemName];\n    }\n    /**\n     * Returns `true` if the given item is registered in the schema.\n     *\n     *\t\tschema.isRegistered( 'paragraph' ); // -> true\n     *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n     *\t\tschema.isRegistered( 'foo' ); // -> false\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n    \t * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRegistered\",\n    value: function isRegistered(item) {\n      return !!this.getDefinition(item);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n     *\n     *\t\tschema.isBlock( 'paragraph' ); // -> true\n     *\t\tschema.isBlock( '$root' ); // -> false\n     *\n     *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n     *\t\tschema.isBlock( paragraphElement ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     \t * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isBlock\",\n    value: function isBlock(item) {\n      var def = this.getDefinition(item);\n      return !!(def && def.isBlock);\n    }\n    /**\n     * Returns `true` if the given item should be treated as a limit element.\n     *\n     * It considers an item to be a limit element if its\n     * {@link module:engine/model/schema~SchemaItemDefinition}'s\n     * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or\n     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n     * was set to `true`.\n     *\n     *\t\tschema.isLimit( 'paragraph' ); // -> false\n     *\t\tschema.isLimit( '$root' ); // -> true\n     *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n     *\t\tschema.isLimit( 'imageBlock' ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     \t * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isLimit\",\n    value: function isLimit(item) {\n      var def = this.getDefinition(item);\n\n      if (!def) {\n        return false;\n      }\n\n      return !!(def.isLimit || def.isObject);\n    }\n    /**\n     * Returns `true` if the given item should be treated as an object element.\n     *\n     * It considers an item to be an object element if its\n     * {@link module:engine/model/schema~SchemaItemDefinition}'s\n     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property\n     * was set to `true`.\n     *\n     *\t\tschema.isObject( 'paragraph' ); // -> false\n     *\t\tschema.isObject( 'imageBlock' ); // -> true\n     *\n     *\t\tconst imageElement = writer.createElement( 'imageBlock' );\n     *\t\tschema.isObject( imageElement ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     \t * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isObject\",\n    value: function isObject(item) {\n      var def = this.getDefinition(item);\n\n      if (!def) {\n        return false;\n      } // Note: Check out the implementation of #isLimit(), #isSelectable(), and #isContent()\n      // to understand why these three constitute an object.\n\n\n      return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n     *\n     *\t\tschema.isInline( 'paragraph' ); // -> false\n     *\t\tschema.isInline( 'softBreak' ); // -> true\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\tschema.isInline( text ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isInline\",\n    value: function isInline(item) {\n      var def = this.getDefinition(item);\n      return !!(def && def.isInline);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.\n     *\n     *\t\tschema.isSelectable( 'paragraph' ); // -> false\n     *\t\tschema.isSelectable( 'heading1' ); // -> false\n     *\t\tschema.isSelectable( 'imageBlock' ); // -> true\n     *\t\tschema.isSelectable( 'tableCell' ); // -> true\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\tschema.isSelectable( text ); // -> false\n     *\n     * See the {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isSelectable\",\n    value: function isSelectable(item) {\n      var def = this.getDefinition(item);\n\n      if (!def) {\n        return false;\n      }\n\n      return !!(def.isSelectable || def.isObject);\n    }\n    /**\n     * Returns `true` if the given item is defined to be\n     * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.\n     *\n     *\t\tschema.isContent( 'paragraph' ); // -> false\n     *\t\tschema.isContent( 'heading1' ); // -> false\n     *\t\tschema.isContent( 'imageBlock' ); // -> true\n     *\t\tschema.isContent( 'horizontalLine' ); // -> true\n     *\n     *\t\tconst text = writer.createText( 'foo' );\n     *\t\tschema.isContent( text ); // -> true\n     *\n     * See the {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n     * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide for more details.\n     *\n     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isContent\",\n    value: function isContent(item) {\n      var def = this.getDefinition(item);\n\n      if (!def) {\n        return false;\n      }\n\n      return !!(def.isContent || def.isObject);\n    }\n    /**\n     * Checks whether the given node (`child`) can be a child of the given context.\n     *\n     *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n     *\n     *\t\tschema.register( 'paragraph', {\n     *\t\t\tallowIn: '$root'\n     *\t\t} );\n     *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n     *\n     * Note: When verifying whether the given node can be a child of the given context, the\n     * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n     * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n     * It happens if one of the context's elements does not allow its child.\n     *\n     * @fires checkChild\n     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n     * @param {module:engine/model/node~Node|String} def The child to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"checkChild\",\n    value: function checkChild(context, def) {\n      // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n      if (!def) {\n        return false;\n      }\n\n      return this._checkContextMatch(def, context);\n    }\n    /**\n     * Checks whether the given attribute can be applied in the given context (on the last\n     * item of the context).\n     *\n     *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n     *\n     *\t\tschema.extend( '$text', {\n     *\t\t\tallowAttributes: 'bold'\n     *\t\t} );\n     *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n     *\n     * @fires checkAttribute\n     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n     * @param {String} attributeName\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"checkAttribute\",\n    value: function checkAttribute(context, attributeName) {\n      var def = this.getDefinition(context.last);\n\n      if (!def) {\n        return false;\n      }\n\n      return def.allowAttributes.includes(attributeName);\n    }\n    /**\n     * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n     *\n     * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n     *\n     * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n     * will be valid.\n     *\n     * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n     * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n     *\n     * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n     * element to which the `elementToMerge` will be merged.\n     * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"checkMerge\",\n    value: function checkMerge(positionOrBaseElement) {\n      var elementToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (positionOrBaseElement instanceof Position) {\n        var nodeBefore = positionOrBaseElement.nodeBefore;\n        var nodeAfter = positionOrBaseElement.nodeAfter;\n\n        if (!(nodeBefore instanceof Element)) {\n          /**\n           * The node before the merge position must be an element.\n           *\n           * @error schema-check-merge-no-element-before\n           */\n          throw new CKEditorError('schema-check-merge-no-element-before', this);\n        }\n\n        if (!(nodeAfter instanceof Element)) {\n          /**\n           * The node after the merge position must be an element.\n           *\n           * @error schema-check-merge-no-element-after\n           */\n          throw new CKEditorError('schema-check-merge-no-element-after', this);\n        }\n\n        return this.checkMerge(nodeBefore, nodeAfter);\n      }\n\n      var _iterator = _createForOfIteratorHelper(elementToMerge.getChildren()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n\n          if (!this.checkChild(positionOrBaseElement, child)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n    /**\n     * Allows registering a callback to the {@link #checkChild} method calls.\n     *\n     * Callbacks allow you to implement rules which are not otherwise possible to achieve\n     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n     * For example, by using this method you can disallow elements in specific contexts.\n     *\n     * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n     * you can use that event instead.\n     *\n     * Example:\n     *\n     *\t\t// Disallow heading1 directly inside a blockQuote.\n     *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n     *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n     *\t\t\t\treturn false;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Which translates to:\n     *\n     *\t\tschema.on( 'checkChild', ( evt, args ) => {\n     *\t\t\tconst context = args[ 0 ];\n     *\t\t\tconst childDefinition = args[ 1 ];\n     *\n     *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n     *\t\t\t\t// Prevent next listeners from being called.\n     *\t\t\t\tevt.stop();\n     *\t\t\t\t// Set the checkChild()'s return value.\n     *\t\t\t\tevt.return = false;\n     *\t\t\t}\n     *\t\t}, { priority: 'high' } );\n     *\n     * @param {Function} callback The callback to be called. It is called with two parameters:\n     * {@link module:engine/model/schema~SchemaContext} (context) instance and\n     * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n     * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n     * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n     */\n\n  }, {\n    key: \"addChildCheck\",\n    value: function addChildCheck(callback) {\n      this.on('checkChild', function (evt, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            ctx = _ref2[0],\n            childDef = _ref2[1];\n\n        // checkChild() was called with a non-registered child.\n        // In 99% cases such check should return false, so not to overcomplicate all callbacks\n        // don't even execute them.\n        if (!childDef) {\n          return;\n        }\n\n        var retValue = callback(ctx, childDef);\n\n        if (typeof retValue == 'boolean') {\n          evt.stop();\n          evt.return = retValue;\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * Allows registering a callback to the {@link #checkAttribute} method calls.\n     *\n     * Callbacks allow you to implement rules which are not otherwise possible to achieve\n     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n     * For example, by using this method you can disallow attribute if node to which it is applied\n     * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n     *\n     * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n     * you can use that event instead.\n     *\n     * Example:\n     *\n     *\t\t// Disallow bold on $text inside heading1.\n     *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n     *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n     *\t\t\t\treturn false;\n     *\t\t\t}\n     *\t\t} );\n     *\n     * Which translates to:\n     *\n     *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n     *\t\t\tconst context = args[ 0 ];\n     *\t\t\tconst attributeName = args[ 1 ];\n     *\n     *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n     *\t\t\t\t// Prevent next listeners from being called.\n     *\t\t\t\tevt.stop();\n     *\t\t\t\t// Set the checkAttribute()'s return value.\n     *\t\t\t\tevt.return = false;\n     *\t\t\t}\n     *\t\t}, { priority: 'high' } );\n     *\n     * @param {Function} callback The callback to be called. It is called with two parameters:\n     * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n     * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n     * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n     */\n\n  }, {\n    key: \"addAttributeCheck\",\n    value: function addAttributeCheck(callback) {\n      this.on('checkAttribute', function (evt, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            ctx = _ref4[0],\n            attributeName = _ref4[1];\n\n        var retValue = callback(ctx, attributeName);\n\n        if (typeof retValue == 'boolean') {\n          evt.stop();\n          evt.return = retValue;\n        }\n      }, {\n        priority: 'high'\n      });\n    }\n    /**\n     * This method allows assigning additional metadata to the model attributes. For example,\n     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n     * used to mark formatting attributes (like `bold` or `italic`).\n     *\n     *\t\t// Mark bold as a formatting attribute.\n     *\t\tschema.setAttributeProperties( 'bold', {\n     *\t\t\tisFormatting: true\n     *\t\t} );\n     *\n     *\t\t// Override code not to be considered a formatting markup.\n     *\t\tschema.setAttributeProperties( 'code', {\n     *\t\t\tisFormatting: false\n     *\t\t} );\n     *\n     * Properties are not limited to members defined in the\n     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\tcustomProperty: 'value'\n     *\t\t} );\n     *\n     * Subsequent calls with the same attribute will extend its custom properties:\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\tone: 1\n     *\t\t} );\n     *\n     *\t\tschema.setAttributeProperties( 'blockQuote', {\n     *\t\t\ttwo: 2\n     *\t\t} );\n     *\n     *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n     *\t\t// Logs: { one: 1, two: 2 }\n     *\n     * @param {String} attributeName A name of the attribute to receive the properties.\n     * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n     */\n\n  }, {\n    key: \"setAttributeProperties\",\n    value: function setAttributeProperties(attributeName, properties) {\n      this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);\n    }\n    /**\n     * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n     *\n     * @param {String} attributeName A name of the attribute.\n     * @returns {module:engine/model/schema~AttributeProperties}\n     */\n\n  }, {\n    key: \"getAttributeProperties\",\n    value: function getAttributeProperties(attributeName) {\n      return this._attributeProperties[attributeName] || {};\n    }\n    /**\n     * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n     * selection/range/position or the root otherwise.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n     * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n     * The selection/range/position to check.\n     * @returns {module:engine/model/element~Element} The lowest limit element containing\n     * the entire `selectionOrRangeOrPosition`.\n     */\n\n  }, {\n    key: \"getLimitElement\",\n    value: function getLimitElement(selectionOrRangeOrPosition) {\n      var element;\n\n      if (selectionOrRangeOrPosition instanceof Position) {\n        element = selectionOrRangeOrPosition.parent;\n      } else {\n        var ranges = selectionOrRangeOrPosition instanceof Range ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges()); // Find the common ancestor for all selection's ranges.\n\n        element = ranges.reduce(function (element, range) {\n          var rangeCommonAncestor = range.getCommonAncestor();\n\n          if (!element) {\n            return rangeCommonAncestor;\n          }\n\n          return element.getCommonAncestor(rangeCommonAncestor, {\n            includeSelf: true\n          });\n        }, null);\n      }\n\n      while (!this.isLimit(element)) {\n        if (element.parent) {\n          element = element.parent;\n        } else {\n          break;\n        }\n      }\n\n      return element;\n    }\n    /**\n     * Checks whether the attribute is allowed in selection:\n     *\n     * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n     * * if the selection is collapsed, then checks if on the selection position there's a text with the\n     * specified attribute allowed.\n     *\n     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n     * Selection which will be checked.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"checkAttributeInSelection\",\n    value: function checkAttributeInSelection(selection, attribute) {\n      if (selection.isCollapsed) {\n        var firstPosition = selection.getFirstPosition();\n\n        var _context = [].concat(_toConsumableArray(firstPosition.getAncestors()), [new Text('', selection.getAttributes())]); // Check whether schema allows for a text with the attribute in the selection.\n\n\n        return this.checkAttribute(_context, attribute);\n      } else {\n        var ranges = selection.getRanges(); // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\n        var _iterator2 = _createForOfIteratorHelper(ranges),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var range = _step2.value;\n\n            var _iterator3 = _createForOfIteratorHelper(range),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var value = _step3.value;\n\n                if (this.checkAttribute(value.item, attribute)) {\n                  // If we found a node that is allowed to have the attribute, return true.\n                  return true;\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } // If we haven't found such node, return false.\n\n\n      return false;\n    }\n    /**\n     * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n     *\n     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n     */\n\n  }, {\n    key: \"getValidRanges\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getValidRanges(ranges, attribute) {\n      var _iterator4, _step4, range;\n\n      return _regeneratorRuntime.wrap(function getValidRanges$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              ranges = convertToMinimalFlatRanges(ranges);\n              _iterator4 = _createForOfIteratorHelper(ranges);\n              _context2.prev = 2;\n\n              _iterator4.s();\n\n            case 4:\n              if ((_step4 = _iterator4.n()).done) {\n                _context2.next = 9;\n                break;\n              }\n\n              range = _step4.value;\n              return _context2.delegateYield(this._getValidRangesForRange(range, attribute), \"t0\", 7);\n\n            case 7:\n              _context2.next = 4;\n              break;\n\n            case 9:\n              _context2.next = 14;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t1 = _context2[\"catch\"](2);\n\n              _iterator4.e(_context2.t1);\n\n            case 14:\n              _context2.prev = 14;\n\n              _iterator4.f();\n\n              return _context2.finish(14);\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, getValidRanges, this, [[2, 11, 14, 17]]);\n    })\n    /**\n     * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n     * nearest to that `position` and is a correct range for selection.\n     *\n     * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n     * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n     * the {@link module:engine/model/schema~Schema schema}.\n     *\n     * Direction of searching for the nearest correct selection range can be specified as:\n     *\n     * * `both` - searching will be performed in both ways,\n     * * `forward` - searching will be performed only forward,\n     * * `backward` - searching will be performed only backward.\n     *\n     * When valid selection range cannot be found, `null` is returned.\n     *\n     * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n     * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n     * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n     */\n\n  }, {\n    key: \"getNearestSelectionRange\",\n    value: function getNearestSelectionRange(position) {\n      var _this2 = this;\n\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';\n\n      // Return collapsed range if provided position is valid.\n      if (this.checkChild(position, '$text')) {\n        return new Range(position);\n      }\n\n      var backwardWalker, forwardWalker; // Never leave a limit element.\n\n      var limitElement = position.getAncestors().reverse().find(function (item) {\n        return _this2.isLimit(item);\n      }) || position.root;\n\n      if (direction == 'both' || direction == 'backward') {\n        backwardWalker = new TreeWalker({\n          boundaries: Range._createIn(limitElement),\n          startPosition: position,\n          direction: 'backward'\n        });\n      }\n\n      if (direction == 'both' || direction == 'forward') {\n        forwardWalker = new TreeWalker({\n          boundaries: Range._createIn(limitElement),\n          startPosition: position\n        });\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(combineWalkers(backwardWalker, forwardWalker)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var data = _step5.value;\n          var type = data.walker == backwardWalker ? 'elementEnd' : 'elementStart';\n          var value = data.value;\n\n          if (value.type == type && this.isObject(value.item)) {\n            return Range._createOn(value.item);\n          }\n\n          if (this.checkChild(value.nextPosition, '$text')) {\n            return new Range(value.nextPosition);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return null;\n    }\n    /**\n     * Tries to find position ancestors that allow to insert a given node.\n     * It starts searching from the given position and goes node by node to the top of the model tree\n     * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an\n     * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.\n     *\n     * @param {module:engine/model/position~Position} position The position that the search will start from.\n     * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.\n     * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n     */\n\n  }, {\n    key: \"findAllowedParent\",\n    value: function findAllowedParent(position, node) {\n      var parent = position.parent;\n\n      while (parent) {\n        if (this.checkChild(parent, node)) {\n          return parent;\n        } // Do not split limit elements.\n\n\n        if (this.isLimit(parent)) {\n          return null;\n        }\n\n        parent = parent.parent;\n      }\n\n      return null;\n    }\n    /**\n     * Sets attributes allowed by the schema on a given node.\n     *\n     * @param {module:engine/model/node~Node} node A node to set attributes on.\n     * @param {Object} attributes Attributes keys and values.\n     * @param {module:engine/model/writer~Writer} writer An instance of the model writer.\n     */\n\n  }, {\n    key: \"setAllowedAttributes\",\n    value: function setAllowedAttributes(node, attributes, writer) {\n      var model = writer.model;\n\n      for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            attributeName = _Object$entries$_i[0],\n            attributeValue = _Object$entries$_i[1];\n\n        if (model.schema.checkAttribute(node, attributeName)) {\n          writer.setAttribute(attributeName, attributeValue, node);\n        }\n      }\n    }\n    /**\n     * Removes attributes disallowed by the schema.\n     *\n     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n     * @param {module:engine/model/writer~Writer} writer\n     */\n\n  }, {\n    key: \"removeDisallowedAttributes\",\n    value: function removeDisallowedAttributes(nodes, writer) {\n      var _iterator6 = _createForOfIteratorHelper(nodes),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var node = _step6.value;\n\n          // When node is a `Text` it has no children, so just filter it out.\n          if (node.is('$text')) {\n            removeDisallowedAttributeFromNode(this, node, writer);\n          } // In a case of `Element` iterates through positions between nodes inside this element\n          // and filter out node before the current position, or position parent when position\n          // is at start of an element. Using positions prevent from omitting merged nodes\n          // see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n          else {\n            var rangeInNode = Range._createIn(node);\n\n            var positionsInRange = rangeInNode.getPositions();\n\n            var _iterator7 = _createForOfIteratorHelper(positionsInRange),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var position = _step7.value;\n                var item = position.nodeBefore || position.parent;\n                removeDisallowedAttributeFromNode(this, item, writer);\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /**\n     * Gets attributes of a node that have a given property.\n     *\n     * @param {module:engine/model/node~Node} node Node to get attributes from.\n     * @param {String} propertyName Name of the property that attribute must have to return it.\n     * @param {Boolean|Symbol|String|Number|Object|null|undefined} propertyValue Desired value of the property that we want to check.\n     * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will\n     * return attributes which given property's value is equal to this parameter.\n     * @returns {Object} Object with attributes' names as key and attributes' values as value.\n     */\n\n  }, {\n    key: \"getAttributesWithProperty\",\n    value: function getAttributesWithProperty(node, propertyName, propertyValue) {\n      var attributes = {};\n\n      var _iterator8 = _createForOfIteratorHelper(node.getAttributes()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n              attributeName = _step8$value[0],\n              attributeValue = _step8$value[1];\n\n          var attributeProperties = this.getAttributeProperties(attributeName);\n\n          if (attributeProperties[propertyName] === undefined) {\n            continue;\n          }\n\n          if (propertyValue === undefined || propertyValue === attributeProperties[propertyName]) {\n            attributes[attributeName] = attributeValue;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return attributes;\n    }\n    /**\n     * Creates an instance of the schema context.\n     *\n     * @param {module:engine/model/schema~SchemaContextDefinition} context\n     * @returns {module:engine/model/schema~SchemaContext}\n     */\n\n  }, {\n    key: \"createContext\",\n    value: function createContext(context) {\n      return new SchemaContext(context);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_clearCache\",\n    value: function _clearCache() {\n      this._compiledDefinitions = null;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      var compiledDefinitions = {};\n      var sourceRules = this._sourceDefinitions;\n      var itemNames = Object.keys(sourceRules);\n\n      for (var _i2 = 0, _itemNames = itemNames; _i2 < _itemNames.length; _i2++) {\n        var itemName = _itemNames[_i2];\n        compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);\n      }\n\n      for (var _i3 = 0, _itemNames2 = itemNames; _i3 < _itemNames2.length; _i3++) {\n        var _itemName = _itemNames2[_i3];\n        compileAllowChildren(compiledDefinitions, _itemName);\n      }\n\n      for (var _i4 = 0, _itemNames3 = itemNames; _i4 < _itemNames3.length; _i4++) {\n        var _itemName2 = _itemNames3[_i4];\n        compileAllowContentOf(compiledDefinitions, _itemName2);\n      }\n\n      for (var _i5 = 0, _itemNames4 = itemNames; _i5 < _itemNames4.length; _i5++) {\n        var _itemName3 = _itemNames4[_i5];\n        compileAllowWhere(compiledDefinitions, _itemName3);\n      }\n\n      for (var _i6 = 0, _itemNames5 = itemNames; _i6 < _itemNames5.length; _i6++) {\n        var _itemName4 = _itemNames5[_i6];\n        compileAllowAttributesOf(compiledDefinitions, _itemName4);\n        compileInheritPropertiesFrom(compiledDefinitions, _itemName4);\n      }\n\n      for (var _i7 = 0, _itemNames6 = itemNames; _i7 < _itemNames6.length; _i7++) {\n        var _itemName5 = _itemNames6[_i7];\n        cleanUpAllowIn(compiledDefinitions, _itemName5);\n        setupAllowChildren(compiledDefinitions, _itemName5);\n        cleanUpAllowAttributes(compiledDefinitions, _itemName5);\n      }\n\n      this._compiledDefinitions = compiledDefinitions;\n    }\n    /**\n     * @private\n     * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n     * @param {module:engine/model/schema~SchemaContext} context\n     * @param {Number} contextItemIndex\n     */\n\n  }, {\n    key: \"_checkContextMatch\",\n    value: function _checkContextMatch(def, context) {\n      var contextItemIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;\n      var contextItem = context.getItem(contextItemIndex);\n\n      if (def.allowIn.includes(contextItem.name)) {\n        if (contextItemIndex == 0) {\n          return true;\n        } else {\n          var parentRule = this.getDefinition(contextItem);\n          return this._checkContextMatch(parentRule, context, contextItemIndex - 1);\n        }\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n     * inside the given range on which the attribute can be applied.\n     *\n     * This is a helper function for {@link ~Schema#getValidRanges}.\n     *\n     * @private\n     * @param {module:engine/model/range~Range} range The range to process.\n     * @param {String} attribute The name of the attribute to check.\n     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n     */\n\n  }, {\n    key: \"_getValidRangesForRange\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function _getValidRangesForRange(range, attribute) {\n      var start, end, _iterator9, _step9, item;\n\n      return _regeneratorRuntime.wrap(function _getValidRangesForRange$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              start = range.start;\n              end = range.start;\n              _iterator9 = _createForOfIteratorHelper(range.getItems({\n                shallow: true\n              }));\n              _context3.prev = 3;\n\n              _iterator9.s();\n\n            case 5:\n              if ((_step9 = _iterator9.n()).done) {\n                _context3.next = 17;\n                break;\n              }\n\n              item = _step9.value;\n\n              if (!item.is('element')) {\n                _context3.next = 9;\n                break;\n              }\n\n              return _context3.delegateYield(this._getValidRangesForRange(Range._createIn(item), attribute), \"t0\", 9);\n\n            case 9:\n              if (this.checkAttribute(item, attribute)) {\n                _context3.next = 14;\n                break;\n              }\n\n              if (start.isEqual(end)) {\n                _context3.next = 13;\n                break;\n              }\n\n              _context3.next = 13;\n              return new Range(start, end);\n\n            case 13:\n              start = Position._createAfter(item);\n\n            case 14:\n              end = Position._createAfter(item);\n\n            case 15:\n              _context3.next = 5;\n              break;\n\n            case 17:\n              _context3.next = 22;\n              break;\n\n            case 19:\n              _context3.prev = 19;\n              _context3.t1 = _context3[\"catch\"](3);\n\n              _iterator9.e(_context3.t1);\n\n            case 22:\n              _context3.prev = 22;\n\n              _iterator9.f();\n\n              return _context3.finish(22);\n\n            case 25:\n              if (start.isEqual(end)) {\n                _context3.next = 28;\n                break;\n              }\n\n              _context3.next = 28;\n              return new Range(start, end);\n\n            case 28:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _getValidRangesForRange, this, [[3, 19, 22, 25]]);\n    })\n  }]);\n\n  return Schema;\n}();\n\nexport { Schema as default };\nmix(Schema, ObservableMixin);\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding standard behavior of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\", you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior, for example implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in various ways, but the most important use case is overriding the standard behavior of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1`, you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.\n * * {@link ~SchemaItemDefinition#allowChildren `allowChildren`} &ndash; Defines which other items are allowed inside this item.\n * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.\n * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits \"allowed children\" from other items.\n * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits \"allowed in\" from other items.\n * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.\n * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.\n * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;\n * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * # The `is*` properties\n *\n * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.\n * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.\n * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is \"text-like\" and should be treated as an inline node.\n * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.\n * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element\n * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.\n * In other words, all actions that happen inside a limit element are limited to its content.\n * All objects are treated as limit elements, too.\n * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is \"self-contained\" and should be treated as a whole.\n * Examples of object elements: `imageBlock`, `table`, `video`, etc. An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the meaning of these types in the\n * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.\n *\n * # Generic items\n *\n * There are several generic items (classes of elements) available: `$root`, `$container`, `$block`, `$blockObject`,\n * `$inlineObject`, and `$text`. They are defined as follows:\n *\n *\t\tschema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\n *\t\tschema.register( '$container', {\n *\t\t\tallowIn: [ '$root', '$container' ]\n *\t\t} );\n *\n *\t\tschema.register( '$block', {\n *\t\t\tallowIn: [ '$root', '$container' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n *\t\tschema.register( '$blockObject', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n *\t\tschema.register( '$inlineObject', {\n *\t\t\tallowWhere: '$text',\n *\t\t\tallowAttributesOf: '$text',\n *\t\t\tisInline: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n *\t\tschema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true,\n *\t\t\tisContent: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` inside a `$root` and allow `$text` as a `paragraph` child:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: '$root',\n *\t\t\tallowChildren: '$text',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * The previous rule can be written in a shorter form using inheritance:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tinheritAllFrom: '$block'\n *\t\t} );\n *\n * Make `imageBlock` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'imageBlock', {\n *\t\t\tinheritAllFrom: '$blockObject',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t} );\n *\n * Make `caption` allowed in `imageBlock` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'imageBlock',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n *\n * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.\n * @property {String|Array.<String>} allowChildren Defines which other items are allowed inside this item.\n * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.\n * @property {String|Array.<String>} allowContentOf Inherits \"allowed children\" from other items.\n * @property {String|Array.<String>} allowWhere Inherits \"allowed in\" from other items.\n * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.\n * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.\n * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n *\n * @property {Boolean} isBlock\n * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n *\n * Read more about the block elements in the\n * {@glink framework/guides/deep-dive/schema#block-elements Block elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive}.\n *\n * @property {Boolean} isInline\n * Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * Read more about the inline elements in the\n * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isLimit\n * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content.\n *\n * Read more about the limit elements in the\n * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isObject\n * Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `imageBlock`, `table`, `video`, etc.\n *\n * **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n *\n * Read more about the object elements in the\n * {@glink framework/guides/deep-dive/schema#object-elements Object elements section} of the Schema deep dive guide.\n *\n * @property {Boolean} isSelectable\n * `true` when an element should be selectable as a whole by the user. Examples of selectable elements: `imageBlock`, `table`, `tableCell`,\n * etc.\n *\n * **Note:** An object is also a selectable element, so\n * {@link module:engine/model/schema~Schema#isSelectable `isSelectable()`} returns `true` for object elements automatically.\n *\n * Read more about selectable elements in the\n * {@glink framework/guides/deep-dive/schema#selectable-elements Selectable elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n *\n * @property {Boolean} isContent\n * An item is a content when it always finds its way to the editor data output regardless of the number and type of its descendants.\n * Examples of content elements: `$text`, `imageBlock`, `table`, etc. (but not `paragraph`, `heading1` or `tableCell`).\n *\n * **Note:** An object is also a content element, so\n * {@link module:engine/model/schema~Schema#isContent `isContent()`} returns `true` for object elements automatically.\n *\n * Read more about content elements in the\n * {@glink framework/guides/deep-dive/schema#content-elements Content elements section} of\n * the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowChildren` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\n\nexport var SchemaContext = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the context.\n   *\n   * @param {module:engine/model/schema~SchemaContextDefinition} context\n   */\n  function SchemaContext(context) {\n    _classCallCheck(this, SchemaContext);\n\n    if (context instanceof SchemaContext) {\n      return context;\n    }\n\n    if (typeof context == 'string') {\n      context = [context];\n    } else if (!Array.isArray(context)) {\n      // `context` is item or position.\n      // Position#getAncestors() doesn't accept any parameters but it works just fine here.\n      context = context.getAncestors({\n        includeSelf: true\n      });\n    }\n\n    this._items = context.map(mapContextItem);\n  }\n  /**\n   * The number of items.\n   *\n   * @type {Number}\n   */\n\n\n  _createClass(SchemaContext, [{\n    key: Symbol.iterator,\n\n    /**\n     * Iterable interface.\n     *\n     * Iterates over all context items.\n     *\n     * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n     */\n    value: function value() {\n      return this._items[Symbol.iterator]();\n    }\n    /**\n     * Returns a new schema context instance with an additional item.\n     *\n     * Item can be added as:\n     *\n     * \t\tconst context = new SchemaContext( [ '$root' ] );\n     *\n     * \t\t// An element.\n     * \t\tconst fooElement = writer.createElement( 'fooElement' );\n     * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n     *\n     * \t\t// A text node.\n     * \t\tconst text = writer.createText( 'foobar' );\n     * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n     *\n     * \t\t// A string (element name).\n     * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n     *\n     * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n     * (without ancestors).\n     *\n     * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n     * to the current context.\n     * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(item) {\n      var ctx = new SchemaContext([item]);\n      ctx._items = [].concat(_toConsumableArray(this._items), _toConsumableArray(ctx._items));\n      return ctx;\n    }\n    /**\n     * Gets an item on the given index.\n     *\n     * @returns {module:engine/model/schema~SchemaContextItem}\n     */\n\n  }, {\n    key: \"getItem\",\n    value: function getItem(index) {\n      return this._items[index];\n    }\n    /**\n     * Returns the names of items.\n     *\n     * @returns {Iterable.<String>}\n     */\n\n  }, {\n    key: \"getNames\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function getNames() {\n      return _regeneratorRuntime.wrap(function getNames$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.delegateYield(this._items.map(function (item) {\n                return item.name;\n              }), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, getNames, this);\n    })\n    /**\n     * Checks whether the context ends with the given nodes.\n     *\n     *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n     *\n     *\t\tctx.endsWith( '$text' ); // -> true\n     *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n     *\t\tctx.endsWith( '$root' ); // -> false\n     *\t\tctx.endsWith( 'paragraph' ); // -> false\n     *\n     * @param {String} query\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"endsWith\",\n    value: function endsWith(query) {\n      return Array.from(this.getNames()).join(' ').endsWith(query);\n    }\n    /**\n     * Checks whether the context starts with the given nodes.\n     *\n     *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n     *\n     *\t\tctx.endsWith( '$root' ); // -> true\n     *\t\tctx.endsWith( '$root paragraph' ); // -> true\n     *\t\tctx.endsWith( '$text' ); // -> false\n     *\t\tctx.endsWith( 'paragraph' ); // -> false\n     *\n     * @param {String} query\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"startsWith\",\n    value: function startsWith(query) {\n      return Array.from(this.getNames()).join(' ').startsWith(query);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._items.length;\n    }\n    /**\n     * The last item (the lowest node).\n     *\n     * @type {module:engine/model/schema~SchemaContextItem}\n     */\n\n  }, {\n    key: \"last\",\n    get: function get() {\n      return this._items[this._items.length - 1];\n    }\n  }]);\n\n  return SchemaContext;\n}();\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node** – in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document – in this case all its ancestors will be used.\n * * By defining an **array of nodes** – in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mixing in an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name` – the name of this item,\n * * `* getAttributeKeys()` – a generator of keys of item attributes,\n * * `getAttribute( keyName )` – a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule(sourceItemRules, itemName) {\n  var itemRule = {\n    name: itemName,\n    allowIn: [],\n    allowContentOf: [],\n    allowWhere: [],\n    allowAttributes: [],\n    allowAttributesOf: [],\n    allowChildren: [],\n    inheritTypesFrom: []\n  };\n  copyTypes(sourceItemRules, itemRule);\n  copyProperty(sourceItemRules, itemRule, 'allowIn');\n  copyProperty(sourceItemRules, itemRule, 'allowContentOf');\n  copyProperty(sourceItemRules, itemRule, 'allowWhere');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributes');\n  copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');\n  copyProperty(sourceItemRules, itemRule, 'allowChildren');\n  copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');\n  makeInheritAllWork(sourceItemRules, itemRule);\n  return itemRule;\n}\n\nfunction compileAllowChildren(compiledDefinitions, itemName) {\n  var item = compiledDefinitions[itemName];\n\n  var _iterator10 = _createForOfIteratorHelper(item.allowChildren),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var allowChildrenItem = _step10.value;\n      var allowedChildren = compiledDefinitions[allowChildrenItem]; // The allowChildren property may point to an unregistered element.\n\n      if (!allowedChildren) {\n        continue;\n      }\n\n      allowedChildren.allowIn.push(itemName);\n    } // The allowIn property already includes correct items, reset the allowChildren property\n    // to avoid duplicates later when setting up compilation results.\n\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  item.allowChildren.length = 0;\n}\n\nfunction compileAllowContentOf(compiledDefinitions, itemName) {\n  var _iterator11 = _createForOfIteratorHelper(compiledDefinitions[itemName].allowContentOf),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var allowContentOfItemName = _step11.value;\n\n      // The allowContentOf property may point to an unregistered element.\n      if (compiledDefinitions[allowContentOfItemName]) {\n        var allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);\n        allowedChildren.forEach(function (allowedItem) {\n          allowedItem.allowIn.push(itemName);\n        });\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  delete compiledDefinitions[itemName].allowContentOf;\n}\n\nfunction compileAllowWhere(compiledDefinitions, itemName) {\n  var _iterator12 = _createForOfIteratorHelper(compiledDefinitions[itemName].allowWhere),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var allowWhereItemName = _step12.value;\n      var inheritFrom = compiledDefinitions[allowWhereItemName]; // The allowWhere property may point to an unregistered element.\n\n      if (inheritFrom) {\n        var _compiledDefinitions$;\n\n        var allowedIn = inheritFrom.allowIn;\n\n        (_compiledDefinitions$ = compiledDefinitions[itemName].allowIn).push.apply(_compiledDefinitions$, _toConsumableArray(allowedIn));\n      }\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  delete compiledDefinitions[itemName].allowWhere;\n}\n\nfunction compileAllowAttributesOf(compiledDefinitions, itemName) {\n  var _iterator13 = _createForOfIteratorHelper(compiledDefinitions[itemName].allowAttributesOf),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var allowAttributeOfItem = _step13.value;\n      var inheritFrom = compiledDefinitions[allowAttributeOfItem];\n\n      if (inheritFrom) {\n        var _compiledDefinitions$2;\n\n        var inheritAttributes = inheritFrom.allowAttributes;\n\n        (_compiledDefinitions$2 = compiledDefinitions[itemName].allowAttributes).push.apply(_compiledDefinitions$2, _toConsumableArray(inheritAttributes));\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  delete compiledDefinitions[itemName].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom(compiledDefinitions, itemName) {\n  var item = compiledDefinitions[itemName];\n\n  var _iterator14 = _createForOfIteratorHelper(item.inheritTypesFrom),\n      _step14;\n\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var inheritPropertiesOfItem = _step14.value;\n      var inheritFrom = compiledDefinitions[inheritPropertiesOfItem];\n\n      if (inheritFrom) {\n        var typeNames = Object.keys(inheritFrom).filter(function (name) {\n          return name.startsWith('is');\n        });\n\n        var _iterator15 = _createForOfIteratorHelper(typeNames),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var name = _step15.value;\n\n            if (!(name in item)) {\n              item[name] = inheritFrom[name];\n            }\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n\n  delete item.inheritTypesFrom;\n} // Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\n\n\nfunction cleanUpAllowIn(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n  var existingItems = itemRule.allowIn.filter(function (itemToCheck) {\n    return compiledDefinitions[itemToCheck];\n  });\n  itemRule.allowIn = Array.from(new Set(existingItems));\n} // Setup allowChildren items based on allowIn.\n\n\nfunction setupAllowChildren(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n\n  var _iterator16 = _createForOfIteratorHelper(itemRule.allowIn),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var allowedParentItemName = _step16.value;\n      var allowedParentItem = compiledDefinitions[allowedParentItemName];\n      allowedParentItem.allowChildren.push(itemName);\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n}\n\nfunction cleanUpAllowAttributes(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));\n}\n\nfunction copyTypes(sourceItemRules, itemRule) {\n  var _iterator17 = _createForOfIteratorHelper(sourceItemRules),\n      _step17;\n\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var sourceItemRule = _step17.value;\n      var typeNames = Object.keys(sourceItemRule).filter(function (name) {\n        return name.startsWith('is');\n      });\n\n      var _iterator18 = _createForOfIteratorHelper(typeNames),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var name = _step18.value;\n          itemRule[name] = sourceItemRule[name];\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n}\n\nfunction copyProperty(sourceItemRules, itemRule, propertyName) {\n  var _iterator19 = _createForOfIteratorHelper(sourceItemRules),\n      _step19;\n\n  try {\n    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n      var sourceItemRule = _step19.value;\n\n      if (typeof sourceItemRule[propertyName] == 'string') {\n        itemRule[propertyName].push(sourceItemRule[propertyName]);\n      } else if (Array.isArray(sourceItemRule[propertyName])) {\n        var _itemRule$propertyNam;\n\n        (_itemRule$propertyNam = itemRule[propertyName]).push.apply(_itemRule$propertyNam, _toConsumableArray(sourceItemRule[propertyName]));\n      }\n    }\n  } catch (err) {\n    _iterator19.e(err);\n  } finally {\n    _iterator19.f();\n  }\n}\n\nfunction makeInheritAllWork(sourceItemRules, itemRule) {\n  var _iterator20 = _createForOfIteratorHelper(sourceItemRules),\n      _step20;\n\n  try {\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      var sourceItemRule = _step20.value;\n      var inheritFrom = sourceItemRule.inheritAllFrom;\n\n      if (inheritFrom) {\n        itemRule.allowContentOf.push(inheritFrom);\n        itemRule.allowWhere.push(inheritFrom);\n        itemRule.allowAttributesOf.push(inheritFrom);\n        itemRule.inheritTypesFrom.push(inheritFrom);\n      }\n    }\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n}\n\nfunction getAllowedChildren(compiledDefinitions, itemName) {\n  var itemRule = compiledDefinitions[itemName];\n  return getValues(compiledDefinitions).filter(function (def) {\n    return def.allowIn.includes(itemRule.name);\n  });\n}\n\nfunction getValues(obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n\nfunction mapContextItem(ctxItem) {\n  if (typeof ctxItem == 'string' || ctxItem.is('documentFragment')) {\n    return {\n      name: typeof ctxItem == 'string' ? ctxItem : '$documentFragment',\n      getAttributeKeys: /*#__PURE__*/_regeneratorRuntime.mark(function getAttributeKeys() {\n        return _regeneratorRuntime.wrap(function getAttributeKeys$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, getAttributeKeys);\n      }),\n      getAttribute: function getAttribute() {}\n    };\n  } else {\n    return {\n      // '$text' means text nodes and text proxies.\n      name: ctxItem.is('element') ? ctxItem.name : '$text',\n      getAttributeKeys: /*#__PURE__*/_regeneratorRuntime.mark(function getAttributeKeys() {\n        return _regeneratorRuntime.wrap(function getAttributeKeys$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.delegateYield(ctxItem.getAttributeKeys(), \"t0\", 1);\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, getAttributeKeys);\n      }),\n      getAttribute: function getAttribute(key) {\n        return ctxItem.getAttribute(key);\n      }\n    };\n  }\n} // Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\n\n\nfunction combineWalkers(backward, forward) {\n  var done, step, _step21;\n\n  return _regeneratorRuntime.wrap(function combineWalkers$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          done = false;\n\n        case 1:\n          if (done) {\n            _context7.next = 17;\n            break;\n          }\n\n          done = true;\n\n          if (!backward) {\n            _context7.next = 9;\n            break;\n          }\n\n          step = backward.next();\n\n          if (step.done) {\n            _context7.next = 9;\n            break;\n          }\n\n          done = false;\n          _context7.next = 9;\n          return {\n            walker: backward,\n            value: step.value\n          };\n\n        case 9:\n          if (!forward) {\n            _context7.next = 15;\n            break;\n          }\n\n          _step21 = forward.next();\n\n          if (_step21.done) {\n            _context7.next = 15;\n            break;\n          }\n\n          done = false;\n          _context7.next = 15;\n          return {\n            walker: forward,\n            value: _step21.value\n          };\n\n        case 15:\n          _context7.next = 1;\n          break;\n\n        case 17:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, _marked);\n} // Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\n\n\nfunction convertToMinimalFlatRanges(ranges) {\n  var _iterator21, _step22, range;\n\n  return _regeneratorRuntime.wrap(function convertToMinimalFlatRanges$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          _iterator21 = _createForOfIteratorHelper(ranges);\n          _context8.prev = 1;\n\n          _iterator21.s();\n\n        case 3:\n          if ((_step22 = _iterator21.n()).done) {\n            _context8.next = 8;\n            break;\n          }\n\n          range = _step22.value;\n          return _context8.delegateYield(range.getMinimalFlatRanges(), \"t0\", 6);\n\n        case 6:\n          _context8.next = 3;\n          break;\n\n        case 8:\n          _context8.next = 13;\n          break;\n\n        case 10:\n          _context8.prev = 10;\n          _context8.t1 = _context8[\"catch\"](1);\n\n          _iterator21.e(_context8.t1);\n\n        case 13:\n          _context8.prev = 13;\n\n          _iterator21.f();\n\n          return _context8.finish(13);\n\n        case 16:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, _marked2, null, [[1, 10, 13, 16]]);\n}\n\nfunction removeDisallowedAttributeFromNode(schema, node, writer) {\n  var _iterator22 = _createForOfIteratorHelper(node.getAttributeKeys()),\n      _step23;\n\n  try {\n    for (_iterator22.s(); !(_step23 = _iterator22.n()).done;) {\n      var attribute = _step23.value;\n\n      if (!schema.checkAttribute(node, attribute)) {\n        writer.removeAttribute(attribute, node);\n      }\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n}","map":null,"metadata":{},"sourceType":"module"}