{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/placeholder\n */\nimport '../../theme/placeholder.css'; // Each document stores information about its placeholder elements and check functions.\n\nvar documentPlaceholders = new WeakMap();\n/**\n * A helper that enables a placeholder on the provided view element (also updates its visibility).\n * The placeholder is a CSS pseudo–element (with a text content) attached to the element.\n *\n * To change the placeholder text, simply call this method again with new options.\n *\n * To disable the placeholder, use {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} helper.\n *\n * @param {Object} [options] Configuration options of the placeholder.\n * @param {module:engine/view/view~View} options.view Editing view instance.\n * @param {module:engine/view/element~Element} options.element Element that will gain a placeholder.\n * See `options.isDirectHost` to learn more.\n * @param {String} options.text Placeholder text.\n * @param {Boolean} [options.isDirectHost=true] If set `false`, the placeholder will not be enabled directly\n * in the passed `element` but in one of its children (selected automatically, i.e. a first empty child element).\n * Useful when attaching placeholders to elements that can host other elements (not just text), for instance,\n * editable root elements.\n * @param {Boolean} [options.keepOnFocus=false] If set `true`, the placeholder stay visible when the host element is focused.\n */\n\nexport function enablePlaceholder(options) {\n  var view = options.view,\n      element = options.element,\n      text = options.text,\n      _options$isDirectHost = options.isDirectHost,\n      isDirectHost = _options$isDirectHost === void 0 ? true : _options$isDirectHost,\n      _options$keepOnFocus = options.keepOnFocus,\n      keepOnFocus = _options$keepOnFocus === void 0 ? false : _options$keepOnFocus;\n  var doc = view.document; // Use a single a single post fixer per—document to update all placeholders.\n\n  if (!documentPlaceholders.has(doc)) {\n    documentPlaceholders.set(doc, new Map()); // If a post-fixer callback makes a change, it should return `true` so other post–fixers\n    // can re–evaluate the document again.\n\n    doc.registerPostFixer(function (writer) {\n      return updateDocumentPlaceholders(doc, writer);\n    });\n  } // Store information about the element placeholder under its document.\n\n\n  documentPlaceholders.get(doc).set(element, {\n    text: text,\n    isDirectHost: isDirectHost,\n    keepOnFocus: keepOnFocus,\n    hostElement: isDirectHost ? element : null\n  }); // Update the placeholders right away.\n\n  view.change(function (writer) {\n    return updateDocumentPlaceholders(doc, writer);\n  });\n}\n/**\n * Disables the placeholder functionality from a given element.\n *\n * See {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} to learn more.\n *\n * @param {module:engine/view/view~View} view\n * @param {module:engine/view/element~Element} element\n */\n\nexport function disablePlaceholder(view, element) {\n  var doc = element.document;\n  view.change(function (writer) {\n    if (!documentPlaceholders.has(doc)) {\n      return;\n    }\n\n    var placeholders = documentPlaceholders.get(doc);\n    var config = placeholders.get(element);\n    writer.removeAttribute('data-placeholder', config.hostElement);\n    hidePlaceholder(writer, config.hostElement);\n    placeholders.delete(element);\n  });\n}\n/**\n * Shows a placeholder in the provided element by changing related attributes and CSS classes.\n *\n * **Note**: This helper will not update the placeholder visibility nor manage the\n * it in any way in the future. What it does is a one–time state change of an element. Use\n * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} and\n * {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} for full\n * placeholder functionality.\n *\n * **Note**: This helper will blindly show the placeholder directly in the root editable element if\n * one is passed, which could result in a visual clash if the editable element has some children\n * (for instance, an empty paragraph). Use {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`}\n * in that case or make sure the correct element is passed to the helper.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/view/element~Element} element\n * @returns {Boolean} `true`, if any changes were made to the `element`.\n */\n\nexport function showPlaceholder(writer, element) {\n  if (!element.hasClass('ck-placeholder')) {\n    writer.addClass('ck-placeholder', element);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Hides a placeholder in the element by changing related attributes and CSS classes.\n *\n * **Note**: This helper will not update the placeholder visibility nor manage the\n * it in any way in the future. What it does is a one–time state change of an element. Use\n * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} and\n * {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} for full\n * placeholder functionality.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/view/element~Element} element\n * @returns {Boolean} `true`, if any changes were made to the `element`.\n */\n\nexport function hidePlaceholder(writer, element) {\n  if (element.hasClass('ck-placeholder')) {\n    writer.removeClass('ck-placeholder', element);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks if a placeholder should be displayed in the element.\n *\n * **Note**: This helper will blindly check the possibility of showing a placeholder directly in the\n * root editable element if one is passed, which may not be the expected result. If an element can\n * host other elements (not just text), most likely one of its children should be checked instead\n * because it will be the final host for the placeholder. Use\n * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} in that case or make\n * sure the correct element is passed to the helper.\n *\n * @param {module:engine/view/element~Element} element Element that holds the placeholder.\n * @param {Boolean} keepOnFocus Focusing the element will keep the placeholder visible.\n * @returns {Boolean}\n */\n\nexport function needsPlaceholder(element, keepOnFocus) {\n  if (!element.isAttached()) {\n    return false;\n  } // Anything but uiElement(s) counts as content.\n\n\n  var hasContent = Array.from(element.getChildren()).some(function (element) {\n    return !element.is('uiElement');\n  });\n\n  if (hasContent) {\n    return false;\n  } // Skip the focus check and make the placeholder visible already regardless of document focus state.\n\n\n  if (keepOnFocus) {\n    return true;\n  }\n\n  var doc = element.document; // If the document is blurred.\n\n  if (!doc.isFocused) {\n    return true;\n  }\n\n  var viewSelection = doc.selection;\n  var selectionAnchor = viewSelection.anchor; // If document is focused and the element is empty but the selection is not anchored inside it.\n\n  return selectionAnchor && selectionAnchor.parent !== element;\n} // Updates all placeholders associated with a document in a post–fixer callback.\n//\n// @private\n// @param { module:engine/view/document~Document} doc\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n// @returns {Boolean} True if any changes were made to the view document.\n\nfunction updateDocumentPlaceholders(doc, writer) {\n  var placeholders = documentPlaceholders.get(doc);\n  var directHostElements = [];\n  var wasViewModified = false; // First set placeholders on the direct hosts.\n\n  var _iterator = _createForOfIteratorHelper(placeholders),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          element = _step$value[0],\n          config = _step$value[1];\n\n      if (config.isDirectHost) {\n        directHostElements.push(element);\n\n        if (updatePlaceholder(writer, element, config)) {\n          wasViewModified = true;\n        }\n      }\n    } // Then set placeholders on the indirect hosts but only on those that does not already have an direct host placeholder.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(placeholders),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          _element = _step2$value[0],\n          _config = _step2$value[1];\n\n      if (_config.isDirectHost) {\n        continue;\n      }\n\n      var hostElement = getChildPlaceholderHostSubstitute(_element); // When not a direct host, it could happen that there is no child element\n      // capable of displaying a placeholder.\n\n      if (!hostElement) {\n        continue;\n      } // Don't override placeholder if the host element already has some direct placeholder.\n\n\n      if (directHostElements.includes(hostElement)) {\n        continue;\n      } // Update the host element (used for setting and removing the placeholder).\n\n\n      _config.hostElement = hostElement;\n\n      if (updatePlaceholder(writer, _element, _config)) {\n        wasViewModified = true;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return wasViewModified;\n} // Updates a single placeholder in a post–fixer callback.\n//\n// @private\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n// @param {module:engine/view/element~Element} element\n// @param {Object} config Configuration of the placeholder\n// @param {String} config.text\n// @param {Boolean} config.isDirectHost\n// @returns {Boolean} True if any changes were made to the view document.\n\n\nfunction updatePlaceholder(writer, element, config) {\n  var text = config.text,\n      isDirectHost = config.isDirectHost,\n      hostElement = config.hostElement;\n  var wasViewModified = false; // This may be necessary when updating the placeholder text to something else.\n\n  if (hostElement.getAttribute('data-placeholder') !== text) {\n    writer.setAttribute('data-placeholder', text, hostElement);\n    wasViewModified = true;\n  } // If the host element is not a direct host then placeholder is needed only when there is only one element.\n\n\n  var isOnlyChild = isDirectHost || element.childCount == 1;\n\n  if (isOnlyChild && needsPlaceholder(hostElement, config.keepOnFocus)) {\n    if (showPlaceholder(writer, hostElement)) {\n      wasViewModified = true;\n    }\n  } else if (hidePlaceholder(writer, hostElement)) {\n    wasViewModified = true;\n  }\n\n  return wasViewModified;\n} // Gets a child element capable of displaying a placeholder if a parent element can host more\n// than just text (for instance, when it is a root editable element). The child element\n// can then be used in other placeholder helpers as a substitute of its parent.\n//\n// @private\n// @param {module:engine/view/element~Element} parent\n// @returns {module:engine/view/element~Element|null}\n\n\nfunction getChildPlaceholderHostSubstitute(parent) {\n  if (parent.childCount) {\n    var firstChild = parent.getChild(0);\n\n    if (firstChild.is('element') && !firstChild.is('uiElement') && !firstChild.is('attributeElement')) {\n      return firstChild;\n    }\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}