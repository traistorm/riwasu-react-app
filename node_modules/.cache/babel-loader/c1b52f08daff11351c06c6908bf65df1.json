{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imagecaption/imagecaptionediting\n */\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Element, enablePlaceholder } from 'ckeditor5/src/engine';\nimport { toWidgetEditable } from 'ckeditor5/src/widget';\nimport ToggleImageCaptionCommand from './toggleimagecaptioncommand';\nimport ImageUtils from '../imageutils';\nimport ImageCaptionUtils from './imagecaptionutils';\n/**\n * The image caption engine plugin. It is responsible for:\n *\n * * registering converters for the caption element,\n * * registering converters for the caption model attribute,\n * * registering the {@link module:image/imagecaption/toggleimagecaptioncommand~ToggleImageCaptionCommand `toggleImageCaption`} command.\n *\n * @extends module:core/plugin~Plugin\n */\n\nvar ImageCaptionEditing = /*#__PURE__*/function (_Plugin) {\n  _inherits(ImageCaptionEditing, _Plugin);\n\n  _createClass(ImageCaptionEditing, null, [{\n    key: \"requires\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return [ImageUtils, ImageCaptionUtils];\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: \"pluginName\",\n    get: function get() {\n      return 'ImageCaptionEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function ImageCaptionEditing(editor) {\n    var _this;\n\n    _classCallCheck(this, ImageCaptionEditing);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageCaptionEditing).call(this, editor));\n    /**\n     * A map that keeps saved JSONified image captions and image model elements they are\n     * associated with.\n     *\n     * To learn more about this system, see {@link #_saveCaption}.\n     *\n     * @member {WeakMap.<module:engine/model/element~Element,Object>}\n     */\n\n    _this._savedCaptionsMap = new WeakMap();\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ImageCaptionEditing, [{\n    key: \"init\",\n    value: function init() {\n      var editor = this.editor;\n      var schema = editor.model.schema; // Schema configuration.\n\n      if (!schema.isRegistered('caption')) {\n        schema.register('caption', {\n          allowIn: 'imageBlock',\n          allowContentOf: '$block',\n          isLimit: true\n        });\n      } else {\n        schema.extend('caption', {\n          allowIn: 'imageBlock'\n        });\n      }\n\n      editor.commands.add('toggleImageCaption', new ToggleImageCaptionCommand(this.editor));\n\n      this._setupConversion();\n\n      this._setupImageTypeCommandsIntegration();\n    }\n    /**\n     * Configures conversion pipelines to support upcasting and downcasting\n     * image captions.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupConversion\",\n    value: function _setupConversion() {\n      var editor = this.editor;\n      var _view = editor.editing.view;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      var imageCaptionUtils = editor.plugins.get('ImageCaptionUtils');\n      var t = editor.t; // View -> model converter for the data pipeline.\n\n      editor.conversion.for('upcast').elementToElement({\n        view: function view(element) {\n          return imageCaptionUtils.matchImageCaptionViewElement(element);\n        },\n        model: 'caption'\n      }); // Model -> view converter for the data pipeline.\n\n      editor.conversion.for('dataDowncast').elementToElement({\n        model: 'caption',\n        view: function view(modelElement, _ref) {\n          var writer = _ref.writer;\n\n          if (!imageUtils.isBlockImage(modelElement.parent)) {\n            return null;\n          }\n\n          return writer.createContainerElement('figcaption');\n        }\n      }); // Model -> view converter for the editing pipeline.\n\n      editor.conversion.for('editingDowncast').elementToElement({\n        model: 'caption',\n        view: function view(modelElement, _ref2) {\n          var writer = _ref2.writer;\n\n          if (!imageUtils.isBlockImage(modelElement.parent)) {\n            return null;\n          }\n\n          var figcaptionElement = writer.createEditableElement('figcaption');\n          writer.setCustomProperty('imageCaption', true, figcaptionElement);\n          enablePlaceholder({\n            view: _view,\n            element: figcaptionElement,\n            text: t('Enter image caption'),\n            keepOnFocus: true\n          });\n          return toWidgetEditable(figcaptionElement, writer);\n        }\n      });\n    }\n    /**\n     * Integrates with {@link module:image/image/imagetypecommand~ImageTypeCommand image type commands}\n     * to make sure the caption is preserved when the type of an image changes so it can be restored\n     * in the future if the user decides they want their caption back.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_setupImageTypeCommandsIntegration\",\n    value: function _setupImageTypeCommandsIntegration() {\n      var _this2 = this;\n\n      var editor = this.editor;\n      var imageUtils = editor.plugins.get('ImageUtils');\n      var imageCaptionUtils = editor.plugins.get('ImageCaptionUtils');\n      var imageTypeInlineCommand = editor.commands.get('imageTypeInline');\n      var imageTypeBlockCommand = editor.commands.get('imageTypeBlock');\n\n      var handleImageTypeChange = function handleImageTypeChange(evt) {\n        // The image type command execution can be unsuccessful.\n        if (!evt.return) {\n          return;\n        }\n\n        var _evt$return = evt.return,\n            oldElement = _evt$return.oldElement,\n            newElement = _evt$return.newElement;\n        /* istanbul ignore if: paranoid check */\n\n        if (!oldElement) {\n          return;\n        }\n\n        if (imageUtils.isBlockImage(oldElement)) {\n          var oldCaptionElement = imageCaptionUtils.getCaptionFromImageModelElement(oldElement); // If the old element was a captioned block image (the caption was visible),\n          // simply save it so it can be restored.\n\n          if (oldCaptionElement) {\n            _this2._saveCaption(newElement, oldCaptionElement);\n\n            return;\n          }\n        }\n\n        var savedOldElementCaption = _this2._getSavedCaption(oldElement); // If either:\n        //\n        // * the block image didn't have a visible caption,\n        // * the block image caption was hidden (and already saved),\n        // * the inline image was passed\n        //\n        // just try to \"pass\" the saved caption from the old image to the new image\n        // so it can be retrieved in the future if the user wants it back.\n\n\n        if (savedOldElementCaption) {\n          // Note: Since we're writing to a WeakMap, we don't bother with removing the\n          // [ oldElement, savedOldElementCaption ] pair from it.\n          _this2._saveCaption(newElement, savedOldElementCaption);\n        }\n      }; // Presence of the commands depends on the Image(Inline|Block)Editing plugins loaded in the editor.\n\n\n      if (imageTypeInlineCommand) {\n        this.listenTo(imageTypeInlineCommand, 'execute', handleImageTypeChange, {\n          priority: 'low'\n        });\n      }\n\n      if (imageTypeBlockCommand) {\n        this.listenTo(imageTypeBlockCommand, 'execute', handleImageTypeChange, {\n          priority: 'low'\n        });\n      }\n    }\n    /**\n     * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption\n     * of an image model element.\n     *\n     * See {@link #_saveCaption}.\n     *\n     * @protected\n     * @param {module:engine/model/element~Element} imageModelElement The model element the\n     * caption should be returned for.\n     * @returns {module:engine/model/element~Element|null} The model caption element or `null` if there is none.\n     */\n\n  }, {\n    key: \"_getSavedCaption\",\n    value: function _getSavedCaption(imageModelElement) {\n      var jsonObject = this._savedCaptionsMap.get(imageModelElement);\n\n      return jsonObject ? Element.fromJSON(jsonObject) : null;\n    }\n    /**\n     * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for\n     * an image element to allow restoring it in the future.\n     *\n     * A caption is saved every time it gets hidden and/or the type of an image changes. The\n     * user should be able to restore it on demand.\n     *\n     * **Note**: The caption cannot be stored in the image model element attribute because,\n     * for instance, when the model state propagates to collaborators, the attribute would get\n     * lost (mainly because it does not convert to anything when the caption is hidden) and\n     * the states of collaborators' models would de-synchronize causing numerous issues.\n     *\n     * See {@link #_getSavedCaption}.\n     *\n     * @protected\n     * @param {module:engine/model/element~Element} imageModelElement The model element the\n     * caption is saved for.\n     * @param {module:engine/model/element~Element} caption The caption model element to be saved.\n     */\n\n  }, {\n    key: \"_saveCaption\",\n    value: function _saveCaption(imageModelElement, caption) {\n      this._savedCaptionsMap.set(imageModelElement, caption.toJSON());\n    }\n  }]);\n\n  return ImageCaptionEditing;\n}(Plugin);\n\nexport { ImageCaptionEditing as default };","map":null,"metadata":{},"sourceType":"module"}