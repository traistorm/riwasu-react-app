{"ast":null,"code":"import _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/twostepcaretmovement\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\n/**\n * This plugin enables the two-step caret (phantom) movement behavior for\n * {@link module:typing/twostepcaretmovement~TwoStepCaretMovement#registerAttribute registered attributes}\n * on arrow right (<kbd>→</kbd>) and left (<kbd>←</kbd>) key press.\n *\n * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the\n * beginning/end of an attribute.\n *\n * **Note:** This plugin support right–to–left (Arabic, Hebrew, etc.) content by mirroring its behavior\n * but for the sake of simplicity examples showcase only left–to–right use–cases.\n *\n * # Forward movement\n *\n * ## \"Entering\" an attribute:\n *\n * When this plugin is enabled and registered for the `a` attribute and the selection is right before it\n * (at the attribute boundary), pressing the right arrow key will not move the selection but update its\n * attributes accordingly:\n *\n * * When enabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *    <kbd>→</kbd>\n *\n *   \t\tfoo<$text a=\"true\">{}bar</$text>\n *\n * * When disabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *   <kbd>→</kbd>\n *\n *   \t\tfoo<$text a=\"true\">b{}ar</$text>\n *\n *\n * ## \"Leaving\" an attribute:\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *    <kbd>→</kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *   <kbd>→</kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>b{}az\n *\n * # Backward movement\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *    <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *   <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">ba{}r</$text>b{}az\n *\n * # Multiple attributes\n *\n * * When enabled and many attributes starts or ends at the same position:\n *\n *   \t\t<$text a=\"true\" b=\"true\">bar</$text>{}baz\n *\n *    <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\" b=\"true\">bar{}</$text>baz\n *\n * * When enabled and one procedes another:\n *\n *   \t\t<$text a=\"true\">bar</$text><$text b=\"true\">{}bar</$text>\n *\n *    <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">bar{}</$text><$text b=\"true\">bar</$text>\n *\n */\n\nvar TwoStepCaretMovement = /*#__PURE__*/function (_Plugin) {\n  _inherits(TwoStepCaretMovement, _Plugin);\n\n  _createClass(TwoStepCaretMovement, null, [{\n    key: \"pluginName\",\n\n    /**\n     * @inheritDoc\n     */\n    get: function get() {\n      return 'TwoStepCaretMovement';\n    }\n    /**\n     * @inheritDoc\n     */\n\n  }]);\n\n  function TwoStepCaretMovement(editor) {\n    var _this;\n\n    _classCallCheck(this, TwoStepCaretMovement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TwoStepCaretMovement).call(this, editor));\n    /**\n     * A set of attributes to handle.\n     *\n     * @protected\n     * @property {module:typing/twostepcaretmovement~TwoStepCaretMovement}\n     */\n\n    _this.attributes = new Set();\n    /**\n     * The current UID of the overridden gravity, as returned by\n     * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n     *\n     * @private\n     * @member {String}\n     */\n\n    _this._overrideUid = null;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(TwoStepCaretMovement, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      var editor = this.editor;\n      var model = editor.model;\n      var view = editor.editing.view;\n      var locale = editor.locale;\n      var modelSelection = model.document.selection; // Listen to keyboard events and handle the caret movement according to the 2-step caret logic.\n\n      this.listenTo(view.document, 'arrowKey', function (evt, data) {\n        // This implementation works only for collapsed selection.\n        if (!modelSelection.isCollapsed) {\n          return;\n        } // When user tries to expand the selection or jump over the whole word or to the beginning/end then\n        // two-steps movement is not necessary.\n\n\n        if (data.shiftKey || data.altKey || data.ctrlKey) {\n          return;\n        }\n\n        var arrowRightPressed = data.keyCode == keyCodes.arrowright;\n        var arrowLeftPressed = data.keyCode == keyCodes.arrowleft; // When neither left or right arrow has been pressed then do noting.\n\n        if (!arrowRightPressed && !arrowLeftPressed) {\n          return;\n        }\n\n        var contentDirection = locale.contentLanguageDirection;\n        var isMovementHandled = false;\n\n        if (contentDirection === 'ltr' && arrowRightPressed || contentDirection === 'rtl' && arrowLeftPressed) {\n          isMovementHandled = _this2._handleForwardMovement(data);\n        } else {\n          isMovementHandled = _this2._handleBackwardMovement(data);\n        } // Stop the keydown event if the two-step caret movement handled it. Avoid collisions\n        // with other features which may also take over the caret movement (e.g. Widget).\n\n\n        if (isMovementHandled === true) {\n          evt.stop();\n        }\n      }, {\n        context: '$text',\n        priority: 'highest'\n      });\n      /**\n       * A flag indicating that the automatic gravity restoration should not happen upon the next\n       * gravity restoration.\n       * {@link module:engine/model/selection~Selection#event:change:range} event.\n       *\n       * @private\n       * @member {String}\n       */\n\n      this._isNextGravityRestorationSkipped = false; // The automatic gravity restoration logic.\n\n      this.listenTo(modelSelection, 'change:range', function (evt, data) {\n        // Skipping the automatic restoration is needed if the selection should change\n        // but the gravity must remain overridden afterwards. See the #handleBackwardMovement\n        // to learn more.\n        if (_this2._isNextGravityRestorationSkipped) {\n          _this2._isNextGravityRestorationSkipped = false;\n          return;\n        } // Skip automatic restore when the gravity is not overridden — simply, there's nothing to restore\n        // at this moment.\n\n\n        if (!_this2._isGravityOverridden) {\n          return;\n        } // Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.\n        // It means that e.g. if the change was external (collaboration) and the user had their\n        // selection around the link, its gravity should remain intact in this change:range event.\n\n\n        if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), _this2.attributes)) {\n          return;\n        }\n\n        _this2._restoreGravity();\n      });\n    }\n    /**\n     * Registers a given attribute for the two-step caret movement.\n     *\n     * @param {String} attribute Name of the attribute to handle.\n     */\n\n  }, {\n    key: \"registerAttribute\",\n    value: function registerAttribute(attribute) {\n      this.attributes.add(attribute);\n    }\n    /**\n     * Updates the document selection and the view according to the two–step caret movement state\n     * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n     *\n     * @private\n     * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n     * @returns {Boolean} `true` when the handler prevented caret movement\n     */\n\n  }, {\n    key: \"_handleForwardMovement\",\n    value: function _handleForwardMovement(data) {\n      var attributes = this.attributes;\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var position = selection.getFirstPosition(); // DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered\n      //\n      // \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n      //\n      // or left the attribute\n      //\n      // \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n      //\n      // and the gravity will be restored automatically.\n\n      if (this._isGravityOverridden) {\n        return false;\n      } // DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the\n      // attribute:\n      // * when the selection was initially set there using the mouse,\n      // * when the editor has just started\n      //\n      //\t\t<paragraph><$text attribute>{}bar</$text>baz</paragraph>\n      //\n\n\n      if (position.isAtStart && hasAnyAttribute(selection, attributes)) {\n        return false;\n      } // ENGAGE 2-SCM When at least one of the observed attributes changes its value (incl. starts, ends).\n      //\n      //\t\t<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>\n      //\t\t<paragraph>foo<$text attribute>bar{}</$text><$text otherAttribute>baz</$text></paragraph>\n      //\t\t<paragraph>foo<$text attribute=1>bar{}</$text><$text attribute=2>baz</$text></paragraph>\n      //\t\t<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>\n      //\n\n\n      if (isBetweenDifferentAttributes(position, attributes)) {\n        preventCaretMovement(data);\n\n        this._overrideGravity();\n\n        return true;\n      }\n    }\n    /**\n     * Updates the document selection and the view according to the two–step caret movement state\n     * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n     *\n     * @private\n     * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n     * @returns {Boolean} `true` when the handler prevented caret movement\n     */\n\n  }, {\n    key: \"_handleBackwardMovement\",\n    value: function _handleBackwardMovement(data) {\n      var attributes = this.attributes;\n      var model = this.editor.model;\n      var selection = model.document.selection;\n      var position = selection.getFirstPosition(); // When the gravity is already overridden (by this plugin), it means we are on the two-step position.\n      // Prevent the movement, restore the gravity and update selection attributes.\n      //\n      //\t\t<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>{}baz</$text></paragraph>\n      //\t\t<paragraph>foo<$text attribute>bar</$text><$text otherAttribute>{}baz</$text></paragraph>\n      //\t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n      //\t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n      //\n\n      if (this._isGravityOverridden) {\n        preventCaretMovement(data);\n\n        this._restoreGravity();\n\n        setSelectionAttributesFromTheNodeBefore(model, attributes, position);\n        return true;\n      } else {\n        // REMOVE SELECTION ATTRIBUTE when restoring gravity towards a non-existent content at the\n        // beginning of the block.\n        //\n        // \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n        //\n        if (position.isAtStart) {\n          if (hasAnyAttribute(selection, attributes)) {\n            preventCaretMovement(data);\n            setSelectionAttributesFromTheNodeBefore(model, attributes, position);\n            return true;\n          }\n\n          return false;\n        } // When we are moving from natural gravity, to the position of the 2SCM, we need to override the gravity,\n        // and make sure it won't be restored. Unless it's at the end of the block and an observed attribute.\n        // We need to check if the caret is a one position before the attribute boundary:\n        //\n        //\t\t<paragraph>foo<$text attribute=1>bar</$text><$text attribute=2>b{}az</$text></paragraph>\n        //\t\t<paragraph>foo<$text attribute>bar</$text><$text otherAttribute>b{}az</$text></paragraph>\n        //\t\t<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>\n        //\t\t<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>\n        //\n\n\n        if (isStepAfterAnyAttributeBoundary(position, attributes)) {\n          // ENGAGE 2-SCM if the selection has no attribute. This may happen when the user\n          // left the attribute using a FORWARD 2-SCM.\n          //\n          // \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n          //\n          if (position.isAtEnd && !hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {\n            preventCaretMovement(data);\n            setSelectionAttributesFromTheNodeBefore(model, attributes, position);\n            return true;\n          } // Skip the automatic gravity restore upon the next selection#change:range event.\n          // If not skipped, it would automatically restore the gravity, which should remain\n          // overridden.\n\n\n          this._isNextGravityRestorationSkipped = true;\n\n          this._overrideGravity(); // Don't return \"true\" here because we didn't call _preventCaretMovement.\n          // Returning here will destabilize the filler logic, which also listens to\n          // keydown (and the event would be stopped).\n\n\n          return false;\n        }\n      }\n    }\n    /**\n     * `true` when the gravity is overridden for the plugin.\n     *\n     * @readonly\n     * @private\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"_overrideGravity\",\n\n    /**\n     * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}\n     * and stores the information about this fact in the {@link #_overrideUid}.\n     *\n     * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n     *\n     * @private\n     */\n    value: function _overrideGravity() {\n      this._overrideUid = this.editor.model.change(function (writer) {\n        return writer.overrideSelectionGravity();\n      });\n    }\n    /**\n     * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.\n     *\n     * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_restoreGravity\",\n    value: function _restoreGravity() {\n      var _this3 = this;\n\n      this.editor.model.change(function (writer) {\n        writer.restoreSelectionGravity(_this3._overrideUid);\n        _this3._overrideUid = null;\n      });\n    }\n  }, {\n    key: \"_isGravityOverridden\",\n    get: function get() {\n      return !!this._overrideUid;\n    }\n  }]);\n\n  return TwoStepCaretMovement;\n}(Plugin); // Checks whether the selection has any of given attributes.\n//\n// @param {module:engine/model/documentselection~DocumentSelection} selection\n// @param {Iterable.<String>} attributes\n\n\nexport { TwoStepCaretMovement as default };\n\nfunction hasAnyAttribute(selection, attributes) {\n  var _iterator = _createForOfIteratorHelper(attributes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var observedAttribute = _step.value;\n\n      if (selection.hasAttribute(observedAttribute)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return false;\n} // Applies the given attributes to the current selection using using the\n// values from the node before the current position. Uses\n// the {@link module:engine/model/writer~Writer model writer}.\n//\n// @param {module:engine/model/model~Model}\n// @param {Iterable.<String>} attributess\n// @param {module:engine/model/position~Position} position\n\n\nfunction setSelectionAttributesFromTheNodeBefore(model, attributes, position) {\n  var nodeBefore = position.nodeBefore;\n  model.change(function (writer) {\n    if (nodeBefore) {\n      writer.setSelectionAttribute(nodeBefore.getAttributes());\n    } else {\n      writer.removeSelectionAttribute(attributes);\n    }\n  });\n} // Prevents the caret movement in the view by calling `preventDefault` on the event data.\n//\n// @alias data.preventDefault\n\n\nfunction preventCaretMovement(data) {\n  data.preventDefault();\n} // Checks whether the step before `isBetweenDifferentAttributes()`.\n//\n// @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isStepAfterAnyAttributeBoundary(position, attributes) {\n  var positionBefore = position.getShiftedBy(-1);\n  return isBetweenDifferentAttributes(positionBefore, attributes);\n} // Checks whether the given position is between different values of given attributes.\n//\n// @param {module:engine/model/position~Position} position\n// @param {Iterable.<String>} attributes\n\n\nfunction isBetweenDifferentAttributes(position, attributes) {\n  var nodeBefore = position.nodeBefore,\n      nodeAfter = position.nodeAfter;\n\n  var _iterator2 = _createForOfIteratorHelper(attributes),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var observedAttribute = _step2.value;\n      var attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : undefined;\n      var attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : undefined;\n\n      if (attrAfter !== attrBefore) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"module"}