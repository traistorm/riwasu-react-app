{"ast":null,"code":"import _slicedToArray from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\Project\\\\React\\\\riwasu-react-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { CKEditorError } from '@ckeditor/ckeditor5-utils';\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\n\nvar History = /*#__PURE__*/function () {\n  /**\n   * Creates an empty History instance.\n   */\n  function History() {\n    _classCallCheck(this, History);\n\n    /**\n     * Operations added to the history.\n     *\n     * @private\n     * @readonly\n     * @type {Array.<module:engine/model/operation/operation~Operation>}\n     */\n    this._operations = [];\n    /**\n     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     *\n     * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n     * value is an operation that has been undone by the \"undoing operation\".\n     *\n     * @private\n     * @member {Map} module:engine/model/history~History#_undoPairs\n     */\n\n    this._undoPairs = new Map();\n    /**\n     * Holds all undone operations.\n     *\n     * @private\n     * @type {Set.<module:engine/model/operation/operation~Operation>}\n     */\n\n    this._undoneOperations = new Set();\n    /**\n     * A map that allows retrieving the operations fast based on the given base version.\n     *\n     * @private\n     * @type Map.<Number,Number>\n     */\n\n    this._baseVersionToOperationIndex = new Map();\n    /**\n     * The history version.\n     *\n     * @private\n     * @type {Number}\n     */\n\n    this._version = 0;\n    /**\n     * The gap pairs kept in the <from,to> format.\n     *\n     * Anytime the `history.version` is set to a version larger than `history.version + 1`,\n     * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.\n     *\n     * @private\n     * @type Map.<number,number>\n     */\n\n    this._gaps = new Map();\n  }\n  /**\n   * The version of the last operation in the history.\n   *\n   * The history version is incremented automatically when a new operation is added to the history.\n   * Setting the version manually should be done only in rare circumstances when a gap is planned\n   * between history versions. When doing so, a gap will be created and the history will accept adding\n   * an operation with base version equal to the new history version.\n   *\n   * @type {Number}\n   */\n\n\n  _createClass(History, [{\n    key: \"addOperation\",\n\n    /**\n     * Adds an operation to the history and increments the history version.\n     *\n     * The operation's base version should be equal to the history version. Otherwise an error is thrown.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n     */\n    value: function addOperation(operation) {\n      if (operation.baseVersion !== this.version) {\n        /**\n         * Only operations with matching versions can be added to the history.\n         *\n         * @error model-document-history-addoperation-incorrect-version\n         * @param {Object} errorData The operation and the current document history version.\n         */\n        throw new CKEditorError('model-document-history-addoperation-incorrect-version', this, {\n          operation: operation,\n          historyVersion: this.version\n        });\n      }\n\n      this._operations.push(operation);\n\n      this._version++;\n\n      this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);\n    }\n    /**\n     * Returns operations from the given range of operation base versions that were added to the history.\n     *\n     * Note that there may be gaps in operations base versions.\n     *\n     * @param {Number} [fromBaseVersion] Base version from which operations should be returned (inclusive).\n     * @param {Number} [toBaseVersion] Base version up to which operations should be returned (exclusive).\n        * @returns {Array.<module:engine/model/operation/operation~Operation>} History operations for the given range, in chronological order.\n     */\n\n  }, {\n    key: \"getOperations\",\n    value: function getOperations(fromBaseVersion) {\n      var toBaseVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.version;\n\n      // When there is no operation in the history, return an empty array.\n      // After that we can be sure that `firstOperation`, `lastOperation` are not nullish.\n      if (!this._operations.length) {\n        return [];\n      }\n\n      var firstOperation = this._operations[0];\n\n      if (fromBaseVersion === undefined) {\n        fromBaseVersion = firstOperation.baseVersion;\n      } // Change exclusive `toBaseVersion` to inclusive, so it will refer to the actual index.\n      // Thanks to that mapping from base versions to operation indexes are possible.\n\n\n      var inclusiveTo = toBaseVersion - 1; // Check if \"from\" or \"to\" point to a gap between versions.\n      // If yes, then change the incorrect position to the proper side of the gap.\n      // Thanks to it, it will be possible to get index of the operation.\n\n      var _iterator = _createForOfIteratorHelper(this._gaps),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              gapFrom = _step$value[0],\n              gapTo = _step$value[1];\n\n          if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {\n            fromBaseVersion = gapTo;\n          }\n\n          if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {\n            inclusiveTo = gapFrom - 1;\n          }\n        } // If the whole range is outside of the operation versions, then return an empty array.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {\n        return [];\n      }\n\n      var fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion); // If the range starts before the first operation, then use the first operation as the range's start.\n\n\n      if (fromIndex === undefined) {\n        fromIndex = 0;\n      }\n\n      var toIndex = this._baseVersionToOperationIndex.get(inclusiveTo); // If the range ends after the last operation, then use the last operation as the range's end.\n\n\n      if (toIndex === undefined) {\n        toIndex = this._operations.length - 1;\n      } // Return the part of the history operations based on the calculated start index and end index.\n\n\n      return this._operations.slice(fromIndex, // The `toIndex` should be included in the returned operations, so add `1`.\n      toIndex + 1);\n    }\n    /**\n     * Returns operation from the history that bases on given `baseVersion`.\n     *\n     * @param {Number} baseVersion Base version of the operation to get.\n     * @returns {module:engine/model/operation/operation~Operation|undefined} Operation with given base version or `undefined` if\n     * there is no such operation in history.\n     */\n\n  }, {\n    key: \"getOperation\",\n    value: function getOperation(baseVersion) {\n      var operationIndex = this._baseVersionToOperationIndex.get(baseVersion);\n\n      if (operationIndex === undefined) {\n        return;\n      }\n\n      return this._operations[operationIndex];\n    }\n    /**\n     * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n     * history is keeping more context information about operations, which helps in operational transformation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n     * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n     */\n\n  }, {\n    key: \"setOperationAsUndone\",\n    value: function setOperationAsUndone(undoneOperation, undoingOperation) {\n      this._undoPairs.set(undoingOperation, undoneOperation);\n\n      this._undoneOperations.add(undoneOperation);\n    }\n    /**\n     * Checks whether given `operation` is undoing any other operation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n     * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n     */\n\n  }, {\n    key: \"isUndoingOperation\",\n    value: function isUndoingOperation(operation) {\n      return this._undoPairs.has(operation);\n    }\n    /**\n     * Checks whether given `operation` has been undone by any other operation.\n     *\n     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n     * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n     */\n\n  }, {\n    key: \"isUndoneOperation\",\n    value: function isUndoneOperation(operation) {\n      return this._undoneOperations.has(operation);\n    }\n    /**\n     * For given `undoingOperation`, returns the operation which has been undone by it.\n     *\n     * @param {module:engine/model/operation/operation~Operation} undoingOperation\n     * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n     * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n     */\n\n  }, {\n    key: \"getUndoneOperation\",\n    value: function getUndoneOperation(undoingOperation) {\n      return this._undoPairs.get(undoingOperation);\n    }\n    /**\n     * Resets the history of operations.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._version = 0;\n      this._undoPairs = new Map();\n      this._operations = [];\n      this._undoneOperations = new Set();\n      this._gaps = new Map();\n      this._baseVersionToOperationIndex = new Map();\n    }\n  }, {\n    key: \"version\",\n    get: function get() {\n      return this._version;\n    },\n    set: function set(version) {\n      // Store a gap if there are some operations already in the history and the\n      // new version does not increment the latest one.\n      if (this._operations.length && version > this._version + 1) {\n        this._gaps.set(this._version, version);\n      }\n\n      this._version = version;\n    }\n    /**\n     * The last history operation.\n     *\n     * @readonly\n     * @type {module:engine/model/operation/operation~Operation|undefined}\n     */\n\n  }, {\n    key: \"lastOperation\",\n    get: function get() {\n      return this._operations[this._operations.length - 1];\n    }\n  }]);\n\n  return History;\n}();\n\nexport { History as default };","map":null,"metadata":{},"sourceType":"module"}